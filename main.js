/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod3) => function __require() {
  return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
};
var __export = (target, all) => {
  for (var name314 in all)
    __defProp(target, name314, { get: all[name314], enumerable: true });
};
var __copyProps = (to2, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
  mod3
));
var __toCommonJS = (mod3) => __copyProps(__defProp({}, "__esModule", { value: true }), mod3);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports, module2) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER: MAX_SAFE_INTEGER2,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports, module2) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports, module2) {
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports = module2.exports = {};
    var re2 = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var t = exports.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max3] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max3}}`).split(`${token}+`).join(`${token}{1,${max3}}`);
      }
      return value;
    };
    var createToken = (name314, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index2 = R++;
      debug(name314, index2, value);
      t[name314] = index2;
      src[index2] = value;
      re2[index2] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index2] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports, module2) {
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options2) => {
      if (!options2) {
        return emptyOpts;
      }
      if (typeof options2 !== "object") {
        return looseOption;
      }
      return options2;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports, module2) {
    var numeric3 = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric3.test(a);
      const bnum = numeric3.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports, module2) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER: MAX_SAFE_INTEGER2 } = require_constants();
    var { safeRe: re2, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class {
      constructor(version4, options2) {
        options2 = parseOptions(options2);
        if (version4 instanceof SemVer) {
          if (version4.loose === !!options2.loose && version4.includePrerelease === !!options2.includePrerelease) {
            return version4;
          } else {
            version4 = version4.version;
          }
        } else if (typeof version4 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version4}".`);
        }
        if (version4.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version4, options2);
        this.options = options2;
        this.loose = !!options2.loose;
        this.includePrerelease = !!options2.includePrerelease;
        const m = version4.trim().match(options2.loose ? re2[t.LOOSE] : re2[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version4}`);
        }
        this.raw = version4;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER2 || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER2 || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER2 || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER2) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i2 = 0;
        do {
          const a = this.prerelease[i2];
          const b = other.prerelease[i2];
          debug("prerelease compare", i2, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i2);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i2 = 0;
        do {
          const a = this.build[i2];
          const b = other.build[i2];
          debug("build compare", i2, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i2);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i2 = this.prerelease.length;
              while (--i2 >= 0) {
                if (typeof this.prerelease[i2] === "number") {
                  this.prerelease[i2]++;
                  i2 = -2;
                }
              }
              if (i2 === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports, module2) {
    var SemVer = require_semver();
    var parse4 = (version4, options2, throwErrors = false) => {
      if (version4 instanceof SemVer) {
        return version4;
      }
      try {
        return new SemVer(version4, options2);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse4;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports, module2) {
    var parse4 = require_parse();
    var valid = (version4, options2) => {
      const v = parse4(version4, options2);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports, module2) {
    var parse4 = require_parse();
    var clean = (version4, options2) => {
      const s = parse4(version4.trim().replace(/^[=v]+/, ""), options2);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports, module2) {
    var SemVer = require_semver();
    var inc = (version4, release, options2, identifier, identifierBase) => {
      if (typeof options2 === "string") {
        identifierBase = identifier;
        identifier = options2;
        options2 = void 0;
      }
      try {
        return new SemVer(
          version4 instanceof SemVer ? version4.version : version4,
          options2
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports, module2) {
    var parse4 = require_parse();
    var diff2 = (version1, version22) => {
      const v1 = parse4(version1, null, true);
      const v2 = parse4(version22, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (highVersion.patch) {
          return "patch";
        }
        if (highVersion.minor) {
          return "minor";
        }
        return "major";
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff2;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports, module2) {
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports, module2) {
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports, module2) {
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports, module2) {
    var parse4 = require_parse();
    var prerelease = (version4, options2) => {
      const parsed = parse4(version4, options2);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports, module2) {
    var SemVer = require_semver();
    var compare2 = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare2;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports, module2) {
    var compare2 = require_compare();
    var rcompare = (a, b, loose) => compare2(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports, module2) {
    var compare2 = require_compare();
    var compareLoose = (a, b) => compare2(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports, module2) {
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports, module2) {
    var compareBuild = require_compare_build();
    var sort2 = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort2;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports, module2) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports, module2) {
    var compare2 = require_compare();
    var gt = (a, b, loose) => compare2(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports, module2) {
    var compare2 = require_compare();
    var lt3 = (a, b, loose) => compare2(a, b, loose) < 0;
    module2.exports = lt3;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports, module2) {
    var compare2 = require_compare();
    var eq = (a, b, loose) => compare2(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports, module2) {
    var compare2 = require_compare();
    var neq = (a, b, loose) => compare2(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports, module2) {
    var compare2 = require_compare();
    var gte3 = (a, b, loose) => compare2(a, b, loose) >= 0;
    module2.exports = gte3;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports, module2) {
    var compare2 = require_compare();
    var lte = (a, b, loose) => compare2(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports, module2) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte3 = require_gte();
    var lt3 = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte3(a, b, loose);
        case "<":
          return lt3(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports, module2) {
    var SemVer = require_semver();
    var parse4 = require_parse();
    var { safeRe: re2, t } = require_re();
    var coerce = (version4, options2) => {
      if (version4 instanceof SemVer) {
        return version4;
      }
      if (typeof version4 === "number") {
        version4 = String(version4);
      }
      if (typeof version4 !== "string") {
        return null;
      }
      options2 = options2 || {};
      let match = null;
      if (!options2.rtl) {
        match = version4.match(options2.includePrerelease ? re2[t.COERCEFULL] : re2[t.COERCE]);
      } else {
        const coerceRtlRegex = options2.includePrerelease ? re2[t.COERCERTLFULL] : re2[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version4)) && (!match || match.index + match[0].length !== version4.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options2.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options2.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse4(`${major}.${minor}.${patch}${prerelease}${build}`, options2);
    };
    module2.exports = coerce;
  }
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/semver/internal/lrucache.js"(exports, module2) {
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module2.exports = LRUCache;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports, module2) {
    var Range2 = class {
      constructor(range2, options2) {
        options2 = parseOptions(options2);
        if (range2 instanceof Range2) {
          if (range2.loose === !!options2.loose && range2.includePrerelease === !!options2.includePrerelease) {
            return range2;
          } else {
            return new Range2(range2.raw, options2);
          }
        }
        if (range2 instanceof Comparator) {
          this.raw = range2.value;
          this.set = [[range2]];
          this.format();
          return this;
        }
        this.options = options2;
        this.loose = !!options2.loose;
        this.includePrerelease = !!options2.includePrerelease;
        this.raw = range2.trim().split(/\s+/).join(" ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range2) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range2;
        const cached = cache2.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re2[t.HYPHENRANGELOOSE] : re2[t.HYPHENRANGE];
        range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range2);
        range2 = range2.replace(re2[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range2);
        range2 = range2.replace(re2[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range2);
        range2 = range2.replace(re2[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range2);
        let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re2[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache2.set(memoKey, result);
        return result;
      }
      intersects(range2, options2) {
        if (!(range2 instanceof Range2)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options2) && range2.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options2) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options2);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version4) {
        if (!version4) {
          return false;
        }
        if (typeof version4 === "string") {
          try {
            version4 = new SemVer(version4, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i2 = 0; i2 < this.set.length; i2++) {
          if (testSet(this.set[i2], version4, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range2;
    var LRU = require_lrucache();
    var cache2 = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re2,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options2) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options2);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options2) => {
      debug("comp", comp, options2);
      comp = replaceCarets(comp, options2);
      debug("caret", comp);
      comp = replaceTildes(comp, options2);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options2);
      debug("xrange", comp);
      comp = replaceStars(comp, options2);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options2) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options2)).join(" ");
    };
    var replaceTilde = (comp, options2) => {
      const r = options2.loose ? re2[t.TILDELOOSE] : re2[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options2) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options2)).join(" ");
    };
    var replaceCaret = (comp, options2) => {
      debug("caret", comp, options2);
      const r = options2.loose ? re2[t.CARETLOOSE] : re2[t.CARET];
      const z = options2.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options2) => {
      debug("replaceXRanges", comp, options2);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options2)).join(" ");
    };
    var replaceXRange = (comp, options2) => {
      comp = comp.trim();
      const r = options2.loose ? re2[t.XRANGELOOSE] : re2[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options2.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options2) => {
      debug("replaceStars", comp, options2);
      return comp.trim().replace(re2[t.STAR], "");
    };
    var replaceGTE0 = (comp, options2) => {
      debug("replaceGTE0", comp, options2);
      return comp.trim().replace(re2[options2.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to2, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to2 = "";
      } else if (isX(tm)) {
        to2 = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to2 = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to2 = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to2 = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to2 = `<=${to2}`;
      }
      return `${from} ${to2}`.trim();
    };
    var testSet = (set, version4, options2) => {
      for (let i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version4)) {
          return false;
        }
      }
      if (version4.prerelease.length && !options2.includePrerelease) {
        for (let i2 = 0; i2 < set.length; i2++) {
          debug(set[i2].semver);
          if (set[i2].semver === Comparator.ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            const allowed = set[i2].semver;
            if (allowed.major === version4.major && allowed.minor === version4.minor && allowed.patch === version4.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports, module2) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options2) {
        options2 = parseOptions(options2);
        if (comp instanceof Comparator) {
          if (comp.loose === !!options2.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options2);
        this.options = options2;
        this.loose = !!options2.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re2[t.COMPARATORLOOSE] : re2[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version4) {
        debug("Comparator.test", version4, this.options.loose);
        if (this.semver === ANY || version4 === ANY) {
          return true;
        }
        if (typeof version4 === "string") {
          try {
            version4 = new SemVer(version4, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version4, this.operator, this.semver, this.options);
      }
      intersects(comp, options2) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range2(comp.value, options2).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range2(this.value, options2).test(comp.semver);
        }
        options2 = parseOptions(options2);
        if (options2.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options2.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options2) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options2) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re2, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range2 = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports, module2) {
    var Range2 = require_range();
    var satisfies = (version4, range2, options2) => {
      try {
        range2 = new Range2(range2, options2);
      } catch (er) {
        return false;
      }
      return range2.test(version4);
    };
    module2.exports = satisfies;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports, module2) {
    var Range2 = require_range();
    var toComparators = (range2, options2) => new Range2(range2, options2).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports, module2) {
    var SemVer = require_semver();
    var Range2 = require_range();
    var maxSatisfying = (versions, range2, options2) => {
      let max3 = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range2(range2, options2);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max3 || maxSV.compare(v) === -1) {
            max3 = v;
            maxSV = new SemVer(max3, options2);
          }
        }
      });
      return max3;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports, module2) {
    var SemVer = require_semver();
    var Range2 = require_range();
    var minSatisfying = (versions, range2, options2) => {
      let min3 = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range2(range2, options2);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min3 || minSV.compare(v) === 1) {
            min3 = v;
            minSV = new SemVer(min3, options2);
          }
        }
      });
      return min3;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports, module2) {
    var SemVer = require_semver();
    var Range2 = require_range();
    var gt = require_gt();
    var minVersion = (range2, loose) => {
      range2 = new Range2(range2, loose);
      let minver = new SemVer("0.0.0");
      if (range2.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range2.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i2 = 0; i2 < range2.set.length; ++i2) {
        const comparators = range2.set[i2];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range2.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports, module2) {
    var Range2 = require_range();
    var validRange = (range2, options2) => {
      try {
        return new Range2(range2, options2).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports, module2) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range2 = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt3 = require_lt();
    var lte = require_lte();
    var gte3 = require_gte();
    var outside = (version4, range2, hilo, options2) => {
      version4 = new SemVer(version4, options2);
      range2 = new Range2(range2, options2);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt3;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt3;
          ltefn = gte3;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version4, range2, options2)) {
        return false;
      }
      for (let i2 = 0; i2 < range2.set.length; ++i2) {
        const comparators = range2.set[i2];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options2)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options2)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version4, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version4, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports, module2) {
    var outside = require_outside();
    var gtr = (version4, range2, options2) => outside(version4, range2, ">", options2);
    module2.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports, module2) {
    var outside = require_outside();
    var ltr = (version4, range2, options2) => outside(version4, range2, "<", options2);
    module2.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports, module2) {
    var Range2 = require_range();
    var intersects = (r1, r2, options2) => {
      r1 = new Range2(r1, options2);
      r2 = new Range2(r2, options2);
      return r1.intersects(r2, options2);
    };
    module2.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports, module2) {
    var satisfies = require_satisfies();
    var compare2 = require_compare();
    module2.exports = (versions, range2, options2) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare2(a, b, options2));
      for (const version4 of v) {
        const included = satisfies(version4, range2, options2);
        if (included) {
          prev = version4;
          if (!first) {
            first = version4;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min3, max3] of set) {
        if (min3 === max3) {
          ranges.push(min3);
        } else if (!max3 && min3 === v[0]) {
          ranges.push("*");
        } else if (!max3) {
          ranges.push(`>=${min3}`);
        } else if (min3 === v[0]) {
          ranges.push(`<=${max3}`);
        } else {
          ranges.push(`${min3} - ${max3}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range2.raw === "string" ? range2.raw : String(range2);
      return simplified.length < original.length ? simplified : range2;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports, module2) {
    var Range2 = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare2 = require_compare();
    var subset2 = (sub2, dom, options2 = {}) => {
      if (sub2 === dom) {
        return true;
      }
      sub2 = new Range2(sub2, options2);
      dom = new Range2(dom, options2);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub2.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options2);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) {
              continue OUTER;
            }
          }
          if (sawNonNull) {
            return false;
          }
        }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion2 = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub2, dom, options2) => {
      if (sub2 === dom) {
        return true;
      }
      if (sub2.length === 1 && sub2[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options2.includePrerelease) {
          sub2 = minimumVersionWithPreRelease;
        } else {
          sub2 = minimumVersion2;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options2.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion2;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt3;
      for (const c of sub2) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options2);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt3 = lowerLT(lt3, c, options2);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt3) {
        gtltComp = compare2(gt.semver, lt3.semver, options2);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt3.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options2)) {
          return null;
        }
        if (lt3 && !satisfies(eq, String(lt3), options2)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options2)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt3 && !options2.includePrerelease && lt3.semver.prerelease.length ? lt3.semver : false;
      let needDomGTPre = gt && !options2.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt3.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options2);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options2)) {
            return false;
          }
        }
        if (lt3) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt3, c, options2);
            if (lower === c && lower !== lt3) {
              return false;
            }
          } else if (lt3.operator === "<=" && !satisfies(lt3.semver, String(c), options2)) {
            return false;
          }
        }
        if (!c.operator && (lt3 || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt3 && gtltComp !== 0) {
        return false;
      }
      if (lt3 && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options2) => {
      if (!a) {
        return b;
      }
      const comp = compare2(a.semver, b.semver, options2);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options2) => {
      if (!a) {
        return b;
      }
      const comp = compare2(a.semver, b.semver, options2);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset2;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports, module2) {
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse4 = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff2 = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare2 = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort2 = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt3 = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte3 = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range2 = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset2 = require_subset();
    module2.exports = {
      parse: parse4,
      valid,
      clean,
      inc,
      diff: diff2,
      major,
      minor,
      patch,
      prerelease,
      compare: compare2,
      rcompare,
      compareLoose,
      compareBuild,
      sort: sort2,
      rsort,
      gt,
      lt: lt3,
      eq,
      neq,
      gte: gte3,
      lte,
      cmp,
      coerce,
      Comparator,
      Range: Range2,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset: subset2,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "node_modules/retry/lib/retry_operation.js"(exports, module2) {
    function RetryOperation(timeouts, options2) {
      if (typeof options2 === "boolean") {
        options2 = { forever: options2 };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options2 || {};
      this._maxRetryTime = options2 && options2.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      this._timer = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module2.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts.slice(0);
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (this._timer) {
        clearTimeout(this._timer);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = new Date().getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(0, this._errors.length - 1);
          timeout = this._cachedTimeouts.slice(-1);
        } else {
          return false;
        }
      }
      var self2 = this;
      this._timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        this._timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = new Date().getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i2 = 0; i2 < this._errors.length; i2++) {
        var error = this._errors[i2];
        var message = error.message;
        var count2 = (counts[message] || 0) + 1;
        counts[message] = count2;
        if (count2 >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count2;
        }
      }
      return mainError;
    };
  }
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "node_modules/retry/lib/retry.js"(exports) {
    var RetryOperation = require_retry_operation();
    exports.operation = function(options2) {
      var timeouts = exports.timeouts(options2);
      return new RetryOperation(timeouts, {
        forever: options2 && (options2.forever || options2.retries === Infinity),
        unref: options2 && options2.unref,
        maxRetryTime: options2 && options2.maxRetryTime
      });
    };
    exports.timeouts = function(options2) {
      if (options2 instanceof Array) {
        return [].concat(options2);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options2) {
        opts[key] = options2[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i2 = 0; i2 < opts.retries; i2++) {
        timeouts.push(this.createTimeout(i2, opts));
      }
      if (options2 && options2.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i2, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports.createTimeout = function(attempt, opts) {
      var random3 = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random3 * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports.wrap = function(obj, options2, methods) {
      if (options2 instanceof Array) {
        methods = options2;
        options2 = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i2 = 0; i2 < methods.length; i2++) {
        var method = methods[i2];
        var original = obj[method];
        obj[method] = function retryWrapper(original2) {
          var op = exports.operation(options2);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }.bind(obj, original);
        obj[method].options = options2;
      }
    };
  }
});

// node_modules/retry/index.js
var require_retry2 = __commonJS({
  "node_modules/retry/index.js"(exports, module2) {
    module2.exports = require_retry();
  }
});

// node_modules/typed-function/lib/umd/typed-function.js
var require_typed_function = __commonJS({
  "node_modules/typed-function/lib/umd/typed-function.js"(exports, module2) {
    (function(global, factory2) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory2() : typeof define === "function" && define.amd ? define(factory2) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global["'typed'"] = factory2());
    })(exports, function() {
      "use strict";
      function ok() {
        return true;
      }
      function notOk() {
        return false;
      }
      function undef() {
        return void 0;
      }
      const NOT_TYPED_FUNCTION = "Argument is not a typed-function.";
      function create() {
        function isPlainObject2(x) {
          return typeof x === "object" && x !== null && x.constructor === Object;
        }
        const _types = [{
          name: "number",
          test: function(x) {
            return typeof x === "number";
          }
        }, {
          name: "string",
          test: function(x) {
            return typeof x === "string";
          }
        }, {
          name: "boolean",
          test: function(x) {
            return typeof x === "boolean";
          }
        }, {
          name: "Function",
          test: function(x) {
            return typeof x === "function";
          }
        }, {
          name: "Array",
          test: Array.isArray
        }, {
          name: "Date",
          test: function(x) {
            return x instanceof Date;
          }
        }, {
          name: "RegExp",
          test: function(x) {
            return x instanceof RegExp;
          }
        }, {
          name: "Object",
          test: isPlainObject2
        }, {
          name: "null",
          test: function(x) {
            return x === null;
          }
        }, {
          name: "undefined",
          test: function(x) {
            return x === void 0;
          }
        }];
        const anyType = {
          name: "any",
          test: ok,
          isAny: true
        };
        let typeMap;
        let typeList;
        let nConversions = 0;
        let typed3 = {
          createCount: 0
        };
        function findType(typeName) {
          const type = typeMap.get(typeName);
          if (type) {
            return type;
          }
          let message = 'Unknown type "' + typeName + '"';
          const name314 = typeName.toLowerCase();
          let otherName;
          for (otherName of typeList) {
            if (otherName.toLowerCase() === name314) {
              message += '. Did you mean "' + otherName + '" ?';
              break;
            }
          }
          throw new TypeError(message);
        }
        function addTypes(types) {
          let beforeSpec = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "any";
          const beforeIndex = beforeSpec ? findType(beforeSpec).index : typeList.length;
          const newTypes = [];
          for (let i2 = 0; i2 < types.length; ++i2) {
            if (!types[i2] || typeof types[i2].name !== "string" || typeof types[i2].test !== "function") {
              throw new TypeError("Object with properties {name: string, test: function} expected");
            }
            const typeName = types[i2].name;
            if (typeMap.has(typeName)) {
              throw new TypeError('Duplicate type name "' + typeName + '"');
            }
            newTypes.push(typeName);
            typeMap.set(typeName, {
              name: typeName,
              test: types[i2].test,
              isAny: types[i2].isAny,
              index: beforeIndex + i2,
              conversionsTo: []
              // Newly added type can't have any conversions to it
            });
          }
          const affectedTypes = typeList.slice(beforeIndex);
          typeList = typeList.slice(0, beforeIndex).concat(newTypes).concat(affectedTypes);
          for (let i2 = beforeIndex + newTypes.length; i2 < typeList.length; ++i2) {
            typeMap.get(typeList[i2]).index = i2;
          }
        }
        function clear() {
          typeMap = /* @__PURE__ */ new Map();
          typeList = [];
          nConversions = 0;
          addTypes([anyType], false);
        }
        clear();
        addTypes(_types);
        function clearConversions() {
          let typeName;
          for (typeName of typeList) {
            typeMap.get(typeName).conversionsTo = [];
          }
          nConversions = 0;
        }
        function findTypeNames(value) {
          const matches = typeList.filter((name314) => {
            const type = typeMap.get(name314);
            return !type.isAny && type.test(value);
          });
          if (matches.length) {
            return matches;
          }
          return ["any"];
        }
        function isTypedFunction(entity) {
          return entity && typeof entity === "function" && "_typedFunctionData" in entity;
        }
        function findSignature(fn, signature, options2) {
          if (!isTypedFunction(fn)) {
            throw new TypeError(NOT_TYPED_FUNCTION);
          }
          const exact = options2 && options2.exact;
          const stringSignature = Array.isArray(signature) ? signature.join(",") : signature;
          const params = parseSignature(stringSignature);
          const canonicalSignature = stringifyParams(params);
          if (!exact || canonicalSignature in fn.signatures) {
            const match = fn._typedFunctionData.signatureMap.get(canonicalSignature);
            if (match) {
              return match;
            }
          }
          const nParams = params.length;
          let remainingSignatures;
          if (exact) {
            remainingSignatures = [];
            let name314;
            for (name314 in fn.signatures) {
              remainingSignatures.push(fn._typedFunctionData.signatureMap.get(name314));
            }
          } else {
            remainingSignatures = fn._typedFunctionData.signatures;
          }
          for (let i2 = 0; i2 < nParams; ++i2) {
            const want = params[i2];
            const filteredSignatures = [];
            let possibility;
            for (possibility of remainingSignatures) {
              const have = getParamAtIndex(possibility.params, i2);
              if (!have || want.restParam && !have.restParam) {
                continue;
              }
              if (!have.hasAny) {
                const haveTypes = paramTypeSet(have);
                if (want.types.some((wtype) => !haveTypes.has(wtype.name))) {
                  continue;
                }
              }
              filteredSignatures.push(possibility);
            }
            remainingSignatures = filteredSignatures;
            if (remainingSignatures.length === 0)
              break;
          }
          let candidate;
          for (candidate of remainingSignatures) {
            if (candidate.params.length <= nParams) {
              return candidate;
            }
          }
          throw new TypeError("Signature not found (signature: " + (fn.name || "unnamed") + "(" + stringifyParams(params, ", ") + "))");
        }
        function find(fn, signature, options2) {
          return findSignature(fn, signature, options2).implementation;
        }
        function convert(value, typeName) {
          const type = findType(typeName);
          if (type.test(value)) {
            return value;
          }
          const conversions = type.conversionsTo;
          if (conversions.length === 0) {
            throw new Error("There are no conversions to " + typeName + " defined.");
          }
          for (let i2 = 0; i2 < conversions.length; i2++) {
            const fromType = findType(conversions[i2].from);
            if (fromType.test(value)) {
              return conversions[i2].convert(value);
            }
          }
          throw new Error("Cannot convert " + value + " to " + typeName);
        }
        function stringifyParams(params) {
          let separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ",";
          return params.map((p) => p.name).join(separator);
        }
        function parseParam(param) {
          const restParam = param.indexOf("...") === 0;
          const types = !restParam ? param : param.length > 3 ? param.slice(3) : "any";
          const typeDefs = types.split("|").map((s) => findType(s.trim()));
          let hasAny = false;
          let paramName = restParam ? "..." : "";
          const exactTypes = typeDefs.map(function(type) {
            hasAny = type.isAny || hasAny;
            paramName += type.name + "|";
            return {
              name: type.name,
              typeIndex: type.index,
              test: type.test,
              isAny: type.isAny,
              conversion: null,
              conversionIndex: -1
            };
          });
          return {
            types: exactTypes,
            name: paramName.slice(0, -1),
            // remove trailing '|' from above
            hasAny,
            hasConversion: false,
            restParam
          };
        }
        function expandParam(param) {
          const typeNames = param.types.map((t) => t.name);
          const matchingConversions = availableConversions(typeNames);
          let hasAny = param.hasAny;
          let newName = param.name;
          const convertibleTypes = matchingConversions.map(function(conversion) {
            const type = findType(conversion.from);
            hasAny = type.isAny || hasAny;
            newName += "|" + conversion.from;
            return {
              name: conversion.from,
              typeIndex: type.index,
              test: type.test,
              isAny: type.isAny,
              conversion,
              conversionIndex: conversion.index
            };
          });
          return {
            types: param.types.concat(convertibleTypes),
            name: newName,
            hasAny,
            hasConversion: convertibleTypes.length > 0,
            restParam: param.restParam
          };
        }
        function paramTypeSet(param) {
          if (!param.typeSet) {
            param.typeSet = /* @__PURE__ */ new Set();
            param.types.forEach((type) => param.typeSet.add(type.name));
          }
          return param.typeSet;
        }
        function parseSignature(rawSignature) {
          const params = [];
          if (typeof rawSignature !== "string") {
            throw new TypeError("Signatures must be strings");
          }
          const signature = rawSignature.trim();
          if (signature === "") {
            return params;
          }
          const rawParams = signature.split(",");
          for (let i2 = 0; i2 < rawParams.length; ++i2) {
            const parsedParam = parseParam(rawParams[i2].trim());
            if (parsedParam.restParam && i2 !== rawParams.length - 1) {
              throw new SyntaxError('Unexpected rest parameter "' + rawParams[i2] + '": only allowed for the last parameter');
            }
            if (parsedParam.types.length === 0) {
              return null;
            }
            params.push(parsedParam);
          }
          return params;
        }
        function hasRestParam(params) {
          const param = last(params);
          return param ? param.restParam : false;
        }
        function compileTest(param) {
          if (!param || param.types.length === 0) {
            return ok;
          } else if (param.types.length === 1) {
            return findType(param.types[0].name).test;
          } else if (param.types.length === 2) {
            const test0 = findType(param.types[0].name).test;
            const test1 = findType(param.types[1].name).test;
            return function or2(x) {
              return test0(x) || test1(x);
            };
          } else {
            const tests = param.types.map(function(type) {
              return findType(type.name).test;
            });
            return function or2(x) {
              for (let i2 = 0; i2 < tests.length; i2++) {
                if (tests[i2](x)) {
                  return true;
                }
              }
              return false;
            };
          }
        }
        function compileTests(params) {
          let tests, test0, test1;
          if (hasRestParam(params)) {
            tests = initial(params).map(compileTest);
            const varIndex = tests.length;
            const lastTest = compileTest(last(params));
            const testRestParam = function(args) {
              for (let i2 = varIndex; i2 < args.length; i2++) {
                if (!lastTest(args[i2])) {
                  return false;
                }
              }
              return true;
            };
            return function testArgs(args) {
              for (let i2 = 0; i2 < tests.length; i2++) {
                if (!tests[i2](args[i2])) {
                  return false;
                }
              }
              return testRestParam(args) && args.length >= varIndex + 1;
            };
          } else {
            if (params.length === 0) {
              return function testArgs(args) {
                return args.length === 0;
              };
            } else if (params.length === 1) {
              test0 = compileTest(params[0]);
              return function testArgs(args) {
                return test0(args[0]) && args.length === 1;
              };
            } else if (params.length === 2) {
              test0 = compileTest(params[0]);
              test1 = compileTest(params[1]);
              return function testArgs(args) {
                return test0(args[0]) && test1(args[1]) && args.length === 2;
              };
            } else {
              tests = params.map(compileTest);
              return function testArgs(args) {
                for (let i2 = 0; i2 < tests.length; i2++) {
                  if (!tests[i2](args[i2])) {
                    return false;
                  }
                }
                return args.length === tests.length;
              };
            }
          }
        }
        function getParamAtIndex(params, index2) {
          return index2 < params.length ? params[index2] : hasRestParam(params) ? last(params) : null;
        }
        function getTypeSetAtIndex(params, index2) {
          const param = getParamAtIndex(params, index2);
          if (!param) {
            return /* @__PURE__ */ new Set();
          }
          return paramTypeSet(param);
        }
        function isExactType(type) {
          return type.conversion === null || type.conversion === void 0;
        }
        function mergeExpectedParams(signatures, index2) {
          const typeSet = /* @__PURE__ */ new Set();
          signatures.forEach((signature) => {
            const paramSet = getTypeSetAtIndex(signature.params, index2);
            let name314;
            for (name314 of paramSet) {
              typeSet.add(name314);
            }
          });
          return typeSet.has("any") ? ["any"] : Array.from(typeSet);
        }
        function createError(name314, args, signatures) {
          let err, expected;
          const _name = name314 || "unnamed";
          let matchingSignatures = signatures;
          let index2;
          for (index2 = 0; index2 < args.length; index2++) {
            const nextMatchingDefs = [];
            matchingSignatures.forEach((signature) => {
              const param = getParamAtIndex(signature.params, index2);
              const test = compileTest(param);
              if ((index2 < signature.params.length || hasRestParam(signature.params)) && test(args[index2])) {
                nextMatchingDefs.push(signature);
              }
            });
            if (nextMatchingDefs.length === 0) {
              expected = mergeExpectedParams(matchingSignatures, index2);
              if (expected.length > 0) {
                const actualTypes = findTypeNames(args[index2]);
                err = new TypeError("Unexpected type of argument in function " + _name + " (expected: " + expected.join(" or ") + ", actual: " + actualTypes.join(" | ") + ", index: " + index2 + ")");
                err.data = {
                  category: "wrongType",
                  fn: _name,
                  index: index2,
                  actual: actualTypes,
                  expected
                };
                return err;
              }
            } else {
              matchingSignatures = nextMatchingDefs;
            }
          }
          const lengths = matchingSignatures.map(function(signature) {
            return hasRestParam(signature.params) ? Infinity : signature.params.length;
          });
          if (args.length < Math.min.apply(null, lengths)) {
            expected = mergeExpectedParams(matchingSignatures, index2);
            err = new TypeError("Too few arguments in function " + _name + " (expected: " + expected.join(" or ") + ", index: " + args.length + ")");
            err.data = {
              category: "tooFewArgs",
              fn: _name,
              index: args.length,
              expected
            };
            return err;
          }
          const maxLength = Math.max.apply(null, lengths);
          if (args.length > maxLength) {
            err = new TypeError("Too many arguments in function " + _name + " (expected: " + maxLength + ", actual: " + args.length + ")");
            err.data = {
              category: "tooManyArgs",
              fn: _name,
              index: args.length,
              expectedLength: maxLength
            };
            return err;
          }
          const argTypes = [];
          for (let i2 = 0; i2 < args.length; ++i2) {
            argTypes.push(findTypeNames(args[i2]).join("|"));
          }
          err = new TypeError('Arguments of type "' + argTypes.join(", ") + '" do not match any of the defined signatures of function ' + _name + ".");
          err.data = {
            category: "mismatch",
            actual: argTypes
          };
          return err;
        }
        function getLowestTypeIndex(param) {
          let min3 = typeList.length + 1;
          for (let i2 = 0; i2 < param.types.length; i2++) {
            if (isExactType(param.types[i2])) {
              min3 = Math.min(min3, param.types[i2].typeIndex);
            }
          }
          return min3;
        }
        function getLowestConversionIndex(param) {
          let min3 = nConversions + 1;
          for (let i2 = 0; i2 < param.types.length; i2++) {
            if (!isExactType(param.types[i2])) {
              min3 = Math.min(min3, param.types[i2].conversionIndex);
            }
          }
          return min3;
        }
        function compareParams(param1, param2) {
          if (param1.hasAny) {
            if (!param2.hasAny) {
              return 1;
            }
          } else if (param2.hasAny) {
            return -1;
          }
          if (param1.restParam) {
            if (!param2.restParam) {
              return 1;
            }
          } else if (param2.restParam) {
            return -1;
          }
          if (param1.hasConversion) {
            if (!param2.hasConversion) {
              return 1;
            }
          } else if (param2.hasConversion) {
            return -1;
          }
          const typeDiff = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);
          if (typeDiff < 0) {
            return -1;
          }
          if (typeDiff > 0) {
            return 1;
          }
          const convDiff = getLowestConversionIndex(param1) - getLowestConversionIndex(param2);
          if (convDiff < 0) {
            return -1;
          }
          if (convDiff > 0) {
            return 1;
          }
          return 0;
        }
        function compareSignatures(signature1, signature2) {
          const pars1 = signature1.params;
          const pars2 = signature2.params;
          const last1 = last(pars1);
          const last2 = last(pars2);
          const hasRest1 = hasRestParam(pars1);
          const hasRest2 = hasRestParam(pars2);
          if (hasRest1 && last1.hasAny) {
            if (!hasRest2 || !last2.hasAny) {
              return 1;
            }
          } else if (hasRest2 && last2.hasAny) {
            return -1;
          }
          let any1 = 0;
          let conv1 = 0;
          let par;
          for (par of pars1) {
            if (par.hasAny)
              ++any1;
            if (par.hasConversion)
              ++conv1;
          }
          let any2 = 0;
          let conv2 = 0;
          for (par of pars2) {
            if (par.hasAny)
              ++any2;
            if (par.hasConversion)
              ++conv2;
          }
          if (any1 !== any2) {
            return any1 - any2;
          }
          if (hasRest1 && last1.hasConversion) {
            if (!hasRest2 || !last2.hasConversion) {
              return 1;
            }
          } else if (hasRest2 && last2.hasConversion) {
            return -1;
          }
          if (conv1 !== conv2) {
            return conv1 - conv2;
          }
          if (hasRest1) {
            if (!hasRest2) {
              return 1;
            }
          } else if (hasRest2) {
            return -1;
          }
          const lengthCriterion = (pars1.length - pars2.length) * (hasRest1 ? -1 : 1);
          if (lengthCriterion !== 0) {
            return lengthCriterion;
          }
          const comparisons = [];
          let tc = 0;
          for (let i2 = 0; i2 < pars1.length; ++i2) {
            const thisComparison = compareParams(pars1[i2], pars2[i2]);
            comparisons.push(thisComparison);
            tc += thisComparison;
          }
          if (tc !== 0) {
            return tc;
          }
          let c;
          for (c of comparisons) {
            if (c !== 0) {
              return c;
            }
          }
          return 0;
        }
        function availableConversions(typeNames) {
          if (typeNames.length === 0) {
            return [];
          }
          const types = typeNames.map(findType);
          if (typeNames.length > 1) {
            types.sort((t1, t2) => t1.index - t2.index);
          }
          let matches = types[0].conversionsTo;
          if (typeNames.length === 1) {
            return matches;
          }
          matches = matches.concat([]);
          const knownTypes = new Set(typeNames);
          for (let i2 = 1; i2 < types.length; ++i2) {
            let newMatch;
            for (newMatch of types[i2].conversionsTo) {
              if (!knownTypes.has(newMatch.from)) {
                matches.push(newMatch);
                knownTypes.add(newMatch.from);
              }
            }
          }
          return matches;
        }
        function compileArgsPreprocessing(params, fn) {
          let fnConvert = fn;
          if (params.some((p) => p.hasConversion)) {
            const restParam = hasRestParam(params);
            const compiledConversions = params.map(compileArgConversion);
            fnConvert = function convertArgs() {
              const args = [];
              const last2 = restParam ? arguments.length - 1 : arguments.length;
              for (let i2 = 0; i2 < last2; i2++) {
                args[i2] = compiledConversions[i2](arguments[i2]);
              }
              if (restParam) {
                args[last2] = arguments[last2].map(compiledConversions[last2]);
              }
              return fn.apply(this, args);
            };
          }
          let fnPreprocess = fnConvert;
          if (hasRestParam(params)) {
            const offset = params.length - 1;
            fnPreprocess = function preprocessRestParams() {
              return fnConvert.apply(this, slice(arguments, 0, offset).concat([slice(arguments, offset)]));
            };
          }
          return fnPreprocess;
        }
        function compileArgConversion(param) {
          let test0, test1, conversion0, conversion1;
          const tests = [];
          const conversions = [];
          param.types.forEach(function(type) {
            if (type.conversion) {
              tests.push(findType(type.conversion.from).test);
              conversions.push(type.conversion.convert);
            }
          });
          switch (conversions.length) {
            case 0:
              return function convertArg(arg2) {
                return arg2;
              };
            case 1:
              test0 = tests[0];
              conversion0 = conversions[0];
              return function convertArg(arg2) {
                if (test0(arg2)) {
                  return conversion0(arg2);
                }
                return arg2;
              };
            case 2:
              test0 = tests[0];
              test1 = tests[1];
              conversion0 = conversions[0];
              conversion1 = conversions[1];
              return function convertArg(arg2) {
                if (test0(arg2)) {
                  return conversion0(arg2);
                }
                if (test1(arg2)) {
                  return conversion1(arg2);
                }
                return arg2;
              };
            default:
              return function convertArg(arg2) {
                for (let i2 = 0; i2 < conversions.length; i2++) {
                  if (tests[i2](arg2)) {
                    return conversions[i2](arg2);
                  }
                }
                return arg2;
              };
          }
        }
        function splitParams(params) {
          function _splitParams(params2, index2, paramsSoFar) {
            if (index2 < params2.length) {
              const param = params2[index2];
              let resultingParams = [];
              if (param.restParam) {
                const exactTypes = param.types.filter(isExactType);
                if (exactTypes.length < param.types.length) {
                  resultingParams.push({
                    types: exactTypes,
                    name: "..." + exactTypes.map((t) => t.name).join("|"),
                    hasAny: exactTypes.some((t) => t.isAny),
                    hasConversion: false,
                    restParam: true
                  });
                }
                resultingParams.push(param);
              } else {
                resultingParams = param.types.map(function(type) {
                  return {
                    types: [type],
                    name: type.name,
                    hasAny: type.isAny,
                    hasConversion: type.conversion,
                    restParam: false
                  };
                });
              }
              return flatMap(resultingParams, function(nextParam) {
                return _splitParams(params2, index2 + 1, paramsSoFar.concat([nextParam]));
              });
            } else {
              return [paramsSoFar];
            }
          }
          return _splitParams(params, 0, []);
        }
        function conflicting(params1, params2) {
          const ii = Math.max(params1.length, params2.length);
          for (let i2 = 0; i2 < ii; i2++) {
            const typeSet1 = getTypeSetAtIndex(params1, i2);
            const typeSet2 = getTypeSetAtIndex(params2, i2);
            let overlap = false;
            let name314;
            for (name314 of typeSet2) {
              if (typeSet1.has(name314)) {
                overlap = true;
                break;
              }
            }
            if (!overlap) {
              return false;
            }
          }
          const len1 = params1.length;
          const len2 = params2.length;
          const restParam1 = hasRestParam(params1);
          const restParam2 = hasRestParam(params2);
          return restParam1 ? restParam2 ? len1 === len2 : len2 >= len1 : restParam2 ? len1 >= len2 : len1 === len2;
        }
        function clearResolutions(functionList) {
          return functionList.map((fn) => {
            if (isReferToSelf(fn)) {
              return referToSelf(fn.referToSelf.callback);
            }
            if (isReferTo(fn)) {
              return makeReferTo(fn.referTo.references, fn.referTo.callback);
            }
            return fn;
          });
        }
        function collectResolutions(references, functionList, signatureMap) {
          const resolvedReferences = [];
          let reference;
          for (reference of references) {
            let resolution = signatureMap[reference];
            if (typeof resolution !== "number") {
              throw new TypeError('No definition for referenced signature "' + reference + '"');
            }
            resolution = functionList[resolution];
            if (typeof resolution !== "function") {
              return false;
            }
            resolvedReferences.push(resolution);
          }
          return resolvedReferences;
        }
        function resolveReferences(functionList, signatureMap, self2) {
          const resolvedFunctions = clearResolutions(functionList);
          const isResolved = new Array(resolvedFunctions.length).fill(false);
          let leftUnresolved = true;
          while (leftUnresolved) {
            leftUnresolved = false;
            let nothingResolved = true;
            for (let i2 = 0; i2 < resolvedFunctions.length; ++i2) {
              if (isResolved[i2])
                continue;
              const fn = resolvedFunctions[i2];
              if (isReferToSelf(fn)) {
                resolvedFunctions[i2] = fn.referToSelf.callback(self2);
                resolvedFunctions[i2].referToSelf = fn.referToSelf;
                isResolved[i2] = true;
                nothingResolved = false;
              } else if (isReferTo(fn)) {
                const resolvedReferences = collectResolutions(fn.referTo.references, resolvedFunctions, signatureMap);
                if (resolvedReferences) {
                  resolvedFunctions[i2] = fn.referTo.callback.apply(this, resolvedReferences);
                  resolvedFunctions[i2].referTo = fn.referTo;
                  isResolved[i2] = true;
                  nothingResolved = false;
                } else {
                  leftUnresolved = true;
                }
              }
            }
            if (nothingResolved && leftUnresolved) {
              throw new SyntaxError("Circular reference detected in resolving typed.referTo");
            }
          }
          return resolvedFunctions;
        }
        function validateDeprecatedThis(signaturesMap) {
          const deprecatedThisRegex = /\bthis(\(|\.signatures\b)/;
          Object.keys(signaturesMap).forEach((signature) => {
            const fn = signaturesMap[signature];
            if (deprecatedThisRegex.test(fn.toString())) {
              throw new SyntaxError("Using `this` to self-reference a function is deprecated since typed-function@3. Use typed.referTo and typed.referToSelf instead.");
            }
          });
        }
        function createTypedFunction(name314, rawSignaturesMap) {
          typed3.createCount++;
          if (Object.keys(rawSignaturesMap).length === 0) {
            throw new SyntaxError("No signatures provided");
          }
          if (typed3.warnAgainstDeprecatedThis) {
            validateDeprecatedThis(rawSignaturesMap);
          }
          const parsedParams = [];
          const originalFunctions = [];
          const signaturesMap = {};
          const preliminarySignatures = [];
          let signature;
          for (signature in rawSignaturesMap) {
            if (!Object.prototype.hasOwnProperty.call(rawSignaturesMap, signature)) {
              continue;
            }
            const params = parseSignature(signature);
            if (!params)
              continue;
            parsedParams.forEach(function(pp) {
              if (conflicting(pp, params)) {
                throw new TypeError('Conflicting signatures "' + stringifyParams(pp) + '" and "' + stringifyParams(params) + '".');
              }
            });
            parsedParams.push(params);
            const functionIndex = originalFunctions.length;
            originalFunctions.push(rawSignaturesMap[signature]);
            const conversionParams = params.map(expandParam);
            let sp;
            for (sp of splitParams(conversionParams)) {
              const spName = stringifyParams(sp);
              preliminarySignatures.push({
                params: sp,
                name: spName,
                fn: functionIndex
              });
              if (sp.every((p) => !p.hasConversion)) {
                signaturesMap[spName] = functionIndex;
              }
            }
          }
          preliminarySignatures.sort(compareSignatures);
          const resolvedFunctions = resolveReferences(originalFunctions, signaturesMap, theTypedFn);
          let s;
          for (s in signaturesMap) {
            if (Object.prototype.hasOwnProperty.call(signaturesMap, s)) {
              signaturesMap[s] = resolvedFunctions[signaturesMap[s]];
            }
          }
          const signatures = [];
          const internalSignatureMap = /* @__PURE__ */ new Map();
          for (s of preliminarySignatures) {
            if (!internalSignatureMap.has(s.name)) {
              s.fn = resolvedFunctions[s.fn];
              signatures.push(s);
              internalSignatureMap.set(s.name, s);
            }
          }
          const ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);
          const ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);
          const ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);
          const ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);
          const ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);
          const ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);
          const allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;
          for (let i2 = 0; i2 < signatures.length; ++i2) {
            signatures[i2].test = compileTests(signatures[i2].params);
          }
          const test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;
          const test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;
          const test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;
          const test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;
          const test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;
          const test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;
          const test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;
          const test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;
          const test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;
          const test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;
          const test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;
          const test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;
          for (let i2 = 0; i2 < signatures.length; ++i2) {
            signatures[i2].implementation = compileArgsPreprocessing(signatures[i2].params, signatures[i2].fn);
          }
          const fn0 = ok0 ? signatures[0].implementation : undef;
          const fn1 = ok1 ? signatures[1].implementation : undef;
          const fn2 = ok2 ? signatures[2].implementation : undef;
          const fn3 = ok3 ? signatures[3].implementation : undef;
          const fn4 = ok4 ? signatures[4].implementation : undef;
          const fn5 = ok5 ? signatures[5].implementation : undef;
          const len0 = ok0 ? signatures[0].params.length : -1;
          const len1 = ok1 ? signatures[1].params.length : -1;
          const len2 = ok2 ? signatures[2].params.length : -1;
          const len3 = ok3 ? signatures[3].params.length : -1;
          const len4 = ok4 ? signatures[4].params.length : -1;
          const len5 = ok5 ? signatures[5].params.length : -1;
          const iStart = allOk ? 6 : 0;
          const iEnd = signatures.length;
          const tests = signatures.map((s2) => s2.test);
          const fns = signatures.map((s2) => s2.implementation);
          const generic = function generic2() {
            for (let i2 = iStart; i2 < iEnd; i2++) {
              if (tests[i2](arguments)) {
                return fns[i2].apply(this, arguments);
              }
            }
            return typed3.onMismatch(name314, arguments, signatures);
          };
          function theTypedFn(arg0, arg1) {
            if (arguments.length === len0 && test00(arg0) && test01(arg1)) {
              return fn0.apply(this, arguments);
            }
            if (arguments.length === len1 && test10(arg0) && test11(arg1)) {
              return fn1.apply(this, arguments);
            }
            if (arguments.length === len2 && test20(arg0) && test21(arg1)) {
              return fn2.apply(this, arguments);
            }
            if (arguments.length === len3 && test30(arg0) && test31(arg1)) {
              return fn3.apply(this, arguments);
            }
            if (arguments.length === len4 && test40(arg0) && test41(arg1)) {
              return fn4.apply(this, arguments);
            }
            if (arguments.length === len5 && test50(arg0) && test51(arg1)) {
              return fn5.apply(this, arguments);
            }
            return generic.apply(this, arguments);
          }
          try {
            Object.defineProperty(theTypedFn, "name", {
              value: name314
            });
          } catch (err) {
          }
          theTypedFn.signatures = signaturesMap;
          theTypedFn._typedFunctionData = {
            signatures,
            signatureMap: internalSignatureMap
          };
          return theTypedFn;
        }
        function _onMismatch(name314, args, signatures) {
          throw createError(name314, args, signatures);
        }
        function initial(arr) {
          return slice(arr, 0, arr.length - 1);
        }
        function last(arr) {
          return arr[arr.length - 1];
        }
        function slice(arr, start, end) {
          return Array.prototype.slice.call(arr, start, end);
        }
        function findInArray(arr, test) {
          for (let i2 = 0; i2 < arr.length; i2++) {
            if (test(arr[i2])) {
              return arr[i2];
            }
          }
          return void 0;
        }
        function flatMap(arr, callback) {
          return Array.prototype.concat.apply([], arr.map(callback));
        }
        function referTo() {
          const references = initial(arguments).map((s) => stringifyParams(parseSignature(s)));
          const callback = last(arguments);
          if (typeof callback !== "function") {
            throw new TypeError("Callback function expected as last argument");
          }
          return makeReferTo(references, callback);
        }
        function makeReferTo(references, callback) {
          return {
            referTo: {
              references,
              callback
            }
          };
        }
        function referToSelf(callback) {
          if (typeof callback !== "function") {
            throw new TypeError("Callback function expected as first argument");
          }
          return {
            referToSelf: {
              callback
            }
          };
        }
        function isReferTo(objectOrFn) {
          return objectOrFn && typeof objectOrFn.referTo === "object" && Array.isArray(objectOrFn.referTo.references) && typeof objectOrFn.referTo.callback === "function";
        }
        function isReferToSelf(objectOrFn) {
          return objectOrFn && typeof objectOrFn.referToSelf === "object" && typeof objectOrFn.referToSelf.callback === "function";
        }
        function checkName(nameSoFar, newName) {
          if (!nameSoFar) {
            return newName;
          }
          if (newName && newName !== nameSoFar) {
            const err = new Error("Function names do not match (expected: " + nameSoFar + ", actual: " + newName + ")");
            err.data = {
              actual: newName,
              expected: nameSoFar
            };
            throw err;
          }
          return nameSoFar;
        }
        function getObjectName(obj) {
          let name314;
          for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key) && (isTypedFunction(obj[key]) || typeof obj[key].signature === "string")) {
              name314 = checkName(name314, obj[key].name);
            }
          }
          return name314;
        }
        function mergeSignatures(dest, source) {
          let key;
          for (key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              if (key in dest) {
                if (source[key] !== dest[key]) {
                  const err = new Error('Signature "' + key + '" is defined twice');
                  err.data = {
                    signature: key,
                    sourceFunction: source[key],
                    destFunction: dest[key]
                  };
                  throw err;
                }
              }
              dest[key] = source[key];
            }
          }
        }
        const saveTyped = typed3;
        typed3 = function(maybeName) {
          const named = typeof maybeName === "string";
          const start = named ? 1 : 0;
          let name314 = named ? maybeName : "";
          const allSignatures = {};
          for (let i2 = start; i2 < arguments.length; ++i2) {
            const item = arguments[i2];
            let theseSignatures = {};
            let thisName;
            if (typeof item === "function") {
              thisName = item.name;
              if (typeof item.signature === "string") {
                theseSignatures[item.signature] = item;
              } else if (isTypedFunction(item)) {
                theseSignatures = item.signatures;
              }
            } else if (isPlainObject2(item)) {
              theseSignatures = item;
              if (!named) {
                thisName = getObjectName(item);
              }
            }
            if (Object.keys(theseSignatures).length === 0) {
              const err = new TypeError("Argument to 'typed' at index " + i2 + " is not a (typed) function, nor an object with signatures as keys and functions as values.");
              err.data = {
                index: i2,
                argument: item
              };
              throw err;
            }
            if (!named) {
              name314 = checkName(name314, thisName);
            }
            mergeSignatures(allSignatures, theseSignatures);
          }
          return createTypedFunction(name314 || "", allSignatures);
        };
        typed3.create = create;
        typed3.createCount = saveTyped.createCount;
        typed3.onMismatch = _onMismatch;
        typed3.throwMismatchError = _onMismatch;
        typed3.createError = createError;
        typed3.clear = clear;
        typed3.clearConversions = clearConversions;
        typed3.addTypes = addTypes;
        typed3._findType = findType;
        typed3.referTo = referTo;
        typed3.referToSelf = referToSelf;
        typed3.convert = convert;
        typed3.findSignature = findSignature;
        typed3.find = find;
        typed3.isTypedFunction = isTypedFunction;
        typed3.warnAgainstDeprecatedThis = true;
        typed3.addType = function(type, beforeObjectTest) {
          let before = "any";
          if (beforeObjectTest !== false && typeMap.has("Object")) {
            before = "Object";
          }
          typed3.addTypes([type], before);
        };
        function _validateConversion(conversion) {
          if (!conversion || typeof conversion.from !== "string" || typeof conversion.to !== "string" || typeof conversion.convert !== "function") {
            throw new TypeError("Object with properties {from: string, to: string, convert: function} expected");
          }
          if (conversion.to === conversion.from) {
            throw new SyntaxError('Illegal to define conversion from "' + conversion.from + '" to itself.');
          }
        }
        typed3.addConversion = function(conversion) {
          let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
            override: false
          };
          _validateConversion(conversion);
          const to2 = findType(conversion.to);
          const existing = to2.conversionsTo.find((other) => other.from === conversion.from);
          if (existing) {
            if (options2 && options2.override) {
              typed3.removeConversion({
                from: existing.from,
                to: conversion.to,
                convert: existing.convert
              });
            } else {
              throw new Error('There is already a conversion from "' + conversion.from + '" to "' + to2.name + '"');
            }
          }
          to2.conversionsTo.push({
            from: conversion.from,
            convert: conversion.convert,
            index: nConversions++
          });
        };
        typed3.addConversions = function(conversions, options2) {
          conversions.forEach((conversion) => typed3.addConversion(conversion, options2));
        };
        typed3.removeConversion = function(conversion) {
          _validateConversion(conversion);
          const to2 = findType(conversion.to);
          const existingConversion = findInArray(to2.conversionsTo, (c) => c.from === conversion.from);
          if (!existingConversion) {
            throw new Error("Attempt to remove nonexistent conversion from " + conversion.from + " to " + conversion.to);
          }
          if (existingConversion.convert !== conversion.convert) {
            throw new Error("Conversion to remove does not match existing conversion");
          }
          const index2 = to2.conversionsTo.indexOf(existingConversion);
          to2.conversionsTo.splice(index2, 1);
        };
        typed3.resolve = function(tf, argList) {
          if (!isTypedFunction(tf)) {
            throw new TypeError(NOT_TYPED_FUNCTION);
          }
          const sigs = tf._typedFunctionData.signatures;
          for (let i2 = 0; i2 < sigs.length; ++i2) {
            if (sigs[i2].test(argList)) {
              return sigs[i2];
            }
          }
          return null;
        };
        return typed3;
      }
      var typedFunction2 = create();
      return typedFunction2;
    });
  }
});

// node_modules/complex.js/complex.js
var require_complex = __commonJS({
  "node_modules/complex.js/complex.js"(exports, module2) {
    (function(root) {
      "use strict";
      var cosh4 = Math.cosh || function(x) {
        return Math.abs(x) < 1e-9 ? 1 - x : (Math.exp(x) + Math.exp(-x)) * 0.5;
      };
      var sinh4 = Math.sinh || function(x) {
        return Math.abs(x) < 1e-9 ? x : (Math.exp(x) - Math.exp(-x)) * 0.5;
      };
      var cosm1 = function(x) {
        var b = Math.PI / 4;
        if (-b > x || x > b) {
          return Math.cos(x) - 1;
        }
        var xx = x * x;
        return xx * (xx * (xx * (xx * (xx * (xx * (xx * (xx / 20922789888e3 - 1 / 87178291200) + 1 / 479001600) - 1 / 3628800) + 1 / 40320) - 1 / 720) + 1 / 24) - 1 / 2);
      };
      var hypot3 = function(x, y) {
        var a = Math.abs(x);
        var b = Math.abs(y);
        if (a < 3e3 && b < 3e3) {
          return Math.sqrt(a * a + b * b);
        }
        if (a < b) {
          a = b;
          b = x / y;
        } else {
          b = y / x;
        }
        return a * Math.sqrt(1 + b * b);
      };
      var parser_exit = function() {
        throw SyntaxError("Invalid Param");
      };
      function logHypot(a, b) {
        var _a = Math.abs(a);
        var _b = Math.abs(b);
        if (a === 0) {
          return Math.log(_b);
        }
        if (b === 0) {
          return Math.log(_a);
        }
        if (_a < 3e3 && _b < 3e3) {
          return Math.log(a * a + b * b) * 0.5;
        }
        a = a / 2;
        b = b / 2;
        return 0.5 * Math.log(a * a + b * b) + Math.LN2;
      }
      var parse4 = function(a, b) {
        var z = { "re": 0, "im": 0 };
        if (a === void 0 || a === null) {
          z["re"] = z["im"] = 0;
        } else if (b !== void 0) {
          z["re"] = a;
          z["im"] = b;
        } else
          switch (typeof a) {
            case "object":
              if ("im" in a && "re" in a) {
                z["re"] = a["re"];
                z["im"] = a["im"];
              } else if ("abs" in a && "arg" in a) {
                if (!Number.isFinite(a["abs"]) && Number.isFinite(a["arg"])) {
                  return Complex3["INFINITY"];
                }
                z["re"] = a["abs"] * Math.cos(a["arg"]);
                z["im"] = a["abs"] * Math.sin(a["arg"]);
              } else if ("r" in a && "phi" in a) {
                if (!Number.isFinite(a["r"]) && Number.isFinite(a["phi"])) {
                  return Complex3["INFINITY"];
                }
                z["re"] = a["r"] * Math.cos(a["phi"]);
                z["im"] = a["r"] * Math.sin(a["phi"]);
              } else if (a.length === 2) {
                z["re"] = a[0];
                z["im"] = a[1];
              } else {
                parser_exit();
              }
              break;
            case "string":
              z["im"] = /* void */
              z["re"] = 0;
              var tokens = a.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);
              var plus = 1;
              var minus = 0;
              if (tokens === null) {
                parser_exit();
              }
              for (var i2 = 0; i2 < tokens.length; i2++) {
                var c = tokens[i2];
                if (c === " " || c === "	" || c === "\n") {
                } else if (c === "+") {
                  plus++;
                } else if (c === "-") {
                  minus++;
                } else if (c === "i" || c === "I") {
                  if (plus + minus === 0) {
                    parser_exit();
                  }
                  if (tokens[i2 + 1] !== " " && !isNaN(tokens[i2 + 1])) {
                    z["im"] += parseFloat((minus % 2 ? "-" : "") + tokens[i2 + 1]);
                    i2++;
                  } else {
                    z["im"] += parseFloat((minus % 2 ? "-" : "") + "1");
                  }
                  plus = minus = 0;
                } else {
                  if (plus + minus === 0 || isNaN(c)) {
                    parser_exit();
                  }
                  if (tokens[i2 + 1] === "i" || tokens[i2 + 1] === "I") {
                    z["im"] += parseFloat((minus % 2 ? "-" : "") + c);
                    i2++;
                  } else {
                    z["re"] += parseFloat((minus % 2 ? "-" : "") + c);
                  }
                  plus = minus = 0;
                }
              }
              if (plus + minus > 0) {
                parser_exit();
              }
              break;
            case "number":
              z["im"] = 0;
              z["re"] = a;
              break;
            default:
              parser_exit();
          }
        if (isNaN(z["re"]) || isNaN(z["im"])) {
        }
        return z;
      };
      function Complex3(a, b) {
        if (!(this instanceof Complex3)) {
          return new Complex3(a, b);
        }
        var z = parse4(a, b);
        this["re"] = z["re"];
        this["im"] = z["im"];
      }
      Complex3.prototype = {
        "re": 0,
        "im": 0,
        /**
         * Calculates the sign of a complex number, which is a normalized complex
         *
         * @returns {Complex}
         */
        "sign": function() {
          var abs3 = this["abs"]();
          return new Complex3(
            this["re"] / abs3,
            this["im"] / abs3
          );
        },
        /**
         * Adds two complex numbers
         *
         * @returns {Complex}
         */
        "add": function(a, b) {
          var z = new Complex3(a, b);
          if (this["isInfinite"]() && z["isInfinite"]()) {
            return Complex3["NAN"];
          }
          if (this["isInfinite"]() || z["isInfinite"]()) {
            return Complex3["INFINITY"];
          }
          return new Complex3(
            this["re"] + z["re"],
            this["im"] + z["im"]
          );
        },
        /**
         * Subtracts two complex numbers
         *
         * @returns {Complex}
         */
        "sub": function(a, b) {
          var z = new Complex3(a, b);
          if (this["isInfinite"]() && z["isInfinite"]()) {
            return Complex3["NAN"];
          }
          if (this["isInfinite"]() || z["isInfinite"]()) {
            return Complex3["INFINITY"];
          }
          return new Complex3(
            this["re"] - z["re"],
            this["im"] - z["im"]
          );
        },
        /**
         * Multiplies two complex numbers
         *
         * @returns {Complex}
         */
        "mul": function(a, b) {
          var z = new Complex3(a, b);
          if (this["isInfinite"]() && z["isZero"]() || this["isZero"]() && z["isInfinite"]()) {
            return Complex3["NAN"];
          }
          if (this["isInfinite"]() || z["isInfinite"]()) {
            return Complex3["INFINITY"];
          }
          if (z["im"] === 0 && this["im"] === 0) {
            return new Complex3(this["re"] * z["re"], 0);
          }
          return new Complex3(
            this["re"] * z["re"] - this["im"] * z["im"],
            this["re"] * z["im"] + this["im"] * z["re"]
          );
        },
        /**
         * Divides two complex numbers
         *
         * @returns {Complex}
         */
        "div": function(a, b) {
          var z = new Complex3(a, b);
          if (this["isZero"]() && z["isZero"]() || this["isInfinite"]() && z["isInfinite"]()) {
            return Complex3["NAN"];
          }
          if (this["isInfinite"]() || z["isZero"]()) {
            return Complex3["INFINITY"];
          }
          if (this["isZero"]() || z["isInfinite"]()) {
            return Complex3["ZERO"];
          }
          a = this["re"];
          b = this["im"];
          var c = z["re"];
          var d = z["im"];
          var t, x;
          if (0 === d) {
            return new Complex3(a / c, b / c);
          }
          if (Math.abs(c) < Math.abs(d)) {
            x = c / d;
            t = c * x + d;
            return new Complex3(
              (a * x + b) / t,
              (b * x - a) / t
            );
          } else {
            x = d / c;
            t = d * x + c;
            return new Complex3(
              (a + b * x) / t,
              (b - a * x) / t
            );
          }
        },
        /**
         * Calculate the power of two complex numbers
         *
         * @returns {Complex}
         */
        "pow": function(a, b) {
          var z = new Complex3(a, b);
          a = this["re"];
          b = this["im"];
          if (z["isZero"]()) {
            return Complex3["ONE"];
          }
          if (z["im"] === 0) {
            if (b === 0 && a > 0) {
              return new Complex3(Math.pow(a, z["re"]), 0);
            } else if (a === 0) {
              switch ((z["re"] % 4 + 4) % 4) {
                case 0:
                  return new Complex3(Math.pow(b, z["re"]), 0);
                case 1:
                  return new Complex3(0, Math.pow(b, z["re"]));
                case 2:
                  return new Complex3(-Math.pow(b, z["re"]), 0);
                case 3:
                  return new Complex3(0, -Math.pow(b, z["re"]));
              }
            }
          }
          if (a === 0 && b === 0 && z["re"] > 0 && z["im"] >= 0) {
            return Complex3["ZERO"];
          }
          var arg2 = Math.atan2(b, a);
          var loh = logHypot(a, b);
          a = Math.exp(z["re"] * loh - z["im"] * arg2);
          b = z["im"] * loh + z["re"] * arg2;
          return new Complex3(
            a * Math.cos(b),
            a * Math.sin(b)
          );
        },
        /**
         * Calculate the complex square root
         *
         * @returns {Complex}
         */
        "sqrt": function() {
          var a = this["re"];
          var b = this["im"];
          var r = this["abs"]();
          var re2, im2;
          if (a >= 0) {
            if (b === 0) {
              return new Complex3(Math.sqrt(a), 0);
            }
            re2 = 0.5 * Math.sqrt(2 * (r + a));
          } else {
            re2 = Math.abs(b) / Math.sqrt(2 * (r - a));
          }
          if (a <= 0) {
            im2 = 0.5 * Math.sqrt(2 * (r - a));
          } else {
            im2 = Math.abs(b) / Math.sqrt(2 * (r + a));
          }
          return new Complex3(re2, b < 0 ? -im2 : im2);
        },
        /**
         * Calculate the complex exponent
         *
         * @returns {Complex}
         */
        "exp": function() {
          var tmp = Math.exp(this["re"]);
          if (this["im"] === 0) {
          }
          return new Complex3(
            tmp * Math.cos(this["im"]),
            tmp * Math.sin(this["im"])
          );
        },
        /**
         * Calculate the complex exponent and subtracts one.
         *
         * This may be more accurate than `Complex(x).exp().sub(1)` if
         * `x` is small.
         *
         * @returns {Complex}
         */
        "expm1": function() {
          var a = this["re"];
          var b = this["im"];
          return new Complex3(
            Math.expm1(a) * Math.cos(b) + cosm1(b),
            Math.exp(a) * Math.sin(b)
          );
        },
        /**
         * Calculate the natural log
         *
         * @returns {Complex}
         */
        "log": function() {
          var a = this["re"];
          var b = this["im"];
          if (b === 0 && a > 0) {
          }
          return new Complex3(
            logHypot(a, b),
            Math.atan2(b, a)
          );
        },
        /**
         * Calculate the magnitude of the complex number
         *
         * @returns {number}
         */
        "abs": function() {
          return hypot3(this["re"], this["im"]);
        },
        /**
         * Calculate the angle of the complex number
         *
         * @returns {number}
         */
        "arg": function() {
          return Math.atan2(this["im"], this["re"]);
        },
        /**
         * Calculate the sine of the complex number
         *
         * @returns {Complex}
         */
        "sin": function() {
          var a = this["re"];
          var b = this["im"];
          return new Complex3(
            Math.sin(a) * cosh4(b),
            Math.cos(a) * sinh4(b)
          );
        },
        /**
         * Calculate the cosine
         *
         * @returns {Complex}
         */
        "cos": function() {
          var a = this["re"];
          var b = this["im"];
          return new Complex3(
            Math.cos(a) * cosh4(b),
            -Math.sin(a) * sinh4(b)
          );
        },
        /**
         * Calculate the tangent
         *
         * @returns {Complex}
         */
        "tan": function() {
          var a = 2 * this["re"];
          var b = 2 * this["im"];
          var d = Math.cos(a) + cosh4(b);
          return new Complex3(
            Math.sin(a) / d,
            sinh4(b) / d
          );
        },
        /**
         * Calculate the cotangent
         *
         * @returns {Complex}
         */
        "cot": function() {
          var a = 2 * this["re"];
          var b = 2 * this["im"];
          var d = Math.cos(a) - cosh4(b);
          return new Complex3(
            -Math.sin(a) / d,
            sinh4(b) / d
          );
        },
        /**
         * Calculate the secant
         *
         * @returns {Complex}
         */
        "sec": function() {
          var a = this["re"];
          var b = this["im"];
          var d = 0.5 * cosh4(2 * b) + 0.5 * Math.cos(2 * a);
          return new Complex3(
            Math.cos(a) * cosh4(b) / d,
            Math.sin(a) * sinh4(b) / d
          );
        },
        /**
         * Calculate the cosecans
         *
         * @returns {Complex}
         */
        "csc": function() {
          var a = this["re"];
          var b = this["im"];
          var d = 0.5 * cosh4(2 * b) - 0.5 * Math.cos(2 * a);
          return new Complex3(
            Math.sin(a) * cosh4(b) / d,
            -Math.cos(a) * sinh4(b) / d
          );
        },
        /**
         * Calculate the complex arcus sinus
         *
         * @returns {Complex}
         */
        "asin": function() {
          var a = this["re"];
          var b = this["im"];
          var t1 = new Complex3(
            b * b - a * a + 1,
            -2 * a * b
          )["sqrt"]();
          var t2 = new Complex3(
            t1["re"] - b,
            t1["im"] + a
          )["log"]();
          return new Complex3(t2["im"], -t2["re"]);
        },
        /**
         * Calculate the complex arcus cosinus
         *
         * @returns {Complex}
         */
        "acos": function() {
          var a = this["re"];
          var b = this["im"];
          var t1 = new Complex3(
            b * b - a * a + 1,
            -2 * a * b
          )["sqrt"]();
          var t2 = new Complex3(
            t1["re"] - b,
            t1["im"] + a
          )["log"]();
          return new Complex3(Math.PI / 2 - t2["im"], t2["re"]);
        },
        /**
         * Calculate the complex arcus tangent
         *
         * @returns {Complex}
         */
        "atan": function() {
          var a = this["re"];
          var b = this["im"];
          if (a === 0) {
            if (b === 1) {
              return new Complex3(0, Infinity);
            }
            if (b === -1) {
              return new Complex3(0, -Infinity);
            }
          }
          var d = a * a + (1 - b) * (1 - b);
          var t1 = new Complex3(
            (1 - b * b - a * a) / d,
            -2 * a / d
          ).log();
          return new Complex3(-0.5 * t1["im"], 0.5 * t1["re"]);
        },
        /**
         * Calculate the complex arcus cotangent
         *
         * @returns {Complex}
         */
        "acot": function() {
          var a = this["re"];
          var b = this["im"];
          if (b === 0) {
            return new Complex3(Math.atan2(1, a), 0);
          }
          var d = a * a + b * b;
          return d !== 0 ? new Complex3(
            a / d,
            -b / d
          ).atan() : new Complex3(
            a !== 0 ? a / 0 : 0,
            b !== 0 ? -b / 0 : 0
          ).atan();
        },
        /**
         * Calculate the complex arcus secant
         *
         * @returns {Complex}
         */
        "asec": function() {
          var a = this["re"];
          var b = this["im"];
          if (a === 0 && b === 0) {
            return new Complex3(0, Infinity);
          }
          var d = a * a + b * b;
          return d !== 0 ? new Complex3(
            a / d,
            -b / d
          ).acos() : new Complex3(
            a !== 0 ? a / 0 : 0,
            b !== 0 ? -b / 0 : 0
          ).acos();
        },
        /**
         * Calculate the complex arcus cosecans
         *
         * @returns {Complex}
         */
        "acsc": function() {
          var a = this["re"];
          var b = this["im"];
          if (a === 0 && b === 0) {
            return new Complex3(Math.PI / 2, Infinity);
          }
          var d = a * a + b * b;
          return d !== 0 ? new Complex3(
            a / d,
            -b / d
          ).asin() : new Complex3(
            a !== 0 ? a / 0 : 0,
            b !== 0 ? -b / 0 : 0
          ).asin();
        },
        /**
         * Calculate the complex sinh
         *
         * @returns {Complex}
         */
        "sinh": function() {
          var a = this["re"];
          var b = this["im"];
          return new Complex3(
            sinh4(a) * Math.cos(b),
            cosh4(a) * Math.sin(b)
          );
        },
        /**
         * Calculate the complex cosh
         *
         * @returns {Complex}
         */
        "cosh": function() {
          var a = this["re"];
          var b = this["im"];
          return new Complex3(
            cosh4(a) * Math.cos(b),
            sinh4(a) * Math.sin(b)
          );
        },
        /**
         * Calculate the complex tanh
         *
         * @returns {Complex}
         */
        "tanh": function() {
          var a = 2 * this["re"];
          var b = 2 * this["im"];
          var d = cosh4(a) + Math.cos(b);
          return new Complex3(
            sinh4(a) / d,
            Math.sin(b) / d
          );
        },
        /**
         * Calculate the complex coth
         *
         * @returns {Complex}
         */
        "coth": function() {
          var a = 2 * this["re"];
          var b = 2 * this["im"];
          var d = cosh4(a) - Math.cos(b);
          return new Complex3(
            sinh4(a) / d,
            -Math.sin(b) / d
          );
        },
        /**
         * Calculate the complex coth
         *
         * @returns {Complex}
         */
        "csch": function() {
          var a = this["re"];
          var b = this["im"];
          var d = Math.cos(2 * b) - cosh4(2 * a);
          return new Complex3(
            -2 * sinh4(a) * Math.cos(b) / d,
            2 * cosh4(a) * Math.sin(b) / d
          );
        },
        /**
         * Calculate the complex sech
         *
         * @returns {Complex}
         */
        "sech": function() {
          var a = this["re"];
          var b = this["im"];
          var d = Math.cos(2 * b) + cosh4(2 * a);
          return new Complex3(
            2 * cosh4(a) * Math.cos(b) / d,
            -2 * sinh4(a) * Math.sin(b) / d
          );
        },
        /**
         * Calculate the complex asinh
         *
         * @returns {Complex}
         */
        "asinh": function() {
          var tmp = this["im"];
          this["im"] = -this["re"];
          this["re"] = tmp;
          var res = this["asin"]();
          this["re"] = -this["im"];
          this["im"] = tmp;
          tmp = res["re"];
          res["re"] = -res["im"];
          res["im"] = tmp;
          return res;
        },
        /**
         * Calculate the complex acosh
         *
         * @returns {Complex}
         */
        "acosh": function() {
          var res = this["acos"]();
          if (res["im"] <= 0) {
            var tmp = res["re"];
            res["re"] = -res["im"];
            res["im"] = tmp;
          } else {
            var tmp = res["im"];
            res["im"] = -res["re"];
            res["re"] = tmp;
          }
          return res;
        },
        /**
         * Calculate the complex atanh
         *
         * @returns {Complex}
         */
        "atanh": function() {
          var a = this["re"];
          var b = this["im"];
          var noIM = a > 1 && b === 0;
          var oneMinus = 1 - a;
          var onePlus = 1 + a;
          var d = oneMinus * oneMinus + b * b;
          var x = d !== 0 ? new Complex3(
            (onePlus * oneMinus - b * b) / d,
            (b * oneMinus + onePlus * b) / d
          ) : new Complex3(
            a !== -1 ? a / 0 : 0,
            b !== 0 ? b / 0 : 0
          );
          var temp = x["re"];
          x["re"] = logHypot(x["re"], x["im"]) / 2;
          x["im"] = Math.atan2(x["im"], temp) / 2;
          if (noIM) {
            x["im"] = -x["im"];
          }
          return x;
        },
        /**
         * Calculate the complex acoth
         *
         * @returns {Complex}
         */
        "acoth": function() {
          var a = this["re"];
          var b = this["im"];
          if (a === 0 && b === 0) {
            return new Complex3(0, Math.PI / 2);
          }
          var d = a * a + b * b;
          return d !== 0 ? new Complex3(
            a / d,
            -b / d
          ).atanh() : new Complex3(
            a !== 0 ? a / 0 : 0,
            b !== 0 ? -b / 0 : 0
          ).atanh();
        },
        /**
         * Calculate the complex acsch
         *
         * @returns {Complex}
         */
        "acsch": function() {
          var a = this["re"];
          var b = this["im"];
          if (b === 0) {
            return new Complex3(
              a !== 0 ? Math.log(a + Math.sqrt(a * a + 1)) : Infinity,
              0
            );
          }
          var d = a * a + b * b;
          return d !== 0 ? new Complex3(
            a / d,
            -b / d
          ).asinh() : new Complex3(
            a !== 0 ? a / 0 : 0,
            b !== 0 ? -b / 0 : 0
          ).asinh();
        },
        /**
         * Calculate the complex asech
         *
         * @returns {Complex}
         */
        "asech": function() {
          var a = this["re"];
          var b = this["im"];
          if (this["isZero"]()) {
            return Complex3["INFINITY"];
          }
          var d = a * a + b * b;
          return d !== 0 ? new Complex3(
            a / d,
            -b / d
          ).acosh() : new Complex3(
            a !== 0 ? a / 0 : 0,
            b !== 0 ? -b / 0 : 0
          ).acosh();
        },
        /**
         * Calculate the complex inverse 1/z
         *
         * @returns {Complex}
         */
        "inverse": function() {
          if (this["isZero"]()) {
            return Complex3["INFINITY"];
          }
          if (this["isInfinite"]()) {
            return Complex3["ZERO"];
          }
          var a = this["re"];
          var b = this["im"];
          var d = a * a + b * b;
          return new Complex3(a / d, -b / d);
        },
        /**
         * Returns the complex conjugate
         *
         * @returns {Complex}
         */
        "conjugate": function() {
          return new Complex3(this["re"], -this["im"]);
        },
        /**
         * Gets the negated complex number
         *
         * @returns {Complex}
         */
        "neg": function() {
          return new Complex3(-this["re"], -this["im"]);
        },
        /**
         * Ceils the actual complex number
         *
         * @returns {Complex}
         */
        "ceil": function(places) {
          places = Math.pow(10, places || 0);
          return new Complex3(
            Math.ceil(this["re"] * places) / places,
            Math.ceil(this["im"] * places) / places
          );
        },
        /**
         * Floors the actual complex number
         *
         * @returns {Complex}
         */
        "floor": function(places) {
          places = Math.pow(10, places || 0);
          return new Complex3(
            Math.floor(this["re"] * places) / places,
            Math.floor(this["im"] * places) / places
          );
        },
        /**
         * Ceils the actual complex number
         *
         * @returns {Complex}
         */
        "round": function(places) {
          places = Math.pow(10, places || 0);
          return new Complex3(
            Math.round(this["re"] * places) / places,
            Math.round(this["im"] * places) / places
          );
        },
        /**
         * Compares two complex numbers
         *
         * **Note:** new Complex(Infinity).equals(Infinity) === false
         *
         * @returns {boolean}
         */
        "equals": function(a, b) {
          var z = new Complex3(a, b);
          return Math.abs(z["re"] - this["re"]) <= Complex3["EPSILON"] && Math.abs(z["im"] - this["im"]) <= Complex3["EPSILON"];
        },
        /**
         * Clones the actual object
         *
         * @returns {Complex}
         */
        "clone": function() {
          return new Complex3(this["re"], this["im"]);
        },
        /**
         * Gets a string of the actual complex number
         *
         * @returns {string}
         */
        "toString": function() {
          var a = this["re"];
          var b = this["im"];
          var ret = "";
          if (this["isNaN"]()) {
            return "NaN";
          }
          if (this["isInfinite"]()) {
            return "Infinity";
          }
          if (Math.abs(a) < Complex3["EPSILON"]) {
            a = 0;
          }
          if (Math.abs(b) < Complex3["EPSILON"]) {
            b = 0;
          }
          if (b === 0) {
            return ret + a;
          }
          if (a !== 0) {
            ret += a;
            ret += " ";
            if (b < 0) {
              b = -b;
              ret += "-";
            } else {
              ret += "+";
            }
            ret += " ";
          } else if (b < 0) {
            b = -b;
            ret += "-";
          }
          if (1 !== b) {
            ret += b;
          }
          return ret + "i";
        },
        /**
         * Returns the actual number as a vector
         *
         * @returns {Array}
         */
        "toVector": function() {
          return [this["re"], this["im"]];
        },
        /**
         * Returns the actual real value of the current object
         *
         * @returns {number|null}
         */
        "valueOf": function() {
          if (this["im"] === 0) {
            return this["re"];
          }
          return null;
        },
        /**
         * Determines whether a complex number is not on the Riemann sphere.
         *
         * @returns {boolean}
         */
        "isNaN": function() {
          return isNaN(this["re"]) || isNaN(this["im"]);
        },
        /**
         * Determines whether or not a complex number is at the zero pole of the
         * Riemann sphere.
         *
         * @returns {boolean}
         */
        "isZero": function() {
          return this["im"] === 0 && this["re"] === 0;
        },
        /**
         * Determines whether a complex number is not at the infinity pole of the
         * Riemann sphere.
         *
         * @returns {boolean}
         */
        "isFinite": function() {
          return isFinite(this["re"]) && isFinite(this["im"]);
        },
        /**
         * Determines whether or not a complex number is at the infinity pole of the
         * Riemann sphere.
         *
         * @returns {boolean}
         */
        "isInfinite": function() {
          return !(this["isNaN"]() || this["isFinite"]());
        }
      };
      Complex3["ZERO"] = new Complex3(0, 0);
      Complex3["ONE"] = new Complex3(1, 0);
      Complex3["I"] = new Complex3(0, 1);
      Complex3["PI"] = new Complex3(Math.PI, 0);
      Complex3["E"] = new Complex3(Math.E, 0);
      Complex3["INFINITY"] = new Complex3(Infinity, Infinity);
      Complex3["NAN"] = new Complex3(NaN, NaN);
      Complex3["EPSILON"] = 1e-15;
      if (typeof define === "function" && define["amd"]) {
        define([], function() {
          return Complex3;
        });
      } else if (typeof exports === "object") {
        Object.defineProperty(Complex3, "__esModule", { "value": true });
        Complex3["default"] = Complex3;
        Complex3["Complex"] = Complex3;
        module2["exports"] = Complex3;
      } else {
        root["Complex"] = Complex3;
      }
    })(exports);
  }
});

// node_modules/javascript-natural-sort/naturalSort.js
var require_naturalSort = __commonJS({
  "node_modules/javascript-natural-sort/naturalSort.js"(exports, module2) {
    module2.exports = function naturalSort2(a, b) {
      "use strict";
      var re2 = /(^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi, sre = /(^[ ]*|[ ]*$)/g, dre = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/, hre = /^0x[0-9a-f]+$/i, ore = /^0/, i2 = function(s) {
        return naturalSort2.insensitive && ("" + s).toLowerCase() || "" + s;
      }, x = i2(a).replace(sre, "") || "", y = i2(b).replace(sre, "") || "", xN = x.replace(re2, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0"), yN = y.replace(re2, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0"), xD = parseInt(x.match(hre), 16) || xN.length !== 1 && x.match(dre) && Date.parse(x), yD = parseInt(y.match(hre), 16) || xD && y.match(dre) && Date.parse(y) || null, oFxNcL, oFyNcL;
      if (yD) {
        if (xD < yD) {
          return -1;
        } else if (xD > yD) {
          return 1;
        }
      }
      for (var cLoc = 0, numS = Math.max(xN.length, yN.length); cLoc < numS; cLoc++) {
        oFxNcL = !(xN[cLoc] || "").match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;
        oFyNcL = !(yN[cLoc] || "").match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0;
        if (isNaN(oFxNcL) !== isNaN(oFyNcL)) {
          return isNaN(oFxNcL) ? 1 : -1;
        } else if (typeof oFxNcL !== typeof oFyNcL) {
          oFxNcL += "";
          oFyNcL += "";
        }
        if (oFxNcL < oFyNcL) {
          return -1;
        }
        if (oFxNcL > oFyNcL) {
          return 1;
        }
      }
      return 0;
    };
  }
});

// node_modules/escape-latex/dist/index.js
var require_dist = __commonJS({
  "node_modules/escape-latex/dist/index.js"(exports, module2) {
    "use strict";
    var _extends2 = Object.assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var defaultEscapes = {
      "{": "\\{",
      "}": "\\}",
      "\\": "\\textbackslash{}",
      "#": "\\#",
      $: "\\$",
      "%": "\\%",
      "&": "\\&",
      "^": "\\textasciicircum{}",
      _: "\\_",
      "~": "\\textasciitilde{}"
    };
    var formatEscapes = {
      "\u2013": "\\--",
      "\u2014": "\\---",
      " ": "~",
      "	": "\\qquad{}",
      "\r\n": "\\newline{}",
      "\n": "\\newline{}"
    };
    var defaultEscapeMapFn = function defaultEscapeMapFn2(defaultEscapes2, formatEscapes2) {
      return _extends2({}, defaultEscapes2, formatEscapes2);
    };
    module2.exports = function(str) {
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$preserveFormatti = _ref.preserveFormatting, preserveFormatting = _ref$preserveFormatti === void 0 ? false : _ref$preserveFormatti, _ref$escapeMapFn = _ref.escapeMapFn, escapeMapFn = _ref$escapeMapFn === void 0 ? defaultEscapeMapFn : _ref$escapeMapFn;
      var runningStr = String(str);
      var result = "";
      var escapes = escapeMapFn(_extends2({}, defaultEscapes), preserveFormatting ? _extends2({}, formatEscapes) : {});
      var escapeKeys = Object.keys(escapes);
      var _loop = function _loop2() {
        var specialCharFound = false;
        escapeKeys.forEach(function(key, index2) {
          if (specialCharFound) {
            return;
          }
          if (runningStr.length >= key.length && runningStr.slice(0, key.length) === key) {
            result += escapes[escapeKeys[index2]];
            runningStr = runningStr.slice(key.length, runningStr.length);
            specialCharFound = true;
          }
        });
        if (!specialCharFound) {
          result += runningStr.slice(0, 1);
          runningStr = runningStr.slice(1, runningStr.length);
        }
      };
      while (runningStr) {
        _loop();
      }
      return result;
    };
  }
});

// node_modules/seedrandom/lib/alea.js
var require_alea = __commonJS({
  "node_modules/seedrandom/lib/alea.js"(exports, module2) {
    (function(global, module3, define2) {
      function Alea(seed) {
        var me = this, mash = Mash();
        me.next = function() {
          var t = 2091639 * me.s0 + me.c * 23283064365386963e-26;
          me.s0 = me.s1;
          me.s1 = me.s2;
          return me.s2 = t - (me.c = t | 0);
        };
        me.c = 1;
        me.s0 = mash(" ");
        me.s1 = mash(" ");
        me.s2 = mash(" ");
        me.s0 -= mash(seed);
        if (me.s0 < 0) {
          me.s0 += 1;
        }
        me.s1 -= mash(seed);
        if (me.s1 < 0) {
          me.s1 += 1;
        }
        me.s2 -= mash(seed);
        if (me.s2 < 0) {
          me.s2 += 1;
        }
        mash = null;
      }
      function copy(f, t) {
        t.c = f.c;
        t.s0 = f.s0;
        t.s1 = f.s1;
        t.s2 = f.s2;
        return t;
      }
      function impl(seed, opts) {
        var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
        prng.int32 = function() {
          return xg.next() * 4294967296 | 0;
        };
        prng.double = function() {
          return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
        };
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      function Mash() {
        var n = 4022871197;
        var mash = function(data) {
          data = String(data);
          for (var i2 = 0; i2 < data.length; i2++) {
            n += data.charCodeAt(i2);
            var h = 0.02519603282416938 * n;
            n = h >>> 0;
            h -= n;
            h *= n;
            n = h >>> 0;
            h -= n;
            n += h * 4294967296;
          }
          return (n >>> 0) * 23283064365386963e-26;
        };
        return mash;
      }
      if (module3 && module3.exports) {
        module3.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.alea = impl;
      }
    })(
      exports,
      typeof module2 == "object" && module2,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/xor128.js
var require_xor128 = __commonJS({
  "node_modules/seedrandom/lib/xor128.js"(exports, module2) {
    (function(global, module3, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.next = function() {
          var t = me.x ^ me.x << 11;
          me.x = me.y;
          me.y = me.z;
          me.z = me.w;
          return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
        };
        if (seed === (seed | 0)) {
          me.x = seed;
        } else {
          strseed += seed;
        }
        for (var k = 0; k < strseed.length + 64; k++) {
          me.x ^= strseed.charCodeAt(k) | 0;
          me.next();
        }
      }
      function copy(f, t) {
        t.x = f.x;
        t.y = f.y;
        t.z = f.z;
        t.w = f.w;
        return t;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module3 && module3.exports) {
        module3.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xor128 = impl;
      }
    })(
      exports,
      typeof module2 == "object" && module2,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/xorwow.js
var require_xorwow = __commonJS({
  "node_modules/seedrandom/lib/xorwow.js"(exports, module2) {
    (function(global, module3, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.next = function() {
          var t = me.x ^ me.x >>> 2;
          me.x = me.y;
          me.y = me.z;
          me.z = me.w;
          me.w = me.v;
          return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
        };
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.v = 0;
        if (seed === (seed | 0)) {
          me.x = seed;
        } else {
          strseed += seed;
        }
        for (var k = 0; k < strseed.length + 64; k++) {
          me.x ^= strseed.charCodeAt(k) | 0;
          if (k == strseed.length) {
            me.d = me.x << 10 ^ me.x >>> 4;
          }
          me.next();
        }
      }
      function copy(f, t) {
        t.x = f.x;
        t.y = f.y;
        t.z = f.z;
        t.w = f.w;
        t.v = f.v;
        t.d = f.d;
        return t;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module3 && module3.exports) {
        module3.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xorwow = impl;
      }
    })(
      exports,
      typeof module2 == "object" && module2,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/xorshift7.js
var require_xorshift7 = __commonJS({
  "node_modules/seedrandom/lib/xorshift7.js"(exports, module2) {
    (function(global, module3, define2) {
      function XorGen(seed) {
        var me = this;
        me.next = function() {
          var X = me.x, i2 = me.i, t, v, w;
          t = X[i2];
          t ^= t >>> 7;
          v = t ^ t << 24;
          t = X[i2 + 1 & 7];
          v ^= t ^ t >>> 10;
          t = X[i2 + 3 & 7];
          v ^= t ^ t >>> 3;
          t = X[i2 + 4 & 7];
          v ^= t ^ t << 7;
          t = X[i2 + 7 & 7];
          t = t ^ t << 13;
          v ^= t ^ t << 9;
          X[i2] = v;
          me.i = i2 + 1 & 7;
          return v;
        };
        function init(me2, seed2) {
          var j, w, X = [];
          if (seed2 === (seed2 | 0)) {
            w = X[0] = seed2;
          } else {
            seed2 = "" + seed2;
            for (j = 0; j < seed2.length; ++j) {
              X[j & 7] = X[j & 7] << 15 ^ seed2.charCodeAt(j) + X[j + 1 & 7] << 13;
            }
          }
          while (X.length < 8)
            X.push(0);
          for (j = 0; j < 8 && X[j] === 0; ++j)
            ;
          if (j == 8)
            w = X[7] = -1;
          else
            w = X[j];
          me2.x = X;
          me2.i = 0;
          for (j = 256; j > 0; --j) {
            me2.next();
          }
        }
        init(me, seed);
      }
      function copy(f, t) {
        t.x = f.x.slice();
        t.i = f.i;
        return t;
      }
      function impl(seed, opts) {
        if (seed == null)
          seed = +new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.x)
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module3 && module3.exports) {
        module3.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xorshift7 = impl;
      }
    })(
      exports,
      typeof module2 == "object" && module2,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/xor4096.js
var require_xor4096 = __commonJS({
  "node_modules/seedrandom/lib/xor4096.js"(exports, module2) {
    (function(global, module3, define2) {
      function XorGen(seed) {
        var me = this;
        me.next = function() {
          var w = me.w, X = me.X, i2 = me.i, t, v;
          me.w = w = w + 1640531527 | 0;
          v = X[i2 + 34 & 127];
          t = X[i2 = i2 + 1 & 127];
          v ^= v << 13;
          t ^= t << 17;
          v ^= v >>> 15;
          t ^= t >>> 12;
          v = X[i2] = v ^ t;
          me.i = i2;
          return v + (w ^ w >>> 16) | 0;
        };
        function init(me2, seed2) {
          var t, v, i2, j, w, X = [], limit = 128;
          if (seed2 === (seed2 | 0)) {
            v = seed2;
            seed2 = null;
          } else {
            seed2 = seed2 + "\0";
            v = 0;
            limit = Math.max(limit, seed2.length);
          }
          for (i2 = 0, j = -32; j < limit; ++j) {
            if (seed2)
              v ^= seed2.charCodeAt((j + 32) % seed2.length);
            if (j === 0)
              w = v;
            v ^= v << 10;
            v ^= v >>> 15;
            v ^= v << 4;
            v ^= v >>> 13;
            if (j >= 0) {
              w = w + 1640531527 | 0;
              t = X[j & 127] ^= v + w;
              i2 = 0 == t ? i2 + 1 : 0;
            }
          }
          if (i2 >= 128) {
            X[(seed2 && seed2.length || 0) & 127] = -1;
          }
          i2 = 127;
          for (j = 4 * 128; j > 0; --j) {
            v = X[i2 + 34 & 127];
            t = X[i2 = i2 + 1 & 127];
            v ^= v << 13;
            t ^= t << 17;
            v ^= v >>> 15;
            t ^= t >>> 12;
            X[i2] = v ^ t;
          }
          me2.w = w;
          me2.X = X;
          me2.i = i2;
        }
        init(me, seed);
      }
      function copy(f, t) {
        t.i = f.i;
        t.w = f.w;
        t.X = f.X.slice();
        return t;
      }
      ;
      function impl(seed, opts) {
        if (seed == null)
          seed = +new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.X)
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module3 && module3.exports) {
        module3.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xor4096 = impl;
      }
    })(
      exports,
      // window object or global
      typeof module2 == "object" && module2,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/tychei.js
var require_tychei = __commonJS({
  "node_modules/seedrandom/lib/tychei.js"(exports, module2) {
    (function(global, module3, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.next = function() {
          var b = me.b, c = me.c, d = me.d, a = me.a;
          b = b << 25 ^ b >>> 7 ^ c;
          c = c - d | 0;
          d = d << 24 ^ d >>> 8 ^ a;
          a = a - b | 0;
          me.b = b = b << 20 ^ b >>> 12 ^ c;
          me.c = c = c - d | 0;
          me.d = d << 16 ^ c >>> 16 ^ a;
          return me.a = a - b | 0;
        };
        me.a = 0;
        me.b = 0;
        me.c = 2654435769 | 0;
        me.d = 1367130551;
        if (seed === Math.floor(seed)) {
          me.a = seed / 4294967296 | 0;
          me.b = seed | 0;
        } else {
          strseed += seed;
        }
        for (var k = 0; k < strseed.length + 20; k++) {
          me.b ^= strseed.charCodeAt(k) | 0;
          me.next();
        }
      }
      function copy(f, t) {
        t.a = f.a;
        t.b = f.b;
        t.c = f.c;
        t.d = f.d;
        return t;
      }
      ;
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module3 && module3.exports) {
        module3.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.tychei = impl;
      }
    })(
      exports,
      typeof module2 == "object" && module2,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/seedrandom.js
var require_seedrandom = __commonJS({
  "node_modules/seedrandom/seedrandom.js"(exports, module2) {
    (function(global, pool, math2) {
      var width = 256, chunks = 6, digits2 = 52, rngname = "random", startdenom = math2.pow(width, chunks), significance = math2.pow(2, digits2), overflow = significance * 2, mask = width - 1, nodecrypto;
      function seedrandom2(seed, options2, callback) {
        var key = [];
        options2 = options2 == true ? { entropy: true } : options2 || {};
        var shortseed = mixkey(flatten3(
          options2.entropy ? [seed, tostring(pool)] : seed == null ? autoseed() : seed,
          3
        ), key);
        var arc4 = new ARC4(key);
        var prng = function() {
          var n = arc4.g(chunks), d = startdenom, x = 0;
          while (n < significance) {
            n = (n + x) * width;
            d *= width;
            x = arc4.g(1);
          }
          while (n >= overflow) {
            n /= 2;
            d /= 2;
            x >>>= 1;
          }
          return (n + x) / d;
        };
        prng.int32 = function() {
          return arc4.g(4) | 0;
        };
        prng.quick = function() {
          return arc4.g(4) / 4294967296;
        };
        prng.double = prng;
        mixkey(tostring(arc4.S), pool);
        return (options2.pass || callback || function(prng2, seed2, is_math_call, state) {
          if (state) {
            if (state.S) {
              copy(state, arc4);
            }
            prng2.state = function() {
              return copy(arc4, {});
            };
          }
          if (is_math_call) {
            math2[rngname] = prng2;
            return seed2;
          } else
            return prng2;
        })(
          prng,
          shortseed,
          "global" in options2 ? options2.global : this == math2,
          options2.state
        );
      }
      function ARC4(key) {
        var t, keylen = key.length, me = this, i2 = 0, j = me.i = me.j = 0, s = me.S = [];
        if (!keylen) {
          key = [keylen++];
        }
        while (i2 < width) {
          s[i2] = i2++;
        }
        for (i2 = 0; i2 < width; i2++) {
          s[i2] = s[j = mask & j + key[i2 % keylen] + (t = s[i2])];
          s[j] = t;
        }
        (me.g = function(count2) {
          var t2, r = 0, i3 = me.i, j2 = me.j, s2 = me.S;
          while (count2--) {
            t2 = s2[i3 = mask & i3 + 1];
            r = r * width + s2[mask & (s2[i3] = s2[j2 = mask & j2 + t2]) + (s2[j2] = t2)];
          }
          me.i = i3;
          me.j = j2;
          return r;
        })(width);
      }
      function copy(f, t) {
        t.i = f.i;
        t.j = f.j;
        t.S = f.S.slice();
        return t;
      }
      ;
      function flatten3(obj, depth) {
        var result = [], typ = typeof obj, prop;
        if (depth && typ == "object") {
          for (prop in obj) {
            try {
              result.push(flatten3(obj[prop], depth - 1));
            } catch (e3) {
            }
          }
        }
        return result.length ? result : typ == "string" ? obj : obj + "\0";
      }
      function mixkey(seed, key) {
        var stringseed = seed + "", smear, j = 0;
        while (j < stringseed.length) {
          key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
        }
        return tostring(key);
      }
      function autoseed() {
        try {
          var out;
          if (nodecrypto && (out = nodecrypto.randomBytes)) {
            out = out(width);
          } else {
            out = new Uint8Array(width);
            (global.crypto || global.msCrypto).getRandomValues(out);
          }
          return tostring(out);
        } catch (e3) {
          var browser = global.navigator, plugins = browser && browser.plugins;
          return [+new Date(), global, plugins, global.screen, tostring(pool)];
        }
      }
      function tostring(a) {
        return String.fromCharCode.apply(0, a);
      }
      mixkey(math2.random(), pool);
      if (typeof module2 == "object" && module2.exports) {
        module2.exports = seedrandom2;
        try {
          nodecrypto = require("crypto");
        } catch (ex) {
        }
      } else if (typeof define == "function" && define.amd) {
        define(function() {
          return seedrandom2;
        });
      } else {
        math2["seed" + rngname] = seedrandom2;
      }
    })(
      // global: `self` in browsers (including strict mode and web workers),
      // otherwise `this` in Node and other environments
      typeof self !== "undefined" ? self : exports,
      [],
      // pool: entropy pool starts empty
      Math
      // math: package containing random, pow, and seedrandom
    );
  }
});

// node_modules/seedrandom/index.js
var require_seedrandom2 = __commonJS({
  "node_modules/seedrandom/index.js"(exports, module2) {
    var alea = require_alea();
    var xor128 = require_xor128();
    var xorwow = require_xorwow();
    var xorshift7 = require_xorshift7();
    var xor4096 = require_xor4096();
    var tychei = require_tychei();
    var sr = require_seedrandom();
    sr.alea = alea;
    sr.xor128 = xor128;
    sr.xorwow = xorwow;
    sr.xorshift7 = xorshift7;
    sr.xor4096 = xor4096;
    sr.tychei = tychei;
    module2.exports = sr;
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  Prism: () => Prism,
  default: () => PiecesPlugin,
  migration: () => migration,
  pluginSettings: () => pluginSettings,
  theme: () => theme
});
module.exports = __toCommonJS(main_exports);
var import_obsidian23 = require("obsidian");

// ../generated_runtime/sdk/http/typescript/core/runtime.ts
var BASE_PATH = "http://localhost:1000".replace(/\/+$/, "");
var Configuration = class {
  constructor(configuration = {}) {
    this.configuration = configuration;
  }
  set config(configuration) {
    this.configuration = configuration;
  }
  get basePath() {
    return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
  }
  get fetchApi() {
    return this.configuration.fetchApi;
  }
  get middleware() {
    return this.configuration.middleware || [];
  }
  get queryParamsStringify() {
    return this.configuration.queryParamsStringify || querystring;
  }
  get username() {
    return this.configuration.username;
  }
  get password() {
    return this.configuration.password;
  }
  get apiKey() {
    const apiKey = this.configuration.apiKey;
    if (apiKey) {
      return typeof apiKey === "function" ? apiKey : () => apiKey;
    }
    return void 0;
  }
  get accessToken() {
    const accessToken = this.configuration.accessToken;
    if (accessToken) {
      return typeof accessToken === "function" ? accessToken : async () => accessToken;
    }
    return void 0;
  }
  get headers() {
    return this.configuration.headers;
  }
  get credentials() {
    return this.configuration.credentials;
  }
};
var DefaultConfig = new Configuration();
var _BaseAPI = class {
  constructor(configuration = DefaultConfig) {
    this.configuration = configuration;
    this.fetchApi = async (url, init) => {
      let fetchParams = { url, init };
      for (const middleware of this.middleware) {
        if (middleware.pre) {
          fetchParams = await middleware.pre({
            fetch: this.fetchApi,
            ...fetchParams
          }) || fetchParams;
        }
      }
      let response = void 0;
      try {
        response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
      } catch (e3) {
        for (const middleware of this.middleware) {
          if (middleware.onError) {
            response = await middleware.onError({
              fetch: this.fetchApi,
              url: fetchParams.url,
              init: fetchParams.init,
              error: e3,
              response: response ? response.clone() : void 0
            }) || response;
          }
        }
        if (response === void 0) {
          if (e3 instanceof Error) {
            throw new FetchError(e3, "The request failed and the interceptors did not return an alternative response");
          } else {
            throw e3;
          }
        }
      }
      for (const middleware of this.middleware) {
        if (middleware.post) {
          response = await middleware.post({
            fetch: this.fetchApi,
            url: fetchParams.url,
            init: fetchParams.init,
            response: response.clone()
          }) || response;
        }
      }
      return response;
    };
    this.middleware = configuration.middleware;
  }
  withMiddleware(...middlewares) {
    const next = this.clone();
    next.middleware = next.middleware.concat(...middlewares);
    return next;
  }
  withPreMiddleware(...preMiddlewares) {
    const middlewares = preMiddlewares.map((pre) => ({ pre }));
    return this.withMiddleware(...middlewares);
  }
  withPostMiddleware(...postMiddlewares) {
    const middlewares = postMiddlewares.map((post) => ({ post }));
    return this.withMiddleware(...middlewares);
  }
  /**
   * Check if the given MIME is a JSON MIME.
   * JSON MIME examples:
   *   application/json
   *   application/json; charset=UTF8
   *   APPLICATION/JSON
   *   application/vnd.company+json
   * @param mime - MIME (Multipurpose Internet Mail Extensions)
   * @return True if the given MIME is JSON, false otherwise.
   */
  isJsonMime(mime) {
    if (!mime) {
      return false;
    }
    return _BaseAPI.jsonRegex.test(mime);
  }
  async request(context, initOverrides) {
    const { url, init } = await this.createFetchParams(context, initOverrides);
    const response = await this.fetchApi(url, init);
    if (response && (response.status >= 200 && response.status < 300)) {
      return response;
    }
    let text;
    try {
      text = await response.text();
    } catch (e3) {
      throw new ResponseError(response, `${url} returned an error code: [${response.status}]`);
    }
    throw new ResponseError(response, `${url} returned an error code: [${response.status}] ${text}`);
  }
  async createFetchParams(context, initOverrides) {
    let url = this.configuration.basePath + context.path;
    if (context.query !== void 0 && Object.keys(context.query).length !== 0) {
      url += "?" + this.configuration.queryParamsStringify(context.query);
    }
    const headers = Object.assign({}, this.configuration.headers, context.headers);
    Object.keys(headers).forEach((key) => headers[key] === void 0 ? delete headers[key] : {});
    const initOverrideFn = typeof initOverrides === "function" ? initOverrides : async () => initOverrides;
    const initParams = {
      method: context.method,
      headers,
      body: context.body,
      credentials: this.configuration.credentials
    };
    const overriddenInit = {
      ...initParams,
      ...await initOverrideFn({
        init: initParams,
        context
      })
    };
    let body;
    if (isFormData(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob(overriddenInit.body)) {
      body = overriddenInit.body;
    } else if (this.isJsonMime(headers["Content-Type"])) {
      body = JSON.stringify(overriddenInit.body);
    } else {
      body = overriddenInit.body;
    }
    const init = {
      ...overriddenInit,
      body
    };
    return { url, init };
  }
  /**
   * Create a shallow clone of `this` by constructing a new instance
   * and then shallow cloning data members.
   */
  clone() {
    const constructor = this.constructor;
    const next = new constructor(this.configuration);
    next.middleware = this.middleware.slice();
    return next;
  }
};
var BaseAPI = _BaseAPI;
BaseAPI.jsonRegex = new RegExp("^(:?application/json|[^;/ 	]+/[^;/ 	]+[+]json)[ 	]*(:?;.*)?$", "i");
function isBlob(value) {
  return typeof Blob !== "undefined" && value instanceof Blob;
}
function isFormData(value) {
  return typeof FormData !== "undefined" && value instanceof FormData;
}
var ResponseError = class extends Error {
  constructor(response, msg) {
    super(msg);
    this.response = response;
    this.name = "ResponseError";
  }
};
var FetchError = class extends Error {
  constructor(cause, msg) {
    super(msg);
    this.cause = cause;
    this.name = "FetchError";
  }
};
var RequiredError = class extends Error {
  constructor(field, msg) {
    super(msg);
    this.field = field;
    this.name = "RequiredError";
  }
};
function exists(json, key) {
  const value = json[key];
  return value !== null && value !== void 0;
}
function querystring(params, prefix = "") {
  return Object.keys(params).map((key) => querystringSingleKey(key, params[key], prefix)).filter((part) => part.length > 0).join("&");
}
function querystringSingleKey(key, value, keyPrefix = "") {
  const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
  if (value instanceof Array) {
    const multiValue = value.map((singleValue) => encodeURIComponent(String(singleValue))).join(`&${encodeURIComponent(fullKey)}=`);
    return `${encodeURIComponent(fullKey)}=${multiValue}`;
  }
  if (value instanceof Set) {
    const valueAsArray = Array.from(value);
    return querystringSingleKey(key, valueAsArray, keyPrefix);
  }
  if (value instanceof Date) {
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
  }
  if (value instanceof Object) {
    return querystring(value, fullKey);
  }
  return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
}
function mapValues(data, fn) {
  return Object.keys(data).reduce(
    (acc, key) => ({ ...acc, [key]: fn(data[key]) }),
    {}
  );
}
var JSONApiResponse = class {
  constructor(raw, transformer = (jsonValue) => jsonValue) {
    this.raw = raw;
    this.transformer = transformer;
  }
  async value() {
    return this.transformer(await this.raw.json());
  }
};
var VoidApiResponse = class {
  constructor(raw) {
    this.raw = raw;
  }
  async value() {
    return void 0;
  }
};
var TextApiResponse = class {
  constructor(raw) {
    this.raw = raw;
  }
  async value() {
    return await this.raw.text();
  }
};

// ../generated_runtime/sdk/http/typescript/core/models/AccessEnum.ts
var AccessEnum = {
  Public: "PUBLIC",
  Private: "PRIVATE"
};
function AccessEnumFromJSON(json) {
  return AccessEnumFromJSONTyped(json, false);
}
function AccessEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function AccessEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/EmbeddedModelSchemaSemanticVersionEnum.ts
function EmbeddedModelSchemaSemanticVersionEnumFromJSON(json) {
  return EmbeddedModelSchemaSemanticVersionEnumFromJSONTyped(json, false);
}
function EmbeddedModelSchemaSemanticVersionEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function EmbeddedModelSchemaSemanticVersionEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/EmbeddedModelSchema.ts
function EmbeddedModelSchemaFromJSON(json) {
  return EmbeddedModelSchemaFromJSONTyped(json, false);
}
function EmbeddedModelSchemaFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "migration": json["migration"],
    "semantic": EmbeddedModelSchemaSemanticVersionEnumFromJSON(json["semantic"])
  };
}
function EmbeddedModelSchemaToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "migration": value.migration,
    "semantic": EmbeddedModelSchemaSemanticVersionEnumToJSON(value.semantic)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedUserProfile.ts
function FlattenedUserProfileFromJSON(json) {
  return FlattenedUserProfileFromJSONTyped(json, false);
}
function FlattenedUserProfileFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "email": !exists(json, "email") ? void 0 : json["email"],
    "name": !exists(json, "name") ? void 0 : json["name"],
    "username": !exists(json, "username") ? void 0 : json["username"],
    "picture": !exists(json, "picture") ? void 0 : json["picture"],
    "vanityname": !exists(json, "vanityname") ? void 0 : json["vanityname"]
  };
}
function FlattenedUserProfileToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "email": value.email,
    "name": value.name,
    "username": value.username,
    "picture": value.picture,
    "vanityname": value.vanityname
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Accessor.ts
function AccessorFromJSON(json) {
  return AccessorFromJSONTyped(json, false);
}
function AccessorFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "os": json["os"],
    "share": json["share"],
    "count": json["count"],
    "user": !exists(json, "user") ? void 0 : FlattenedUserProfileFromJSON(json["user"])
  };
}
function AccessorToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "os": value.os,
    "share": value.share,
    "count": value.count,
    "user": FlattenedUserProfileToJSON(value.user)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Accessors.ts
function AccessorsFromJSON(json) {
  return AccessorsFromJSONTyped(json, false);
}
function AccessorsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(AccessorFromJSON)
  };
}
function AccessorsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(AccessorToJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/OSAppletEnum.ts
var OSAppletEnum = {
  Copilot: "COPILOT",
  PiecesOsToolbar: "PIECES_OS_TOOLBAR",
  WorkstreamSuggestions: "WORKSTREAM_SUGGESTIONS",
  SavedMaterials: "SAVED_MATERIALS",
  WorkflowActivity: "WORKFLOW_ACTIVITY",
  WorkstreamActivity: "WORKSTREAM_ACTIVITY",
  GlobalSearch: "GLOBAL_SEARCH",
  PiecesSuiteSettingsAndIntegrationsManager: "PIECES_SUITE_SETTINGS_AND_INTEGRATIONS_MANAGER",
  CapturedContext: "CAPTURED_CONTEXT",
  UpdatesAndUpcoming: "UPDATES_AND_UPCOMING",
  NotificationsManager: "NOTIFICATIONS_MANAGER",
  SharebleLinkViewer: "SHAREBLE_LINK_VIEWER",
  FutureAppletModulePlaceholderA: "FUTURE_APPLET_MODULE_PLACEHOLDER_A",
  FutureAppletModulePlaceholderB: "FUTURE_APPLET_MODULE_PLACEHOLDER_B",
  FutureAppletModulePlaceholderC: "FUTURE_APPLET_MODULE_PLACEHOLDER_C",
  UnknownAppletModule: "UNKNOWN_APPLET_MODULE"
};
function OSAppletEnumFromJSON(json) {
  return OSAppletEnumFromJSONTyped(json, false);
}
function OSAppletEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function OSAppletEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/ActiveOSServerApplet.ts
function ActiveOSServerAppletFromJSON(json) {
  return ActiveOSServerAppletFromJSONTyped(json, false);
}
function ActiveOSServerAppletFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "port": json["port"],
    "type": OSAppletEnumFromJSON(json["type"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ApplicationNameEnum.ts
var ApplicationNameEnum = {
  Sublime: "SUBLIME",
  VsCode: "VS_CODE",
  Jetbrains: "JETBRAINS",
  FirefoxAddonMv2: "FIREFOX_ADDON_MV2",
  FirefoxAddonMv3: "FIREFOX_ADDON_MV3",
  SafariExtensionMv2: "SAFARI_EXTENSION_MV2",
  SafariExtensionMv3: "SAFARI_EXTENSION_MV3",
  PiecesForDevelopers: "PIECES_FOR_DEVELOPERS",
  PiecesForDevelopersCli: "PIECES_FOR_DEVELOPERS_CLI",
  OsServer: "OS_SERVER",
  GoogleChromeExtensionMv2: "GOOGLE_CHROME_EXTENSION_MV2",
  GoogleChromeExtensionMv3: "GOOGLE_CHROME_EXTENSION_MV3",
  UltraEdit: "ULTRA_EDIT",
  AtomPackage: "ATOM_PACKAGE",
  AdobeIllustratorPiecesColorShare: "ADOBE_ILLUSTRATOR_PIECES_COLOR_SHARE",
  MicrosoftTeams: "MICROSOFT_TEAMS",
  ChatGpt: "CHAT_GPT",
  Obsidian: "OBSIDIAN",
  JupyterHub: "JUPYTER_HUB",
  VisualStudio: "VISUAL_STUDIO",
  MicrosoftEdge: "MICROSOFT_EDGE",
  Brave: "BRAVE",
  GoogleChat: "GOOGLE_CHAT",
  Slack: "SLACK",
  AzureDataStudio: "AZURE_DATA_STUDIO",
  OpenSource: "OPEN_SOURCE",
  RStudio: "R_STUDIO",
  Vim: "VIM",
  Notion: "NOTION",
  GithubDesktop: "GITHUB_DESKTOP",
  Raycast: "RAYCAST",
  Replit: "REPLIT",
  Alfred: "ALFRED",
  Figma: "FIGMA",
  Sketch: "SKETCH",
  AdobeIllustrator: "ADOBE_ILLUSTRATOR",
  NotepadPlusPlus: "NOTEPAD_PLUS_PLUS",
  Embeetle: "EMBEETLE",
  Eclipse: "ECLIPSE",
  XCode: "X_CODE",
  Netbeans: "NETBEANS",
  Unknown: "UNKNOWN"
};
function ApplicationNameEnumFromJSON(json) {
  return ApplicationNameEnumFromJSONTyped(json, false);
}
function ApplicationNameEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function ApplicationNameEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/CapabilitiesEnum.ts
var CapabilitiesEnum = {
  Local: "LOCAL",
  Cloud: "CLOUD",
  Blended: "BLENDED"
};
function CapabilitiesEnumFromJSON(json) {
  return CapabilitiesEnumFromJSONTyped(json, false);
}
function CapabilitiesEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function CapabilitiesEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/MechanismEnum.ts
var MechanismEnum = {
  Manual: "MANUAL",
  Recommended: "RECOMMENDED",
  Automatic: "AUTOMATIC",
  Internal: "INTERNAL",
  Deleted: "DELETED"
};
function MechanismEnumFromJSON(json) {
  return MechanismEnumFromJSONTyped(json, false);
}
function MechanismEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function MechanismEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/PlatformEnum.ts
var PlatformEnum = {
  Web: "WEB",
  Macos: "MACOS",
  Linux: "LINUX",
  Windows: "WINDOWS",
  Fuchsia: "FUCHSIA",
  Ios: "IOS",
  Android: "ANDROID",
  Unknown: "UNKNOWN"
};
function PlatformEnumFromJSON(json) {
  return PlatformEnumFromJSONTyped(json, false);
}
function PlatformEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function PlatformEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/PrivacyEnum.ts
function PrivacyEnumFromJSON(json) {
  return PrivacyEnumFromJSONTyped(json, false);
}
function PrivacyEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function PrivacyEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/Application.ts
function ApplicationFromJSON(json) {
  return ApplicationFromJSONTyped(json, false);
}
function ApplicationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "name": ApplicationNameEnumFromJSON(json["name"]),
    "version": json["version"],
    "platform": PlatformEnumFromJSON(json["platform"]),
    "onboarded": json["onboarded"],
    "privacy": PrivacyEnumFromJSON(json["privacy"]),
    "capabilities": !exists(json, "capabilities") ? void 0 : CapabilitiesEnumFromJSON(json["capabilities"]),
    "mechanism": !exists(json, "mechanism") ? void 0 : MechanismEnumFromJSON(json["mechanism"]),
    "automaticUnload": !exists(json, "automaticUnload") ? void 0 : json["automaticUnload"]
  };
}
function ApplicationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "name": ApplicationNameEnumToJSON(value.name),
    "version": value.version,
    "platform": PlatformEnumToJSON(value.platform),
    "onboarded": value.onboarded,
    "privacy": PrivacyEnumToJSON(value.privacy),
    "capabilities": CapabilitiesEnumToJSON(value.capabilities),
    "mechanism": MechanismEnumToJSON(value.mechanism),
    "automaticUnload": value.automaticUnload
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/GroupedTimestamp.ts
function GroupedTimestampFromJSON(json) {
  return GroupedTimestampFromJSONTyped(json, false);
}
function GroupedTimestampFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "value": new Date(json["value"]),
    "readable": !exists(json, "readable") ? void 0 : json["readable"]
  };
}
function GroupedTimestampToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "value": value.value.toISOString(),
    "readable": value.readable
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ReferencedAsset.ts
function ReferencedAssetFromJSON(json) {
  return ReferencedAssetFromJSONTyped(json, false);
}
function ReferencedAssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "reference": !exists(json, "reference") ? void 0 : FlattenedAssetFromJSON(json["reference"])
  };
}
function ReferencedAssetToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "reference": FlattenedAssetToJSON(value.reference)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ByteDescriptor.ts
function ByteDescriptorFromJSON(json) {
  return ByteDescriptorFromJSONTyped(json, false);
}
function ByteDescriptorFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "value": json["value"],
    "readable": json["readable"]
  };
}
function ByteDescriptorToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "value": value.value,
    "readable": value.readable
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ClassificationGenericEnum.ts
var ClassificationGenericEnum = {
  Code: "CODE",
  Text: "TEXT",
  Image: "IMAGE",
  Video: "VIDEO",
  ExternalResourceReference: "EXTERNAL_RESOURCE_REFERENCE",
  Unknown: "UNKNOWN",
  File: "FILE"
};
function ClassificationGenericEnumFromJSON(json) {
  return ClassificationGenericEnumFromJSONTyped(json, false);
}
function ClassificationGenericEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function ClassificationGenericEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/ClassificationRenderingEnum.ts
function ClassificationRenderingEnumFromJSON(json) {
  return ClassificationRenderingEnumFromJSONTyped(json, false);
}
function ClassificationRenderingEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function ClassificationRenderingEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/ClassificationSpecificEnum.ts
var ClassificationSpecificEnum = {
  Csx: "csx",
  Cs: "cs",
  Html: "html",
  Htm: "htm",
  Shtml: "shtml",
  Xhtml: "xhtml",
  Hs: "hs",
  HsBoot: "hs-boot",
  Hsig: "hsig",
  Cpp: "cpp",
  Cc: "cc",
  Cp: "cp",
  Cxx: "cxx",
  C: "c",
  H: "h",
  Hh: "hh",
  Hpp: "hpp",
  Hxx: "hxx",
  Inl: "inl",
  Ipp: "ipp",
  Ixx: "ixx",
  Cppm: "cppm",
  Csv: "csv",
  Doc: "doc",
  Docm: "docm",
  Docx: "docx",
  Exe: "exe",
  Gif: "gif",
  Ico: "ico",
  Jpe: "jpe",
  Jpeg: "jpeg",
  Jpg: "jpg",
  Jpgm: "jpgm",
  Jpgv: "jpgv",
  Log: "log",
  Mp2: "mp2",
  Mp2a: "mp2a",
  Mp3: "mp3",
  Mp4: "mp4",
  Mp4a: "mp4a",
  Oga: "oga",
  Ogg: "ogg",
  Ogv: "ogv",
  Ogx: "ogx",
  Ppt: "ppt",
  Pptx: "pptx",
  Pptm: "pptm",
  Qt: "qt",
  Text: "text",
  Tif: "tif",
  Tiff: "tiff",
  Txt: "txt",
  Wav: "wav",
  Weba: "weba",
  Webm: "webm",
  Webp: "webp",
  Xla: "xla",
  Xlam: "xlam",
  Xlc: "xlc",
  Xlm: "xlm",
  Xls: "xls",
  Xlsb: "xlsb",
  Xlsm: "xlsm",
  Xlsx: "xlsx",
  Xlt: "xlt",
  Xltm: "xltm",
  Xltx: "xltx",
  Pdf: "pdf",
  Png: "png",
  Rpm: "rpm",
  Zip: "zip",
  Woff: "woff",
  Woff2: "woff2",
  Svgz: "svgz",
  Bin: "bin",
  Bmp: "bmp",
  Eot: "eot",
  Gz: "gz",
  Jar: "jar",
  Mpkg: "mpkg",
  Ai: "ai",
  Eps: "eps",
  Dmg: "dmg",
  List: "list",
  Rtx: "rtx",
  Uri: "uri",
  Uris: "uris",
  Urls: "urls",
  Css: "css",
  Dart: "dart",
  Java: "java",
  Bsh: "bsh",
  Js: "js",
  Jsx: "jsx",
  Mjs: "mjs",
  Htc: "htc",
  Json: "json",
  Ipynb: "ipynb",
  Gltf: "gltf",
  Jsonml: "jsonml",
  Ps: "ps",
  Ssml: "ssml",
  Wasm: "wasm",
  Rtf: "rtf",
  Cco: "cco",
  Pl: "pl",
  Pc: "pc",
  Pm: "pm",
  Pmc: "pmc",
  Pod: "pod",
  T: "t",
  Xml: "xml",
  Tld: "tld",
  Dtml: "dtml",
  Rng: "rng",
  Rss: "rss",
  Opml: "opml",
  Svg: "svg",
  Xaml: "xaml",
  SublimeSnippet: "sublime-snippet",
  TmLanguage: "tmLanguage",
  TmPreferences: "tmPreferences",
  TmSnippet: "tmSnippet",
  TmTheme: "tmTheme",
  Csproj: "csproj",
  Fsproj: "fsproj",
  Sqlproj: "sqlproj",
  Vbproj: "vbproj",
  Vcproj: "vcproj",
  Vcxproj: "vcxproj",
  Dae: "dae",
  Props: "props",
  Targets: "targets",
  Xsd: "xsd",
  Xsl: "xsl",
  Xslt: "xslt",
  Ecma: "ecma",
  Node: "node",
  Php: "php",
  Php3: "php3",
  Php4: "php4",
  Php5: "php5",
  Php7: "php7",
  Php8: "php8",
  Phps: "phps",
  Phpt: "phpt",
  Phtml: "phtml",
  Py: "py",
  Py3: "py3",
  Pyw: "pyw",
  Pyi: "pyi",
  Pyx: "pyx",
  PyxIn: "pyx.in",
  Pxd: "pxd",
  PxdIn: "pxd.in",
  Pxi: "pxi",
  PxiIn: "pxi.in",
  Rpy: "rpy",
  Cpy: "cpy",
  Gyp: "gyp",
  Gypi: "gypi",
  Vpy: "vpy",
  Smk: "smk",
  Wscript: "wscript",
  Bazel: "bazel",
  Bzl: "bzl",
  Pyc: "pyc",
  Class: "class",
  P: "p",
  Pas: "pas",
  Curl: "curl",
  Mcurl: "mcurl",
  Go: "go",
  Swift: "swift",
  Rs: "rs",
  Ts: "ts",
  Tsx: "tsx",
  Rb: "rb",
  Rbi: "rbi",
  Rbx: "rbx",
  Rjs: "rjs",
  Rabl: "rabl",
  Rake: "rake",
  Capfile: "capfile",
  Jbuilder: "jbuilder",
  Gemspec: "gemspec",
  Podspec: "podspec",
  Irbrc: "irbrc",
  Pryrc: "pryrc",
  Prawn: "prawn",
  Thor: "thor",
  Appfile: "Appfile",
  Appraisals: "Appraisals",
  Berksfile: "Berksfile",
  Brewfile: "Brewfile",
  Cheffile: "Cheffile",
  Deliverfile: "Deliverfile",
  Fastfile: "Fastfile",
  Gemfile: "Gemfile",
  Guardfile: "Guardfile",
  Podfile: "Podfile",
  Rakefile: "Rakefile",
  Rantfile: "Rantfile",
  Scanfile: "Scanfile",
  Simplecov: "simplecov",
  Snapfile: "Snapfile",
  Thorfile: "Thorfile",
  Vagrantfile: "Vagrantfile",
  Scala: "scala",
  Sbt: "sbt",
  Sc: "sc",
  Cmd: "cmd",
  Bat: "bat",
  Coffee: "coffee",
  Erl: "erl",
  Hrl: "hrl",
  Escript: "escript",
  Lua: "lua",
  Md: "md",
  Mdown: "mdown",
  Mdwn: "mdwn",
  Markdown: "markdown",
  Markdn: "markdn",
  Matlab: "matlab",
  M: "m",
  Ps1: "ps1",
  Sh: "sh",
  Bash: "bash",
  Bashrc: "bashrc",
  Ash: "ash",
  Zsh: "zsh",
  BashAliases: ".bash_aliases",
  BashCompletions: ".bash_completions",
  BashFunctions: ".bash_functions",
  BashLogin: ".bash_login",
  BashLogout: ".bash_logout",
  BashProfile: ".bash_profile",
  BashVariables: ".bash_variables",
  Profile: ".profile",
  TextmateInit: ".textmate_init",
  Zlogin: ".zlogin",
  Zlogout: ".zlogout",
  Zprofile: ".zprofile",
  Zshenv: ".zshenv",
  Zshrc: ".zshrc",
  Pkgbuild: "PKGBUILD",
  Ebuild: "ebuild",
  Eclass: "eclass",
  R: "r",
  Sql: "sql",
  Ddl: "ddl",
  Dml: "dml",
  Tex: "tex",
  Ltx: "ltx",
  Sty: "sty",
  Cls: "cls",
  Unknown: "UNKNOWN",
  Yaml: "yaml",
  Yml: "yml",
  Toml: "toml",
  Tml: "tml",
  CargoLock: "Cargo.lock",
  GopkgLock: "Gopkg.lock",
  Pipfile: "Pipfile",
  PoetryLock: "poetry.lock",
  UniformResourceLocator: "uniform_resource_locator",
  CustomUrlScheme: "custom_url_scheme",
  UnixFilePath: "unix_file_path",
  WindowsFilePath: "windows_file_path",
  UniformResourceIdentifier: "uniform_resource_identifier",
  Hljs1c: "hljs-1c",
  HljsAbnf: "hljs-abnf",
  HljsAccesslog: "hljs-accesslog",
  HljsActionscript: "hljs-actionscript",
  HljsAda: "hljs-ada",
  HljsAngelscript: "hljs-angelscript",
  HljsApache: "hljs-apache",
  HljsApplescript: "hljs-applescript",
  HljsArcade: "hljs-arcade",
  HljsArduino: "hljs-arduino",
  HljsArmasm: "hljs-armasm",
  HljsAsciidoc: "hljs-asciidoc",
  HljsAspectj: "hljs-aspectj",
  HljsAutohotkey: "hljs-autohotkey",
  HljsAutoit: "hljs-autoit",
  HljsAvrasm: "hljs-avrasm",
  HljsAwk: "hljs-awk",
  HljsAxapta: "hljs-axapta",
  HljsBash: "hljs-bash",
  HljsBasic: "hljs-basic",
  HljsBnf: "hljs-bnf",
  HljsBrainfuck: "hljs-brainfuck",
  HljsCal: "hljs-cal",
  HljsCapnproto: "hljs-capnproto",
  HljsCeylon: "hljs-ceylon",
  HljsClean: "hljs-clean",
  HljsClojureRepl: "hljs-clojure-repl",
  HljsClojure: "hljs-clojure",
  HljsCmake: "hljs-cmake",
  HljsCoffeescript: "hljs-coffeescript",
  HljsCoq: "hljs-coq",
  HljsCos: "hljs-cos",
  HljsCpp: "hljs-cpp",
  HljsCrmsh: "hljs-crmsh",
  HljsCrystal: "hljs-crystal",
  HljsC: "hljs-c",
  HljsCs: "hljs-cs",
  HljsCsp: "hljs-csp",
  HljsCss: "hljs-css",
  HljsD: "hljs-d",
  HljsDart: "hljs-dart",
  HljsDelphi: "hljs-delphi",
  HljsDiff: "hljs-diff",
  HljsDjango: "hljs-django",
  HljsDns: "hljs-dns",
  HljsDockerfile: "hljs-dockerfile",
  HljsDos: "hljs-dos",
  HljsDsconfig: "hljs-dsconfig",
  HljsDts: "hljs-dts",
  HljsDust: "hljs-dust",
  HljsEbnf: "hljs-ebnf",
  HljsElixir: "hljs-elixir",
  HljsElm: "hljs-elm",
  HljsErb: "hljs-erb",
  HljsErlangRepl: "hljs-erlang-repl",
  HljsErlang: "hljs-erlang",
  HljsExcel: "hljs-excel",
  HljsFix: "hljs-fix",
  HljsFlix: "hljs-flix",
  HljsFortran: "hljs-fortran",
  HljsFsharp: "hljs-fsharp",
  HljsGams: "hljs-gams",
  HljsGauss: "hljs-gauss",
  HljsGcode: "hljs-gcode",
  HljsGherkin: "hljs-gherkin",
  HljsGlsl: "hljs-glsl",
  HljsGml: "hljs-gml",
  HljsGo: "hljs-go",
  HljsGolo: "hljs-golo",
  HljsGradle: "hljs-gradle",
  HljsGroovy: "hljs-groovy",
  HljsHaml: "hljs-haml",
  HljsHandlebars: "hljs-handlebars",
  HljsHaskell: "hljs-haskell",
  HljsHaxe: "hljs-haxe",
  HljsHsp: "hljs-hsp",
  HljsHtmlbars: "hljs-htmlbars",
  HljsHttp: "hljs-http",
  HljsHy: "hljs-hy",
  HljsInform7: "hljs-inform7",
  HljsIni: "hljs-ini",
  HljsIrpf90: "hljs-irpf90",
  HljsIsbl: "hljs-isbl",
  HljsJava: "hljs-java",
  HljsJavascript: "hljs-javascript",
  HljsJbossCli: "hljs-jboss-cli",
  HljsJson: "hljs-json",
  HljsJuliaRepl: "hljs-julia-repl",
  HljsJulia: "hljs-julia",
  HljsKotlin: "hljs-kotlin",
  HljsLasso: "hljs-lasso",
  HljsLdif: "hljs-ldif",
  HljsLeaf: "hljs-leaf",
  HljsLess: "hljs-less",
  HljsLisp: "hljs-lisp",
  HljsLivecodeserver: "hljs-livecodeserver",
  HljsLivescript: "hljs-livescript",
  HljsLlvm: "hljs-llvm",
  HljsLsl: "hljs-lsl",
  HljsLua: "hljs-lua",
  HljsMakefile: "hljs-makefile",
  HljsMarkdown: "hljs-markdown",
  HljsMathematica: "hljs-mathematica",
  HljsMatlab: "hljs-matlab",
  HljsMaxima: "hljs-maxima",
  HljsMel: "hljs-mel",
  HljsMercury: "hljs-mercury",
  HljsMipsasm: "hljs-mipsasm",
  HljsMizar: "hljs-mizar",
  HljsMojolicious: "hljs-mojolicious",
  HljsMonkey: "hljs-monkey",
  HljsMoonscript: "hljs-moonscript",
  HljsN1ql: "hljs-n1ql",
  HljsNginx: "hljs-nginx",
  HljsNimrod: "hljs-nimrod",
  HljsNix: "hljs-nix",
  HljsNsis: "hljs-nsis",
  HljsObjectivec: "hljs-objectivec",
  HljsOcaml: "hljs-ocaml",
  HljsOpenscad: "hljs-openscad",
  HljsOxygene: "hljs-oxygene",
  HljsParser3: "hljs-parser3",
  HljsPerl: "hljs-perl",
  HljsPf: "hljs-pf",
  HljsPgsql: "hljs-pgsql",
  HljsPhp: "hljs-php",
  HljsPlaintext: "hljs-plaintext",
  HljsPony: "hljs-pony",
  HljsPowershell: "hljs-powershell",
  HljsProcessing: "hljs-processing",
  HljsProfile: "hljs-profile",
  HljsProlog: "hljs-prolog",
  HljsProperties: "hljs-properties",
  HljsProtobuf: "hljs-protobuf",
  HljsPuppet: "hljs-puppet",
  HljsPurebasic: "hljs-purebasic",
  HljsPython: "hljs-python",
  HljsQ: "hljs-q",
  HljsQml: "hljs-qml",
  HljsR: "hljs-r",
  HljsReasonml: "hljs-reasonml",
  HljsRib: "hljs-rib",
  HljsRoboconf: "hljs-roboconf",
  HljsRouteros: "hljs-routeros",
  HljsRsl: "hljs-rsl",
  HljsRuby: "hljs-ruby",
  HljsRuleslanguage: "hljs-ruleslanguage",
  HljsRust: "hljs-rust",
  HljsSas: "hljs-sas",
  HljsScala: "hljs-scala",
  HljsScheme: "hljs-scheme",
  HljsScilab: "hljs-scilab",
  HljsScss: "hljs-scss",
  HljsShell: "hljs-shell",
  HljsSmali: "hljs-smali",
  HljsSmalltalk: "hljs-smalltalk",
  HljsSml: "hljs-sml",
  HljsSqf: "hljs-sqf",
  HljsSql: "hljs-sql",
  HljsStan: "hljs-stan",
  HljsStata: "hljs-stata",
  HljsStep21: "hljs-step21",
  HljsStylus: "hljs-stylus",
  HljsSubunit: "hljs-subunit",
  HljsSwift: "hljs-swift",
  HljsTaggerscript: "hljs-taggerscript",
  HljsTap: "hljs-tap",
  HljsTcl: "hljs-tcl",
  HljsTex: "hljs-tex",
  HljsThrift: "hljs-thrift",
  HljsTp: "hljs-tp",
  HljsTwig: "hljs-twig",
  HljsTypescript: "hljs-typescript",
  HljsVala: "hljs-vala",
  HljsVbnet: "hljs-vbnet",
  HljsVbscriptHtml: "hljs-vbscript-html",
  HljsVbscript: "hljs-vbscript",
  HljsVerilog: "hljs-verilog",
  HljsVhdl: "hljs-vhdl",
  HljsVim: "hljs-vim",
  HljsX86asm: "hljs-x86asm",
  HljsXl: "hljs-xl",
  HljsXml: "hljs-xml",
  HljsXquery: "hljs-xquery",
  HljsYaml: "hljs-yaml",
  HljsToml: "hljs-toml",
  HljsZephir: "hljs-zephir",
  HljsHtml: "hljs-html",
  Groovy: "groovy",
  Kt: "kt",
  El: "el",
  Clj: "clj",
  Ex: "ex",
  Adb: "adb",
  Ads: "ads",
  Agda: "agda",
  Elm: "elm",
  Exs: "exs",
  Glsl: "glsl",
  Ml: "ml",
  Lean: "lean",
  Lisp: "lisp",
  Rkt: "rkt",
  Sparql: "sparql",
  Vhdl: "vhdl",
  Zig: "zig",
  Dockerfile: "dockerfile",
  F03: "f03",
  F08: "f08",
  F18: "f18",
  F90: "f90",
  F95: "f95",
  Jl: "jl",
  Mm: "mm",
  Scm: "scm",
  Sol: "sol",
  Sv: "sv",
  Asp: "asp",
  Cfm: "cfm",
  Fs: "fs",
  Fsi: "fsi",
  Fsx: "fsx",
  Tf: "tf",
  Vba: "vba",
  Svelte: "svelte",
  Vue: "vue",
  Scss: "scss",
  Feature: "feature",
  Ini: "ini",
  Ftl: "ftl",
  Hcl: "hcl",
  Abap: "abap"
};
function ClassificationSpecificEnumFromJSON(json) {
  return ClassificationSpecificEnumFromJSONTyped(json, false);
}
function ClassificationSpecificEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function ClassificationSpecificEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/Classification.ts
function ClassificationFromJSON(json) {
  return ClassificationFromJSONTyped(json, false);
}
function ClassificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "generic": ClassificationGenericEnumFromJSON(json["generic"]),
    "specific": ClassificationSpecificEnumFromJSON(json["specific"]),
    "rendering": !exists(json, "rendering") ? void 0 : ClassificationRenderingEnumFromJSON(json["rendering"])
  };
}
function ClassificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "generic": ClassificationGenericEnumToJSON(value.generic),
    "specific": ClassificationSpecificEnumToJSON(value.specific),
    "rendering": ClassificationRenderingEnumToJSON(value.rendering)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TransferableBytes.ts
function TransferableBytesFromJSON(json) {
  return TransferableBytesFromJSONTyped(json, false);
}
function TransferableBytesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "raw": !exists(json, "raw") ? void 0 : json["raw"],
    "base64": !exists(json, "base64") ? void 0 : json["base64"],
    "base64Url": !exists(json, "base64_url") ? void 0 : json["base64_url"],
    "dataUrl": !exists(json, "data_url") ? void 0 : json["data_url"]
  };
}
function TransferableBytesToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "raw": value.raw,
    "base64": value.base64,
    "base64_url": value.base64Url,
    "data_url": value.dataUrl
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TransferableString.ts
function TransferableStringFromJSON(json) {
  return TransferableStringFromJSONTyped(json, false);
}
function TransferableStringFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "raw": !exists(json, "raw") ? void 0 : json["raw"],
    "base64": !exists(json, "base64") ? void 0 : json["base64"],
    "base64Url": !exists(json, "base64_url") ? void 0 : json["base64_url"],
    "dataUrl": !exists(json, "data_url") ? void 0 : json["data_url"]
  };
}
function TransferableStringToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "raw": value.raw,
    "base64": value.base64,
    "base64_url": value.base64Url,
    "data_url": value.dataUrl
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FileFormat.ts
function FileFormatFromJSON(json) {
  return FileFormatFromJSONTyped(json, false);
}
function FileFormatFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "bytes": !exists(json, "bytes") ? void 0 : TransferableBytesFromJSON(json["bytes"]),
    "string": !exists(json, "string") ? void 0 : TransferableStringFromJSON(json["string"])
  };
}
function FileFormatToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "bytes": TransferableBytesToJSON(value.bytes),
    "string": TransferableStringToJSON(value.string)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ExternalMLProviderEnum.ts
function ExternalMLProviderEnumFromJSON(json) {
  return ExternalMLProviderEnumFromJSONTyped(json, false);
}
function ExternalMLProviderEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function ExternalMLProviderEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/ModelCapabilities.ts
function ModelCapabilitiesFromJSON(json) {
  return ModelCapabilitiesFromJSONTyped(json, false);
}
function ModelCapabilitiesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "temporal": !exists(json, "temporal") ? void 0 : json["temporal"],
    "images": !exists(json, "images") ? void 0 : json["images"],
    "videos": !exists(json, "videos") ? void 0 : json["videos"],
    "documents": !exists(json, "documents") ? void 0 : json["documents"],
    "codebases": !exists(json, "codebases") ? void 0 : json["codebases"],
    "assets": !exists(json, "assets") ? void 0 : json["assets"],
    "websites": !exists(json, "websites") ? void 0 : json["websites"]
  };
}
function ModelCapabilitiesToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "temporal": value.temporal,
    "images": value.images,
    "videos": value.videos,
    "documents": value.documents,
    "codebases": value.codebases,
    "assets": value.assets,
    "websites": value.websites
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ModelFoundationEnum.ts
function ModelFoundationEnumFromJSON(json) {
  return ModelFoundationEnumFromJSONTyped(json, false);
}
function ModelFoundationEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function ModelFoundationEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/ModelMaxTokens.ts
function ModelMaxTokensFromJSON(json) {
  return ModelMaxTokensFromJSONTyped(json, false);
}
function ModelMaxTokensFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "total": json["total"],
    "input": !exists(json, "input") ? void 0 : json["input"],
    "output": !exists(json, "output") ? void 0 : json["output"]
  };
}
function ModelMaxTokensToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "total": value.total,
    "input": value.input,
    "output": value.output
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ModelTypeEnum.ts
function ModelTypeEnumFromJSON(json) {
  return ModelTypeEnumFromJSONTyped(json, false);
}
function ModelTypeEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function ModelTypeEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/ModelUsageEnum.ts
function ModelUsageEnumFromJSON(json) {
  return ModelUsageEnumFromJSONTyped(json, false);
}
function ModelUsageEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function ModelUsageEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/Model.ts
function ModelFromJSON(json) {
  return ModelFromJSONTyped(json, false);
}
function ModelFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "version": json["version"],
    "created": GroupedTimestampFromJSON(json["created"]),
    "name": json["name"],
    "description": !exists(json, "description") ? void 0 : json["description"],
    "cloud": json["cloud"],
    "type": ModelTypeEnumFromJSON(json["type"]),
    "usage": ModelUsageEnumFromJSON(json["usage"]),
    "bytes": !exists(json, "bytes") ? void 0 : ByteDescriptorFromJSON(json["bytes"]),
    "ram": !exists(json, "ram") ? void 0 : ByteDescriptorFromJSON(json["ram"]),
    "quantization": !exists(json, "quantization") ? void 0 : json["quantization"],
    "foundation": !exists(json, "foundation") ? void 0 : ModelFoundationEnumFromJSON(json["foundation"]),
    "downloaded": !exists(json, "downloaded") ? void 0 : json["downloaded"],
    "loaded": !exists(json, "loaded") ? void 0 : json["loaded"],
    "unique": !exists(json, "unique") ? void 0 : json["unique"],
    "parameters": !exists(json, "parameters") ? void 0 : json["parameters"],
    "provider": !exists(json, "provider") ? void 0 : ExternalMLProviderEnumFromJSON(json["provider"]),
    "cpu": !exists(json, "cpu") ? void 0 : json["cpu"],
    "downloading": !exists(json, "downloading") ? void 0 : json["downloading"],
    "maxTokens": !exists(json, "maxTokens") ? void 0 : ModelMaxTokensFromJSON(json["maxTokens"]),
    "custom": !exists(json, "custom") ? void 0 : json["custom"],
    "capabilities": !exists(json, "capabilities") ? void 0 : ModelCapabilitiesFromJSON(json["capabilities"])
  };
}
function ModelToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "version": value.version,
    "created": GroupedTimestampToJSON(value.created),
    "name": value.name,
    "description": value.description,
    "cloud": value.cloud,
    "type": ModelTypeEnumToJSON(value.type),
    "usage": ModelUsageEnumToJSON(value.usage),
    "bytes": ByteDescriptorToJSON(value.bytes),
    "ram": ByteDescriptorToJSON(value.ram),
    "quantization": value.quantization,
    "foundation": ModelFoundationEnumToJSON(value.foundation),
    "downloaded": value.downloaded,
    "loaded": value.loaded,
    "unique": value.unique,
    "parameters": value.parameters,
    "provider": ExternalMLProviderEnumToJSON(value.provider),
    "cpu": value.cpu,
    "downloading": value.downloading,
    "maxTokens": ModelMaxTokensToJSON(value.maxTokens),
    "custom": value.custom,
    "capabilities": ModelCapabilitiesToJSON(value.capabilities)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/CodeAnalysis.ts
function CodeAnalysisFromJSON(json) {
  return CodeAnalysisFromJSONTyped(json, false);
}
function CodeAnalysisFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "tokenized": !exists(json, "tokenized") ? void 0 : json["tokenized"],
    "language": !exists(json, "language") ? void 0 : json["language"],
    "type": ClassificationGenericEnumFromJSON(json["type"]),
    "prediction": !exists(json, "prediction") ? void 0 : json["prediction"],
    "similarity": !exists(json, "similarity") ? void 0 : json["similarity"],
    "top5Colors": !exists(json, "top5Colors") ? void 0 : json["top5Colors"],
    "top5Sorted": !exists(json, "top5Sorted") ? void 0 : json["top5Sorted"],
    "id": json["id"],
    "analysis": json["analysis"],
    "model": ModelFromJSON(json["model"])
  };
}
function CodeAnalysisToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "tokenized": value.tokenized,
    "language": value.language,
    "type": ClassificationGenericEnumToJSON(value.type),
    "prediction": value.prediction,
    "similarity": value.similarity,
    "top5Colors": value.top5Colors,
    "top5Sorted": value.top5Sorted,
    "id": value.id,
    "analysis": value.analysis,
    "model": ModelToJSON(value.model)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedOCRAnalysis.ts
function FlattenedOCRAnalysisFromJSON(json) {
  return FlattenedOCRAnalysisFromJSONTyped(json, false);
}
function FlattenedOCRAnalysisFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "raw": ReferencedFormatFromJSON(json["raw"]),
    "hocr": ReferencedFormatFromJSON(json["hocr"]),
    "model": ModelFromJSON(json["model"]),
    "image": json["image"]
  };
}
function FlattenedOCRAnalysisToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "raw": ReferencedFormatToJSON(value.raw),
    "hocr": ReferencedFormatToJSON(value.hocr),
    "model": ModelToJSON(value.model),
    "image": value.image
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedImageAnalysis.ts
function FlattenedImageAnalysisFromJSON(json) {
  return FlattenedImageAnalysisFromJSONTyped(json, false);
}
function FlattenedImageAnalysisFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "ocr": !exists(json, "ocr") ? void 0 : FlattenedOCRAnalysisFromJSON(json["ocr"]),
    "analysis": json["analysis"]
  };
}
function FlattenedImageAnalysisToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "ocr": FlattenedOCRAnalysisToJSON(value.ocr),
    "analysis": value.analysis
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedAnalysis.ts
function FlattenedAnalysisFromJSON(json) {
  return FlattenedAnalysisFromJSONTyped(json, false);
}
function FlattenedAnalysisFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "code": !exists(json, "code") ? void 0 : CodeAnalysisFromJSON(json["code"]),
    "id": json["id"],
    "format": json["format"],
    "image": !exists(json, "image") ? void 0 : FlattenedImageAnalysisFromJSON(json["image"])
  };
}
function FlattenedAnalysisToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "code": CodeAnalysisToJSON(value.code),
    "id": value.id,
    "format": value.format,
    "image": FlattenedImageAnalysisToJSON(value.image)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FragmentMetadata.ts
function FragmentMetadataFromJSON(json) {
  return FragmentMetadataFromJSONTyped(json, false);
}
function FragmentMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "ext": !exists(json, "ext") ? void 0 : ClassificationSpecificEnumFromJSON(json["ext"])
  };
}
function FragmentMetadataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "ext": ClassificationSpecificEnumToJSON(value.ext)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FragmentFormat.ts
function FragmentFormatFromJSON(json) {
  return FragmentFormatFromJSONTyped(json, false);
}
function FragmentFormatFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "string": !exists(json, "string") ? void 0 : TransferableStringFromJSON(json["string"]),
    "bytes": !exists(json, "bytes") ? void 0 : TransferableBytesFromJSON(json["bytes"]),
    "metadata": !exists(json, "metadata") ? void 0 : FragmentMetadataFromJSON(json["metadata"])
  };
}
function FragmentFormatToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "string": TransferableStringToJSON(value.string),
    "bytes": TransferableBytesToJSON(value.bytes),
    "metadata": FragmentMetadataToJSON(value.metadata)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/NodeTypeEnum.ts
function NodeTypeEnumFromJSON(json) {
  return NodeTypeEnumFromJSONTyped(json, false);
}
function NodeTypeEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function NodeTypeEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/Node.ts
function NodeFromJSON(json) {
  return NodeFromJSONTyped(json, false);
}
function NodeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "type": NodeTypeEnumFromJSON(json["type"]),
    "root": json["root"],
    "created": GroupedTimestampFromJSON(json["created"])
  };
}
function NodeToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "id": value.id,
    "type": NodeTypeEnumToJSON(value.type),
    "root": value.root,
    "created": GroupedTimestampToJSON(value.created)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Edges.ts
function EdgesFromJSON(json) {
  return EdgesFromJSONTyped(json, false);
}
function EdgesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "iterable": json["iterable"].map(NodeFromJSON)
  };
}
function EdgesToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "iterable": value.iterable.map(NodeToJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Embedding.ts
function EmbeddingFromJSON(json) {
  return EmbeddingFromJSONTyped(json, false);
}
function EmbeddingFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "raw": json["raw"],
    "model": ModelFromJSON(json["model"]),
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"])
  };
}
function EmbeddingToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "raw": value.raw,
    "model": ModelToJSON(value.model),
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "deleted": GroupedTimestampToJSON(value.deleted)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Embeddings.ts
function EmbeddingsFromJSON(json) {
  return EmbeddingsFromJSONTyped(json, false);
}
function EmbeddingsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "iterable": json["iterable"].map(EmbeddingFromJSON)
  };
}
function EmbeddingsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "iterable": value.iterable.map(EmbeddingToJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Relationship.ts
function RelationshipFromJSON(json) {
  return RelationshipFromJSONTyped(json, false);
}
function RelationshipFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "embeddings": EmbeddingsFromJSON(json["embeddings"]),
    "edges": EdgesFromJSON(json["edges"]),
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"])
  };
}
function RelationshipToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "id": value.id,
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "embeddings": EmbeddingsToJSON(value.embeddings),
    "edges": EdgesToJSON(value.edges),
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "deleted": GroupedTimestampToJSON(value.deleted)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Role.ts
function RoleFromJSON(json) {
  return RoleFromJSONTyped(json, false);
}
function RoleFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function RoleToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedFormat.ts
function FlattenedFormatFromJSON(json) {
  return FlattenedFormatFromJSONTyped(json, false);
}
function FlattenedFormatFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "creator": json["creator"],
    "classification": ClassificationFromJSON(json["classification"]),
    "icon": !exists(json, "icon") ? void 0 : json["icon"],
    "role": RoleFromJSON(json["role"]),
    "application": ApplicationFromJSON(json["application"]),
    "asset": json["asset"],
    "bytes": ByteDescriptorFromJSON(json["bytes"]),
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"]),
    "synced": !exists(json, "synced") ? void 0 : GroupedTimestampFromJSON(json["synced"]),
    "cloud": !exists(json, "cloud") ? void 0 : json["cloud"],
    "fragment": !exists(json, "fragment") ? void 0 : FragmentFormatFromJSON(json["fragment"]),
    "file": !exists(json, "file") ? void 0 : FileFormatFromJSON(json["file"]),
    "analysis": !exists(json, "analysis") ? void 0 : FlattenedAnalysisFromJSON(json["analysis"]),
    "relationship": !exists(json, "relationship") ? void 0 : RelationshipFromJSON(json["relationship"]),
    "activities": !exists(json, "activities") ? void 0 : FlattenedActivitiesFromJSON(json["activities"])
  };
}
function FlattenedFormatToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "creator": value.creator,
    "classification": ClassificationToJSON(value.classification),
    "icon": value.icon,
    "role": RoleToJSON(value.role),
    "application": ApplicationToJSON(value.application),
    "asset": value.asset,
    "bytes": ByteDescriptorToJSON(value.bytes),
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "deleted": GroupedTimestampToJSON(value.deleted),
    "synced": GroupedTimestampToJSON(value.synced),
    "cloud": value.cloud,
    "fragment": FragmentFormatToJSON(value.fragment),
    "file": FileFormatToJSON(value.file),
    "analysis": FlattenedAnalysisToJSON(value.analysis),
    "relationship": RelationshipToJSON(value.relationship),
    "activities": FlattenedActivitiesToJSON(value.activities)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ReferencedFormat.ts
function ReferencedFormatFromJSON(json) {
  return ReferencedFormatFromJSONTyped2(json, false);
}
function ReferencedFormatFromJSONTyped2(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "reference": !exists(json, "reference") ? void 0 : FlattenedFormatFromJSON(json["reference"])
  };
}
function ReferencedFormatToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "reference": FlattenedFormatToJSON(value.reference)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/AnalyticsTrackedAdoptionEventIdentifierDescriptionPairs.ts
var AnalyticsTrackedAdoptionEventIdentifierDescriptionPairsAdoptionInstallEnum = {
  TheUserHasInstalledAPiecesApplication: "the_user_has_installed_a_pieces_application"
};
function AnalyticsTrackedAdoptionEventIdentifierDescriptionPairsFromJSON(json) {
  return AnalyticsTrackedAdoptionEventIdentifierDescriptionPairsFromJSONTyped(json, false);
}
function AnalyticsTrackedAdoptionEventIdentifierDescriptionPairsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "adoptionInstall": !exists(json, "adoption_install") ? void 0 : json["adoption_install"],
    "adoptionUninstall": !exists(json, "adoption_uninstall") ? void 0 : json["adoption_uninstall"]
  };
}
function AnalyticsTrackedAdoptionEventIdentifierDescriptionPairsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "adoption_install": value.adoptionInstall,
    "adoption_uninstall": value.adoptionUninstall
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededTrackedAdoptionEvent.ts
function SeededTrackedAdoptionEventFromJSON(json) {
  return SeededTrackedAdoptionEventFromJSONTyped(json, false);
}
function SeededTrackedAdoptionEventFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "identifierDescriptionPair": !exists(json, "identifier_description_pair") ? void 0 : AnalyticsTrackedAdoptionEventIdentifierDescriptionPairsFromJSON(json["identifier_description_pair"])
  };
}
function SeededTrackedAdoptionEventToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "identifier_description_pair": AnalyticsTrackedAdoptionEventIdentifierDescriptionPairsToJSON(value.identifierDescriptionPair)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TrackedAssetEventIdentifierDescriptionPairs.ts
var TrackedAssetEventIdentifierDescriptionPairsAssetFormatCopiedEnum = {
  AnAssetPreviewFormatWasCopied: "an_asset_preview_format_was_copied"
};
var TrackedAssetEventIdentifierDescriptionPairsSearchedAssetReferencedEnum = {
  ASearchedAssetWasReferencedByTheUser: "a_searched_asset_was_referenced_by_the_user"
};
var TrackedAssetEventIdentifierDescriptionPairsAssetReferencedEnum = {
  AnAssetWasReferencedByTheUser: "an_asset_was_referenced_by_the_user"
};
function TrackedAssetEventIdentifierDescriptionPairsFromJSON(json) {
  return TrackedAssetEventIdentifierDescriptionPairsFromJSONTyped(json, false);
}
function TrackedAssetEventIdentifierDescriptionPairsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "assetCreated": !exists(json, "asset_created") ? void 0 : json["asset_created"],
    "assetViewed": !exists(json, "asset_viewed") ? void 0 : json["asset_viewed"],
    "assetFormatCopied": !exists(json, "asset_format_copied") ? void 0 : json["asset_format_copied"],
    "assetFormatDownloaded": !exists(json, "asset_format_downloaded") ? void 0 : json["asset_format_downloaded"],
    "assetDeleted": !exists(json, "asset_deleted") ? void 0 : json["asset_deleted"],
    "assetDescriptionUpdated": !exists(json, "asset_description_updated") ? void 0 : json["asset_description_updated"],
    "assetNameUpdated": !exists(json, "asset_name_updated") ? void 0 : json["asset_name_updated"],
    "assetFormatGenericClassificationUpdated": !exists(json, "asset_format_generic_classification_updated") ? void 0 : json["asset_format_generic_classification_updated"],
    "assetFormatSpecificClassificationUpdated": !exists(json, "asset_format_specific_classification_updated") ? void 0 : json["asset_format_specific_classification_updated"],
    "assetCreationFailed": !exists(json, "asset_creation_failed") ? void 0 : json["asset_creation_failed"],
    "assetTagAdded": !exists(json, "asset_tag_added") ? void 0 : json["asset_tag_added"],
    "assetLinkAdded": !exists(json, "asset_link_added") ? void 0 : json["asset_link_added"],
    "assetLinkGenerated": !exists(json, "asset_link_generated") ? void 0 : json["asset_link_generated"],
    "assetLinkDeleted": !exists(json, "asset_link_deleted") ? void 0 : json["asset_link_deleted"],
    "assetTagDeleted": !exists(json, "asset_tag_deleted") ? void 0 : json["asset_tag_deleted"],
    "assetUpdated": !exists(json, "asset_updated") ? void 0 : json["asset_updated"],
    "assetFormatValueEdited": !exists(json, "asset_format_value_edited") ? void 0 : json["asset_format_value_edited"],
    "assetFormatUpdated": !exists(json, "asset_format_updated") ? void 0 : json["asset_format_updated"],
    "assetLinkRevoked": !exists(json, "asset_link_revoked") ? void 0 : json["asset_link_revoked"],
    "assetPersonAdded": !exists(json, "asset_person_added") ? void 0 : json["asset_person_added"],
    "assetPersonDeleted": !exists(json, "asset_person_deleted") ? void 0 : json["asset_person_deleted"],
    "assetSensitiveAdded": !exists(json, "asset_sensitive_added") ? void 0 : json["asset_sensitive_added"],
    "assetSensitiveDeleted": !exists(json, "asset_sensitive_deleted") ? void 0 : json["asset_sensitive_deleted"],
    "suggestedAssetReferenced": !exists(json, "suggested_asset_referenced") ? void 0 : json["suggested_asset_referenced"],
    "searchedAssetReferenced": !exists(json, "searched_asset_referenced") ? void 0 : json["searched_asset_referenced"],
    "assetReferenced": !exists(json, "asset_referenced") ? void 0 : json["asset_referenced"],
    "activityAssetReferenced": !exists(json, "activity_asset_referenced") ? void 0 : json["activity_asset_referenced"],
    "assetAnnotationAdded": !exists(json, "asset_annotation_added") ? void 0 : json["asset_annotation_added"],
    "assetAnnotationDeleted": !exists(json, "asset_annotation_deleted") ? void 0 : json["asset_annotation_deleted"],
    "assetAnnotationUpdated": !exists(json, "asset_annotation_updated") ? void 0 : json["asset_annotation_updated"],
    "assetHintAdded": !exists(json, "asset_hint_added") ? void 0 : json["asset_hint_added"],
    "assetHintDeleted": !exists(json, "asset_hint_deleted") ? void 0 : json["asset_hint_deleted"],
    "assetHintUpdated": !exists(json, "asset_hint_updated") ? void 0 : json["asset_hint_updated"],
    "assetAnchorAdded": !exists(json, "asset_anchor_added") ? void 0 : json["asset_anchor_added"],
    "assetAnchorDeleted": !exists(json, "asset_anchor_deleted") ? void 0 : json["asset_anchor_deleted"],
    "assetAnchorUpdated": !exists(json, "asset_anchor_updated") ? void 0 : json["asset_anchor_updated"]
  };
}
function TrackedAssetEventIdentifierDescriptionPairsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "asset_created": value.assetCreated,
    "asset_viewed": value.assetViewed,
    "asset_format_copied": value.assetFormatCopied,
    "asset_format_downloaded": value.assetFormatDownloaded,
    "asset_deleted": value.assetDeleted,
    "asset_description_updated": value.assetDescriptionUpdated,
    "asset_name_updated": value.assetNameUpdated,
    "asset_format_generic_classification_updated": value.assetFormatGenericClassificationUpdated,
    "asset_format_specific_classification_updated": value.assetFormatSpecificClassificationUpdated,
    "asset_creation_failed": value.assetCreationFailed,
    "asset_tag_added": value.assetTagAdded,
    "asset_link_added": value.assetLinkAdded,
    "asset_link_generated": value.assetLinkGenerated,
    "asset_link_deleted": value.assetLinkDeleted,
    "asset_tag_deleted": value.assetTagDeleted,
    "asset_updated": value.assetUpdated,
    "asset_format_value_edited": value.assetFormatValueEdited,
    "asset_format_updated": value.assetFormatUpdated,
    "asset_link_revoked": value.assetLinkRevoked,
    "asset_person_added": value.assetPersonAdded,
    "asset_person_deleted": value.assetPersonDeleted,
    "asset_sensitive_added": value.assetSensitiveAdded,
    "asset_sensitive_deleted": value.assetSensitiveDeleted,
    "suggested_asset_referenced": value.suggestedAssetReferenced,
    "searched_asset_referenced": value.searchedAssetReferenced,
    "asset_referenced": value.assetReferenced,
    "activity_asset_referenced": value.activityAssetReferenced,
    "asset_annotation_added": value.assetAnnotationAdded,
    "asset_annotation_deleted": value.assetAnnotationDeleted,
    "asset_annotation_updated": value.assetAnnotationUpdated,
    "asset_hint_added": value.assetHintAdded,
    "asset_hint_deleted": value.assetHintDeleted,
    "asset_hint_updated": value.assetHintUpdated,
    "asset_anchor_added": value.assetAnchorAdded,
    "asset_anchor_deleted": value.assetAnchorDeleted,
    "asset_anchor_updated": value.assetAnchorUpdated
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/AnchorTypeEnum.ts
var AnchorTypeEnum = {
  File: "FILE",
  Directory: "DIRECTORY"
};
function AnchorTypeEnumFromJSON(json) {
  return AnchorTypeEnumFromJSONTyped(json, false);
}
function AnchorTypeEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function AnchorTypeEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/Score.ts
function ScoreFromJSON(json) {
  return ScoreFromJSONTyped(json, false);
}
function ScoreFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "manual": json["manual"],
    "automatic": json["automatic"],
    "priority": !exists(json, "priority") ? void 0 : json["priority"],
    "reuse": !exists(json, "reuse") ? void 0 : json["reuse"],
    "update": !exists(json, "update") ? void 0 : json["update"],
    "reference": !exists(json, "reference") ? void 0 : json["reference"],
    "searched": !exists(json, "searched") ? void 0 : json["searched"]
  };
}
function ScoreToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "manual": value.manual,
    "automatic": value.automatic,
    "priority": value.priority,
    "reuse": value.reuse,
    "update": value.update,
    "reference": value.reference,
    "searched": value.searched
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedAnchorPoint.ts
function FlattenedAnchorPointFromJSON(json) {
  return FlattenedAnchorPointFromJSONTyped(json, false);
}
function FlattenedAnchorPointFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "verified": !exists(json, "verified") ? void 0 : json["verified"],
    "fullpath": json["fullpath"],
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"]),
    "platform": !exists(json, "platform") ? void 0 : PlatformEnumFromJSON(json["platform"]),
    "anchor": ReferencedAnchorFromJSON(json["anchor"]),
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function FlattenedAnchorPointToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "verified": value.verified,
    "fullpath": value.fullpath,
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "deleted": GroupedTimestampToJSON(value.deleted),
    "platform": PlatformEnumToJSON(value.platform),
    "anchor": ReferencedAnchorToJSON(value.anchor),
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ReferencedAnchorPoint.ts
function ReferencedAnchorPointFromJSON(json) {
  return ReferencedAnchorPointFromJSONTyped(json, false);
}
function ReferencedAnchorPointFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "reference": !exists(json, "reference") ? void 0 : FlattenedAnchorPointFromJSON(json["reference"])
  };
}
function ReferencedAnchorPointToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "reference": FlattenedAnchorPointToJSON(value.reference)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedAnchorPoints.ts
function FlattenedAnchorPointsFromJSON(json) {
  return FlattenedAnchorPointsFromJSONTyped(json, false);
}
function FlattenedAnchorPointsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(ReferencedAnchorPointFromJSON),
    "indices": !exists(json, "indices") ? void 0 : json["indices"],
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function FlattenedAnchorPointsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(ReferencedAnchorPointToJSON),
    "indices": value.indices,
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/AnnotationTypeEnum.ts
var AnnotationTypeEnum = {
  Description: "DESCRIPTION",
  Comment: "COMMENT",
  Documentation: "DOCUMENTATION",
  Summary: "SUMMARY",
  Explanation: "EXPLANATION",
  GitCommit: "GIT_COMMIT"
};
function AnnotationTypeEnumFromJSON(json) {
  return AnnotationTypeEnumFromJSONTyped(json, false);
}
function AnnotationTypeEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function AnnotationTypeEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/ConversationMessageSentimentEnum.ts
function ConversationMessageSentimentEnumFromJSON(json) {
  return ConversationMessageSentimentEnumFromJSONTyped(json, false);
}
function ConversationMessageSentimentEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function ConversationMessageSentimentEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedAnchors.ts
function FlattenedAnchorsFromJSON(json) {
  return FlattenedAnchorsFromJSONTyped(json, false);
}
function FlattenedAnchorsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(ReferencedAnchorFromJSON),
    "indices": !exists(json, "indices") ? void 0 : json["indices"],
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function FlattenedAnchorsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(ReferencedAnchorToJSON),
    "indices": value.indices,
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedAssets.ts
function FlattenedAssetsFromJSON(json) {
  return FlattenedAssetsFromJSONTyped(json, false);
}
function FlattenedAssetsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": !exists(json, "iterable") ? void 0 : json["iterable"].map(ReferencedAssetFromJSON),
    "indices": !exists(json, "indices") ? void 0 : json["indices"],
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function FlattenedAssetsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable === void 0 ? void 0 : value.iterable.map(ReferencedAssetToJSON),
    "indices": value.indices,
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TagCategoryEnum.ts
function TagCategoryEnumFromJSON(json) {
  return TagCategoryEnumFromJSONTyped(json, false);
}
function TagCategoryEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function TagCategoryEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedTag.ts
function FlattenedTagFromJSON(json) {
  return FlattenedTagFromJSONTyped(json, false);
}
function FlattenedTagFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "text": json["text"],
    "mechanisms": !exists(json, "mechanisms") ? void 0 : mapValues(json["mechanisms"], MechanismEnumFromJSON),
    "assets": !exists(json, "assets") ? void 0 : FlattenedAssetsFromJSON(json["assets"]),
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"]),
    "category": TagCategoryEnumFromJSON(json["category"]),
    "relationship": !exists(json, "relationship") ? void 0 : RelationshipFromJSON(json["relationship"]),
    "interactions": !exists(json, "interactions") ? void 0 : json["interactions"],
    "persons": !exists(json, "persons") ? void 0 : FlattenedPersonsFromJSON(json["persons"]),
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function FlattenedTagToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "text": value.text,
    "mechanisms": value.mechanisms === void 0 ? void 0 : mapValues(value.mechanisms, MechanismEnumToJSON),
    "assets": FlattenedAssetsToJSON(value.assets),
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "deleted": GroupedTimestampToJSON(value.deleted),
    "category": TagCategoryEnumToJSON(value.category),
    "relationship": RelationshipToJSON(value.relationship),
    "interactions": value.interactions,
    "persons": FlattenedPersonsToJSON(value.persons),
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ReferencedTag.ts
function ReferencedTagFromJSON(json) {
  return ReferencedTagFromJSONTyped(json, false);
}
function ReferencedTagFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "reference": !exists(json, "reference") ? void 0 : FlattenedTagFromJSON(json["reference"])
  };
}
function ReferencedTagToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "reference": FlattenedTagToJSON(value.reference)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedTags.ts
function FlattenedTagsFromJSON(json) {
  return FlattenedTagsFromJSONTyped(json, false);
}
function FlattenedTagsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(ReferencedTagFromJSON),
    "indices": !exists(json, "indices") ? void 0 : json["indices"],
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function FlattenedTagsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(ReferencedTagToJSON),
    "indices": value.indices,
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Applications.ts
function ApplicationsFromJSON(json) {
  return ApplicationsFromJSONTyped(json, false);
}
function ApplicationsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(ApplicationFromJSON)
  };
}
function ApplicationsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(ApplicationToJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/AnonymousTemporalRange.ts
function AnonymousTemporalRangeFromJSON(json) {
  return AnonymousTemporalRangeFromJSONTyped(json, false);
}
function AnonymousTemporalRangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "from": !exists(json, "from") ? void 0 : GroupedTimestampFromJSON(json["from"]),
    "to": !exists(json, "to") ? void 0 : GroupedTimestampFromJSON(json["to"]),
    "between": !exists(json, "between") ? void 0 : json["between"],
    "continuous": !exists(json, "continuous") ? void 0 : json["continuous"]
  };
}
function AnonymousTemporalRangeToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "from": GroupedTimestampToJSON(value.from),
    "to": GroupedTimestampToJSON(value.to),
    "between": value.between,
    "continuous": value.continuous
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/BrowserSelection.ts
function BrowserSelectionFromJSON(json) {
  return BrowserSelectionFromJSONTyped(json, false);
}
function BrowserSelectionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "classification": ClassificationFromJSON(json["classification"]),
    "value": TransferableStringFromJSON(json["value"])
  };
}
function BrowserSelectionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "classification": ClassificationToJSON(value.classification),
    "value": TransferableStringToJSON(value.value)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/BrowserTabValue.ts
function BrowserTabValueFromJSON(json) {
  return BrowserTabValueFromJSONTyped(json, false);
}
function BrowserTabValueFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "html": !exists(json, "html") ? void 0 : TransferableStringFromJSON(json["html"]),
    "md": !exists(json, "md") ? void 0 : TransferableStringFromJSON(json["md"]),
    "text": !exists(json, "text") ? void 0 : TransferableStringFromJSON(json["text"]),
    "snippet": !exists(json, "snippet") ? void 0 : BrowserSelectionFromJSON(json["snippet"]),
    "selection": !exists(json, "selection") ? void 0 : BrowserSelectionFromJSON(json["selection"])
  };
}
function BrowserTabValueToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "html": TransferableStringToJSON(value.html),
    "md": TransferableStringToJSON(value.md),
    "text": TransferableStringToJSON(value.text),
    "snippet": BrowserSelectionToJSON(value.snippet),
    "selection": BrowserSelectionToJSON(value.selection)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/BrowserTabValues.ts
function BrowserTabValuesFromJSON(json) {
  return BrowserTabValuesFromJSONTyped(json, false);
}
function BrowserTabValuesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(BrowserTabValueFromJSON)
  };
}
function BrowserTabValuesToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(BrowserTabValueToJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ExternallySourcedEnum.ts
function ExternallySourcedEnumFromJSON(json) {
  return ExternallySourcedEnumFromJSONTyped(json, false);
}
function ExternallySourcedEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function ExternallySourcedEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/MailgunMetadata.ts
function MailgunMetadataFromJSON(json) {
  return MailgunMetadataFromJSONTyped(json, false);
}
function MailgunMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "messageId": json["messageId"]
  };
}
function MailgunMetadataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "messageId": value.messageId
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/PersonBasicType.ts
function PersonBasicTypeFromJSON(json) {
  return PersonBasicTypeFromJSONTyped(json, false);
}
function PersonBasicTypeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "username": !exists(json, "username") ? void 0 : json["username"],
    "name": !exists(json, "name") ? void 0 : json["name"],
    "picture": !exists(json, "picture") ? void 0 : json["picture"],
    "email": !exists(json, "email") ? void 0 : json["email"],
    "sourced": !exists(json, "sourced") ? void 0 : ExternallySourcedEnumFromJSON(json["sourced"]),
    "url": !exists(json, "url") ? void 0 : json["url"],
    "mailgun": !exists(json, "mailgun") ? void 0 : MailgunMetadataFromJSON(json["mailgun"])
  };
}
function PersonBasicTypeToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "username": value.username,
    "name": value.name,
    "picture": value.picture,
    "email": value.email,
    "sourced": ExternallySourcedEnumToJSON(value.sourced),
    "url": value.url,
    "mailgun": MailgunMetadataToJSON(value.mailgun)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/DocumentContributor.ts
function DocumentContributorFromJSON(json) {
  return DocumentContributorFromJSONTyped(json, false);
}
function DocumentContributorFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "classification": !exists(json, "classification") ? void 0 : ClassificationFromJSON(json["classification"]),
    "value": !exists(json, "value") ? void 0 : TransferableStringFromJSON(json["value"]),
    "person": PersonBasicTypeFromJSON(json["person"]),
    "updated": !exists(json, "updated") ? void 0 : GroupedTimestampFromJSON(json["updated"])
  };
}
function DocumentContributorToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "classification": ClassificationToJSON(value.classification),
    "value": TransferableStringToJSON(value.value),
    "person": PersonBasicTypeToJSON(value.person),
    "updated": GroupedTimestampToJSON(value.updated)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/DocumentContributors.ts
function DocumentContributorsFromJSON(json) {
  return DocumentContributorsFromJSONTyped(json, false);
}
function DocumentContributorsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(DocumentContributorFromJSON)
  };
}
function DocumentContributorsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(DocumentContributorToJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededAnnotation.ts
function SeededAnnotationFromJSON(json) {
  return SeededAnnotationFromJSONTyped(json, false);
}
function SeededAnnotationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "mechanism": !exists(json, "mechanism") ? void 0 : MechanismEnumFromJSON(json["mechanism"]),
    "asset": !exists(json, "asset") ? void 0 : json["asset"],
    "person": !exists(json, "person") ? void 0 : json["person"],
    "type": AnnotationTypeEnumFromJSON(json["type"]),
    "text": json["text"],
    "model": !exists(json, "model") ? void 0 : json["model"],
    "pseudo": !exists(json, "pseudo") ? void 0 : json["pseudo"],
    "favorited": !exists(json, "favorited") ? void 0 : json["favorited"],
    "anchor": !exists(json, "anchor") ? void 0 : json["anchor"],
    "conversation": !exists(json, "conversation") ? void 0 : json["conversation"],
    "messages": !exists(json, "messages") ? void 0 : FlattenedConversationMessagesFromJSON(json["messages"])
  };
}
function SeededAnnotationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "mechanism": MechanismEnumToJSON(value.mechanism),
    "asset": value.asset,
    "person": value.person,
    "type": AnnotationTypeEnumToJSON(value.type),
    "text": value.text,
    "model": value.model,
    "pseudo": value.pseudo,
    "favorited": value.favorited,
    "anchor": value.anchor,
    "conversation": value.conversation,
    "messages": FlattenedConversationMessagesToJSON(value.messages)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededAnchor.ts
function SeededAnchorFromJSON(json) {
  return SeededAnchorFromJSONTyped(json, false);
}
function SeededAnchorFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "type": AnchorTypeEnumFromJSON(json["type"]),
    "watch": !exists(json, "watch") ? void 0 : json["watch"],
    "fullpath": json["fullpath"],
    "asset": !exists(json, "asset") ? void 0 : json["asset"],
    "platform": !exists(json, "platform") ? void 0 : PlatformEnumFromJSON(json["platform"]),
    "name": !exists(json, "name") ? void 0 : json["name"],
    "annotations": !exists(json, "annotations") ? void 0 : json["annotations"].map(SeededAnnotationFromJSON),
    "conversation": !exists(json, "conversation") ? void 0 : json["conversation"],
    "persons": !exists(json, "persons") ? void 0 : FlattenedPersonsFromJSON(json["persons"])
  };
}
function SeededAnchorToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "type": AnchorTypeEnumToJSON(value.type),
    "watch": value.watch,
    "fullpath": value.fullpath,
    "asset": value.asset,
    "platform": PlatformEnumToJSON(value.platform),
    "name": value.name,
    "annotations": value.annotations === void 0 ? void 0 : value.annotations.map(SeededAnnotationToJSON),
    "conversation": value.conversation,
    "persons": FlattenedPersonsToJSON(value.persons)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededWebsite.ts
function SeededWebsiteFromJSON(json) {
  return SeededWebsiteFromJSONTyped(json, false);
}
function SeededWebsiteFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "asset": !exists(json, "asset") ? void 0 : json["asset"],
    "conversation": !exists(json, "conversation") ? void 0 : json["conversation"],
    "url": json["url"],
    "name": json["name"],
    "mechanism": !exists(json, "mechanism") ? void 0 : MechanismEnumFromJSON(json["mechanism"]),
    "person": !exists(json, "person") ? void 0 : json["person"]
  };
}
function SeededWebsiteToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "asset": value.asset,
    "conversation": value.conversation,
    "url": value.url,
    "name": value.name,
    "mechanism": MechanismEnumToJSON(value.mechanism),
    "person": value.person
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/BrowserTab.ts
function BrowserTabFromJSON(json) {
  return BrowserTabFromJSONTyped(json, false);
}
function BrowserTabFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "values": !exists(json, "values") ? void 0 : BrowserTabValuesFromJSON(json["values"]),
    "anchor": !exists(json, "anchor") ? void 0 : SeededAnchorFromJSON(json["anchor"]),
    "website": !exists(json, "website") ? void 0 : SeededWebsiteFromJSON(json["website"]),
    "range": !exists(json, "range") ? void 0 : AnonymousTemporalRangeFromJSON(json["range"]),
    "current": !exists(json, "current") ? void 0 : json["current"],
    "contributors": !exists(json, "contributors") ? void 0 : DocumentContributorsFromJSON(json["contributors"])
  };
}
function BrowserTabToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "values": BrowserTabValuesToJSON(value.values),
    "anchor": SeededAnchorToJSON(value.anchor),
    "website": SeededWebsiteToJSON(value.website),
    "range": AnonymousTemporalRangeToJSON(value.range),
    "current": value.current,
    "contributors": DocumentContributorsToJSON(value.contributors)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/BrowserTabs.ts
function BrowserTabsFromJSON(json) {
  return BrowserTabsFromJSONTyped(json, false);
}
function BrowserTabsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(BrowserTabFromJSON)
  };
}
function BrowserTabsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(BrowserTabToJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/WorkstreamEventTriggerContextBrowser.ts
function WorkstreamEventTriggerContextBrowserFromJSON(json) {
  return WorkstreamEventTriggerContextBrowserFromJSONTyped(json, false);
}
function WorkstreamEventTriggerContextBrowserFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "tabs": !exists(json, "tabs") ? void 0 : BrowserTabsFromJSON(json["tabs"])
  };
}
function WorkstreamEventTriggerContextBrowserToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "tabs": BrowserTabsToJSON(value.tabs)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/LanguageServerProtocolLocationRangePosition.ts
function LanguageServerProtocolLocationRangePositionFromJSON(json) {
  return LanguageServerProtocolLocationRangePositionFromJSONTyped(json, false);
}
function LanguageServerProtocolLocationRangePositionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "line": json["line"],
    "character": json["character"]
  };
}
function LanguageServerProtocolLocationRangePositionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "line": value.line,
    "character": value.character
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/LanguageServerProtocolLocationRange.ts
function LanguageServerProtocolLocationRangeFromJSON(json) {
  return LanguageServerProtocolLocationRangeFromJSONTyped(json, false);
}
function LanguageServerProtocolLocationRangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "start": LanguageServerProtocolLocationRangePositionFromJSON(json["start"]),
    "end": LanguageServerProtocolLocationRangePositionFromJSON(json["end"])
  };
}
function LanguageServerProtocolLocationRangeToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "start": LanguageServerProtocolLocationRangePositionToJSON(value.start),
    "end": LanguageServerProtocolLocationRangePositionToJSON(value.end)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/LanguageServerProtocolLocation.ts
function LanguageServerProtocolLocationFromJSON(json) {
  return LanguageServerProtocolLocationFromJSONTyped(json, false);
}
function LanguageServerProtocolLocationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "uri": json["uri"],
    "range": LanguageServerProtocolLocationRangeFromJSON(json["range"])
  };
}
function LanguageServerProtocolLocationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "uri": value.uri,
    "range": LanguageServerProtocolLocationRangeToJSON(value.range)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/IDESelection.ts
function IDESelectionFromJSON(json) {
  return IDESelectionFromJSONTyped(json, false);
}
function IDESelectionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "location": !exists(json, "location") ? void 0 : LanguageServerProtocolLocationFromJSON(json["location"]),
    "classification": !exists(json, "classification") ? void 0 : ClassificationFromJSON(json["classification"]),
    "value": !exists(json, "value") ? void 0 : TransferableStringFromJSON(json["value"])
  };
}
function IDESelectionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "location": LanguageServerProtocolLocationToJSON(value.location),
    "classification": ClassificationToJSON(value.classification),
    "value": TransferableStringToJSON(value.value)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/IDESelections.ts
function IDESelectionsFromJSON(json) {
  return IDESelectionsFromJSONTyped(json, false);
}
function IDESelectionsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(IDESelectionFromJSON)
  };
}
function IDESelectionsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(IDESelectionToJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/LanguageServerProtocolCode.ts
function LanguageServerProtocolCodeFromJSON(json) {
  return LanguageServerProtocolCodeFromJSONTyped(json, false);
}
function LanguageServerProtocolCodeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "codeInteger": !exists(json, "code_integer") ? void 0 : json["code_integer"],
    "codeString": !exists(json, "code_string") ? void 0 : json["code_string"],
    "rawJson": !exists(json, "raw_json") ? void 0 : json["raw_json"]
  };
}
function LanguageServerProtocolCodeToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "code_integer": value.codeInteger,
    "code_string": value.codeString,
    "raw_json": value.rawJson
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/LanguageServerProtocolCodeDescription.ts
function LanguageServerProtocolCodeDescriptionFromJSON(json) {
  return LanguageServerProtocolCodeDescriptionFromJSONTyped(json, false);
}
function LanguageServerProtocolCodeDescriptionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "href": json["href"]
  };
}
function LanguageServerProtocolCodeDescriptionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "href": value.href
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/LanguageServerProtocolSeverityEnum.ts
function LanguageServerProtocolSeverityEnumFromJSON(json) {
  return LanguageServerProtocolSeverityEnumFromJSONTyped(json, false);
}
function LanguageServerProtocolSeverityEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function LanguageServerProtocolSeverityEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/LanguageServerProtocolDiagnostic.ts
function LanguageServerProtocolDiagnosticFromJSON(json) {
  return LanguageServerProtocolDiagnosticFromJSONTyped(json, false);
}
function LanguageServerProtocolDiagnosticFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "range": LanguageServerProtocolLocationRangeFromJSON(json["range"]),
    "severity": !exists(json, "severity") ? void 0 : LanguageServerProtocolSeverityEnumFromJSON(json["severity"]),
    "code": !exists(json, "code") ? void 0 : LanguageServerProtocolCodeFromJSON(json["code"]),
    "codeDescription": !exists(json, "codeDescription") ? void 0 : LanguageServerProtocolCodeDescriptionFromJSON(json["codeDescription"]),
    "source": !exists(json, "source") ? void 0 : json["source"],
    "message": json["message"]
  };
}
function LanguageServerProtocolDiagnosticToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "range": LanguageServerProtocolLocationRangeToJSON(value.range),
    "severity": LanguageServerProtocolSeverityEnumToJSON(value.severity),
    "code": LanguageServerProtocolCodeToJSON(value.code),
    "codeDescription": LanguageServerProtocolCodeDescriptionToJSON(value.codeDescription),
    "source": value.source,
    "message": value.message
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/LanguageServerProtocolDiagnostics.ts
function LanguageServerProtocolDiagnosticsFromJSON(json) {
  return LanguageServerProtocolDiagnosticsFromJSONTyped(json, false);
}
function LanguageServerProtocolDiagnosticsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(LanguageServerProtocolDiagnosticFromJSON)
  };
}
function LanguageServerProtocolDiagnosticsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(LanguageServerProtocolDiagnosticToJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/LanguageServerProtocol.ts
function LanguageServerProtocolFromJSON(json) {
  return LanguageServerProtocolFromJSONTyped(json, false);
}
function LanguageServerProtocolFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "diagnostics": !exists(json, "diagnostics") ? void 0 : LanguageServerProtocolDiagnosticsFromJSON(json["diagnostics"])
  };
}
function LanguageServerProtocolToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "diagnostics": LanguageServerProtocolDiagnosticsToJSON(value.diagnostics)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/IDETab.ts
function IDETabFromJSON(json) {
  return IDETabFromJSONTyped(json, false);
}
function IDETabFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "value": !exists(json, "value") ? void 0 : TransferableStringFromJSON(json["value"]),
    "classification": !exists(json, "classification") ? void 0 : ClassificationFromJSON(json["classification"]),
    "selections": !exists(json, "selections") ? void 0 : IDESelectionsFromJSON(json["selections"]),
    "anchor": SeededAnchorFromJSON(json["anchor"]),
    "range": !exists(json, "range") ? void 0 : AnonymousTemporalRangeFromJSON(json["range"]),
    "current": !exists(json, "current") ? void 0 : json["current"],
    "contributors": !exists(json, "contributors") ? void 0 : DocumentContributorsFromJSON(json["contributors"]),
    "lsp": !exists(json, "lsp") ? void 0 : LanguageServerProtocolFromJSON(json["lsp"])
  };
}
function IDETabToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "value": TransferableStringToJSON(value.value),
    "classification": ClassificationToJSON(value.classification),
    "selections": IDESelectionsToJSON(value.selections),
    "anchor": SeededAnchorToJSON(value.anchor),
    "range": AnonymousTemporalRangeToJSON(value.range),
    "current": value.current,
    "contributors": DocumentContributorsToJSON(value.contributors),
    "lsp": LanguageServerProtocolToJSON(value.lsp)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/IDETabs.ts
function IDETabsFromJSON(json) {
  return IDETabsFromJSONTyped(json, false);
}
function IDETabsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(IDETabFromJSON)
  };
}
function IDETabsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(IDETabToJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Classifications.ts
function ClassificationsFromJSON(json) {
  return ClassificationsFromJSONTyped(json, false);
}
function ClassificationsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(ClassificationFromJSON)
  };
}
function ClassificationsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(ClassificationToJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ProjectModule.ts
function ProjectModuleFromJSON(json) {
  return ProjectModuleFromJSONTyped(json, false);
}
function ProjectModuleFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "anchor": SeededAnchorFromJSON(json["anchor"]),
    "range": !exists(json, "range") ? void 0 : AnonymousTemporalRangeFromJSON(json["range"]),
    "contributors": !exists(json, "contributors") ? void 0 : DocumentContributorsFromJSON(json["contributors"]),
    "classifications": !exists(json, "classifications") ? void 0 : ClassificationsFromJSON(json["classifications"])
  };
}
function ProjectModuleToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "anchor": SeededAnchorToJSON(value.anchor),
    "range": AnonymousTemporalRangeToJSON(value.range),
    "contributors": DocumentContributorsToJSON(value.contributors),
    "classifications": ClassificationsToJSON(value.classifications)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ProjectModules.ts
function ProjectModulesFromJSON(json) {
  return ProjectModulesFromJSONTyped(json, false);
}
function ProjectModulesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(ProjectModuleFromJSON)
  };
}
function ProjectModulesToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(ProjectModuleToJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/WorkstreamEventTriggerContextIDE.ts
function WorkstreamEventTriggerContextIDEFromJSON(json) {
  return WorkstreamEventTriggerContextIDEFromJSONTyped(json, false);
}
function WorkstreamEventTriggerContextIDEFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "tabs": !exists(json, "tabs") ? void 0 : IDETabsFromJSON(json["tabs"]),
    "modules": !exists(json, "modules") ? void 0 : ProjectModulesFromJSON(json["modules"]),
    "name": !exists(json, "name") ? void 0 : json["name"]
  };
}
function WorkstreamEventTriggerContextIDEToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "tabs": IDETabsToJSON(value.tabs),
    "modules": ProjectModulesToJSON(value.modules),
    "name": value.name
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/WorkstreamEventContext.ts
function WorkstreamEventContextFromJSON(json) {
  return WorkstreamEventContextFromJSONTyped(json, false);
}
function WorkstreamEventContextFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "ide": !exists(json, "ide") ? void 0 : WorkstreamEventTriggerContextIDEFromJSON(json["ide"]),
    "browser": !exists(json, "browser") ? void 0 : WorkstreamEventTriggerContextBrowserFromJSON(json["browser"])
  };
}
function WorkstreamEventContextToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "ide": WorkstreamEventTriggerContextIDEToJSON(value.ide),
    "browser": WorkstreamEventTriggerContextBrowserToJSON(value.browser)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/WorkstreamEventTrigger.ts
function WorkstreamEventTriggerFromJSON(json) {
  return WorkstreamEventTriggerFromJSONTyped(json, false);
}
function WorkstreamEventTriggerFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "checkIn": !exists(json, "check_in") ? void 0 : json["check_in"],
    "copy": !exists(json, "copy") ? void 0 : json["copy"],
    "paste": !exists(json, "paste") ? void 0 : json["paste"],
    "fileOpen": !exists(json, "file_open") ? void 0 : json["file_open"],
    "fileClose": !exists(json, "file_close") ? void 0 : json["file_close"],
    "tabSwitch": !exists(json, "tab_switch") ? void 0 : json["tab_switch"],
    "tabClose": !exists(json, "tab_close") ? void 0 : json["tab_close"],
    "tabOpen": !exists(json, "tab_open") ? void 0 : json["tab_open"],
    "tabEnter": !exists(json, "tab_enter") ? void 0 : json["tab_enter"],
    "tabLeave": !exists(json, "tab_leave") ? void 0 : json["tab_leave"],
    "urlChanged": !exists(json, "url_changed") ? void 0 : json["url_changed"],
    "applicationEnter": !exists(json, "application_enter") ? void 0 : json["application_enter"],
    "applicationLeave": !exists(json, "application_leave") ? void 0 : json["application_leave"],
    "applicationSwitch": !exists(json, "application_switch") ? void 0 : json["application_switch"]
  };
}
function WorkstreamEventTriggerToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "check_in": value.checkIn,
    "copy": value.copy,
    "paste": value.paste,
    "file_open": value.fileOpen,
    "file_close": value.fileClose,
    "tab_switch": value.tabSwitch,
    "tab_close": value.tabClose,
    "tab_open": value.tabOpen,
    "tab_enter": value.tabEnter,
    "tab_leave": value.tabLeave,
    "url_changed": value.urlChanged,
    "application_enter": value.applicationEnter,
    "application_leave": value.applicationLeave,
    "application_switch": value.applicationSwitch
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedWorkstreamEvent.ts
function FlattenedWorkstreamEventFromJSON(json) {
  return FlattenedWorkstreamEventFromJSONTyped(json, false);
}
function FlattenedWorkstreamEventFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"]),
    "application": ApplicationFromJSON(json["application"]),
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "trigger": WorkstreamEventTriggerFromJSON(json["trigger"]),
    "context": !exists(json, "context") ? void 0 : WorkstreamEventContextFromJSON(json["context"]),
    "summaries": !exists(json, "summaries") ? void 0 : FlattenedWorkstreamSummariesFromJSON(json["summaries"])
  };
}
function FlattenedWorkstreamEventToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "score": ScoreToJSON(value.score),
    "application": ApplicationToJSON(value.application),
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "trigger": WorkstreamEventTriggerToJSON(value.trigger),
    "context": WorkstreamEventContextToJSON(value.context),
    "summaries": FlattenedWorkstreamSummariesToJSON(value.summaries)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ReferencedWorkstreamEvent.ts
function ReferencedWorkstreamEventFromJSON(json) {
  return ReferencedWorkstreamEventFromJSONTyped(json, false);
}
function ReferencedWorkstreamEventFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "reference": !exists(json, "reference") ? void 0 : FlattenedWorkstreamEventFromJSON(json["reference"])
  };
}
function ReferencedWorkstreamEventToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "reference": FlattenedWorkstreamEventToJSON(value.reference)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedWorkstreamEvents.ts
function FlattenedWorkstreamEventsFromJSON(json) {
  return FlattenedWorkstreamEventsFromJSONTyped(json, false);
}
function FlattenedWorkstreamEventsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(ReferencedWorkstreamEventFromJSON),
    "indices": !exists(json, "indices") ? void 0 : json["indices"],
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function FlattenedWorkstreamEventsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(ReferencedWorkstreamEventToJSON),
    "indices": value.indices,
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedWorkstreamSummary.ts
function FlattenedWorkstreamSummaryFromJSON(json) {
  return FlattenedWorkstreamSummaryFromJSONTyped(json, false);
}
function FlattenedWorkstreamSummaryFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"]),
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "events": !exists(json, "events") ? void 0 : FlattenedWorkstreamEventsFromJSON(json["events"]),
    "name": json["name"],
    "annotations": !exists(json, "annotations") ? void 0 : FlattenedAnnotationsFromJSON(json["annotations"]),
    "ranges": !exists(json, "ranges") ? void 0 : FlattenedRangesFromJSON(json["ranges"]),
    "model": ModelFromJSON(json["model"]),
    "websites": !exists(json, "websites") ? void 0 : FlattenedWebsitesFromJSON(json["websites"]),
    "anchors": !exists(json, "anchors") ? void 0 : FlattenedAnchorsFromJSON(json["anchors"]),
    "assets": !exists(json, "assets") ? void 0 : FlattenedAssetsFromJSON(json["assets"]),
    "conversations": !exists(json, "conversations") ? void 0 : FlattenedConversationsFromJSON(json["conversations"]),
    "persons": !exists(json, "persons") ? void 0 : FlattenedPersonsFromJSON(json["persons"]),
    "applications": !exists(json, "applications") ? void 0 : ApplicationsFromJSON(json["applications"])
  };
}
function FlattenedWorkstreamSummaryToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "score": ScoreToJSON(value.score),
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "events": FlattenedWorkstreamEventsToJSON(value.events),
    "name": value.name,
    "annotations": FlattenedAnnotationsToJSON(value.annotations),
    "ranges": FlattenedRangesToJSON(value.ranges),
    "model": ModelToJSON(value.model),
    "websites": FlattenedWebsitesToJSON(value.websites),
    "anchors": FlattenedAnchorsToJSON(value.anchors),
    "assets": FlattenedAssetsToJSON(value.assets),
    "conversations": FlattenedConversationsToJSON(value.conversations),
    "persons": FlattenedPersonsToJSON(value.persons),
    "applications": ApplicationsToJSON(value.applications)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ReferencedWorkstreamSummary.ts
function ReferencedWorkstreamSummaryFromJSON(json) {
  return ReferencedWorkstreamSummaryFromJSONTyped(json, false);
}
function ReferencedWorkstreamSummaryFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "reference": !exists(json, "reference") ? void 0 : FlattenedWorkstreamSummaryFromJSON(json["reference"])
  };
}
function ReferencedWorkstreamSummaryToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "reference": FlattenedWorkstreamSummaryToJSON(value.reference)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedWorkstreamSummaries.ts
function FlattenedWorkstreamSummariesFromJSON(json) {
  return FlattenedWorkstreamSummariesFromJSONTyped2(json, false);
}
function FlattenedWorkstreamSummariesFromJSONTyped2(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(ReferencedWorkstreamSummaryFromJSON),
    "indices": !exists(json, "indices") ? void 0 : json["indices"],
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function FlattenedWorkstreamSummariesToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(ReferencedWorkstreamSummaryToJSON),
    "indices": value.indices,
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedRange.ts
function FlattenedRangeFromJSON(json) {
  return FlattenedRangeFromJSONTyped(json, false);
}
function FlattenedRangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"]),
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "to": !exists(json, "to") ? void 0 : GroupedTimestampFromJSON(json["to"]),
    "from": !exists(json, "from") ? void 0 : GroupedTimestampFromJSON(json["from"]),
    "between": !exists(json, "between") ? void 0 : json["between"],
    "summaries": !exists(json, "summaries") ? void 0 : FlattenedWorkstreamSummariesFromJSON(json["summaries"]),
    "conversations": !exists(json, "conversations") ? void 0 : FlattenedConversationsFromJSON(json["conversations"])
  };
}
function FlattenedRangeToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "score": ScoreToJSON(value.score),
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "to": GroupedTimestampToJSON(value.to),
    "from": GroupedTimestampToJSON(value.from),
    "between": value.between,
    "summaries": FlattenedWorkstreamSummariesToJSON(value.summaries),
    "conversations": FlattenedConversationsToJSON(value.conversations)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ReferencedRange.ts
function ReferencedRangeFromJSON(json) {
  return ReferencedRangeFromJSONTyped(json, false);
}
function ReferencedRangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "reference": !exists(json, "reference") ? void 0 : FlattenedRangeFromJSON(json["reference"])
  };
}
function ReferencedRangeToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "reference": FlattenedRangeToJSON(value.reference)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedRanges.ts
function FlattenedRangesFromJSON(json) {
  return FlattenedRangesFromJSONTyped2(json, false);
}
function FlattenedRangesFromJSONTyped2(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(ReferencedRangeFromJSON),
    "indices": !exists(json, "indices") ? void 0 : json["indices"],
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"]),
    "continuous": !exists(json, "continuous") ? void 0 : json["continuous"]
  };
}
function FlattenedRangesToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(ReferencedRangeToJSON),
    "indices": value.indices,
    "score": ScoreToJSON(value.score),
    "continuous": value.continuous
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TemporalRangeGrounding.ts
function TemporalRangeGroundingFromJSON(json) {
  return TemporalRangeGroundingFromJSONTyped(json, false);
}
function TemporalRangeGroundingFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "workstreams": !exists(json, "workstreams") ? void 0 : FlattenedRangesFromJSON(json["workstreams"])
  };
}
function TemporalRangeGroundingToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "workstreams": FlattenedRangesToJSON(value.workstreams)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ConversationGrounding.ts
function ConversationGroundingFromJSON(json) {
  return ConversationGroundingFromJSONTyped(json, false);
}
function ConversationGroundingFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "messages": !exists(json, "messages") ? void 0 : FlattenedConversationMessagesFromJSON(json["messages"]),
    "temporal": !exists(json, "temporal") ? void 0 : TemporalRangeGroundingFromJSON(json["temporal"])
  };
}
function ConversationGroundingToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "messages": FlattenedConversationMessagesToJSON(value.messages),
    "temporal": TemporalRangeGroundingToJSON(value.temporal)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ConversationTypeEnum.ts
function ConversationTypeEnumFromJSON(json) {
  return ConversationTypeEnumFromJSONTyped(json, false);
}
function ConversationTypeEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function ConversationTypeEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTConversationPipelineForContextualizedCodeDialog.ts
function QGPTConversationPipelineForContextualizedCodeDialogFromJSON(json) {
  return QGPTConversationPipelineForContextualizedCodeDialogFromJSONTyped(json, false);
}
function QGPTConversationPipelineForContextualizedCodeDialogFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"])
  };
}
function QGPTConversationPipelineForContextualizedCodeDialogToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTConversationPipelineForContextualizedCodeGeneration.ts
function QGPTConversationPipelineForContextualizedCodeGenerationFromJSON(json) {
  return QGPTConversationPipelineForContextualizedCodeGenerationFromJSONTyped(json, false);
}
function QGPTConversationPipelineForContextualizedCodeGenerationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"])
  };
}
function QGPTConversationPipelineForContextualizedCodeGenerationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTConversationPipelineForContextualizedCodeWorkstreamDialog.ts
function QGPTConversationPipelineForContextualizedCodeWorkstreamDialogFromJSON(json) {
  return QGPTConversationPipelineForContextualizedCodeWorkstreamDialogFromJSONTyped(json, false);
}
function QGPTConversationPipelineForContextualizedCodeWorkstreamDialogFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"])
  };
}
function QGPTConversationPipelineForContextualizedCodeWorkstreamDialogToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTConversationPipelineForGeneralizedCodeDialog.ts
function QGPTConversationPipelineForGeneralizedCodeDialogFromJSON(json) {
  return QGPTConversationPipelineForGeneralizedCodeDialogFromJSONTyped(json, false);
}
function QGPTConversationPipelineForGeneralizedCodeDialogFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"])
  };
}
function QGPTConversationPipelineForGeneralizedCodeDialogToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTConversationPipeline.ts
function QGPTConversationPipelineFromJSON(json) {
  return QGPTConversationPipelineFromJSONTyped(json, false);
}
function QGPTConversationPipelineFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "contextualizedCodeGeneration": !exists(json, "contextualized_code_generation") ? void 0 : QGPTConversationPipelineForContextualizedCodeGenerationFromJSON(json["contextualized_code_generation"]),
    "generalizedCodeDialog": !exists(json, "generalized_code_dialog") ? void 0 : QGPTConversationPipelineForGeneralizedCodeDialogFromJSON(json["generalized_code_dialog"]),
    "contextualizedCodeDialog": !exists(json, "contextualized_code_dialog") ? void 0 : QGPTConversationPipelineForContextualizedCodeDialogFromJSON(json["contextualized_code_dialog"]),
    "contextualizedCodeWorkstreamDialog": !exists(json, "contextualized_code_workstream_dialog") ? void 0 : QGPTConversationPipelineForContextualizedCodeWorkstreamDialogFromJSON(json["contextualized_code_workstream_dialog"])
  };
}
function QGPTConversationPipelineToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "contextualized_code_generation": QGPTConversationPipelineForContextualizedCodeGenerationToJSON(value.contextualizedCodeGeneration),
    "generalized_code_dialog": QGPTConversationPipelineForGeneralizedCodeDialogToJSON(value.generalizedCodeDialog),
    "contextualized_code_dialog": QGPTConversationPipelineForContextualizedCodeDialogToJSON(value.contextualizedCodeDialog),
    "contextualized_code_workstream_dialog": QGPTConversationPipelineForContextualizedCodeWorkstreamDialogToJSON(value.contextualizedCodeWorkstreamDialog)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTTaskPipelineForCodeCommentation.ts
function QGPTTaskPipelineForCodeCommentationFromJSON(json) {
  return QGPTTaskPipelineForCodeCommentationFromJSONTyped(json, false);
}
function QGPTTaskPipelineForCodeCommentationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"])
  };
}
function QGPTTaskPipelineForCodeCommentationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTTaskPipelineForCodeCompletion.ts
function QGPTTaskPipelineForCodeCompletionFromJSON(json) {
  return QGPTTaskPipelineForCodeCompletionFromJSONTyped(json, false);
}
function QGPTTaskPipelineForCodeCompletionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "context": !exists(json, "context") ? void 0 : json["context"]
  };
}
function QGPTTaskPipelineForCodeCompletionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "context": value.context
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTTaskPipelineForCodeExplanation.ts
function QGPTTaskPipelineForCodeExplanationFromJSON(json) {
  return QGPTTaskPipelineForCodeExplanationFromJSONTyped(json, false);
}
function QGPTTaskPipelineForCodeExplanationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"])
  };
}
function QGPTTaskPipelineForCodeExplanationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTTaskPipelineForCodeFix.ts
function QGPTTaskPipelineForCodeFixFromJSON(json) {
  return QGPTTaskPipelineForCodeFixFromJSONTyped(json, false);
}
function QGPTTaskPipelineForCodeFixFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "error": !exists(json, "error") ? void 0 : json["error"]
  };
}
function QGPTTaskPipelineForCodeFixToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "error": value.error
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTTaskPipelineForCodeModification.ts
function QGPTTaskPipelineForCodeModificationFromJSON(json) {
  return QGPTTaskPipelineForCodeModificationFromJSONTyped(json, false);
}
function QGPTTaskPipelineForCodeModificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "instruction": !exists(json, "instruction") ? void 0 : json["instruction"]
  };
}
function QGPTTaskPipelineForCodeModificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "instruction": value.instruction
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTTaskPipeline.ts
function QGPTTaskPipelineFromJSON(json) {
  return QGPTTaskPipelineFromJSONTyped(json, false);
}
function QGPTTaskPipelineFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "codeExplanation": !exists(json, "code_explanation") ? void 0 : QGPTTaskPipelineForCodeExplanationFromJSON(json["code_explanation"]),
    "codeCommentation": !exists(json, "code_commentation") ? void 0 : QGPTTaskPipelineForCodeCommentationFromJSON(json["code_commentation"]),
    "codeFix": !exists(json, "code_fix") ? void 0 : QGPTTaskPipelineForCodeFixFromJSON(json["code_fix"]),
    "codeModification": !exists(json, "code_modification") ? void 0 : QGPTTaskPipelineForCodeModificationFromJSON(json["code_modification"]),
    "codeCompletion": !exists(json, "code_completion") ? void 0 : QGPTTaskPipelineForCodeCompletionFromJSON(json["code_completion"])
  };
}
function QGPTTaskPipelineToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "code_explanation": QGPTTaskPipelineForCodeExplanationToJSON(value.codeExplanation),
    "code_commentation": QGPTTaskPipelineForCodeCommentationToJSON(value.codeCommentation),
    "code_fix": QGPTTaskPipelineForCodeFixToJSON(value.codeFix),
    "code_modification": QGPTTaskPipelineForCodeModificationToJSON(value.codeModification),
    "code_completion": QGPTTaskPipelineForCodeCompletionToJSON(value.codeCompletion)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTPromptPipeline.ts
function QGPTPromptPipelineFromJSON(json) {
  return QGPTPromptPipelineFromJSONTyped(json, false);
}
function QGPTPromptPipelineFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "task": !exists(json, "task") ? void 0 : QGPTTaskPipelineFromJSON(json["task"]),
    "conversation": !exists(json, "conversation") ? void 0 : QGPTConversationPipelineFromJSON(json["conversation"])
  };
}
function QGPTPromptPipelineToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "task": QGPTTaskPipelineToJSON(value.task),
    "conversation": QGPTConversationPipelineToJSON(value.conversation)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ReferencedModel.ts
function ReferencedModelFromJSON(json) {
  return ReferencedModelFromJSONTyped(json, false);
}
function ReferencedModelFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"]
  };
}
function ReferencedModelToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedConversation.ts
function FlattenedConversationFromJSON(json) {
  return FlattenedConversationFromJSONTyped(json, false);
}
function FlattenedConversationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "name": !exists(json, "name") ? void 0 : json["name"],
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"]),
    "favorited": !exists(json, "favorited") ? void 0 : json["favorited"],
    "application": !exists(json, "application") ? void 0 : ApplicationFromJSON(json["application"]),
    "annotations": !exists(json, "annotations") ? void 0 : FlattenedAnnotationsFromJSON(json["annotations"]),
    "messages": FlattenedConversationMessagesFromJSON(json["messages"]),
    "model": !exists(json, "model") ? void 0 : ReferencedModelFromJSON(json["model"]),
    "assets": !exists(json, "assets") ? void 0 : FlattenedAssetsFromJSON(json["assets"]),
    "websites": !exists(json, "websites") ? void 0 : FlattenedWebsitesFromJSON(json["websites"]),
    "anchors": !exists(json, "anchors") ? void 0 : FlattenedAnchorsFromJSON(json["anchors"]),
    "type": ConversationTypeEnumFromJSON(json["type"]),
    "grounding": !exists(json, "grounding") ? void 0 : ConversationGroundingFromJSON(json["grounding"]),
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"]),
    "pipeline": !exists(json, "pipeline") ? void 0 : QGPTPromptPipelineFromJSON(json["pipeline"]),
    "demo": !exists(json, "demo") ? void 0 : json["demo"],
    "summaries": !exists(json, "summaries") ? void 0 : FlattenedWorkstreamSummariesFromJSON(json["summaries"])
  };
}
function FlattenedConversationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "name": value.name,
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "deleted": GroupedTimestampToJSON(value.deleted),
    "favorited": value.favorited,
    "application": ApplicationToJSON(value.application),
    "annotations": FlattenedAnnotationsToJSON(value.annotations),
    "messages": FlattenedConversationMessagesToJSON(value.messages),
    "model": ReferencedModelToJSON(value.model),
    "assets": FlattenedAssetsToJSON(value.assets),
    "websites": FlattenedWebsitesToJSON(value.websites),
    "anchors": FlattenedAnchorsToJSON(value.anchors),
    "type": ConversationTypeEnumToJSON(value.type),
    "grounding": ConversationGroundingToJSON(value.grounding),
    "score": ScoreToJSON(value.score),
    "pipeline": QGPTPromptPipelineToJSON(value.pipeline),
    "demo": value.demo,
    "summaries": FlattenedWorkstreamSummariesToJSON(value.summaries)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ReferencedConversation.ts
function ReferencedConversationFromJSON(json) {
  return ReferencedConversationFromJSONTyped(json, false);
}
function ReferencedConversationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "reference": !exists(json, "reference") ? void 0 : FlattenedConversationFromJSON(json["reference"])
  };
}
function ReferencedConversationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "reference": FlattenedConversationToJSON(value.reference)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedConversations.ts
function FlattenedConversationsFromJSON(json) {
  return FlattenedConversationsFromJSONTyped3(json, false);
}
function FlattenedConversationsFromJSONTyped3(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(ReferencedConversationFromJSON),
    "indices": !exists(json, "indices") ? void 0 : json["indices"],
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function FlattenedConversationsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(ReferencedConversationToJSON),
    "indices": value.indices,
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedWebsite.ts
function FlattenedWebsiteFromJSON(json) {
  return FlattenedWebsiteFromJSONTyped(json, false);
}
function FlattenedWebsiteFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "assets": !exists(json, "assets") ? void 0 : FlattenedAssetsFromJSON(json["assets"]),
    "name": json["name"],
    "url": json["url"],
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"]),
    "mechanisms": !exists(json, "mechanisms") ? void 0 : mapValues(json["mechanisms"], MechanismEnumFromJSON),
    "interactions": !exists(json, "interactions") ? void 0 : json["interactions"],
    "persons": !exists(json, "persons") ? void 0 : FlattenedPersonsFromJSON(json["persons"]),
    "conversations": !exists(json, "conversations") ? void 0 : FlattenedConversationsFromJSON(json["conversations"]),
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"]),
    "summaries": !exists(json, "summaries") ? void 0 : FlattenedWorkstreamSummariesFromJSON(json["summaries"]),
    "messages": !exists(json, "messages") ? void 0 : FlattenedConversationMessagesFromJSON(json["messages"])
  };
}
function FlattenedWebsiteToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "assets": FlattenedAssetsToJSON(value.assets),
    "name": value.name,
    "url": value.url,
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "deleted": GroupedTimestampToJSON(value.deleted),
    "mechanisms": value.mechanisms === void 0 ? void 0 : mapValues(value.mechanisms, MechanismEnumToJSON),
    "interactions": value.interactions,
    "persons": FlattenedPersonsToJSON(value.persons),
    "conversations": FlattenedConversationsToJSON(value.conversations),
    "score": ScoreToJSON(value.score),
    "summaries": FlattenedWorkstreamSummariesToJSON(value.summaries),
    "messages": FlattenedConversationMessagesToJSON(value.messages)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ReferencedWebsite.ts
function ReferencedWebsiteFromJSON(json) {
  return ReferencedWebsiteFromJSONTyped(json, false);
}
function ReferencedWebsiteFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "reference": !exists(json, "reference") ? void 0 : FlattenedWebsiteFromJSON(json["reference"])
  };
}
function ReferencedWebsiteToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "reference": FlattenedWebsiteToJSON(value.reference)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedWebsites.ts
function FlattenedWebsitesFromJSON(json) {
  return FlattenedWebsitesFromJSONTyped3(json, false);
}
function FlattenedWebsitesFromJSONTyped3(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(ReferencedWebsiteFromJSON),
    "indices": !exists(json, "indices") ? void 0 : json["indices"],
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function FlattenedWebsitesToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(ReferencedWebsiteToJSON),
    "indices": value.indices,
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/PersonAccessScopedEnum.ts
function PersonAccessScopedEnumFromJSON(json) {
  return PersonAccessScopedEnumFromJSONTyped(json, false);
}
function PersonAccessScopedEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function PersonAccessScopedEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/PersonAccess.ts
function PersonAccessFromJSON(json) {
  return PersonAccessFromJSONTyped(json, false);
}
function PersonAccessFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "scoped": !exists(json, "scoped") ? void 0 : PersonAccessScopedEnumFromJSON(json["scoped"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"])
  };
}
function PersonAccessToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "scoped": PersonAccessScopedEnumToJSON(value.scoped),
    "deleted": GroupedTimestampToJSON(value.deleted)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/PersonModel.ts
function PersonModelFromJSON(json) {
  return PersonModelFromJSONTyped(json, false);
}
function PersonModelFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "asset": !exists(json, "asset") ? void 0 : ReferencedAssetFromJSON(json["asset"]),
    "model": !exists(json, "model") ? void 0 : ReferencedModelFromJSON(json["model"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"]),
    "explanation": !exists(json, "explanation") ? void 0 : ReferencedAnnotationFromJSON(json["explanation"])
  };
}
function PersonModelToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "asset": ReferencedAssetToJSON(value.asset),
    "model": ReferencedModelToJSON(value.model),
    "deleted": GroupedTimestampToJSON(value.deleted),
    "explanation": ReferencedAnnotationToJSON(value.explanation)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Font.ts
function FontFromJSON(json) {
  return FontFromJSONTyped(json, false);
}
function FontFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "size": json["size"]
  };
}
function FontToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "size": value.size
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Theme.ts
function ThemeFromJSON(json) {
  return ThemeFromJSONTyped(json, false);
}
function ThemeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "dark": json["dark"]
  };
}
function ThemeToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "dark": value.dark
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Aesthetics.ts
function AestheticsFromJSON(json) {
  return AestheticsFromJSONTyped(json, false);
}
function AestheticsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "theme": ThemeFromJSON(json["theme"]),
    "font": FontFromJSON(json["font"])
  };
}
function AestheticsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "theme": ThemeToJSON(value.theme),
    "font": FontToJSON(value.font)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/AllocationStatusEnum.ts
var AllocationStatusEnum = {
  Pending: "PENDING",
  Running: "RUNNING",
  Failed: "FAILED",
  Succeeded: "SUCCEEDED",
  Unknown: "UNKNOWN"
};
function AllocationStatusEnumFromJSON(json) {
  return AllocationStatusEnumFromJSONTyped(json, false);
}
function AllocationStatusEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function AllocationStatusEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/AllocationCloudStatus.ts
function AllocationCloudStatusFromJSON(json) {
  return AllocationCloudStatusFromJSONTyped(json, false);
}
function AllocationCloudStatusFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "cloud": AllocationStatusEnumFromJSON(json["cloud"])
  };
}
function AllocationCloudStatusToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "cloud": AllocationStatusEnumToJSON(value.cloud)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/AllocationCloudUrl.ts
function AllocationCloudUrlFromJSON(json) {
  return AllocationCloudUrlFromJSONTyped(json, false);
}
function AllocationCloudUrlFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "status": AllocationStatusEnumFromJSON(json["status"]),
    "url": json["url"]
  };
}
function AllocationCloudUrlToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "status": AllocationStatusEnumToJSON(value.status),
    "url": value.url
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/AllocationCloudUrls.ts
function AllocationCloudUrlsFromJSON(json) {
  return AllocationCloudUrlsFromJSONTyped(json, false);
}
function AllocationCloudUrlsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "base": AllocationCloudUrlFromJSON(json["base"]),
    "id": AllocationCloudUrlFromJSON(json["id"]),
    "vanity": !exists(json, "vanity") ? void 0 : AllocationCloudUrlFromJSON(json["vanity"])
  };
}
function AllocationCloudUrlsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "base": AllocationCloudUrlToJSON(value.base),
    "id": AllocationCloudUrlToJSON(value.id),
    "vanity": AllocationCloudUrlToJSON(value.vanity)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/AllocationCloud.ts
function AllocationCloudFromJSON(json) {
  return AllocationCloudFromJSONTyped(json, false);
}
function AllocationCloudFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "user": json["user"],
    "urls": AllocationCloudUrlsFromJSON(json["urls"]),
    "status": AllocationCloudStatusFromJSON(json["status"]),
    "project": json["project"],
    "updated": !exists(json, "updated") ? void 0 : GroupedTimestampFromJSON(json["updated"]),
    "version": !exists(json, "version") ? void 0 : json["version"],
    "region": !exists(json, "region") ? void 0 : json["region"]
  };
}
function AllocationCloudToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "user": value.user,
    "urls": AllocationCloudUrlsToJSON(value.urls),
    "status": AllocationCloudStatusToJSON(value.status),
    "project": value.project,
    "updated": GroupedTimestampToJSON(value.updated),
    "version": value.version,
    "region": value.region
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Auth0OpenAIUserMetadata.ts
function Auth0OpenAIUserMetadataFromJSON(json) {
  return Auth0OpenAIUserMetadataFromJSONTyped(json, false);
}
function Auth0OpenAIUserMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "apiKey": !exists(json, "api_key") ? void 0 : json["api_key"],
    "apiKeyName": !exists(json, "api_key_name") ? void 0 : json["api_key_name"],
    "organizationKey": !exists(json, "organization_key") ? void 0 : json["organization_key"]
  };
}
function Auth0OpenAIUserMetadataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "api_key": value.apiKey,
    "api_key_name": value.apiKeyName,
    "organization_key": value.organizationKey
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Auth0UserAllocationMetadata.ts
function Auth0UserAllocationMetadataFromJSON(json) {
  return Auth0UserAllocationMetadataFromJSONTyped(json, false);
}
function Auth0UserAllocationMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "project": json["project"],
    "region": json["region"]
  };
}
function Auth0UserAllocationMetadataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "project": value.project,
    "region": value.region
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Auth0UserMetadata.ts
function Auth0UserMetadataFromJSON(json) {
  return Auth0UserMetadataFromJSONTyped(json, false);
}
function Auth0UserMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "globalId": json["global_id"],
    "cloudKey": !exists(json, "cloud_key") ? void 0 : json["cloud_key"],
    "stripeCustomerId": !exists(json, "stripe_customer_id") ? void 0 : json["stripe_customer_id"],
    "vanityname": !exists(json, "vanityname") ? void 0 : json["vanityname"],
    "allocation": !exists(json, "allocation") ? void 0 : Auth0UserAllocationMetadataFromJSON(json["allocation"]),
    "openAI": !exists(json, "open_AI") ? void 0 : Auth0OpenAIUserMetadataFromJSON(json["open_AI"]),
    "beta": !exists(json, "beta") ? void 0 : AnonymousTemporalRangeFromJSON(json["beta"])
  };
}
function Auth0UserMetadataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "global_id": value.globalId,
    "cloud_key": value.cloudKey,
    "stripe_customer_id": value.stripeCustomerId,
    "vanityname": value.vanityname,
    "allocation": Auth0UserAllocationMetadataToJSON(value.allocation),
    "open_AI": Auth0OpenAIUserMetadataToJSON(value.openAI),
    "beta": AnonymousTemporalRangeToJSON(value.beta)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ExternalProviderProfileData.ts
function ExternalProviderProfileDataFromJSON(json) {
  return ExternalProviderProfileDataFromJSONTyped(json, false);
}
function ExternalProviderProfileDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "name": !exists(json, "name") ? void 0 : json["name"],
    "picture": !exists(json, "picture") ? void 0 : json["picture"],
    "nickname": !exists(json, "nickname") ? void 0 : json["nickname"],
    "email": !exists(json, "email") ? void 0 : json["email"],
    "emailVerified": !exists(json, "email_verified") ? void 0 : json["email_verified"],
    "nodeId": !exists(json, "node_id") ? void 0 : json["node_id"],
    "gravatarId": !exists(json, "gravatar_id") ? void 0 : json["gravatar_id"],
    "url": !exists(json, "url") ? void 0 : json["url"],
    "htmlUrl": !exists(json, "html_url") ? void 0 : json["html_url"],
    "followersUrl": !exists(json, "followers_url") ? void 0 : json["followers_url"],
    "followingUrl": !exists(json, "following_url") ? void 0 : json["following_url"],
    "gistsUrl": !exists(json, "gists_url") ? void 0 : json["gists_url"],
    "starredUrl": !exists(json, "starred_url") ? void 0 : json["starred_url"],
    "subscriptionsUrl": !exists(json, "subscriptions_url") ? void 0 : json["subscriptions_url"],
    "organizationsUrl": !exists(json, "organizations_url") ? void 0 : json["organizations_url"],
    "reposUrl": !exists(json, "repos_url") ? void 0 : json["repos_url"],
    "eventsUrl": !exists(json, "events_url") ? void 0 : json["events_url"],
    "receivedEventsUrl": !exists(json, "received_events_url") ? void 0 : json["received_events_url"],
    "type": !exists(json, "type") ? void 0 : json["type"],
    "siteAdmin": !exists(json, "site_admin") ? void 0 : json["site_admin"],
    "company": !exists(json, "company") ? void 0 : json["company"],
    "blog": !exists(json, "blog") ? void 0 : json["blog"],
    "anchor": !exists(json, "anchor") ? void 0 : json["anchor"],
    "hireable": !exists(json, "hireable") ? void 0 : json["hireable"],
    "bio": !exists(json, "bio") ? void 0 : json["bio"],
    "twitterUsername": !exists(json, "twitter_username") ? void 0 : json["twitter_username"],
    "publicRepos": !exists(json, "public_repos") ? void 0 : json["public_repos"],
    "publicGists": !exists(json, "public_gists") ? void 0 : json["public_gists"],
    "followers": !exists(json, "followers") ? void 0 : json["followers"],
    "following": !exists(json, "following") ? void 0 : json["following"],
    "createdAt": !exists(json, "created_at") ? void 0 : json["created_at"],
    "updatedAt": !exists(json, "updated_at") ? void 0 : json["updated_at"],
    "privateGists": !exists(json, "private_gists") ? void 0 : json["private_gists"],
    "totalPrivateRepos": !exists(json, "total_private_repos") ? void 0 : json["total_private_repos"],
    "ownedPrivateRepos": !exists(json, "owned_private_repos") ? void 0 : json["owned_private_repos"],
    "diskUsage": !exists(json, "disk_usage") ? void 0 : json["disk_usage"],
    "collaborators": !exists(json, "collaborators") ? void 0 : json["collaborators"],
    "twoFactorAuthentication": !exists(json, "two_factor_authentication") ? void 0 : json["two_factor_authentication"]
  };
}
function ExternalProviderProfileDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "name": value.name,
    "picture": value.picture,
    "nickname": value.nickname,
    "email": value.email,
    "email_verified": value.emailVerified,
    "node_id": value.nodeId,
    "gravatar_id": value.gravatarId,
    "url": value.url,
    "html_url": value.htmlUrl,
    "followers_url": value.followersUrl,
    "following_url": value.followingUrl,
    "gists_url": value.gistsUrl,
    "starred_url": value.starredUrl,
    "subscriptions_url": value.subscriptionsUrl,
    "organizations_url": value.organizationsUrl,
    "repos_url": value.reposUrl,
    "events_url": value.eventsUrl,
    "received_events_url": value.receivedEventsUrl,
    "type": value.type,
    "site_admin": value.siteAdmin,
    "company": value.company,
    "blog": value.blog,
    "anchor": value.anchor,
    "hireable": value.hireable,
    "bio": value.bio,
    "twitter_username": value.twitterUsername,
    "public_repos": value.publicRepos,
    "public_gists": value.publicGists,
    "followers": value.followers,
    "following": value.following,
    "created_at": value.createdAt,
    "updated_at": value.updatedAt,
    "private_gists": value.privateGists,
    "total_private_repos": value.totalPrivateRepos,
    "owned_private_repos": value.ownedPrivateRepos,
    "disk_usage": value.diskUsage,
    "collaborators": value.collaborators,
    "two_factor_authentication": value.twoFactorAuthentication
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ExternalProviderTypeEnum.ts
function ExternalProviderTypeEnumFromJSON(json) {
  return ExternalProviderTypeEnumFromJSONTyped(json, false);
}
function ExternalProviderTypeEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function ExternalProviderTypeEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/ExternalProvider.ts
function ExternalProviderFromJSON(json) {
  return ExternalProviderFromJSONTyped(json, false);
}
function ExternalProviderFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "type": ExternalProviderTypeEnumFromJSON(json["type"]),
    "userId": json["user_id"],
    "accessToken": !exists(json, "access_token") ? void 0 : json["access_token"],
    "expiresIn": !exists(json, "expires_in") ? void 0 : json["expires_in"],
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "profileData": !exists(json, "profileData") ? void 0 : ExternalProviderProfileDataFromJSON(json["profileData"]),
    "connection": !exists(json, "connection") ? void 0 : json["connection"],
    "isSocial": !exists(json, "isSocial") ? void 0 : json["isSocial"]
  };
}
function ExternalProviderToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "type": ExternalProviderTypeEnumToJSON(value.type),
    "user_id": value.userId,
    "access_token": value.accessToken,
    "expires_in": value.expiresIn,
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "profileData": ExternalProviderProfileDataToJSON(value.profileData),
    "connection": value.connection,
    "isSocial": value.isSocial
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ExternalProviders.ts
function ExternalProvidersFromJSON(json) {
  return ExternalProvidersFromJSONTyped(json, false);
}
function ExternalProvidersFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(ExternalProviderFromJSON)
  };
}
function ExternalProvidersToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(ExternalProviderToJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/UserProfile.ts
function UserProfileFromJSON(json) {
  return UserProfileFromJSONTyped(json, false);
}
function UserProfileFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "picture": !exists(json, "picture") ? void 0 : json["picture"],
    "email": !exists(json, "email") ? void 0 : json["email"],
    "created": !exists(json, "created") ? void 0 : GroupedTimestampFromJSON(json["created"]),
    "updated": !exists(json, "updated") ? void 0 : GroupedTimestampFromJSON(json["updated"]),
    "username": !exists(json, "username") ? void 0 : json["username"],
    "id": json["id"],
    "name": !exists(json, "name") ? void 0 : json["name"],
    "aesthetics": AestheticsFromJSON(json["aesthetics"]),
    "vanityname": !exists(json, "vanityname") ? void 0 : json["vanityname"],
    "allocation": !exists(json, "allocation") ? void 0 : AllocationCloudFromJSON(json["allocation"]),
    "providers": !exists(json, "providers") ? void 0 : ExternalProvidersFromJSON(json["providers"]),
    "auth0": !exists(json, "auth0") ? void 0 : Auth0UserMetadataFromJSON(json["auth0"])
  };
}
function UserProfileToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "picture": value.picture,
    "email": value.email,
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "username": value.username,
    "id": value.id,
    "name": value.name,
    "aesthetics": AestheticsToJSON(value.aesthetics),
    "vanityname": value.vanityname,
    "allocation": AllocationCloudToJSON(value.allocation),
    "providers": ExternalProvidersToJSON(value.providers),
    "auth0": Auth0UserMetadataToJSON(value.auth0)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/PersonType.ts
function PersonTypeFromJSON(json) {
  return PersonTypeFromJSONTyped(json, false);
}
function PersonTypeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "basic": !exists(json, "basic") ? void 0 : PersonBasicTypeFromJSON(json["basic"]),
    "platform": !exists(json, "platform") ? void 0 : UserProfileFromJSON(json["platform"])
  };
}
function PersonTypeToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "basic": PersonBasicTypeToJSON(value.basic),
    "platform": UserProfileToJSON(value.platform)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedPerson.ts
function FlattenedPersonFromJSON(json) {
  return FlattenedPersonFromJSONTyped(json, false);
}
function FlattenedPersonFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"]),
    "type": PersonTypeFromJSON(json["type"]),
    "assets": !exists(json, "assets") ? void 0 : FlattenedAssetsFromJSON(json["assets"]),
    "mechanisms": !exists(json, "mechanisms") ? void 0 : mapValues(json["mechanisms"], MechanismEnumFromJSON),
    "interactions": !exists(json, "interactions") ? void 0 : json["interactions"],
    "access": !exists(json, "access") ? void 0 : mapValues(json["access"], PersonAccessFromJSON),
    "tags": !exists(json, "tags") ? void 0 : FlattenedTagsFromJSON(json["tags"]),
    "websites": !exists(json, "websites") ? void 0 : FlattenedWebsitesFromJSON(json["websites"]),
    "models": !exists(json, "models") ? void 0 : mapValues(json["models"], PersonModelFromJSON),
    "annotations": !exists(json, "annotations") ? void 0 : FlattenedAnnotationsFromJSON(json["annotations"]),
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"]),
    "summaries": !exists(json, "summaries") ? void 0 : FlattenedWorkstreamSummariesFromJSON(json["summaries"]),
    "anchors": !exists(json, "anchors") ? void 0 : FlattenedAnchorsFromJSON(json["anchors"]),
    "messages": !exists(json, "messages") ? void 0 : FlattenedConversationMessagesFromJSON(json["messages"])
  };
}
function FlattenedPersonToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "deleted": GroupedTimestampToJSON(value.deleted),
    "type": PersonTypeToJSON(value.type),
    "assets": FlattenedAssetsToJSON(value.assets),
    "mechanisms": value.mechanisms === void 0 ? void 0 : mapValues(value.mechanisms, MechanismEnumToJSON),
    "interactions": value.interactions,
    "access": value.access === void 0 ? void 0 : mapValues(value.access, PersonAccessToJSON),
    "tags": FlattenedTagsToJSON(value.tags),
    "websites": FlattenedWebsitesToJSON(value.websites),
    "models": value.models === void 0 ? void 0 : mapValues(value.models, PersonModelToJSON),
    "annotations": FlattenedAnnotationsToJSON(value.annotations),
    "score": ScoreToJSON(value.score),
    "summaries": FlattenedWorkstreamSummariesToJSON(value.summaries),
    "anchors": FlattenedAnchorsToJSON(value.anchors),
    "messages": FlattenedConversationMessagesToJSON(value.messages)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ReferencedPerson.ts
function ReferencedPersonFromJSON(json) {
  return ReferencedPersonFromJSONTyped(json, false);
}
function ReferencedPersonFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "reference": !exists(json, "reference") ? void 0 : FlattenedPersonFromJSON(json["reference"])
  };
}
function ReferencedPersonToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "reference": FlattenedPersonToJSON(value.reference)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedPersons.ts
function FlattenedPersonsFromJSON(json) {
  return FlattenedPersonsFromJSONTyped5(json, false);
}
function FlattenedPersonsFromJSONTyped5(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(ReferencedPersonFromJSON),
    "indices": !exists(json, "indices") ? void 0 : json["indices"],
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function FlattenedPersonsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(ReferencedPersonToJSON),
    "indices": value.indices,
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTConversationMessageRoleEnum.ts
function QGPTConversationMessageRoleEnumFromJSON(json) {
  return QGPTConversationMessageRoleEnumFromJSONTyped(json, false);
}
function QGPTConversationMessageRoleEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function QGPTConversationMessageRoleEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedConversationMessage.ts
function FlattenedConversationMessageFromJSON(json) {
  return FlattenedConversationMessageFromJSONTyped(json, false);
}
function FlattenedConversationMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"]),
    "model": !exists(json, "model") ? void 0 : ModelFromJSON(json["model"]),
    "fragment": !exists(json, "fragment") ? void 0 : FragmentFormatFromJSON(json["fragment"]),
    "conversation": ReferencedConversationFromJSON(json["conversation"]),
    "sentiment": !exists(json, "sentiment") ? void 0 : ConversationMessageSentimentEnumFromJSON(json["sentiment"]),
    "role": QGPTConversationMessageRoleEnumFromJSON(json["role"]),
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"]),
    "annotations": !exists(json, "annotations") ? void 0 : FlattenedAnnotationsFromJSON(json["annotations"]),
    "anchors": !exists(json, "anchors") ? void 0 : FlattenedAnchorsFromJSON(json["anchors"]),
    "persons": !exists(json, "persons") ? void 0 : FlattenedPersonsFromJSON(json["persons"]),
    "websites": !exists(json, "websites") ? void 0 : FlattenedWebsitesFromJSON(json["websites"])
  };
}
function FlattenedConversationMessageToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "deleted": GroupedTimestampToJSON(value.deleted),
    "model": ModelToJSON(value.model),
    "fragment": FragmentFormatToJSON(value.fragment),
    "conversation": ReferencedConversationToJSON(value.conversation),
    "sentiment": ConversationMessageSentimentEnumToJSON(value.sentiment),
    "role": QGPTConversationMessageRoleEnumToJSON(value.role),
    "score": ScoreToJSON(value.score),
    "annotations": FlattenedAnnotationsToJSON(value.annotations),
    "anchors": FlattenedAnchorsToJSON(value.anchors),
    "persons": FlattenedPersonsToJSON(value.persons),
    "websites": FlattenedWebsitesToJSON(value.websites)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ReferencedConversationMessage.ts
function ReferencedConversationMessageFromJSON(json) {
  return ReferencedConversationMessageFromJSONTyped(json, false);
}
function ReferencedConversationMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "reference": !exists(json, "reference") ? void 0 : FlattenedConversationMessageFromJSON(json["reference"])
  };
}
function ReferencedConversationMessageToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "reference": FlattenedConversationMessageToJSON(value.reference)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedConversationMessages.ts
function FlattenedConversationMessagesFromJSON(json) {
  return FlattenedConversationMessagesFromJSONTyped6(json, false);
}
function FlattenedConversationMessagesFromJSONTyped6(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(ReferencedConversationMessageFromJSON),
    "indices": !exists(json, "indices") ? void 0 : json["indices"],
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function FlattenedConversationMessagesToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(ReferencedConversationMessageToJSON),
    "indices": value.indices,
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedAnnotation.ts
function FlattenedAnnotationFromJSON(json) {
  return FlattenedAnnotationFromJSONTyped(json, false);
}
function FlattenedAnnotationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"]),
    "mechanism": !exists(json, "mechanism") ? void 0 : MechanismEnumFromJSON(json["mechanism"]),
    "asset": !exists(json, "asset") ? void 0 : ReferencedAssetFromJSON(json["asset"]),
    "person": !exists(json, "person") ? void 0 : ReferencedPersonFromJSON(json["person"]),
    "type": AnnotationTypeEnumFromJSON(json["type"]),
    "text": json["text"],
    "model": !exists(json, "model") ? void 0 : ReferencedModelFromJSON(json["model"]),
    "pseudo": !exists(json, "pseudo") ? void 0 : json["pseudo"],
    "favorited": !exists(json, "favorited") ? void 0 : json["favorited"],
    "anchor": !exists(json, "anchor") ? void 0 : ReferencedAnchorFromJSON(json["anchor"]),
    "conversation": !exists(json, "conversation") ? void 0 : ReferencedConversationFromJSON(json["conversation"]),
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"]),
    "messages": !exists(json, "messages") ? void 0 : FlattenedConversationMessagesFromJSON(json["messages"]),
    "summary": !exists(json, "summary") ? void 0 : ReferencedWorkstreamSummaryFromJSON(json["summary"])
  };
}
function FlattenedAnnotationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "deleted": GroupedTimestampToJSON(value.deleted),
    "mechanism": MechanismEnumToJSON(value.mechanism),
    "asset": ReferencedAssetToJSON(value.asset),
    "person": ReferencedPersonToJSON(value.person),
    "type": AnnotationTypeEnumToJSON(value.type),
    "text": value.text,
    "model": ReferencedModelToJSON(value.model),
    "pseudo": value.pseudo,
    "favorited": value.favorited,
    "anchor": ReferencedAnchorToJSON(value.anchor),
    "conversation": ReferencedConversationToJSON(value.conversation),
    "score": ScoreToJSON(value.score),
    "messages": FlattenedConversationMessagesToJSON(value.messages),
    "summary": ReferencedWorkstreamSummaryToJSON(value.summary)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ReferencedAnnotation.ts
function ReferencedAnnotationFromJSON(json) {
  return ReferencedAnnotationFromJSONTyped2(json, false);
}
function ReferencedAnnotationFromJSONTyped2(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "reference": !exists(json, "reference") ? void 0 : FlattenedAnnotationFromJSON(json["reference"])
  };
}
function ReferencedAnnotationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "reference": FlattenedAnnotationToJSON(value.reference)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedAnnotations.ts
function FlattenedAnnotationsFromJSON(json) {
  return FlattenedAnnotationsFromJSONTyped5(json, false);
}
function FlattenedAnnotationsFromJSONTyped5(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(ReferencedAnnotationFromJSON),
    "indices": !exists(json, "indices") ? void 0 : json["indices"],
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function FlattenedAnnotationsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(ReferencedAnnotationToJSON),
    "indices": value.indices,
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedAnchor.ts
function FlattenedAnchorFromJSON(json) {
  return FlattenedAnchorFromJSONTyped(json, false);
}
function FlattenedAnchorFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "type": AnchorTypeEnumFromJSON(json["type"]),
    "watch": !exists(json, "watch") ? void 0 : json["watch"],
    "points": FlattenedAnchorPointsFromJSON(json["points"]),
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"]),
    "assets": !exists(json, "assets") ? void 0 : FlattenedAssetsFromJSON(json["assets"]),
    "name": !exists(json, "name") ? void 0 : json["name"],
    "annotations": !exists(json, "annotations") ? void 0 : FlattenedAnnotationsFromJSON(json["annotations"]),
    "conversations": !exists(json, "conversations") ? void 0 : FlattenedConversationsFromJSON(json["conversations"]),
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"]),
    "summaries": !exists(json, "summaries") ? void 0 : FlattenedWorkstreamSummariesFromJSON(json["summaries"]),
    "persons": !exists(json, "persons") ? void 0 : FlattenedPersonsFromJSON(json["persons"]),
    "messages": !exists(json, "messages") ? void 0 : FlattenedConversationMessagesFromJSON(json["messages"])
  };
}
function FlattenedAnchorToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "type": AnchorTypeEnumToJSON(value.type),
    "watch": value.watch,
    "points": FlattenedAnchorPointsToJSON(value.points),
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "deleted": GroupedTimestampToJSON(value.deleted),
    "assets": FlattenedAssetsToJSON(value.assets),
    "name": value.name,
    "annotations": FlattenedAnnotationsToJSON(value.annotations),
    "conversations": FlattenedConversationsToJSON(value.conversations),
    "score": ScoreToJSON(value.score),
    "summaries": FlattenedWorkstreamSummariesToJSON(value.summaries),
    "persons": FlattenedPersonsToJSON(value.persons),
    "messages": FlattenedConversationMessagesToJSON(value.messages)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ReferencedAnchor.ts
function ReferencedAnchorFromJSON(json) {
  return ReferencedAnchorFromJSONTyped4(json, false);
}
function ReferencedAnchorFromJSONTyped4(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "reference": !exists(json, "reference") ? void 0 : FlattenedAnchorFromJSON(json["reference"])
  };
}
function ReferencedAnchorToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "reference": FlattenedAnchorToJSON(value.reference)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/HintTypeEnum.ts
function HintTypeEnumFromJSON(json) {
  return HintTypeEnumFromJSONTyped(json, false);
}
function HintTypeEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function HintTypeEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedHint.ts
function FlattenedHintFromJSON(json) {
  return FlattenedHintFromJSONTyped(json, false);
}
function FlattenedHintFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"]),
    "mechanisms": !exists(json, "mechanisms") ? void 0 : mapValues(json["mechanisms"], MechanismEnumFromJSON),
    "assets": !exists(json, "assets") ? void 0 : FlattenedAssetsFromJSON(json["assets"]),
    "type": HintTypeEnumFromJSON(json["type"]),
    "text": json["text"],
    "model": !exists(json, "model") ? void 0 : ReferencedModelFromJSON(json["model"]),
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function FlattenedHintToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "deleted": GroupedTimestampToJSON(value.deleted),
    "mechanisms": value.mechanisms === void 0 ? void 0 : mapValues(value.mechanisms, MechanismEnumToJSON),
    "assets": FlattenedAssetsToJSON(value.assets),
    "type": HintTypeEnumToJSON(value.type),
    "text": value.text,
    "model": ReferencedModelToJSON(value.model),
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ReferencedHint.ts
function ReferencedHintFromJSON(json) {
  return ReferencedHintFromJSONTyped(json, false);
}
function ReferencedHintFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "reference": !exists(json, "reference") ? void 0 : FlattenedHintFromJSON(json["reference"])
  };
}
function ReferencedHintToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "reference": FlattenedHintToJSON(value.reference)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SensitiveCategoryEnum.ts
function SensitiveCategoryEnumFromJSON(json) {
  return SensitiveCategoryEnumFromJSONTyped(json, false);
}
function SensitiveCategoryEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function SensitiveCategoryEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/TextLocation.ts
function TextLocationFromJSON(json) {
  return TextLocationFromJSONTyped(json, false);
}
function TextLocationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "text": json["text"],
    "start": json["start"],
    "end": json["end"]
  };
}
function TextLocationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "text": value.text,
    "start": value.start,
    "end": value.end
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TextMatch.ts
function TextMatchFromJSON(json) {
  return TextMatchFromJSONTyped(json, false);
}
function TextMatchFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "group": TextLocationFromJSON(json["group"]),
    "subgroup": !exists(json, "subgroup") ? void 0 : TextLocationFromJSON(json["subgroup"])
  };
}
function TextMatchToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "group": TextLocationToJSON(value.group),
    "subgroup": TextLocationToJSON(value.subgroup)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SensitiveMetadata.ts
function SensitiveMetadataFromJSON(json) {
  return SensitiveMetadataFromJSONTyped(json, false);
}
function SensitiveMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "match": !exists(json, "match") ? void 0 : TextMatchFromJSON(json["match"]),
    "entropy": !exists(json, "entropy") ? void 0 : json["entropy"]
  };
}
function SensitiveMetadataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "match": TextMatchToJSON(value.match),
    "entropy": value.entropy
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SensitiveSeverityEnum.ts
function SensitiveSeverityEnumFromJSON(json) {
  return SensitiveSeverityEnumFromJSONTyped(json, false);
}
function SensitiveSeverityEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function SensitiveSeverityEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedSensitive.ts
function FlattenedSensitiveFromJSON(json) {
  return FlattenedSensitiveFromJSONTyped(json, false);
}
function FlattenedSensitiveFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"]),
    "asset": ReferencedAssetFromJSON(json["asset"]),
    "text": json["text"],
    "mechanism": MechanismEnumFromJSON(json["mechanism"]),
    "category": SensitiveCategoryEnumFromJSON(json["category"]),
    "severity": SensitiveSeverityEnumFromJSON(json["severity"]),
    "name": json["name"],
    "description": json["description"],
    "metadata": !exists(json, "metadata") ? void 0 : SensitiveMetadataFromJSON(json["metadata"]),
    "interactions": !exists(json, "interactions") ? void 0 : json["interactions"],
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function FlattenedSensitiveToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "deleted": GroupedTimestampToJSON(value.deleted),
    "asset": ReferencedAssetToJSON(value.asset),
    "text": value.text,
    "mechanism": MechanismEnumToJSON(value.mechanism),
    "category": SensitiveCategoryEnumToJSON(value.category),
    "severity": SensitiveSeverityEnumToJSON(value.severity),
    "name": value.name,
    "description": value.description,
    "metadata": SensitiveMetadataToJSON(value.metadata),
    "interactions": value.interactions,
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ReferencedSensitive.ts
function ReferencedSensitiveFromJSON(json) {
  return ReferencedSensitiveFromJSONTyped(json, false);
}
function ReferencedSensitiveFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "reference": !exists(json, "reference") ? void 0 : FlattenedSensitiveFromJSON(json["reference"])
  };
}
function ReferencedSensitiveToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "reference": FlattenedSensitiveToJSON(value.reference)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Recipients.ts
function RecipientsFromJSON(json) {
  return RecipientsFromJSONTyped(json, false);
}
function RecipientsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "iterable": json["iterable"].map(PersonBasicTypeFromJSON),
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"])
  };
}
function RecipientsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "iterable": value.iterable.map(PersonBasicTypeToJSON),
    "schema": EmbeddedModelSchemaToJSON(value.schema)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/GitHubGistDistribution.ts
function GitHubGistDistributionFromJSON(json) {
  return GitHubGistDistributionFromJSONTyped(json, false);
}
function GitHubGistDistributionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "recipients": RecipientsFromJSON(json["recipients"]),
    "_public": json["public"],
    "description": !exists(json, "description") ? void 0 : json["description"],
    "name": json["name"],
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"]),
    "githubId": json["github_id"],
    "url": json["url"]
  };
}
function GitHubGistDistributionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "recipients": RecipientsToJSON(value.recipients),
    "public": value._public,
    "description": value.description,
    "name": value.name,
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "deleted": GroupedTimestampToJSON(value.deleted),
    "github_id": value.githubId,
    "url": value.url
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/GitHubDistribution.ts
function GitHubDistributionFromJSON(json) {
  return GitHubDistributionFromJSONTyped(json, false);
}
function GitHubDistributionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "gist": !exists(json, "gist") ? void 0 : GitHubGistDistributionFromJSON(json["gist"])
  };
}
function GitHubDistributionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "gist": GitHubGistDistributionToJSON(value.gist)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/MailgunDistribution.ts
function MailgunDistributionFromJSON(json) {
  return MailgunDistributionFromJSONTyped(json, false);
}
function MailgunDistributionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "recipients": RecipientsFromJSON(json["recipients"])
  };
}
function MailgunDistributionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "recipients": RecipientsToJSON(value.recipients)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedDistribution.ts
function FlattenedDistributionFromJSON(json) {
  return FlattenedDistributionFromJSONTyped(json, false);
}
function FlattenedDistributionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "share": json["share"],
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"]),
    "mailgun": !exists(json, "mailgun") ? void 0 : MailgunDistributionFromJSON(json["mailgun"]),
    "github": !exists(json, "github") ? void 0 : GitHubDistributionFromJSON(json["github"])
  };
}
function FlattenedDistributionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "share": value.share,
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "deleted": GroupedTimestampToJSON(value.deleted),
    "mailgun": MailgunDistributionToJSON(value.mailgun),
    "github": GitHubDistributionToJSON(value.github)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ReferencedDistribution.ts
function ReferencedDistributionFromJSON(json) {
  return ReferencedDistributionFromJSONTyped(json, false);
}
function ReferencedDistributionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "reference": !exists(json, "reference") ? void 0 : FlattenedDistributionFromJSON(json["reference"])
  };
}
function ReferencedDistributionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "reference": FlattenedDistributionToJSON(value.reference)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedDistributions.ts
function FlattenedDistributionsFromJSON(json) {
  return FlattenedDistributionsFromJSONTyped(json, false);
}
function FlattenedDistributionsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(ReferencedDistributionFromJSON)
  };
}
function FlattenedDistributionsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(ReferencedDistributionToJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedShare.ts
function FlattenedShareFromJSON(json) {
  return FlattenedShareFromJSONTyped(json, false);
}
function FlattenedShareFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "asset": !exists(json, "asset") ? void 0 : json["asset"],
    "user": !exists(json, "user") ? void 0 : json["user"],
    "link": json["link"],
    "access": AccessEnumFromJSON(json["access"]),
    "accessors": AccessorsFromJSON(json["accessors"]),
    "created": GroupedTimestampFromJSON(json["created"]),
    "_short": json["short"],
    "name": !exists(json, "name") ? void 0 : json["name"],
    "assets": !exists(json, "assets") ? void 0 : FlattenedAssetsFromJSON(json["assets"]),
    "distributions": !exists(json, "distributions") ? void 0 : FlattenedDistributionsFromJSON(json["distributions"]),
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function FlattenedShareToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "asset": value.asset,
    "user": value.user,
    "link": value.link,
    "access": AccessEnumToJSON(value.access),
    "accessors": AccessorsToJSON(value.accessors),
    "created": GroupedTimestampToJSON(value.created),
    "short": value._short,
    "name": value.name,
    "assets": FlattenedAssetsToJSON(value.assets),
    "distributions": FlattenedDistributionsToJSON(value.distributions),
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ReferencedShare.ts
function ReferencedShareFromJSON(json) {
  return ReferencedShareFromJSONTyped(json, false);
}
function ReferencedShareFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "reference": !exists(json, "reference") ? void 0 : FlattenedShareFromJSON(json["reference"])
  };
}
function ReferencedShareToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "reference": FlattenedShareToJSON(value.reference)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TrackedAssetEventCreationMetadataClipboard.ts
function TrackedAssetEventCreationMetadataClipboardFromJSON(json) {
  return TrackedAssetEventCreationMetadataClipboardFromJSONTyped(json, false);
}
function TrackedAssetEventCreationMetadataClipboardFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "keyboard": !exists(json, "keyboard") ? void 0 : json["keyboard"],
    "interaction": !exists(json, "interaction") ? void 0 : json["interaction"]
  };
}
function TrackedAssetEventCreationMetadataClipboardToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "keyboard": value.keyboard,
    "interaction": value.interaction
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TrackedAssetEventCreationMetadataFile.ts
function TrackedAssetEventCreationMetadataFileFromJSON(json) {
  return TrackedAssetEventCreationMetadataFileFromJSONTyped(json, false);
}
function TrackedAssetEventCreationMetadataFileFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "keyboard": !exists(json, "keyboard") ? void 0 : json["keyboard"],
    "dragAndDrop": !exists(json, "drag_and_drop") ? void 0 : json["drag_and_drop"],
    "interaction": !exists(json, "interaction") ? void 0 : json["interaction"]
  };
}
function TrackedAssetEventCreationMetadataFileToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "keyboard": value.keyboard,
    "drag_and_drop": value.dragAndDrop,
    "interaction": value.interaction
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TrackedAssetEventCreationMetadata.ts
function TrackedAssetEventCreationMetadataFromJSON(json) {
  return TrackedAssetEventCreationMetadataFromJSONTyped(json, false);
}
function TrackedAssetEventCreationMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "clipboard": !exists(json, "clipboard") ? void 0 : TrackedAssetEventCreationMetadataClipboardFromJSON(json["clipboard"]),
    "file": !exists(json, "file") ? void 0 : TrackedAssetEventCreationMetadataFileFromJSON(json["file"])
  };
}
function TrackedAssetEventCreationMetadataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "clipboard": TrackedAssetEventCreationMetadataClipboardToJSON(value.clipboard),
    "file": TrackedAssetEventCreationMetadataFileToJSON(value.file)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TrackedAssetEventFormatReclassificationMetadata.ts
function TrackedAssetEventFormatReclassificationMetadataFromJSON(json) {
  return TrackedAssetEventFormatReclassificationMetadataFromJSONTyped(json, false);
}
function TrackedAssetEventFormatReclassificationMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "previous": !exists(json, "previous") ? void 0 : ClassificationFromJSON(json["previous"]),
    "current": !exists(json, "current") ? void 0 : ClassificationFromJSON(json["current"])
  };
}
function TrackedAssetEventFormatReclassificationMetadataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "previous": ClassificationToJSON(value.previous),
    "current": ClassificationToJSON(value.current)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TrackedAssetEventRenameMetadata.ts
function TrackedAssetEventRenameMetadataFromJSON(json) {
  return TrackedAssetEventRenameMetadataFromJSONTyped(json, false);
}
function TrackedAssetEventRenameMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "previous": json["previous"],
    "current": json["current"]
  };
}
function TrackedAssetEventRenameMetadataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "previous": value.previous,
    "current": value.current
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Space.ts
function SpaceFromJSON(json) {
  return SpaceFromJSONTyped(json, false);
}
function SpaceFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "size": !exists(json, "size") ? void 0 : json["size"],
    "duration": !exists(json, "duration") ? void 0 : json["duration"]
  };
}
function SpaceToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "size": value.size,
    "duration": value.duration
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TrackedAssetsEventSearchMetadataResults.ts
function TrackedAssetsEventSearchMetadataResultsFromJSON(json) {
  return TrackedAssetsEventSearchMetadataResultsFromJSONTyped(json, false);
}
function TrackedAssetsEventSearchMetadataResultsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "fuzzy": !exists(json, "fuzzy") ? void 0 : json["fuzzy"],
    "exact": !exists(json, "exact") ? void 0 : json["exact"],
    "assets": !exists(json, "assets") ? void 0 : FlattenedAssetsFromJSON(json["assets"]),
    "space": !exists(json, "space") ? void 0 : SpaceFromJSON(json["space"])
  };
}
function TrackedAssetsEventSearchMetadataResultsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "fuzzy": value.fuzzy,
    "exact": value.exact,
    "assets": FlattenedAssetsToJSON(value.assets),
    "space": SpaceToJSON(value.space)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TrackedAssetsEventSearchMetadata.ts
function TrackedAssetsEventSearchMetadataFromJSON(json) {
  return TrackedAssetsEventSearchMetadataFromJSONTyped(json, false);
}
function TrackedAssetsEventSearchMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "query": !exists(json, "query") ? void 0 : json["query"],
    "results": !exists(json, "results") ? void 0 : TrackedAssetsEventSearchMetadataResultsFromJSON(json["results"])
  };
}
function TrackedAssetsEventSearchMetadataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "query": value.query,
    "results": TrackedAssetsEventSearchMetadataResultsToJSON(value.results)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TrackedAssetEventMetadata.ts
function TrackedAssetEventMetadataFromJSON(json) {
  return TrackedAssetEventMetadataFromJSONTyped(json, false);
}
function TrackedAssetEventMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "reclassification": !exists(json, "reclassification") ? void 0 : TrackedAssetEventFormatReclassificationMetadataFromJSON(json["reclassification"]),
    "creation": !exists(json, "creation") ? void 0 : TrackedAssetEventCreationMetadataFromJSON(json["creation"]),
    "rename": !exists(json, "rename") ? void 0 : TrackedAssetEventRenameMetadataFromJSON(json["rename"]),
    "tag": !exists(json, "tag") ? void 0 : ReferencedTagFromJSON(json["tag"]),
    "website": !exists(json, "website") ? void 0 : ReferencedWebsiteFromJSON(json["website"]),
    "person": !exists(json, "person") ? void 0 : ReferencedPersonFromJSON(json["person"]),
    "sensitive": !exists(json, "sensitive") ? void 0 : ReferencedSensitiveFromJSON(json["sensitive"]),
    "share": !exists(json, "share") ? void 0 : ReferencedShareFromJSON(json["share"]),
    "search": !exists(json, "search") ? void 0 : TrackedAssetsEventSearchMetadataFromJSON(json["search"]),
    "annotation": !exists(json, "annotation") ? void 0 : ReferencedAnnotationFromJSON(json["annotation"]),
    "hint": !exists(json, "hint") ? void 0 : ReferencedHintFromJSON(json["hint"]),
    "anchor": !exists(json, "anchor") ? void 0 : ReferencedAnchorFromJSON(json["anchor"])
  };
}
function TrackedAssetEventMetadataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "reclassification": TrackedAssetEventFormatReclassificationMetadataToJSON(value.reclassification),
    "creation": TrackedAssetEventCreationMetadataToJSON(value.creation),
    "rename": TrackedAssetEventRenameMetadataToJSON(value.rename),
    "tag": ReferencedTagToJSON(value.tag),
    "website": ReferencedWebsiteToJSON(value.website),
    "person": ReferencedPersonToJSON(value.person),
    "sensitive": ReferencedSensitiveToJSON(value.sensitive),
    "share": ReferencedShareToJSON(value.share),
    "search": TrackedAssetsEventSearchMetadataToJSON(value.search),
    "annotation": ReferencedAnnotationToJSON(value.annotation),
    "hint": ReferencedHintToJSON(value.hint),
    "anchor": ReferencedAnchorToJSON(value.anchor)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededTrackedAssetEvent.ts
function SeededTrackedAssetEventFromJSON(json) {
  return SeededTrackedAssetEventFromJSONTyped(json, false);
}
function SeededTrackedAssetEventFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "asset": ReferencedAssetFromJSON(json["asset"]),
    "identifierDescriptionPair": TrackedAssetEventIdentifierDescriptionPairsFromJSON(json["identifier_description_pair"]),
    "metadata": !exists(json, "metadata") ? void 0 : TrackedAssetEventMetadataFromJSON(json["metadata"])
  };
}
function SeededTrackedAssetEventToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "asset": ReferencedAssetToJSON(value.asset),
    "identifier_description_pair": TrackedAssetEventIdentifierDescriptionPairsToJSON(value.identifierDescriptionPair),
    "metadata": TrackedAssetEventMetadataToJSON(value.metadata)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededTrackedAssetsEventMetadata.ts
function SeededTrackedAssetsEventMetadataFromJSON(json) {
  return SeededTrackedAssetsEventMetadataFromJSONTyped(json, false);
}
function SeededTrackedAssetsEventMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "search": !exists(json, "search") ? void 0 : TrackedAssetsEventSearchMetadataFromJSON(json["search"])
  };
}
function SeededTrackedAssetsEventMetadataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "search": TrackedAssetsEventSearchMetadataToJSON(value.search)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TrackedAssetsEventIdentifierDescriptionPairs.ts
function TrackedAssetsEventIdentifierDescriptionPairsFromJSON(json) {
  return TrackedAssetsEventIdentifierDescriptionPairsFromJSONTyped(json, false);
}
function TrackedAssetsEventIdentifierDescriptionPairsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "assetsSearched": !exists(json, "assets_searched") ? void 0 : json["assets_searched"]
  };
}
function TrackedAssetsEventIdentifierDescriptionPairsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "assets_searched": value.assetsSearched
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededTrackedAssetsEvent.ts
function SeededTrackedAssetsEventFromJSON(json) {
  return SeededTrackedAssetsEventFromJSONTyped(json, false);
}
function SeededTrackedAssetsEventFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "identifierDescriptionPair": !exists(json, "identifier_description_pair") ? void 0 : TrackedAssetsEventIdentifierDescriptionPairsFromJSON(json["identifier_description_pair"]),
    "metadata": !exists(json, "metadata") ? void 0 : SeededTrackedAssetsEventMetadataFromJSON(json["metadata"])
  };
}
function SeededTrackedAssetsEventToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "identifier_description_pair": TrackedAssetsEventIdentifierDescriptionPairsToJSON(value.identifierDescriptionPair),
    "metadata": SeededTrackedAssetsEventMetadataToJSON(value.metadata)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TrackedConversationEventIdentifierDescriptionPairs.ts
function TrackedConversationEventIdentifierDescriptionPairsFromJSON(json) {
  return TrackedConversationEventIdentifierDescriptionPairsFromJSONTyped(json, false);
}
function TrackedConversationEventIdentifierDescriptionPairsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "conversationCreated": !exists(json, "conversation_created") ? void 0 : json["conversation_created"],
    "conversationReferenced": !exists(json, "conversation_referenced") ? void 0 : json["conversation_referenced"],
    "conversationDeleted": !exists(json, "conversation_deleted") ? void 0 : json["conversation_deleted"],
    "conversationSummaryAnnotationGeneratedByTheUser": !exists(json, "conversation_summary_annotation_generated_by_the_user") ? void 0 : json["conversation_summary_annotation_generated_by_the_user"],
    "conversationNameUpdatedByTheSystem": !exists(json, "conversation_name_updated_by_the_system") ? void 0 : json["conversation_name_updated_by_the_system"],
    "conversationNameUpdatedByTheUser": !exists(json, "conversation_name_updated_by_the_user") ? void 0 : json["conversation_name_updated_by_the_user"],
    "conversationSummaryAnnotationGeneratedByTheSystem": !exists(json, "conversation_summary_annotation_generated_by_the_system") ? void 0 : json["conversation_summary_annotation_generated_by_the_system"]
  };
}
function TrackedConversationEventIdentifierDescriptionPairsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "conversation_created": value.conversationCreated,
    "conversation_referenced": value.conversationReferenced,
    "conversation_deleted": value.conversationDeleted,
    "conversation_summary_annotation_generated_by_the_user": value.conversationSummaryAnnotationGeneratedByTheUser,
    "conversation_name_updated_by_the_system": value.conversationNameUpdatedByTheSystem,
    "conversation_name_updated_by_the_user": value.conversationNameUpdatedByTheUser,
    "conversation_summary_annotation_generated_by_the_system": value.conversationSummaryAnnotationGeneratedByTheSystem
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TrackedConversationEventRenameMetadata.ts
function TrackedConversationEventRenameMetadataFromJSON(json) {
  return TrackedConversationEventRenameMetadataFromJSONTyped(json, false);
}
function TrackedConversationEventRenameMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "previous": json["previous"],
    "current": json["current"]
  };
}
function TrackedConversationEventRenameMetadataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "previous": value.previous,
    "current": value.current
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TrackedConversationEventMetadata.ts
function TrackedConversationEventMetadataFromJSON(json) {
  return TrackedConversationEventMetadataFromJSONTyped(json, false);
}
function TrackedConversationEventMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "rename": !exists(json, "rename") ? void 0 : TrackedConversationEventRenameMetadataFromJSON(json["rename"])
  };
}
function TrackedConversationEventMetadataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "rename": TrackedConversationEventRenameMetadataToJSON(value.rename)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededTrackedConversationEvent.ts
function SeededTrackedConversationEventFromJSON(json) {
  return SeededTrackedConversationEventFromJSONTyped(json, false);
}
function SeededTrackedConversationEventFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "identifierDescriptionPair": TrackedConversationEventIdentifierDescriptionPairsFromJSON(json["identifier_description_pair"]),
    "conversation": ReferencedConversationFromJSON(json["conversation"]),
    "metadata": !exists(json, "metadata") ? void 0 : TrackedConversationEventMetadataFromJSON(json["metadata"])
  };
}
function SeededTrackedConversationEventToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "identifier_description_pair": TrackedConversationEventIdentifierDescriptionPairsToJSON(value.identifierDescriptionPair),
    "conversation": ReferencedConversationToJSON(value.conversation),
    "metadata": TrackedConversationEventMetadataToJSON(value.metadata)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TrackedFormatEventIdentifierDescriptionPairs.ts
function TrackedFormatEventIdentifierDescriptionPairsFromJSON(json) {
  return TrackedFormatEventIdentifierDescriptionPairsFromJSONTyped(json, false);
}
function TrackedFormatEventIdentifierDescriptionPairsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "formatCreated": !exists(json, "format_created") ? void 0 : json["format_created"],
    "formatCopied": !exists(json, "format_copied") ? void 0 : json["format_copied"],
    "formatPartiallyCopied": !exists(json, "format_partially_copied") ? void 0 : json["format_partially_copied"],
    "formatDownloaded": !exists(json, "format_downloaded") ? void 0 : json["format_downloaded"],
    "formatDeleted": !exists(json, "format_deleted") ? void 0 : json["format_deleted"],
    "formatGenericClassificationUpdated": !exists(json, "format_generic_classification_updated") ? void 0 : json["format_generic_classification_updated"],
    "formatSpecificClassificationUpdated": !exists(json, "format_specific_classification_updated") ? void 0 : json["format_specific_classification_updated"],
    "formatUpdated": !exists(json, "format_updated") ? void 0 : json["format_updated"],
    "formatInserted": !exists(json, "format_inserted") ? void 0 : json["format_inserted"],
    "formatValueEdited": !exists(json, "format_value_edited") ? void 0 : json["format_value_edited"]
  };
}
function TrackedFormatEventIdentifierDescriptionPairsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "format_created": value.formatCreated,
    "format_copied": value.formatCopied,
    "format_partially_copied": value.formatPartiallyCopied,
    "format_downloaded": value.formatDownloaded,
    "format_deleted": value.formatDeleted,
    "format_generic_classification_updated": value.formatGenericClassificationUpdated,
    "format_specific_classification_updated": value.formatSpecificClassificationUpdated,
    "format_updated": value.formatUpdated,
    "format_inserted": value.formatInserted,
    "format_value_edited": value.formatValueEdited
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TrackedFormatEventMetadata.ts
function TrackedFormatEventMetadataFromJSON(json) {
  return TrackedFormatEventMetadataFromJSONTyped(json, false);
}
function TrackedFormatEventMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "reclassification": !exists(json, "reclassification") ? void 0 : TrackedAssetEventFormatReclassificationMetadataFromJSON(json["reclassification"])
  };
}
function TrackedFormatEventMetadataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "reclassification": TrackedAssetEventFormatReclassificationMetadataToJSON(value.reclassification)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededTrackedFormatEvent.ts
function SeededTrackedFormatEventFromJSON(json) {
  return SeededTrackedFormatEventFromJSONTyped(json, false);
}
function SeededTrackedFormatEventFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "identifierDescriptionPair": TrackedFormatEventIdentifierDescriptionPairsFromJSON(json["identifier_description_pair"]),
    "format": ReferencedFormatFromJSON(json["format"]),
    "metadata": !exists(json, "metadata") ? void 0 : TrackedFormatEventMetadataFromJSON(json["metadata"])
  };
}
function SeededTrackedFormatEventToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "identifier_description_pair": TrackedFormatEventIdentifierDescriptionPairsToJSON(value.identifierDescriptionPair),
    "format": ReferencedFormatToJSON(value.format),
    "metadata": TrackedFormatEventMetadataToJSON(value.metadata)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededTrackedInteractionEventIdentifierDescriptionPairs.ts
function SeededTrackedInteractionEventIdentifierDescriptionPairsFromJSON(json) {
  return SeededTrackedInteractionEventIdentifierDescriptionPairsFromJSONTyped(json, false);
}
function SeededTrackedInteractionEventIdentifierDescriptionPairsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "assetsListRefreshed": !exists(json, "assets_list_refreshed") ? void 0 : json["assets_list_refreshed"]
  };
}
function SeededTrackedInteractionEventIdentifierDescriptionPairsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "assets_list_refreshed": value.assetsListRefreshed
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededTrackedInteractionEvent.ts
function SeededTrackedInteractionEventFromJSON(json) {
  return SeededTrackedInteractionEventFromJSONTyped(json, false);
}
function SeededTrackedInteractionEventFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "description": json["description"],
    "element": !exists(json, "element") ? void 0 : json["element"],
    "identifierDescriptionPair": !exists(json, "identifier_description_pair") ? void 0 : SeededTrackedInteractionEventIdentifierDescriptionPairsFromJSON(json["identifier_description_pair"])
  };
}
function SeededTrackedInteractionEventToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "description": value.description,
    "element": value.element,
    "identifier_description_pair": SeededTrackedInteractionEventIdentifierDescriptionPairsToJSON(value.identifierDescriptionPair)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededTrackedKeyboardEventIdentifierDescriptionPairs.ts
function SeededTrackedKeyboardEventIdentifierDescriptionPairsFromJSON(json) {
  return SeededTrackedKeyboardEventIdentifierDescriptionPairsFromJSONTyped(json, false);
}
function SeededTrackedKeyboardEventIdentifierDescriptionPairsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "assetsListRefreshed": !exists(json, "assets_list_refreshed") ? void 0 : json["assets_list_refreshed"]
  };
}
function SeededTrackedKeyboardEventIdentifierDescriptionPairsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "assets_list_refreshed": value.assetsListRefreshed
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededTrackedKeyboardEvent.ts
function SeededTrackedKeyboardEventFromJSON(json) {
  return SeededTrackedKeyboardEventFromJSONTyped(json, false);
}
function SeededTrackedKeyboardEventFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "description": json["description"],
    "shortcut": json["shortcut"],
    "identifierDescriptionPair": !exists(json, "identifier_description_pair") ? void 0 : SeededTrackedKeyboardEventIdentifierDescriptionPairsFromJSON(json["identifier_description_pair"])
  };
}
function SeededTrackedKeyboardEventToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "description": value.description,
    "shortcut": value.shortcut,
    "identifier_description_pair": SeededTrackedKeyboardEventIdentifierDescriptionPairsToJSON(value.identifierDescriptionPair)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/GraphicalImageDescriptiveStatistics.ts
function GraphicalImageDescriptiveStatisticsFromJSON(json) {
  return GraphicalImageDescriptiveStatisticsFromJSONTyped(json, false);
}
function GraphicalImageDescriptiveStatisticsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "width": json["width"],
    "height": json["height"],
    "channels": json["channels"],
    "asset": json["asset"],
    "user": !exists(json, "user") ? void 0 : json["user"],
    "created": json["created"],
    "os": json["os"]
  };
}
function GraphicalImageDescriptiveStatisticsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "width": value.width,
    "height": value.height,
    "channels": value.channels,
    "asset": value.asset,
    "user": value.user,
    "created": value.created,
    "os": value.os
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/GraphicalImageStatistics.ts
function GraphicalImageStatisticsFromJSON(json) {
  return GraphicalImageStatisticsFromJSONTyped(json, false);
}
function GraphicalImageStatisticsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "descriptive": !exists(json, "descriptive") ? void 0 : GraphicalImageDescriptiveStatisticsFromJSON(json["descriptive"])
  };
}
function GraphicalImageStatisticsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "descriptive": GraphicalImageDescriptiveStatisticsToJSON(value.descriptive)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/GraphicalImageProcessing.ts
function GraphicalImageProcessingFromJSON(json) {
  return GraphicalImageProcessingFromJSONTyped(json, false);
}
function GraphicalImageProcessingFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "statistics": !exists(json, "statistics") ? void 0 : GraphicalImageStatisticsFromJSON(json["statistics"])
  };
}
function GraphicalImageProcessingToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "statistics": GraphicalImageStatisticsToJSON(value.statistics)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/GraphicalOCRDescriptiveStatisticsConfidence.ts
function GraphicalOCRDescriptiveStatisticsConfidenceFromJSON(json) {
  return GraphicalOCRDescriptiveStatisticsConfidenceFromJSONTyped(json, false);
}
function GraphicalOCRDescriptiveStatisticsConfidenceFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "mean": json["mean"]
  };
}
function GraphicalOCRDescriptiveStatisticsConfidenceToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "mean": value.mean
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/GraphicalOCRDescriptiveStatistics.ts
function GraphicalOCRDescriptiveStatisticsFromJSON(json) {
  return GraphicalOCRDescriptiveStatisticsFromJSONTyped(json, false);
}
function GraphicalOCRDescriptiveStatisticsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "asset": json["asset"],
    "user": json["user"],
    "model": json["model"],
    "created": json["created"],
    "os": json["os"],
    "confidence": GraphicalOCRDescriptiveStatisticsConfidenceFromJSON(json["confidence"]),
    "duration": json["duration"]
  };
}
function GraphicalOCRDescriptiveStatisticsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "asset": value.asset,
    "user": value.user,
    "model": value.model,
    "created": value.created,
    "os": value.os,
    "confidence": GraphicalOCRDescriptiveStatisticsConfidenceToJSON(value.confidence),
    "duration": value.duration
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/GraphicalOCRStatistics.ts
function GraphicalOCRStatisticsFromJSON(json) {
  return GraphicalOCRStatisticsFromJSONTyped(json, false);
}
function GraphicalOCRStatisticsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "descriptive": !exists(json, "descriptive") ? void 0 : GraphicalOCRDescriptiveStatisticsFromJSON(json["descriptive"])
  };
}
function GraphicalOCRStatisticsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "descriptive": GraphicalOCRDescriptiveStatisticsToJSON(value.descriptive)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/GraphicalOCRProcessing.ts
function GraphicalOCRProcessingFromJSON(json) {
  return GraphicalOCRProcessingFromJSONTyped(json, false);
}
function GraphicalOCRProcessingFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "statistics": !exists(json, "statistics") ? void 0 : GraphicalOCRStatisticsFromJSON(json["statistics"])
  };
}
function GraphicalOCRProcessingToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "statistics": GraphicalOCRStatisticsToJSON(value.statistics)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/GraphicalSVGStatistics.ts
function GraphicalSVGStatisticsFromJSON(json) {
  return GraphicalSVGStatisticsFromJSONTyped(json, false);
}
function GraphicalSVGStatisticsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": !exists(json, "id") ? void 0 : json["id"]
  };
}
function GraphicalSVGStatisticsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/GraphicalMachineLearningProcessingEvent.ts
function GraphicalMachineLearningProcessingEventFromJSON(json) {
  return GraphicalMachineLearningProcessingEventFromJSONTyped(json, false);
}
function GraphicalMachineLearningProcessingEventFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "ocr": !exists(json, "ocr") ? void 0 : GraphicalOCRProcessingFromJSON(json["ocr"]),
    "image": !exists(json, "image") ? void 0 : GraphicalImageProcessingFromJSON(json["image"]),
    "svg": !exists(json, "svg") ? void 0 : GraphicalSVGStatisticsFromJSON(json["svg"])
  };
}
function GraphicalMachineLearningProcessingEventToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "ocr": GraphicalOCRProcessingToJSON(value.ocr),
    "image": GraphicalImageProcessingToJSON(value.image),
    "svg": GraphicalSVGStatisticsToJSON(value.svg)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TLPCodeDirectoryAnalytics.ts
function TLPCodeDirectoryAnalyticsFromJSON(json) {
  return TLPCodeDirectoryAnalyticsFromJSONTyped(json, false);
}
function TLPCodeDirectoryAnalyticsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": !exists(json, "id") ? void 0 : json["id"]
  };
}
function TLPCodeDirectoryAnalyticsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TLPCodeFileAnalytics.ts
function TLPCodeFileAnalyticsFromJSON(json) {
  return TLPCodeFileAnalyticsFromJSONTyped(json, false);
}
function TLPCodeFileAnalyticsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": !exists(json, "id") ? void 0 : json["id"]
  };
}
function TLPCodeFileAnalyticsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TLPCodeRepositoryAnalytics.ts
function TLPCodeRepositoryAnalyticsFromJSON(json) {
  return TLPCodeRepositoryAnalyticsFromJSONTyped(json, false);
}
function TLPCodeRepositoryAnalyticsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": !exists(json, "id") ? void 0 : json["id"]
  };
}
function TLPCodeRepositoryAnalyticsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SystemExecutionCpuInformation.ts
function SystemExecutionCpuInformationFromJSON(json) {
  return SystemExecutionCpuInformationFromJSONTyped(json, false);
}
function SystemExecutionCpuInformationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "count": json["count"],
    "brand": json["brand"],
    "frequency": json["frequency"]
  };
}
function SystemExecutionCpuInformationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "count": value.count,
    "brand": value.brand,
    "frequency": value.frequency
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SystemExecutionInformation.ts
function SystemExecutionInformationFromJSON(json) {
  return SystemExecutionInformationFromJSONTyped(json, false);
}
function SystemExecutionInformationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "memory": json["memory"],
    "os": json["os"],
    "kernel": json["kernel"],
    "cpu": SystemExecutionCpuInformationFromJSON(json["cpu"])
  };
}
function SystemExecutionInformationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "memory": value.memory,
    "os": value.os,
    "kernel": value.kernel,
    "cpu": SystemExecutionCpuInformationToJSON(value.cpu)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TLPCodeFragmentClassificationMetadata.ts
function TLPCodeFragmentClassificationMetadataFromJSON(json) {
  return TLPCodeFragmentClassificationMetadataFromJSONTyped(json, false);
}
function TLPCodeFragmentClassificationMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "context": !exists(json, "context") ? void 0 : ClassificationFromJSON(json["context"]),
    "prior": !exists(json, "prior") ? void 0 : ClassificationFromJSON(json["prior"])
  };
}
function TLPCodeFragmentClassificationMetadataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "context": ClassificationToJSON(value.context),
    "prior": ClassificationToJSON(value.prior)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TLPCodeFragmentClassification.ts
function TLPCodeFragmentClassificationFromJSON(json) {
  return TLPCodeFragmentClassificationFromJSONTyped(json, false);
}
function TLPCodeFragmentClassificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "asset": json["asset"],
    "model": json["model"],
    "created": json["created"],
    "classification": json["classification"],
    "probability": json["probability"],
    "context": json["context"],
    "distribution": !exists(json, "distribution") ? void 0 : json["distribution"],
    "metadata": !exists(json, "metadata") ? void 0 : TLPCodeFragmentClassificationMetadataFromJSON(json["metadata"]),
    "user": json["user"],
    "latency": !exists(json, "latency") ? void 0 : json["latency"],
    "system": !exists(json, "system") ? void 0 : SystemExecutionInformationFromJSON(json["system"])
  };
}
function TLPCodeFragmentClassificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "asset": value.asset,
    "model": value.model,
    "created": value.created,
    "classification": value.classification,
    "probability": value.probability,
    "context": value.context,
    "distribution": value.distribution,
    "metadata": TLPCodeFragmentClassificationMetadataToJSON(value.metadata),
    "user": value.user,
    "latency": value.latency,
    "system": SystemExecutionInformationToJSON(value.system)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TLPCodeFragmentDescription.ts
function TLPCodeFragmentDescriptionFromJSON(json) {
  return TLPCodeFragmentDescriptionFromJSONTyped(json, false);
}
function TLPCodeFragmentDescriptionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "description": !exists(json, "description") ? void 0 : json["description"],
    "asset": json["asset"],
    "created": json["created"],
    "model": json["model"],
    "latency": !exists(json, "latency") ? void 0 : json["latency"],
    "user": json["user"],
    "context": !exists(json, "context") ? void 0 : json["context"],
    "os": !exists(json, "os") ? void 0 : json["os"]
  };
}
function TLPCodeFragmentDescriptionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "description": value.description,
    "asset": value.asset,
    "created": value.created,
    "model": value.model,
    "latency": value.latency,
    "user": value.user,
    "context": value.context,
    "os": value.os
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TLPCodeFragmentReclassificationUpdates.ts
function TLPCodeFragmentReclassificationUpdatesFromJSON(json) {
  return TLPCodeFragmentReclassificationUpdatesFromJSONTyped(json, false);
}
function TLPCodeFragmentReclassificationUpdatesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "previous": ClassificationFromJSON(json["previous"]),
    "current": ClassificationFromJSON(json["current"])
  };
}
function TLPCodeFragmentReclassificationUpdatesToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "previous": ClassificationToJSON(value.previous),
    "current": ClassificationToJSON(value.current)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TLPCodeFragmentReclassification.ts
function TLPCodeFragmentReclassificationFromJSON(json) {
  return TLPCodeFragmentReclassificationFromJSONTyped(json, false);
}
function TLPCodeFragmentReclassificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "asset": json["asset"],
    "model": json["model"],
    "created": json["created"],
    "updates": TLPCodeFragmentReclassificationUpdatesFromJSON(json["updates"]),
    "user": json["user"],
    "context": json["context"]
  };
}
function TLPCodeFragmentReclassificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "asset": value.asset,
    "model": value.model,
    "created": value.created,
    "updates": TLPCodeFragmentReclassificationUpdatesToJSON(value.updates),
    "user": value.user,
    "context": value.context
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TLPCodeFragmentDescriptiveStatistics.ts
function TLPCodeFragmentDescriptiveStatisticsFromJSON(json) {
  return TLPCodeFragmentDescriptiveStatisticsFromJSONTyped(json, false);
}
function TLPCodeFragmentDescriptiveStatisticsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "user": json["user"],
    "os": json["os"],
    "language": json["language"],
    "length": json["length"],
    "ast": json["ast"],
    "timestamp": json["timestamp"],
    "asset": json["asset"],
    "context": json["context"],
    "snippet": json["snippet"]
  };
}
function TLPCodeFragmentDescriptiveStatisticsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "user": value.user,
    "os": value.os,
    "language": value.language,
    "length": value.length,
    "ast": value.ast,
    "timestamp": value.timestamp,
    "asset": value.asset,
    "context": value.context,
    "snippet": value.snippet
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TLPCodeFragmentStatistics.ts
function TLPCodeFragmentStatisticsFromJSON(json) {
  return TLPCodeFragmentStatisticsFromJSONTyped(json, false);
}
function TLPCodeFragmentStatisticsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "descriptive": !exists(json, "descriptive") ? void 0 : TLPCodeFragmentDescriptiveStatisticsFromJSON(json["descriptive"])
  };
}
function TLPCodeFragmentStatisticsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "descriptive": TLPCodeFragmentDescriptiveStatisticsToJSON(value.descriptive)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TLPCodeSnippetTagifyCode.ts
function TLPCodeSnippetTagifyCodeFromJSON(json) {
  return TLPCodeSnippetTagifyCodeFromJSONTyped(json, false);
}
function TLPCodeSnippetTagifyCodeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "distribution": json["distribution"],
    "inferredDistribution": json["inferred_distribution"],
    "tags": json["tags"],
    "inferredTags": json["inferred_tags"],
    "model": json["model"],
    "labelVersion": json["label_version"],
    "threshold": json["threshold"],
    "inferredThreshold": json["inferred_threshold"],
    "context": json["context"],
    "asset": json["asset"]
  };
}
function TLPCodeSnippetTagifyCodeToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "distribution": value.distribution,
    "inferred_distribution": value.inferredDistribution,
    "tags": value.tags,
    "inferred_tags": value.inferredTags,
    "model": value.model,
    "label_version": value.labelVersion,
    "threshold": value.threshold,
    "inferred_threshold": value.inferredThreshold,
    "context": value.context,
    "asset": value.asset
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TLPCodeFragmentTagify.ts
function TLPCodeFragmentTagifyFromJSON(json) {
  return TLPCodeFragmentTagifyFromJSONTyped(json, false);
}
function TLPCodeFragmentTagifyFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "code": !exists(json, "code") ? void 0 : TLPCodeSnippetTagifyCodeFromJSON(json["code"])
  };
}
function TLPCodeFragmentTagifyToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "code": TLPCodeSnippetTagifyCodeToJSON(value.code)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TLPCodeFragmentSuggestedReuse.ts
function TLPCodeFragmentSuggestedReuseFromJSON(json) {
  return TLPCodeFragmentSuggestedReuseFromJSONTyped(json, false);
}
function TLPCodeFragmentSuggestedReuseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": !exists(json, "id") ? void 0 : json["id"]
  };
}
function TLPCodeFragmentSuggestedReuseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TLPCodeFragmentSuggestedSave.ts
function TLPCodeFragmentSuggestedSaveFromJSON(json) {
  return TLPCodeFragmentSuggestedSaveFromJSONTyped(json, false);
}
function TLPCodeFragmentSuggestedSaveFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "asset": json["asset"],
    "user": json["user"],
    "model": json["model"],
    "created": json["created"],
    "os": json["os"],
    "context": !exists(json, "context") ? void 0 : json["context"],
    "score": !exists(json, "score") ? void 0 : json["score"],
    "candidates": !exists(json, "candidates") ? void 0 : json["candidates"]
  };
}
function TLPCodeFragmentSuggestedSaveToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "asset": value.asset,
    "user": value.user,
    "model": value.model,
    "created": value.created,
    "os": value.os,
    "context": value.context,
    "score": value.score,
    "candidates": value.candidates
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TLPCodeSnippetSuggestedInteractions.ts
function TLPCodeSnippetSuggestedInteractionsFromJSON(json) {
  return TLPCodeSnippetSuggestedInteractionsFromJSONTyped(json, false);
}
function TLPCodeSnippetSuggestedInteractionsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "save": !exists(json, "save") ? void 0 : TLPCodeFragmentSuggestedSaveFromJSON(json["save"]),
    "reuse": !exists(json, "reuse") ? void 0 : TLPCodeFragmentSuggestedReuseFromJSON(json["reuse"])
  };
}
function TLPCodeSnippetSuggestedInteractionsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "save": TLPCodeFragmentSuggestedSaveToJSON(value.save),
    "reuse": TLPCodeFragmentSuggestedReuseToJSON(value.reuse)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TLPCodeSnippetAnalytics.ts
function TLPCodeSnippetAnalyticsFromJSON(json) {
  return TLPCodeSnippetAnalyticsFromJSONTyped(json, false);
}
function TLPCodeSnippetAnalyticsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "statistics": !exists(json, "statistics") ? void 0 : TLPCodeFragmentStatisticsFromJSON(json["statistics"]),
    "classification": !exists(json, "classification") ? void 0 : TLPCodeFragmentClassificationFromJSON(json["classification"]),
    "reclassification": !exists(json, "reclassification") ? void 0 : TLPCodeFragmentReclassificationFromJSON(json["reclassification"]),
    "suggested": !exists(json, "suggested") ? void 0 : TLPCodeSnippetSuggestedInteractionsFromJSON(json["suggested"]),
    "tagify": !exists(json, "tagify") ? void 0 : TLPCodeFragmentTagifyFromJSON(json["tagify"]),
    "description": !exists(json, "description") ? void 0 : TLPCodeFragmentDescriptionFromJSON(json["description"])
  };
}
function TLPCodeSnippetAnalyticsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "statistics": TLPCodeFragmentStatisticsToJSON(value.statistics),
    "classification": TLPCodeFragmentClassificationToJSON(value.classification),
    "reclassification": TLPCodeFragmentReclassificationToJSON(value.reclassification),
    "suggested": TLPCodeSnippetSuggestedInteractionsToJSON(value.suggested),
    "tagify": TLPCodeFragmentTagifyToJSON(value.tagify),
    "description": TLPCodeFragmentDescriptionToJSON(value.description)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TLPCodeProcessing.ts
function TLPCodeProcessingFromJSON(json) {
  return TLPCodeProcessingFromJSONTyped(json, false);
}
function TLPCodeProcessingFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "fragment": !exists(json, "fragment") ? void 0 : TLPCodeSnippetAnalyticsFromJSON(json["fragment"]),
    "file": !exists(json, "file") ? void 0 : TLPCodeFileAnalyticsFromJSON(json["file"]),
    "directory": !exists(json, "directory") ? void 0 : TLPCodeDirectoryAnalyticsFromJSON(json["directory"]),
    "repository": !exists(json, "repository") ? void 0 : TLPCodeRepositoryAnalyticsFromJSON(json["repository"])
  };
}
function TLPCodeProcessingToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "fragment": TLPCodeSnippetAnalyticsToJSON(value.fragment),
    "file": TLPCodeFileAnalyticsToJSON(value.file),
    "directory": TLPCodeDirectoryAnalyticsToJSON(value.directory),
    "repository": TLPCodeRepositoryAnalyticsToJSON(value.repository)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TLPMachineLearningProcessingEvent.ts
function TLPMachineLearningProcessingEventFromJSON(json) {
  return TLPMachineLearningProcessingEventFromJSONTyped(json, false);
}
function TLPMachineLearningProcessingEventFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "code": !exists(json, "code") ? void 0 : TLPCodeProcessingFromJSON(json["code"])
  };
}
function TLPMachineLearningProcessingEventToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "code": TLPCodeProcessingToJSON(value.code)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededTrackedMachineLearningEvent.ts
function SeededTrackedMachineLearningEventFromJSON(json) {
  return SeededTrackedMachineLearningEventFromJSONTyped(json, false);
}
function SeededTrackedMachineLearningEventFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "tlp": !exists(json, "tlp") ? void 0 : TLPMachineLearningProcessingEventFromJSON(json["tlp"]),
    "graphical": !exists(json, "graphical") ? void 0 : GraphicalMachineLearningProcessingEventFromJSON(json["graphical"])
  };
}
function SeededTrackedMachineLearningEventToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "tlp": TLPMachineLearningProcessingEventToJSON(value.tlp),
    "graphical": GraphicalMachineLearningProcessingEventToJSON(value.graphical)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TrackedSessionEventIdentifierDescriptionPairs.ts
function TrackedSessionEventIdentifierDescriptionPairsFromJSON(json) {
  return TrackedSessionEventIdentifierDescriptionPairsFromJSONTyped(json, false);
}
function TrackedSessionEventIdentifierDescriptionPairsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "sessionInitialized": !exists(json, "session_initialized") ? void 0 : json["session_initialized"],
    "sessionLocalConnectionSucceeded": !exists(json, "session_local_connection_succeeded") ? void 0 : json["session_local_connection_succeeded"],
    "sessionLocalConnectionFailed": !exists(json, "session_local_connection_failed") ? void 0 : json["session_local_connection_failed"],
    "sessionInactive": !exists(json, "session_inactive") ? void 0 : json["session_inactive"],
    "sessionActive": !exists(json, "session_active") ? void 0 : json["session_active"],
    "sessionTerminated": !exists(json, "session_terminated") ? void 0 : json["session_terminated"],
    "sessionAuthenticatedWithSignIn": !exists(json, "session_authenticated_with_sign_in") ? void 0 : json["session_authenticated_with_sign_in"],
    "sessionUnauthenticatedWithSignOut": !exists(json, "session_unauthenticated_with_sign_out") ? void 0 : json["session_unauthenticated_with_sign_out"],
    "sessionUnauthenticatedWithDismiss": !exists(json, "session_unauthenticated_with_dismiss") ? void 0 : json["session_unauthenticated_with_dismiss"],
    "sessionUnauthenticatedWithRemind": !exists(json, "session_unauthenticated_with_remind") ? void 0 : json["session_unauthenticated_with_remind"],
    "sessionOnboardingInitialized": !exists(json, "session_onboarding_initialized") ? void 0 : json["session_onboarding_initialized"],
    "sessionOnboardingCompleted": !exists(json, "session_onboarding_completed") ? void 0 : json["session_onboarding_completed"]
  };
}
function TrackedSessionEventIdentifierDescriptionPairsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "session_initialized": value.sessionInitialized,
    "session_local_connection_succeeded": value.sessionLocalConnectionSucceeded,
    "session_local_connection_failed": value.sessionLocalConnectionFailed,
    "session_inactive": value.sessionInactive,
    "session_active": value.sessionActive,
    "session_terminated": value.sessionTerminated,
    "session_authenticated_with_sign_in": value.sessionAuthenticatedWithSignIn,
    "session_unauthenticated_with_sign_out": value.sessionUnauthenticatedWithSignOut,
    "session_unauthenticated_with_dismiss": value.sessionUnauthenticatedWithDismiss,
    "session_unauthenticated_with_remind": value.sessionUnauthenticatedWithRemind,
    "session_onboarding_initialized": value.sessionOnboardingInitialized,
    "session_onboarding_completed": value.sessionOnboardingCompleted
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededTrackedSessionEvent.ts
function SeededTrackedSessionEventFromJSON(json) {
  return SeededTrackedSessionEventFromJSONTyped(json, false);
}
function SeededTrackedSessionEventFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "identifierDescriptionPair": TrackedSessionEventIdentifierDescriptionPairsFromJSON(json["identifier_description_pair"])
  };
}
function SeededTrackedSessionEventToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "identifier_description_pair": TrackedSessionEventIdentifierDescriptionPairsToJSON(value.identifierDescriptionPair)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededConnectorTracking.ts
function SeededConnectorTrackingFromJSON(json) {
  return SeededConnectorTrackingFromJSONTyped(json, false);
}
function SeededConnectorTrackingFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "format": !exists(json, "format") ? void 0 : SeededTrackedFormatEventFromJSON(json["format"]),
    "asset": !exists(json, "asset") ? void 0 : SeededTrackedAssetEventFromJSON(json["asset"]),
    "interaction": !exists(json, "interaction") ? void 0 : SeededTrackedInteractionEventFromJSON(json["interaction"]),
    "keyboard": !exists(json, "keyboard") ? void 0 : SeededTrackedKeyboardEventFromJSON(json["keyboard"]),
    "session": !exists(json, "session") ? void 0 : SeededTrackedSessionEventFromJSON(json["session"]),
    "assets": !exists(json, "assets") ? void 0 : SeededTrackedAssetsEventFromJSON(json["assets"]),
    "ml": !exists(json, "ml") ? void 0 : SeededTrackedMachineLearningEventFromJSON(json["ml"]),
    "adoption": !exists(json, "adoption") ? void 0 : SeededTrackedAdoptionEventFromJSON(json["adoption"]),
    "conversation": !exists(json, "conversation") ? void 0 : SeededTrackedConversationEventFromJSON(json["conversation"])
  };
}
function SeededConnectorTrackingToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "format": SeededTrackedFormatEventToJSON(value.format),
    "asset": SeededTrackedAssetEventToJSON(value.asset),
    "interaction": SeededTrackedInteractionEventToJSON(value.interaction),
    "keyboard": SeededTrackedKeyboardEventToJSON(value.keyboard),
    "session": SeededTrackedSessionEventToJSON(value.session),
    "assets": SeededTrackedAssetsEventToJSON(value.assets),
    "ml": SeededTrackedMachineLearningEventToJSON(value.ml),
    "adoption": SeededTrackedAdoptionEventToJSON(value.adoption),
    "conversation": SeededTrackedConversationEventToJSON(value.conversation)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedActivity.ts
function FlattenedActivityFromJSON(json) {
  return FlattenedActivityFromJSONTyped(json, false);
}
function FlattenedActivityFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "event": SeededConnectorTrackingFromJSON(json["event"]),
    "application": ApplicationFromJSON(json["application"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"]),
    "asset": !exists(json, "asset") ? void 0 : ReferencedAssetFromJSON(json["asset"]),
    "format": !exists(json, "format") ? void 0 : ReferencedFormatFromJSON(json["format"]),
    "user": !exists(json, "user") ? void 0 : FlattenedUserProfileFromJSON(json["user"]),
    "mechanism": MechanismEnumFromJSON(json["mechanism"]),
    "rank": !exists(json, "rank") ? void 0 : json["rank"]
  };
}
function FlattenedActivityToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "event": SeededConnectorTrackingToJSON(value.event),
    "application": ApplicationToJSON(value.application),
    "deleted": GroupedTimestampToJSON(value.deleted),
    "asset": ReferencedAssetToJSON(value.asset),
    "format": ReferencedFormatToJSON(value.format),
    "user": FlattenedUserProfileToJSON(value.user),
    "mechanism": MechanismEnumToJSON(value.mechanism),
    "rank": value.rank
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ReferencedActivity.ts
function ReferencedActivityFromJSON(json) {
  return ReferencedActivityFromJSONTyped(json, false);
}
function ReferencedActivityFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "reference": !exists(json, "reference") ? void 0 : FlattenedActivityFromJSON(json["reference"])
  };
}
function ReferencedActivityToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "reference": FlattenedActivityToJSON(value.reference)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedActivities.ts
function FlattenedActivitiesFromJSON(json) {
  return FlattenedActivitiesFromJSONTyped2(json, false);
}
function FlattenedActivitiesFromJSONTyped2(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(ReferencedActivityFromJSON)
  };
}
function FlattenedActivitiesToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(ReferencedActivityToJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedFormats.ts
function FlattenedFormatsFromJSON(json) {
  return FlattenedFormatsFromJSONTyped(json, false);
}
function FlattenedFormatsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(ReferencedFormatFromJSON)
  };
}
function FlattenedFormatsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(ReferencedFormatToJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedHints.ts
function FlattenedHintsFromJSON(json) {
  return FlattenedHintsFromJSONTyped(json, false);
}
function FlattenedHintsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(ReferencedHintFromJSON),
    "indices": !exists(json, "indices") ? void 0 : json["indices"],
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function FlattenedHintsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(ReferencedHintToJSON),
    "indices": value.indices,
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedPreview.ts
function FlattenedPreviewFromJSON(json) {
  return FlattenedPreviewFromJSONTyped(json, false);
}
function FlattenedPreviewFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "base": json["base"],
    "overlay": !exists(json, "overlay") ? void 0 : json["overlay"]
  };
}
function FlattenedPreviewToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "base": value.base,
    "overlay": value.overlay
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedSensitives.ts
function FlattenedSensitivesFromJSON(json) {
  return FlattenedSensitivesFromJSONTyped(json, false);
}
function FlattenedSensitivesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(ReferencedSensitiveFromJSON),
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function FlattenedSensitivesToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(ReferencedSensitiveToJSON),
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedShares.ts
function FlattenedSharesFromJSON(json) {
  return FlattenedSharesFromJSONTyped(json, false);
}
function FlattenedSharesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(FlattenedShareFromJSON),
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function FlattenedSharesToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(FlattenedShareToJSON),
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedAsset.ts
function FlattenedAssetFromJSON(json) {
  return FlattenedAssetFromJSONTyped2(json, false);
}
function FlattenedAssetFromJSONTyped2(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "name": !exists(json, "name") ? void 0 : json["name"],
    "creator": json["creator"],
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "synced": !exists(json, "synced") ? void 0 : GroupedTimestampFromJSON(json["synced"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"]),
    "formats": FlattenedFormatsFromJSON(json["formats"]),
    "preview": FlattenedPreviewFromJSON(json["preview"]),
    "original": json["original"],
    "shares": !exists(json, "shares") ? void 0 : FlattenedSharesFromJSON(json["shares"]),
    "mechanism": MechanismEnumFromJSON(json["mechanism"]),
    "websites": !exists(json, "websites") ? void 0 : FlattenedWebsitesFromJSON(json["websites"]),
    "interacted": !exists(json, "interacted") ? void 0 : GroupedTimestampFromJSON(json["interacted"]),
    "tags": !exists(json, "tags") ? void 0 : FlattenedTagsFromJSON(json["tags"]),
    "sensitives": !exists(json, "sensitives") ? void 0 : FlattenedSensitivesFromJSON(json["sensitives"]),
    "persons": !exists(json, "persons") ? void 0 : FlattenedPersonsFromJSON(json["persons"]),
    "curated": !exists(json, "curated") ? void 0 : json["curated"],
    "discovered": !exists(json, "discovered") ? void 0 : json["discovered"],
    "activities": !exists(json, "activities") ? void 0 : FlattenedActivitiesFromJSON(json["activities"]),
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"]),
    "favorited": !exists(json, "favorited") ? void 0 : json["favorited"],
    "pseudo": !exists(json, "pseudo") ? void 0 : json["pseudo"],
    "annotations": !exists(json, "annotations") ? void 0 : FlattenedAnnotationsFromJSON(json["annotations"]),
    "hints": !exists(json, "hints") ? void 0 : FlattenedHintsFromJSON(json["hints"]),
    "anchors": !exists(json, "anchors") ? void 0 : FlattenedAnchorsFromJSON(json["anchors"]),
    "conversations": !exists(json, "conversations") ? void 0 : FlattenedConversationsFromJSON(json["conversations"]),
    "demo": !exists(json, "demo") ? void 0 : json["demo"],
    "summaries": !exists(json, "summaries") ? void 0 : FlattenedWorkstreamSummariesFromJSON(json["summaries"])
  };
}
function FlattenedAssetToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "name": value.name,
    "creator": value.creator,
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "synced": GroupedTimestampToJSON(value.synced),
    "deleted": GroupedTimestampToJSON(value.deleted),
    "formats": FlattenedFormatsToJSON(value.formats),
    "preview": FlattenedPreviewToJSON(value.preview),
    "original": value.original,
    "shares": FlattenedSharesToJSON(value.shares),
    "mechanism": MechanismEnumToJSON(value.mechanism),
    "websites": FlattenedWebsitesToJSON(value.websites),
    "interacted": GroupedTimestampToJSON(value.interacted),
    "tags": FlattenedTagsToJSON(value.tags),
    "sensitives": FlattenedSensitivesToJSON(value.sensitives),
    "persons": FlattenedPersonsToJSON(value.persons),
    "curated": value.curated,
    "discovered": value.discovered,
    "activities": FlattenedActivitiesToJSON(value.activities),
    "score": ScoreToJSON(value.score),
    "favorited": value.favorited,
    "pseudo": value.pseudo,
    "annotations": FlattenedAnnotationsToJSON(value.annotations),
    "hints": FlattenedHintsToJSON(value.hints),
    "anchors": FlattenedAnchorsToJSON(value.anchors),
    "conversations": FlattenedConversationsToJSON(value.conversations),
    "demo": value.demo,
    "summaries": FlattenedWorkstreamSummariesToJSON(value.summaries)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Activity.ts
function ActivityFromJSON(json) {
  return ActivityFromJSONTyped(json, false);
}
function ActivityFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "event": SeededConnectorTrackingFromJSON(json["event"]),
    "application": ApplicationFromJSON(json["application"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"]),
    "asset": !exists(json, "asset") ? void 0 : FlattenedAssetFromJSON(json["asset"]),
    "user": !exists(json, "user") ? void 0 : FlattenedUserProfileFromJSON(json["user"]),
    "format": !exists(json, "format") ? void 0 : FlattenedFormatFromJSON(json["format"]),
    "mechanism": MechanismEnumFromJSON(json["mechanism"]),
    "rank": !exists(json, "rank") ? void 0 : json["rank"]
  };
}
function ActivityToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "event": SeededConnectorTrackingToJSON(value.event),
    "application": ApplicationToJSON(value.application),
    "deleted": GroupedTimestampToJSON(value.deleted),
    "asset": FlattenedAssetToJSON(value.asset),
    "user": FlattenedUserProfileToJSON(value.user),
    "format": FlattenedFormatToJSON(value.format),
    "mechanism": MechanismEnumToJSON(value.mechanism),
    "rank": value.rank
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Activities.ts
function ActivitiesFromJSON(json) {
  return ActivitiesFromJSONTyped(json, false);
}
function ActivitiesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(ActivityFromJSON)
  };
}
function ActivitiesToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(ActivityToJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Allocations.ts
function AllocationsFromJSON(json) {
  return AllocationsFromJSONTyped(json, false);
}
function AllocationsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(AllocationCloudFromJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Format.ts
function FormatFromJSON(json) {
  return FormatFromJSONTyped(json, false);
}
function FormatFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "creator": json["creator"],
    "classification": ClassificationFromJSON(json["classification"]),
    "icon": !exists(json, "icon") ? void 0 : json["icon"],
    "role": RoleFromJSON(json["role"]),
    "application": ApplicationFromJSON(json["application"]),
    "asset": FlattenedAssetFromJSON(json["asset"]),
    "bytes": ByteDescriptorFromJSON(json["bytes"]),
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"]),
    "synced": !exists(json, "synced") ? void 0 : GroupedTimestampFromJSON(json["synced"]),
    "cloud": !exists(json, "cloud") ? void 0 : json["cloud"],
    "fragment": !exists(json, "fragment") ? void 0 : FragmentFormatFromJSON(json["fragment"]),
    "file": !exists(json, "file") ? void 0 : FileFormatFromJSON(json["file"]),
    "analysis": !exists(json, "analysis") ? void 0 : AnalysisFromJSON(json["analysis"]),
    "relationship": !exists(json, "relationship") ? void 0 : RelationshipFromJSON(json["relationship"]),
    "activities": !exists(json, "activities") ? void 0 : ActivitiesFromJSON(json["activities"])
  };
}
function FormatToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "creator": value.creator,
    "classification": ClassificationToJSON(value.classification),
    "icon": value.icon,
    "role": RoleToJSON(value.role),
    "application": ApplicationToJSON(value.application),
    "asset": FlattenedAssetToJSON(value.asset),
    "bytes": ByteDescriptorToJSON(value.bytes),
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "deleted": GroupedTimestampToJSON(value.deleted),
    "synced": GroupedTimestampToJSON(value.synced),
    "cloud": value.cloud,
    "fragment": FragmentFormatToJSON(value.fragment),
    "file": FileFormatToJSON(value.file),
    "analysis": AnalysisToJSON(value.analysis),
    "relationship": RelationshipToJSON(value.relationship),
    "activities": ActivitiesToJSON(value.activities)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/OCRAnalysis.ts
function OCRAnalysisFromJSON(json) {
  return OCRAnalysisFromJSONTyped(json, false);
}
function OCRAnalysisFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "raw": FormatFromJSON(json["raw"]),
    "hocr": FormatFromJSON(json["hocr"]),
    "image": json["image"],
    "model": ModelFromJSON(json["model"])
  };
}
function OCRAnalysisToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "raw": FormatToJSON(value.raw),
    "hocr": FormatToJSON(value.hocr),
    "image": value.image,
    "model": ModelToJSON(value.model)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ImageAnalysis.ts
function ImageAnalysisFromJSON(json) {
  return ImageAnalysisFromJSONTyped(json, false);
}
function ImageAnalysisFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "analysis": json["analysis"],
    "ocr": !exists(json, "ocr") ? void 0 : OCRAnalysisFromJSON(json["ocr"])
  };
}
function ImageAnalysisToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "analysis": value.analysis,
    "ocr": OCRAnalysisToJSON(value.ocr)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Analysis.ts
function AnalysisFromJSON(json) {
  return AnalysisFromJSONTyped2(json, false);
}
function AnalysisFromJSONTyped2(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "code": !exists(json, "code") ? void 0 : CodeAnalysisFromJSON(json["code"]),
    "id": json["id"],
    "format": json["format"],
    "image": !exists(json, "image") ? void 0 : ImageAnalysisFromJSON(json["image"])
  };
}
function AnalysisToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "code": CodeAnalysisToJSON(value.code),
    "id": value.id,
    "format": value.format,
    "image": ImageAnalysisToJSON(value.image)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Anchor.ts
function AnchorFromJSON(json) {
  return AnchorFromJSONTyped(json, false);
}
function AnchorFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "name": !exists(json, "name") ? void 0 : json["name"],
    "type": AnchorTypeEnumFromJSON(json["type"]),
    "watch": !exists(json, "watch") ? void 0 : json["watch"],
    "points": FlattenedAnchorPointsFromJSON(json["points"]),
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"]),
    "assets": !exists(json, "assets") ? void 0 : FlattenedAssetsFromJSON(json["assets"]),
    "annotations": !exists(json, "annotations") ? void 0 : FlattenedAnnotationsFromJSON(json["annotations"]),
    "conversations": !exists(json, "conversations") ? void 0 : FlattenedConversationsFromJSON(json["conversations"]),
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"]),
    "summaries": !exists(json, "summaries") ? void 0 : FlattenedWorkstreamSummariesFromJSON(json["summaries"]),
    "persons": !exists(json, "persons") ? void 0 : FlattenedPersonsFromJSON(json["persons"]),
    "messages": !exists(json, "messages") ? void 0 : FlattenedConversationMessagesFromJSON(json["messages"])
  };
}
function AnchorToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "name": value.name,
    "type": AnchorTypeEnumToJSON(value.type),
    "watch": value.watch,
    "points": FlattenedAnchorPointsToJSON(value.points),
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "deleted": GroupedTimestampToJSON(value.deleted),
    "assets": FlattenedAssetsToJSON(value.assets),
    "annotations": FlattenedAnnotationsToJSON(value.annotations),
    "conversations": FlattenedConversationsToJSON(value.conversations),
    "score": ScoreToJSON(value.score),
    "summaries": FlattenedWorkstreamSummariesToJSON(value.summaries),
    "persons": FlattenedPersonsToJSON(value.persons),
    "messages": FlattenedConversationMessagesToJSON(value.messages)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/AnchorPoint.ts
function AnchorPointFromJSON(json) {
  return AnchorPointFromJSONTyped(json, false);
}
function AnchorPointFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "verified": !exists(json, "verified") ? void 0 : json["verified"],
    "fullpath": json["fullpath"],
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"]),
    "platform": !exists(json, "platform") ? void 0 : PlatformEnumFromJSON(json["platform"]),
    "anchor": ReferencedAnchorFromJSON(json["anchor"]),
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function AnchorPointToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "verified": value.verified,
    "fullpath": value.fullpath,
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "deleted": GroupedTimestampToJSON(value.deleted),
    "platform": PlatformEnumToJSON(value.platform),
    "anchor": ReferencedAnchorToJSON(value.anchor),
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Anchors.ts
function AnchorsFromJSON(json) {
  return AnchorsFromJSONTyped(json, false);
}
function AnchorsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(AnchorFromJSON),
    "indices": !exists(json, "indices") ? void 0 : json["indices"],
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function AnchorsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(AnchorToJSON),
    "indices": value.indices,
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Annotation.ts
function AnnotationFromJSON(json) {
  return AnnotationFromJSONTyped(json, false);
}
function AnnotationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"]),
    "mechanism": !exists(json, "mechanism") ? void 0 : MechanismEnumFromJSON(json["mechanism"]),
    "asset": !exists(json, "asset") ? void 0 : ReferencedAssetFromJSON(json["asset"]),
    "person": !exists(json, "person") ? void 0 : ReferencedPersonFromJSON(json["person"]),
    "type": AnnotationTypeEnumFromJSON(json["type"]),
    "text": json["text"],
    "model": !exists(json, "model") ? void 0 : ReferencedModelFromJSON(json["model"]),
    "pseudo": !exists(json, "pseudo") ? void 0 : json["pseudo"],
    "favorited": !exists(json, "favorited") ? void 0 : json["favorited"],
    "anchor": !exists(json, "anchor") ? void 0 : ReferencedAnchorFromJSON(json["anchor"]),
    "conversation": !exists(json, "conversation") ? void 0 : ReferencedConversationFromJSON(json["conversation"]),
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"]),
    "messages": !exists(json, "messages") ? void 0 : FlattenedConversationMessagesFromJSON(json["messages"]),
    "summary": !exists(json, "summary") ? void 0 : ReferencedWorkstreamSummaryFromJSON(json["summary"])
  };
}
function AnnotationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "deleted": GroupedTimestampToJSON(value.deleted),
    "mechanism": MechanismEnumToJSON(value.mechanism),
    "asset": ReferencedAssetToJSON(value.asset),
    "person": ReferencedPersonToJSON(value.person),
    "type": AnnotationTypeEnumToJSON(value.type),
    "text": value.text,
    "model": ReferencedModelToJSON(value.model),
    "pseudo": value.pseudo,
    "favorited": value.favorited,
    "anchor": ReferencedAnchorToJSON(value.anchor),
    "conversation": ReferencedConversationToJSON(value.conversation),
    "score": ScoreToJSON(value.score),
    "messages": FlattenedConversationMessagesToJSON(value.messages),
    "summary": ReferencedWorkstreamSummaryToJSON(value.summary)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Annotations.ts
function AnnotationsFromJSON(json) {
  return AnnotationsFromJSONTyped(json, false);
}
function AnnotationsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(AnnotationFromJSON),
    "indices": !exists(json, "indices") ? void 0 : json["indices"],
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function AnnotationsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(AnnotationToJSON),
    "indices": value.indices,
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Conversation.ts
function ConversationFromJSON(json) {
  return ConversationFromJSONTyped(json, false);
}
function ConversationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "name": !exists(json, "name") ? void 0 : json["name"],
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"]),
    "favorited": !exists(json, "favorited") ? void 0 : json["favorited"],
    "application": !exists(json, "application") ? void 0 : ApplicationFromJSON(json["application"]),
    "annotations": !exists(json, "annotations") ? void 0 : FlattenedAnnotationsFromJSON(json["annotations"]),
    "messages": FlattenedConversationMessagesFromJSON(json["messages"]),
    "model": !exists(json, "model") ? void 0 : ReferencedModelFromJSON(json["model"]),
    "assets": !exists(json, "assets") ? void 0 : FlattenedAssetsFromJSON(json["assets"]),
    "websites": !exists(json, "websites") ? void 0 : FlattenedWebsitesFromJSON(json["websites"]),
    "anchors": !exists(json, "anchors") ? void 0 : FlattenedAnchorsFromJSON(json["anchors"]),
    "type": ConversationTypeEnumFromJSON(json["type"]),
    "grounding": !exists(json, "grounding") ? void 0 : ConversationGroundingFromJSON(json["grounding"]),
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"]),
    "pipeline": !exists(json, "pipeline") ? void 0 : QGPTPromptPipelineFromJSON(json["pipeline"]),
    "demo": !exists(json, "demo") ? void 0 : json["demo"],
    "summaries": !exists(json, "summaries") ? void 0 : FlattenedWorkstreamSummariesFromJSON(json["summaries"])
  };
}
function ConversationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "name": value.name,
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "deleted": GroupedTimestampToJSON(value.deleted),
    "favorited": value.favorited,
    "application": ApplicationToJSON(value.application),
    "annotations": FlattenedAnnotationsToJSON(value.annotations),
    "messages": FlattenedConversationMessagesToJSON(value.messages),
    "model": ReferencedModelToJSON(value.model),
    "assets": FlattenedAssetsToJSON(value.assets),
    "websites": FlattenedWebsitesToJSON(value.websites),
    "anchors": FlattenedAnchorsToJSON(value.anchors),
    "type": ConversationTypeEnumToJSON(value.type),
    "grounding": ConversationGroundingToJSON(value.grounding),
    "score": ScoreToJSON(value.score),
    "pipeline": QGPTPromptPipelineToJSON(value.pipeline),
    "demo": value.demo,
    "summaries": FlattenedWorkstreamSummariesToJSON(value.summaries)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Conversations.ts
function ConversationsFromJSON(json) {
  return ConversationsFromJSONTyped(json, false);
}
function ConversationsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(ConversationFromJSON),
    "indices": !exists(json, "indices") ? void 0 : json["indices"],
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function ConversationsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(ConversationToJSON),
    "indices": value.indices,
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Formats.ts
function FormatsFromJSON(json) {
  return FormatsFromJSONTyped(json, false);
}
function FormatsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(FormatFromJSON)
  };
}
function FormatsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(FormatToJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Hint.ts
function HintFromJSON(json) {
  return HintFromJSONTyped(json, false);
}
function HintFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"]),
    "mechanisms": !exists(json, "mechanisms") ? void 0 : mapValues(json["mechanisms"], MechanismEnumFromJSON),
    "assets": !exists(json, "assets") ? void 0 : FlattenedAssetsFromJSON(json["assets"]),
    "type": HintTypeEnumFromJSON(json["type"]),
    "text": json["text"],
    "model": !exists(json, "model") ? void 0 : ReferencedModelFromJSON(json["model"]),
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function HintToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "deleted": GroupedTimestampToJSON(value.deleted),
    "mechanisms": value.mechanisms === void 0 ? void 0 : mapValues(value.mechanisms, MechanismEnumToJSON),
    "assets": FlattenedAssetsToJSON(value.assets),
    "type": HintTypeEnumToJSON(value.type),
    "text": value.text,
    "model": ReferencedModelToJSON(value.model),
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Hints.ts
function HintsFromJSON(json) {
  return HintsFromJSONTyped(json, false);
}
function HintsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(HintFromJSON),
    "indices": !exists(json, "indices") ? void 0 : json["indices"],
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function HintsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(HintToJSON),
    "indices": value.indices,
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Person.ts
function PersonFromJSON(json) {
  return PersonFromJSONTyped(json, false);
}
function PersonFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"]),
    "type": PersonTypeFromJSON(json["type"]),
    "assets": !exists(json, "assets") ? void 0 : FlattenedAssetsFromJSON(json["assets"]),
    "mechanisms": !exists(json, "mechanisms") ? void 0 : mapValues(json["mechanisms"], MechanismEnumFromJSON),
    "interactions": !exists(json, "interactions") ? void 0 : json["interactions"],
    "access": !exists(json, "access") ? void 0 : mapValues(json["access"], PersonAccessFromJSON),
    "tags": !exists(json, "tags") ? void 0 : FlattenedTagsFromJSON(json["tags"]),
    "websites": !exists(json, "websites") ? void 0 : FlattenedWebsitesFromJSON(json["websites"]),
    "models": !exists(json, "models") ? void 0 : mapValues(json["models"], PersonModelFromJSON),
    "annotations": !exists(json, "annotations") ? void 0 : FlattenedAnnotationsFromJSON(json["annotations"]),
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"]),
    "summaries": !exists(json, "summaries") ? void 0 : FlattenedWorkstreamSummariesFromJSON(json["summaries"]),
    "anchors": !exists(json, "anchors") ? void 0 : FlattenedAnchorsFromJSON(json["anchors"]),
    "messages": !exists(json, "messages") ? void 0 : FlattenedConversationMessagesFromJSON(json["messages"])
  };
}
function PersonToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "deleted": GroupedTimestampToJSON(value.deleted),
    "type": PersonTypeToJSON(value.type),
    "assets": FlattenedAssetsToJSON(value.assets),
    "mechanisms": value.mechanisms === void 0 ? void 0 : mapValues(value.mechanisms, MechanismEnumToJSON),
    "interactions": value.interactions,
    "access": value.access === void 0 ? void 0 : mapValues(value.access, PersonAccessToJSON),
    "tags": FlattenedTagsToJSON(value.tags),
    "websites": FlattenedWebsitesToJSON(value.websites),
    "models": value.models === void 0 ? void 0 : mapValues(value.models, PersonModelToJSON),
    "annotations": FlattenedAnnotationsToJSON(value.annotations),
    "score": ScoreToJSON(value.score),
    "summaries": FlattenedWorkstreamSummariesToJSON(value.summaries),
    "anchors": FlattenedAnchorsToJSON(value.anchors),
    "messages": FlattenedConversationMessagesToJSON(value.messages)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Persons.ts
function PersonsFromJSON(json) {
  return PersonsFromJSONTyped(json, false);
}
function PersonsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(PersonFromJSON),
    "indices": !exists(json, "indices") ? void 0 : json["indices"],
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function PersonsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(PersonToJSON),
    "indices": value.indices,
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Preview.ts
function PreviewFromJSON(json) {
  return PreviewFromJSONTyped(json, false);
}
function PreviewFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "base": ReferencedFormatFromJSON(json["base"]),
    "overlay": !exists(json, "overlay") ? void 0 : ReferencedFormatFromJSON(json["overlay"])
  };
}
function PreviewToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "base": ReferencedFormatToJSON(value.base),
    "overlay": ReferencedFormatToJSON(value.overlay)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Sensitive.ts
function SensitiveFromJSON(json) {
  return SensitiveFromJSONTyped(json, false);
}
function SensitiveFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"]),
    "asset": FlattenedAssetFromJSON(json["asset"]),
    "text": json["text"],
    "mechanism": MechanismEnumFromJSON(json["mechanism"]),
    "category": SensitiveCategoryEnumFromJSON(json["category"]),
    "severity": SensitiveSeverityEnumFromJSON(json["severity"]),
    "name": json["name"],
    "description": json["description"],
    "metadata": !exists(json, "metadata") ? void 0 : SensitiveMetadataFromJSON(json["metadata"]),
    "interactions": !exists(json, "interactions") ? void 0 : json["interactions"],
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function SensitiveToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "deleted": GroupedTimestampToJSON(value.deleted),
    "asset": FlattenedAssetToJSON(value.asset),
    "text": value.text,
    "mechanism": MechanismEnumToJSON(value.mechanism),
    "category": SensitiveCategoryEnumToJSON(value.category),
    "severity": SensitiveSeverityEnumToJSON(value.severity),
    "name": value.name,
    "description": value.description,
    "metadata": SensitiveMetadataToJSON(value.metadata),
    "interactions": value.interactions,
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Sensitives.ts
function SensitivesFromJSON(json) {
  return SensitivesFromJSONTyped(json, false);
}
function SensitivesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(SensitiveFromJSON),
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function SensitivesToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(SensitiveToJSON),
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Distribution.ts
function DistributionFromJSON(json) {
  return DistributionFromJSONTyped(json, false);
}
function DistributionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "share": FlattenedShareFromJSON(json["share"]),
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"]),
    "mailgun": !exists(json, "mailgun") ? void 0 : MailgunDistributionFromJSON(json["mailgun"]),
    "github": !exists(json, "github") ? void 0 : GitHubDistributionFromJSON(json["github"])
  };
}
function DistributionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "share": FlattenedShareToJSON(value.share),
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "deleted": GroupedTimestampToJSON(value.deleted),
    "mailgun": MailgunDistributionToJSON(value.mailgun),
    "github": GitHubDistributionToJSON(value.github)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Distributions.ts
function DistributionsFromJSON(json) {
  return DistributionsFromJSONTyped(json, false);
}
function DistributionsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "iterable": json["iterable"].map(DistributionFromJSON),
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"])
  };
}
function DistributionsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "iterable": value.iterable.map(DistributionToJSON),
    "schema": EmbeddedModelSchemaToJSON(value.schema)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Share.ts
function ShareFromJSON(json) {
  return ShareFromJSONTyped(json, false);
}
function ShareFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "user": !exists(json, "user") ? void 0 : json["user"],
    "asset": !exists(json, "asset") ? void 0 : FlattenedAssetFromJSON(json["asset"]),
    "assets": !exists(json, "assets") ? void 0 : FlattenedAssetsFromJSON(json["assets"]),
    "link": json["link"],
    "access": AccessEnumFromJSON(json["access"]),
    "accessors": AccessorsFromJSON(json["accessors"]),
    "created": GroupedTimestampFromJSON(json["created"]),
    "_short": json["short"],
    "name": !exists(json, "name") ? void 0 : json["name"],
    "distributions": !exists(json, "distributions") ? void 0 : DistributionsFromJSON(json["distributions"]),
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function ShareToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "user": value.user,
    "asset": FlattenedAssetToJSON(value.asset),
    "assets": FlattenedAssetsToJSON(value.assets),
    "link": value.link,
    "access": AccessEnumToJSON(value.access),
    "accessors": AccessorsToJSON(value.accessors),
    "created": GroupedTimestampToJSON(value.created),
    "short": value._short,
    "name": value.name,
    "distributions": DistributionsToJSON(value.distributions),
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Shares.ts
function SharesFromJSON(json) {
  return SharesFromJSONTyped(json, false);
}
function SharesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(ShareFromJSON),
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function SharesToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(ShareToJSON),
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Tag.ts
function TagFromJSON(json) {
  return TagFromJSONTyped(json, false);
}
function TagFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "text": json["text"],
    "mechanisms": !exists(json, "mechanisms") ? void 0 : mapValues(json["mechanisms"], MechanismEnumFromJSON),
    "assets": !exists(json, "assets") ? void 0 : FlattenedAssetsFromJSON(json["assets"]),
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"]),
    "category": TagCategoryEnumFromJSON(json["category"]),
    "relationship": !exists(json, "relationship") ? void 0 : RelationshipFromJSON(json["relationship"]),
    "interactions": !exists(json, "interactions") ? void 0 : json["interactions"],
    "persons": !exists(json, "persons") ? void 0 : FlattenedPersonsFromJSON(json["persons"]),
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function TagToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "text": value.text,
    "mechanisms": value.mechanisms === void 0 ? void 0 : mapValues(value.mechanisms, MechanismEnumToJSON),
    "assets": FlattenedAssetsToJSON(value.assets),
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "deleted": GroupedTimestampToJSON(value.deleted),
    "category": TagCategoryEnumToJSON(value.category),
    "relationship": RelationshipToJSON(value.relationship),
    "interactions": value.interactions,
    "persons": FlattenedPersonsToJSON(value.persons),
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Tags.ts
function TagsFromJSON(json) {
  return TagsFromJSONTyped(json, false);
}
function TagsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(TagFromJSON),
    "indices": !exists(json, "indices") ? void 0 : json["indices"],
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function TagsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(TagToJSON),
    "indices": value.indices,
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Website.ts
function WebsiteFromJSON(json) {
  return WebsiteFromJSONTyped(json, false);
}
function WebsiteFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "assets": !exists(json, "assets") ? void 0 : FlattenedAssetsFromJSON(json["assets"]),
    "url": json["url"],
    "name": json["name"],
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"]),
    "mechanisms": !exists(json, "mechanisms") ? void 0 : mapValues(json["mechanisms"], MechanismEnumFromJSON),
    "interactions": !exists(json, "interactions") ? void 0 : json["interactions"],
    "persons": !exists(json, "persons") ? void 0 : FlattenedPersonsFromJSON(json["persons"]),
    "conversations": !exists(json, "conversations") ? void 0 : FlattenedConversationsFromJSON(json["conversations"]),
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"]),
    "summaries": !exists(json, "summaries") ? void 0 : FlattenedWorkstreamSummariesFromJSON(json["summaries"]),
    "messages": !exists(json, "messages") ? void 0 : FlattenedConversationMessagesFromJSON(json["messages"])
  };
}
function WebsiteToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "assets": FlattenedAssetsToJSON(value.assets),
    "url": value.url,
    "name": value.name,
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "deleted": GroupedTimestampToJSON(value.deleted),
    "mechanisms": value.mechanisms === void 0 ? void 0 : mapValues(value.mechanisms, MechanismEnumToJSON),
    "interactions": value.interactions,
    "persons": FlattenedPersonsToJSON(value.persons),
    "conversations": FlattenedConversationsToJSON(value.conversations),
    "score": ScoreToJSON(value.score),
    "summaries": FlattenedWorkstreamSummariesToJSON(value.summaries),
    "messages": FlattenedConversationMessagesToJSON(value.messages)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Websites.ts
function WebsitesFromJSON(json) {
  return WebsitesFromJSONTyped(json, false);
}
function WebsitesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(WebsiteFromJSON),
    "indices": !exists(json, "indices") ? void 0 : json["indices"],
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function WebsitesToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(WebsiteToJSON),
    "indices": value.indices,
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/WorkstreamSummary.ts
function WorkstreamSummaryFromJSON(json) {
  return WorkstreamSummaryFromJSONTyped(json, false);
}
function WorkstreamSummaryFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"]),
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "events": !exists(json, "events") ? void 0 : FlattenedWorkstreamEventsFromJSON(json["events"]),
    "name": json["name"],
    "annotations": !exists(json, "annotations") ? void 0 : FlattenedAnnotationsFromJSON(json["annotations"]),
    "ranges": !exists(json, "ranges") ? void 0 : FlattenedRangesFromJSON(json["ranges"]),
    "model": ModelFromJSON(json["model"]),
    "websites": !exists(json, "websites") ? void 0 : FlattenedWebsitesFromJSON(json["websites"]),
    "anchors": !exists(json, "anchors") ? void 0 : FlattenedAnchorsFromJSON(json["anchors"]),
    "assets": !exists(json, "assets") ? void 0 : FlattenedAssetsFromJSON(json["assets"]),
    "conversations": !exists(json, "conversations") ? void 0 : FlattenedConversationsFromJSON(json["conversations"]),
    "persons": !exists(json, "persons") ? void 0 : FlattenedPersonsFromJSON(json["persons"]),
    "applications": !exists(json, "applications") ? void 0 : ApplicationsFromJSON(json["applications"])
  };
}
function WorkstreamSummaryToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "score": ScoreToJSON(value.score),
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "events": FlattenedWorkstreamEventsToJSON(value.events),
    "name": value.name,
    "annotations": FlattenedAnnotationsToJSON(value.annotations),
    "ranges": FlattenedRangesToJSON(value.ranges),
    "model": ModelToJSON(value.model),
    "websites": FlattenedWebsitesToJSON(value.websites),
    "anchors": FlattenedAnchorsToJSON(value.anchors),
    "assets": FlattenedAssetsToJSON(value.assets),
    "conversations": FlattenedConversationsToJSON(value.conversations),
    "persons": FlattenedPersonsToJSON(value.persons),
    "applications": ApplicationsToJSON(value.applications)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/WorkstreamSummaries.ts
function WorkstreamSummariesFromJSON(json) {
  return WorkstreamSummariesFromJSONTyped(json, false);
}
function WorkstreamSummariesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(WorkstreamSummaryFromJSON),
    "indices": !exists(json, "indices") ? void 0 : json["indices"],
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function WorkstreamSummariesToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(WorkstreamSummaryToJSON),
    "indices": value.indices,
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Asset.ts
function AssetFromJSON(json) {
  return AssetFromJSONTyped(json, false);
}
function AssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "name": !exists(json, "name") ? void 0 : json["name"],
    "creator": json["creator"],
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "synced": !exists(json, "synced") ? void 0 : GroupedTimestampFromJSON(json["synced"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"]),
    "formats": FormatsFromJSON(json["formats"]),
    "preview": PreviewFromJSON(json["preview"]),
    "original": ReferencedFormatFromJSON(json["original"]),
    "shares": !exists(json, "shares") ? void 0 : SharesFromJSON(json["shares"]),
    "mechanism": MechanismEnumFromJSON(json["mechanism"]),
    "websites": !exists(json, "websites") ? void 0 : WebsitesFromJSON(json["websites"]),
    "interacted": !exists(json, "interacted") ? void 0 : GroupedTimestampFromJSON(json["interacted"]),
    "tags": !exists(json, "tags") ? void 0 : TagsFromJSON(json["tags"]),
    "sensitives": !exists(json, "sensitives") ? void 0 : SensitivesFromJSON(json["sensitives"]),
    "persons": !exists(json, "persons") ? void 0 : PersonsFromJSON(json["persons"]),
    "curated": !exists(json, "curated") ? void 0 : json["curated"],
    "discovered": !exists(json, "discovered") ? void 0 : json["discovered"],
    "activities": !exists(json, "activities") ? void 0 : ActivitiesFromJSON(json["activities"]),
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"]),
    "favorited": !exists(json, "favorited") ? void 0 : json["favorited"],
    "pseudo": !exists(json, "pseudo") ? void 0 : json["pseudo"],
    "annotations": !exists(json, "annotations") ? void 0 : AnnotationsFromJSON(json["annotations"]),
    "hints": !exists(json, "hints") ? void 0 : HintsFromJSON(json["hints"]),
    "anchors": !exists(json, "anchors") ? void 0 : AnchorsFromJSON(json["anchors"]),
    "conversations": !exists(json, "conversations") ? void 0 : ConversationsFromJSON(json["conversations"]),
    "summaries": !exists(json, "summaries") ? void 0 : WorkstreamSummariesFromJSON(json["summaries"]),
    "demo": !exists(json, "demo") ? void 0 : json["demo"]
  };
}
function AssetToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "name": value.name,
    "creator": value.creator,
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "synced": GroupedTimestampToJSON(value.synced),
    "deleted": GroupedTimestampToJSON(value.deleted),
    "formats": FormatsToJSON(value.formats),
    "preview": PreviewToJSON(value.preview),
    "original": ReferencedFormatToJSON(value.original),
    "shares": SharesToJSON(value.shares),
    "mechanism": MechanismEnumToJSON(value.mechanism),
    "websites": WebsitesToJSON(value.websites),
    "interacted": GroupedTimestampToJSON(value.interacted),
    "tags": TagsToJSON(value.tags),
    "sensitives": SensitivesToJSON(value.sensitives),
    "persons": PersonsToJSON(value.persons),
    "curated": value.curated,
    "discovered": value.discovered,
    "activities": ActivitiesToJSON(value.activities),
    "score": ScoreToJSON(value.score),
    "favorited": value.favorited,
    "pseudo": value.pseudo,
    "annotations": AnnotationsToJSON(value.annotations),
    "hints": HintsToJSON(value.hints),
    "anchors": AnchorsToJSON(value.anchors),
    "conversations": ConversationsToJSON(value.conversations),
    "summaries": WorkstreamSummariesToJSON(value.summaries),
    "demo": value.demo
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/AssetFilterPhraseOptions.ts
function AssetFilterPhraseOptionsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "annotation": AnnotationTypeEnumToJSON(value.annotation)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/AssetFilterPhrase.ts
function AssetFilterPhraseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "value": value.value,
    "annotation": value.annotation,
    "title": value.title,
    "content": value.content,
    "options": AssetFilterPhraseOptionsToJSON(value.options)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/AssetFilterTimestamp.ts
function AssetFilterTimestampToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "from": GroupedTimestampToJSON(value.from),
    "to": GroupedTimestampToJSON(value.to),
    "between": value.between
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FilterOperationTypeEnum.ts
var FilterOperationTypeEnum = {
  And: "AND",
  Or: "OR"
};
function FilterOperationTypeEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/AssetFilters.ts
function AssetFiltersToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(AssetFilterToJSON),
    "type": FilterOperationTypeEnumToJSON(value.type)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/AssetFilter.ts
function AssetFilterToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "classification": ClassificationSpecificEnumToJSON(value.classification),
    "tags": value.tags,
    "websites": value.websites,
    "persons": value.persons,
    "phrase": AssetFilterPhraseToJSON(value.phrase),
    "created": AssetFilterTimestampToJSON(value.created),
    "updated": AssetFilterTimestampToJSON(value.updated),
    "operations": AssetFiltersToJSON(value.operations)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/AssetReclassification.ts
function AssetReclassificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "ext": ClassificationSpecificEnumToJSON(value.ext),
    "asset": AssetToJSON(value.asset)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/AssetSearchSpace.ts
function AssetSearchSpaceToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "identifers": FlattenedAssetsToJSON(value.identifers)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Assets.ts
function AssetsFromJSON(json) {
  return AssetsFromJSONTyped(json, false);
}
function AssetsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(AssetFromJSON),
    "indices": !exists(json, "indices") ? void 0 : json["indices"],
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}
function AssetsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(AssetToJSON),
    "indices": value.indices,
    "score": ScoreToJSON(value.score)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/AssetsSearchWithFiltersInput.ts
function AssetsSearchWithFiltersInputToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "query": value.query,
    "space": AssetSearchSpaceToJSON(value.space),
    "filters": AssetFiltersToJSON(value.filters),
    "casing": value.casing
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SearchedMatchEnum.ts
function SearchedMatchEnumFromJSON(json) {
  return SearchedMatchEnumFromJSONTyped(json, false);
}
function SearchedMatchEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// ../generated_runtime/sdk/http/typescript/core/models/SearchedAsset.ts
function SearchedAssetFromJSON(json) {
  return SearchedAssetFromJSONTyped(json, false);
}
function SearchedAssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "asset": !exists(json, "asset") ? void 0 : AssetFromJSON(json["asset"]),
    "exact": json["exact"],
    "score": json["score"],
    "match": SearchedMatchEnumFromJSON(json["match"]),
    "identifier": json["identifier"],
    "pseudo": !exists(json, "pseudo") ? void 0 : json["pseudo"]
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SearchedAssets.ts
function SearchedAssetsFromJSON(json) {
  return SearchedAssetsFromJSONTyped(json, false);
}
function SearchedAssetsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(SearchedAssetFromJSON),
    "suggested": json["suggested"],
    "exact": json["exact"]
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/AssetsSearchWithFiltersOutput.ts
function AssetsSearchWithFiltersOutputFromJSON(json) {
  return AssetsSearchWithFiltersOutputFromJSONTyped(json, false);
}
function AssetsSearchWithFiltersOutputFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "results": SearchedAssetsFromJSON(json["results"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Auth0Identity.ts
function Auth0IdentityToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "connection": value.connection,
    "isSocial": value.isSocial,
    "provider": value.provider,
    "user_id": value.userId,
    "access_token": value.accessToken,
    "expires_in": value.expiresIn
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Auth0User.ts
function Auth0UserToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "name": value.name,
    "picture": value.picture,
    "email": value.email,
    "created_at": value.createdAt === void 0 ? void 0 : value.createdAt.toISOString(),
    "email_verified": value.emailVerified,
    "family_name": value.familyName,
    "given_name": value.givenName,
    "identities": value.identities === void 0 ? void 0 : value.identities.map(Auth0IdentityToJSON),
    "nickname": value.nickname,
    "updated_at": value.updatedAt === void 0 ? void 0 : value.updatedAt.toISOString(),
    "username": value.username,
    "user_metadata": Auth0UserMetadataToJSON(value.userMetadata),
    "locale": value.locale,
    "user_id": value.userId,
    "last_ip": value.lastIp,
    "last_login": value.lastLogin === void 0 ? void 0 : value.lastLogin.toISOString(),
    "logins_count": value.loginsCount,
    "blocked_for": value.blockedFor,
    "guardian_authenticators": value.guardianAuthenticators
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Auth0UserBetaStatus.ts
function Auth0UserBetaStatusFromJSON(json) {
  return Auth0UserBetaStatusFromJSONTyped(json, false);
}
function Auth0UserBetaStatusFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "vision": !exists(json, "vision") ? void 0 : AnonymousTemporalRangeFromJSON(json["vision"])
  };
}
function Auth0UserBetaStatusToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "vision": AnonymousTemporalRangeToJSON(value.vision)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/AvailableFormats.ts
function AvailableFormatsFromJSON(json) {
  return AvailableFormatsFromJSONTyped(json, false);
}
function AvailableFormatsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(ClassificationFromJSON)
  };
}
function AvailableFormatsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(ClassificationToJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ModelDownloadProgressStatusEnum.ts
function ModelDownloadProgressStatusEnumFromJSON(json) {
  return ModelDownloadProgressStatusEnumFromJSONTyped(json, false);
}
function ModelDownloadProgressStatusEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// ../generated_runtime/sdk/http/typescript/core/models/OSHealth.ts
function OSHealthFromJSON(json) {
  return OSHealthFromJSONTyped(json, false);
}
function OSHealthFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "version": json["version"]
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Health.ts
function HealthFromJSON(json) {
  return HealthFromJSONTyped(json, false);
}
function HealthFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "os": OSHealthFromJSON(json["os"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Context.ts
function ContextFromJSON(json) {
  return ContextFromJSONTyped(json, false);
}
function ContextFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "os": json["os"],
    "application": ApplicationFromJSON(json["application"]),
    "health": HealthFromJSON(json["health"]),
    "user": !exists(json, "user") ? void 0 : UserProfileFromJSON(json["user"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ConversationMessage.ts
function ConversationMessageFromJSON(json) {
  return ConversationMessageFromJSONTyped(json, false);
}
function ConversationMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "created": GroupedTimestampFromJSON(json["created"]),
    "updated": GroupedTimestampFromJSON(json["updated"]),
    "deleted": !exists(json, "deleted") ? void 0 : GroupedTimestampFromJSON(json["deleted"]),
    "model": !exists(json, "model") ? void 0 : ModelFromJSON(json["model"]),
    "fragment": !exists(json, "fragment") ? void 0 : FragmentFormatFromJSON(json["fragment"]),
    "conversation": ReferencedConversationFromJSON(json["conversation"]),
    "sentiment": !exists(json, "sentiment") ? void 0 : ConversationMessageSentimentEnumFromJSON(json["sentiment"]),
    "role": QGPTConversationMessageRoleEnumFromJSON(json["role"]),
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"]),
    "annotations": !exists(json, "annotations") ? void 0 : FlattenedAnnotationsFromJSON(json["annotations"]),
    "websites": !exists(json, "websites") ? void 0 : FlattenedWebsitesFromJSON(json["websites"]),
    "persons": !exists(json, "persons") ? void 0 : FlattenedPersonsFromJSON(json["persons"]),
    "anchors": !exists(json, "anchors") ? void 0 : FlattenedAnchorsFromJSON(json["anchors"])
  };
}
function ConversationMessageToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "created": GroupedTimestampToJSON(value.created),
    "updated": GroupedTimestampToJSON(value.updated),
    "deleted": GroupedTimestampToJSON(value.deleted),
    "model": ModelToJSON(value.model),
    "fragment": FragmentFormatToJSON(value.fragment),
    "conversation": ReferencedConversationToJSON(value.conversation),
    "sentiment": ConversationMessageSentimentEnumToJSON(value.sentiment),
    "role": QGPTConversationMessageRoleEnumToJSON(value.role),
    "score": ScoreToJSON(value.score),
    "annotations": FlattenedAnnotationsToJSON(value.annotations),
    "websites": FlattenedWebsitesToJSON(value.websites),
    "persons": FlattenedPersonsToJSON(value.persons),
    "anchors": FlattenedAnchorsToJSON(value.anchors)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ConversationMessages.ts
function ConversationMessagesFromJSON(json) {
  return ConversationMessagesFromJSONTyped(json, false);
}
function ConversationMessagesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(ConversationMessageFromJSON),
    "indices": !exists(json, "indices") ? void 0 : json["indices"],
    "score": !exists(json, "score") ? void 0 : ScoreFromJSON(json["score"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ConversationSummarizeInput.ts
function ConversationSummarizeInputToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "messages": FlattenedConversationMessagesToJSON(value.messages)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ConversationSummarizeOutput.ts
function ConversationSummarizeOutputFromJSON(json) {
  return ConversationSummarizeOutputFromJSONTyped(json, false);
}
function ConversationSummarizeOutputFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "conversation": ReferencedConversationFromJSON(json["conversation"]),
    "annotation": ReferencedAnnotationFromJSON(json["annotation"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ConversationsCreateFromAssetOutput.ts
function ConversationsCreateFromAssetOutputFromJSON(json) {
  return ConversationsCreateFromAssetOutputFromJSONTyped(json, false);
}
function ConversationsCreateFromAssetOutputFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "conversation": ReferencedConversationFromJSON(json["conversation"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/DetectedExternalApplication.ts
function DetectedExternalApplicationFromJSON(json) {
  return DetectedExternalApplicationFromJSONTyped(json, false);
}
function DetectedExternalApplicationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "name": json["name"],
    "version": !exists(json, "version") ? void 0 : json["version"]
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/DetectedExternalApplications.ts
function DetectedExternalApplicationsFromJSON(json) {
  return DetectedExternalApplicationsFromJSONTyped(json, false);
}
function DetectedExternalApplicationsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(DetectedExternalApplicationFromJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededAssetSensitive.ts
function SeededAssetSensitiveFromJSON(json) {
  return SeededAssetSensitiveFromJSONTyped(json, false);
}
function SeededAssetSensitiveFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "text": json["text"],
    "mechanism": !exists(json, "mechanism") ? void 0 : MechanismEnumFromJSON(json["mechanism"]),
    "category": SensitiveCategoryEnumFromJSON(json["category"]),
    "severity": SensitiveSeverityEnumFromJSON(json["severity"]),
    "name": json["name"],
    "description": json["description"],
    "metadata": !exists(json, "metadata") ? void 0 : SensitiveMetadataFromJSON(json["metadata"])
  };
}
function SeededAssetSensitiveToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "text": value.text,
    "mechanism": MechanismEnumToJSON(value.mechanism),
    "category": SensitiveCategoryEnumToJSON(value.category),
    "severity": SensitiveSeverityEnumToJSON(value.severity),
    "name": value.name,
    "description": value.description,
    "metadata": SensitiveMetadataToJSON(value.metadata)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededAssetTag.ts
function SeededAssetTagFromJSON(json) {
  return SeededAssetTagFromJSONTyped(json, false);
}
function SeededAssetTagFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "text": json["text"],
    "mechanism": !exists(json, "mechanism") ? void 0 : MechanismEnumFromJSON(json["mechanism"]),
    "category": !exists(json, "category") ? void 0 : TagCategoryEnumFromJSON(json["category"])
  };
}
function SeededAssetTagToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "text": value.text,
    "mechanism": MechanismEnumToJSON(value.mechanism),
    "category": TagCategoryEnumToJSON(value.category)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededAssetWebsite.ts
function SeededAssetWebsiteFromJSON(json) {
  return SeededAssetWebsiteFromJSONTyped(json, false);
}
function SeededAssetWebsiteFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "url": json["url"],
    "name": json["name"],
    "mechanism": !exists(json, "mechanism") ? void 0 : MechanismEnumFromJSON(json["mechanism"])
  };
}
function SeededAssetWebsiteToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "url": value.url,
    "name": value.name,
    "mechanism": MechanismEnumToJSON(value.mechanism)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededHint.ts
function SeededHintFromJSON(json) {
  return SeededHintFromJSONTyped(json, false);
}
function SeededHintFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "mechanism": !exists(json, "mechanism") ? void 0 : MechanismEnumFromJSON(json["mechanism"]),
    "asset": !exists(json, "asset") ? void 0 : json["asset"],
    "type": HintTypeEnumFromJSON(json["type"]),
    "text": json["text"],
    "model": !exists(json, "model") ? void 0 : json["model"]
  };
}
function SeededHintToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "mechanism": MechanismEnumToJSON(value.mechanism),
    "asset": value.asset,
    "type": HintTypeEnumToJSON(value.type),
    "text": value.text,
    "model": value.model
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededPerson.ts
function SeededPersonFromJSON(json) {
  return SeededPersonFromJSONTyped(json, false);
}
function SeededPersonFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "asset": !exists(json, "asset") ? void 0 : json["asset"],
    "mechanism": !exists(json, "mechanism") ? void 0 : MechanismEnumFromJSON(json["mechanism"]),
    "access": !exists(json, "access") ? void 0 : PersonAccessFromJSON(json["access"]),
    "type": PersonTypeFromJSON(json["type"]),
    "model": !exists(json, "model") ? void 0 : PersonModelFromJSON(json["model"]),
    "annotations": !exists(json, "annotations") ? void 0 : json["annotations"].map(SeededAnnotationFromJSON),
    "anchors": !exists(json, "anchors") ? void 0 : FlattenedAnchorsFromJSON(json["anchors"])
  };
}
function SeededPersonToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "asset": value.asset,
    "mechanism": MechanismEnumToJSON(value.mechanism),
    "access": PersonAccessToJSON(value.access),
    "type": PersonTypeToJSON(value.type),
    "model": PersonModelToJSON(value.model),
    "annotations": value.annotations === void 0 ? void 0 : value.annotations.map(SeededAnnotationToJSON),
    "anchors": FlattenedAnchorsToJSON(value.anchors)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededAssetMetadata.ts
function SeededAssetMetadataFromJSON(json) {
  return SeededAssetMetadataFromJSONTyped(json, false);
}
function SeededAssetMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "name": !exists(json, "name") ? void 0 : json["name"],
    "mechanism": !exists(json, "mechanism") ? void 0 : MechanismEnumFromJSON(json["mechanism"]),
    "tags": !exists(json, "tags") ? void 0 : json["tags"].map(SeededAssetTagFromJSON),
    "websites": !exists(json, "websites") ? void 0 : json["websites"].map(SeededAssetWebsiteFromJSON),
    "sensitives": !exists(json, "sensitives") ? void 0 : json["sensitives"].map(SeededAssetSensitiveFromJSON),
    "persons": !exists(json, "persons") ? void 0 : json["persons"].map(SeededPersonFromJSON),
    "annotations": !exists(json, "annotations") ? void 0 : json["annotations"].map(SeededAnnotationFromJSON),
    "hints": !exists(json, "hints") ? void 0 : json["hints"].map(SeededHintFromJSON),
    "anchors": !exists(json, "anchors") ? void 0 : json["anchors"].map(SeededAnchorFromJSON)
  };
}
function SeededAssetMetadataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "name": value.name,
    "mechanism": MechanismEnumToJSON(value.mechanism),
    "tags": value.tags === void 0 ? void 0 : value.tags.map(SeededAssetTagToJSON),
    "websites": value.websites === void 0 ? void 0 : value.websites.map(SeededAssetWebsiteToJSON),
    "sensitives": value.sensitives === void 0 ? void 0 : value.sensitives.map(SeededAssetSensitiveToJSON),
    "persons": value.persons === void 0 ? void 0 : value.persons.map(SeededPersonToJSON),
    "annotations": value.annotations === void 0 ? void 0 : value.annotations.map(SeededAnnotationToJSON),
    "hints": value.hints === void 0 ? void 0 : value.hints.map(SeededHintToJSON),
    "anchors": value.anchors === void 0 ? void 0 : value.anchors.map(SeededAnchorToJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FileMetadata.ts
function FileMetadataFromJSON(json) {
  return FileMetadataFromJSONTyped(json, false);
}
function FileMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "name": !exists(json, "name") ? void 0 : json["name"],
    "ext": !exists(json, "ext") ? void 0 : ClassificationSpecificEnumFromJSON(json["ext"]),
    "size": !exists(json, "size") ? void 0 : json["size"]
  };
}
function FileMetadataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "name": value.name,
    "ext": ClassificationSpecificEnumToJSON(value.ext),
    "size": value.size
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededFile.ts
function SeededFileFromJSON(json) {
  return SeededFileFromJSONTyped(json, false);
}
function SeededFileFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "bytes": !exists(json, "bytes") ? void 0 : TransferableBytesFromJSON(json["bytes"]),
    "string": !exists(json, "string") ? void 0 : TransferableStringFromJSON(json["string"]),
    "metadata": !exists(json, "metadata") ? void 0 : FileMetadataFromJSON(json["metadata"])
  };
}
function SeededFileToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "bytes": TransferableBytesToJSON(value.bytes),
    "string": TransferableStringToJSON(value.string),
    "metadata": FileMetadataToJSON(value.metadata)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededFragment.ts
function SeededFragmentFromJSON(json) {
  return SeededFragmentFromJSONTyped(json, false);
}
function SeededFragmentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "string": !exists(json, "string") ? void 0 : TransferableStringFromJSON(json["string"]),
    "bytes": !exists(json, "bytes") ? void 0 : TransferableBytesFromJSON(json["bytes"]),
    "metadata": !exists(json, "metadata") ? void 0 : FragmentMetadataFromJSON(json["metadata"])
  };
}
function SeededFragmentToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "string": TransferableStringToJSON(value.string),
    "bytes": TransferableBytesToJSON(value.bytes),
    "metadata": FragmentMetadataToJSON(value.metadata)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TLPDirectedDiscoveryFilterEnum.ts
function TLPDirectedDiscoveryFilterEnumFromJSON(json) {
  return TLPDirectedDiscoveryFilterEnumFromJSONTyped(json, false);
}
function TLPDirectedDiscoveryFilterEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function TLPDirectedDiscoveryFilterEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/TLPDirectedDiscoveryFilter.ts
function TLPDirectedDiscoveryFilterFromJSON(json) {
  return TLPDirectedDiscoveryFilterFromJSONTyped(json, false);
}
function TLPDirectedDiscoveryFilterFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "name": TLPDirectedDiscoveryFilterEnumFromJSON(json["name"])
  };
}
function TLPDirectedDiscoveryFilterToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "name": TLPDirectedDiscoveryFilterEnumToJSON(value.name)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TLPDirectedDiscoveryFilters.ts
function TLPDirectedDiscoveryFiltersFromJSON(json) {
  return TLPDirectedDiscoveryFiltersFromJSONTyped(json, false);
}
function TLPDirectedDiscoveryFiltersFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "iterable": json["iterable"].map(TLPDirectedDiscoveryFilterFromJSON)
  };
}
function TLPDirectedDiscoveryFiltersToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "iterable": value.iterable.map(TLPDirectedDiscoveryFilterToJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/DiscoveredAsset.ts
function DiscoveredAssetFromJSON(json) {
  return DiscoveredAssetFromJSONTyped(json, false);
}
function DiscoveredAssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "file": !exists(json, "file") ? void 0 : SeededFileFromJSON(json["file"]),
    "fragment": !exists(json, "fragment") ? void 0 : SeededFragmentFromJSON(json["fragment"]),
    "directory": !exists(json, "directory") ? void 0 : json["directory"],
    "metadata": !exists(json, "metadata") ? void 0 : SeededAssetMetadataFromJSON(json["metadata"]),
    "filters": !exists(json, "filters") ? void 0 : TLPDirectedDiscoveryFiltersFromJSON(json["filters"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/DiscoveredAssets.ts
function DiscoveredAssetsFromJSON(json) {
  return DiscoveredAssetsFromJSONTyped(json, false);
}
function DiscoveredAssetsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "application": json["application"],
    "iterable": json["iterable"].map(DiscoveredAssetFromJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/DiscoveredHtmlWebpage.ts
function DiscoveredHtmlWebpageFromJSON(json) {
  return DiscoveredHtmlWebpageFromJSONTyped(json, false);
}
function DiscoveredHtmlWebpageFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "assets": DiscoveredAssetsFromJSON(json["assets"]),
    "url": json["url"]
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/DiscoveredHtmlWebpages.ts
function DiscoveredHtmlWebpagesFromJSON(json) {
  return DiscoveredHtmlWebpagesFromJSONTyped(json, false);
}
function DiscoveredHtmlWebpagesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(DiscoveredHtmlWebpageFromJSON),
    "application": json["application"]
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededTag.ts
function SeededTagFromJSON(json) {
  return SeededTagFromJSONTyped(json, false);
}
function SeededTagFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "text": json["text"],
    "asset": !exists(json, "asset") ? void 0 : json["asset"],
    "mechanism": !exists(json, "mechanism") ? void 0 : MechanismEnumFromJSON(json["mechanism"]),
    "category": !exists(json, "category") ? void 0 : TagCategoryEnumFromJSON(json["category"]),
    "person": !exists(json, "person") ? void 0 : json["person"]
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/DiscoveredRelatedTag.ts
function DiscoveredRelatedTagFromJSON(json) {
  return DiscoveredRelatedTagFromJSONTyped(json, false);
}
function DiscoveredRelatedTagFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "seed": SeededTagFromJSON(json["seed"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/DiscoveredRelatedTags.ts
function DiscoveredRelatedTagsFromJSON(json) {
  return DiscoveredRelatedTagsFromJSONTyped(json, false);
}
function DiscoveredRelatedTagsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "application": json["application"],
    "iterable": json["iterable"].map(DiscoveredRelatedTagFromJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededSensitive.ts
function SeededSensitiveFromJSON(json) {
  return SeededSensitiveFromJSONTyped(json, false);
}
function SeededSensitiveFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "asset": json["asset"],
    "text": json["text"],
    "mechanism": !exists(json, "mechanism") ? void 0 : MechanismEnumFromJSON(json["mechanism"]),
    "category": SensitiveCategoryEnumFromJSON(json["category"]),
    "severity": SensitiveSeverityEnumFromJSON(json["severity"]),
    "name": json["name"],
    "description": json["description"],
    "metadata": !exists(json, "metadata") ? void 0 : SensitiveMetadataFromJSON(json["metadata"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/DiscoveredSensitive.ts
function DiscoveredSensitiveFromJSON(json) {
  return DiscoveredSensitiveFromJSONTyped(json, false);
}
function DiscoveredSensitiveFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "seed": SeededSensitiveFromJSON(json["seed"]),
    "text": json["text"]
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/DiscoveredSensitives.ts
function DiscoveredSensitivesFromJSON(json) {
  return DiscoveredSensitivesFromJSONTyped(json, false);
}
function DiscoveredSensitivesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(DiscoveredSensitiveFromJSON),
    "application": json["application"]
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/EmbeddingsSearchOptionsEmbeddingTypeEnum.ts
function EmbeddingsSearchOptionsEmbeddingTypeEnumToJSON(value) {
  return value;
}

// ../generated_runtime/sdk/http/typescript/core/models/EmbeddingsSearchOptions.ts
function EmbeddingsSearchOptionsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "type": EmbeddingsSearchOptionsEmbeddingTypeEnumToJSON(value.type),
    "similarity": value.similarity
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ExportedAsset.ts
function ExportedAssetFromJSON(json) {
  return ExportedAssetFromJSONTyped(json, false);
}
function ExportedAssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "name": json["name"],
    "description": json["description"],
    "created": GroupedTimestampFromJSON(json["created"]),
    "raw": FileFormatFromJSON(json["raw"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FilePickerInput.ts
function FilePickerInputToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "allowedExtensions": value.allowedExtensions,
    "allowMultiple": value.allowMultiple
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FlattenedApplication.ts
function FlattenedApplicationFromJSON(json) {
  return FlattenedApplicationFromJSONTyped(json, false);
}
function FlattenedApplicationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "name": ApplicationNameEnumFromJSON(json["name"]),
    "version": json["version"],
    "platform": PlatformEnumFromJSON(json["platform"]),
    "onboarded": json["onboarded"],
    "privacy": PrivacyEnumFromJSON(json["privacy"]),
    "capabilities": !exists(json, "capabilities") ? void 0 : CapabilitiesEnumFromJSON(json["capabilities"]),
    "mechanism": !exists(json, "mechanism") ? void 0 : MechanismEnumFromJSON(json["mechanism"]),
    "automaticUnload": !exists(json, "automaticUnload") ? void 0 : json["automaticUnload"]
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FormatReclassification.ts
function FormatReclassificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "ext": ClassificationSpecificEnumToJSON(value.ext),
    "format": FormatToJSON(value.format)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/FullTextSearchOptions.ts
function FullTextSearchOptionsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "similarity": value.similarity,
    "exact": value.exact
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/InactiveOSServerApplet.ts
function InactiveOSServerAppletToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "parent": ApplicationToJSON(value.parent),
    "port": value.port,
    "type": OSAppletEnumToJSON(value.type)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/InteractedAssetInteractions.ts
function InteractedAssetInteractionsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "viewed": value.viewed,
    "touched": value.touched,
    "scrolled": value.scrolled
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/InteractedAsset.ts
function InteractedAssetToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "asset": value.asset,
    "interactions": InteractedAssetInteractionsToJSON(value.interactions)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/InteractedAssets.ts
function InteractedAssetsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(InteractedAssetToJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededAssetEnrichment.ts
function SeededAssetEnrichmentFromJSON(json) {
  return SeededAssetEnrichmentFromJSONTyped(json, false);
}
function SeededAssetEnrichmentFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "tags": !exists(json, "tags") ? void 0 : json["tags"],
    "websites": !exists(json, "websites") ? void 0 : json["websites"],
    "persons": !exists(json, "persons") ? void 0 : json["persons"],
    "hints": !exists(json, "hints") ? void 0 : json["hints"]
  };
}
function SeededAssetEnrichmentToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "tags": value.tags,
    "websites": value.websites,
    "persons": value.persons,
    "hints": value.hints
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededClassification.ts
function SeededClassificationFromJSON(json) {
  return SeededClassificationFromJSONTyped(json, false);
}
function SeededClassificationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "generic": !exists(json, "generic") ? void 0 : ClassificationGenericEnumFromJSON(json["generic"]),
    "specific": !exists(json, "specific") ? void 0 : ClassificationSpecificEnumFromJSON(json["specific"]),
    "rendering": !exists(json, "rendering") ? void 0 : ClassificationRenderingEnumFromJSON(json["rendering"])
  };
}
function SeededClassificationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "generic": ClassificationGenericEnumToJSON(value.generic),
    "specific": ClassificationSpecificEnumToJSON(value.specific),
    "rendering": ClassificationRenderingEnumToJSON(value.rendering)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededFormat.ts
function SeededFormatFromJSON(json) {
  return SeededFormatFromJSONTyped(json, false);
}
function SeededFormatFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "file": !exists(json, "file") ? void 0 : SeededFileFromJSON(json["file"]),
    "fragment": !exists(json, "fragment") ? void 0 : SeededFragmentFromJSON(json["fragment"]),
    "classification": !exists(json, "classification") ? void 0 : SeededClassificationFromJSON(json["classification"])
  };
}
function SeededFormatToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "file": SeededFileToJSON(value.file),
    "fragment": SeededFragmentToJSON(value.fragment),
    "classification": SeededClassificationToJSON(value.classification)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededAsset.ts
function SeededAssetFromJSON(json) {
  return SeededAssetFromJSONTyped(json, false);
}
function SeededAssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "metadata": !exists(json, "metadata") ? void 0 : SeededAssetMetadataFromJSON(json["metadata"]),
    "application": ApplicationFromJSON(json["application"]),
    "format": SeededFormatFromJSON(json["format"]),
    "discovered": !exists(json, "discovered") ? void 0 : json["discovered"],
    "available": !exists(json, "available") ? void 0 : AvailableFormatsFromJSON(json["available"]),
    "pseudo": !exists(json, "pseudo") ? void 0 : json["pseudo"],
    "enrichment": !exists(json, "enrichment") ? void 0 : SeededAssetEnrichmentFromJSON(json["enrichment"]),
    "demo": !exists(json, "demo") ? void 0 : json["demo"]
  };
}
function SeededAssetToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "metadata": SeededAssetMetadataToJSON(value.metadata),
    "application": ApplicationToJSON(value.application),
    "format": SeededFormatToJSON(value.format),
    "discovered": value.discovered,
    "available": AvailableFormatsToJSON(value.available),
    "pseudo": value.pseudo,
    "enrichment": SeededAssetEnrichmentToJSON(value.enrichment),
    "demo": value.demo
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Seed.ts
var SeedTypeEnum = {
  Format: "SEEDED_FORMAT",
  Asset: "SEEDED_ASSET"
};
function SeedFromJSON(json) {
  return SeedFromJSONTyped(json, false);
}
function SeedFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "asset": !exists(json, "asset") ? void 0 : SeededAssetFromJSON(json["asset"]),
    "person": !exists(json, "person") ? void 0 : SeededPersonFromJSON(json["person"]),
    "anchor": !exists(json, "anchor") ? void 0 : SeededAnchorFromJSON(json["anchor"]),
    "website": !exists(json, "website") ? void 0 : SeededWebsiteFromJSON(json["website"]),
    "type": !exists(json, "type") ? void 0 : json["type"]
  };
}
function SeedToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "asset": SeededAssetToJSON(value.asset),
    "person": SeededPersonToJSON(value.person),
    "anchor": SeededAnchorToJSON(value.anchor),
    "website": SeededWebsiteToJSON(value.website),
    "type": value.type
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededGitHubGistDistribution.ts
function SeededGitHubGistDistributionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "recipients": RecipientsToJSON(value.recipients),
    "public": value._public,
    "description": value.description,
    "name": value.name
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededGitHubDistribution.ts
function SeededGitHubDistributionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "gist": SeededGitHubGistDistributionToJSON(value.gist)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededDistribution.ts
function SeededDistributionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "mailgun": MailgunDistributionToJSON(value.mailgun),
    "github": SeededGitHubDistributionToJSON(value.github)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededDistributions.ts
function SeededDistributionsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(SeededDistributionToJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededUser.ts
function SeededUserToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "emails": value.emails
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Linkify.ts
function LinkifyToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "seed": SeedToJSON(value.seed),
    "asset": AssetToJSON(value.asset),
    "users": value.users === void 0 ? void 0 : value.users.map(SeededUserToJSON),
    "access": AccessEnumToJSON(value.access),
    "distributions": SeededDistributionsToJSON(value.distributions)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/LinkifyMultiple.ts
function LinkifyMultipleToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "assets": value.assets,
    "users": value.users === void 0 ? void 0 : value.users.map(SeededUserToJSON),
    "access": AccessEnumToJSON(value.access),
    "name": value.name
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ModelDeleteCacheInput.ts
function ModelDeleteCacheInputToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ModelDeleteCacheOutput.ts
function ModelDeleteCacheOutputFromJSON(json) {
  return ModelDeleteCacheOutputFromJSONTyped(json, false);
}
function ModelDeleteCacheOutputFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "model": ReferencedModelFromJSON(json["model"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ModelDownloadProgress.ts
function ModelDownloadProgressFromJSON(json) {
  return ModelDownloadProgressFromJSONTyped(json, false);
}
function ModelDownloadProgressFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "status": !exists(json, "status") ? void 0 : ModelDownloadProgressStatusEnumFromJSON(json["status"]),
    "percentage": !exists(json, "percentage") ? void 0 : json["percentage"]
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Models.ts
function ModelsFromJSON(json) {
  return ModelsFromJSONTyped(json, false);
}
function ModelsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(ModelFromJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/OSDeviceCPUHardwareInformation.ts
function OSDeviceCPUHardwareInformationFromJSON(json) {
  return OSDeviceCPUHardwareInformationFromJSONTyped(json, false);
}
function OSDeviceCPUHardwareInformationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "name": !exists(json, "name") ? void 0 : json["name"],
    "memory": !exists(json, "memory") ? void 0 : json["memory"]
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/OSDeviceDependenciesInformation.ts
function OSDeviceDependenciesInformationFromJSON(json) {
  return OSDeviceDependenciesInformationFromJSONTyped(json, false);
}
function OSDeviceDependenciesInformationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "vulkan": json["vulkan"]
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/OSDeviceGPUHardwareCapabilitiesInformation.ts
function OSDeviceGPUHardwareCapabilitiesInformationFromJSON(json) {
  return OSDeviceGPUHardwareCapabilitiesInformationFromJSONTyped(json, false);
}
function OSDeviceGPUHardwareCapabilitiesInformationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "llm": !exists(json, "llm") ? void 0 : json["llm"]
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/OSDeviceGPUHardwareInformation.ts
function OSDeviceGPUHardwareInformationFromJSON(json) {
  return OSDeviceGPUHardwareInformationFromJSONTyped(json, false);
}
function OSDeviceGPUHardwareInformationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "name": !exists(json, "name") ? void 0 : json["name"],
    "memory": !exists(json, "memory") ? void 0 : json["memory"],
    "capabilities": !exists(json, "capabilities") ? void 0 : OSDeviceGPUHardwareCapabilitiesInformationFromJSON(json["capabilities"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/OSDeviceHardwareInformation.ts
function OSDeviceHardwareInformationFromJSON(json) {
  return OSDeviceHardwareInformationFromJSONTyped(json, false);
}
function OSDeviceHardwareInformationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "cpu": !exists(json, "cpu") ? void 0 : OSDeviceCPUHardwareInformationFromJSON(json["cpu"]),
    "gpu": !exists(json, "gpu") ? void 0 : OSDeviceGPUHardwareInformationFromJSON(json["gpu"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/OSDeviceInformationReturnable.ts
function OSDeviceInformationReturnableFromJSON(json) {
  return OSDeviceInformationReturnableFromJSONTyped(json, false);
}
function OSDeviceInformationReturnableFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "dependencies": !exists(json, "dependencies") ? void 0 : OSDeviceDependenciesInformationFromJSON(json["dependencies"]),
    "name": !exists(json, "name") ? void 0 : json["name"],
    "version": !exists(json, "version") ? void 0 : json["version"],
    "hardware": !exists(json, "hardware") ? void 0 : OSDeviceHardwareInformationFromJSON(json["hardware"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/OSFileStreamingReadProgress.ts
function OSFileStreamingReadProgressFromJSON(json) {
  return OSFileStreamingReadProgressFromJSONTyped(json, false);
}
function OSFileStreamingReadProgressFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "total": ByteDescriptorFromJSON(json["total"]),
    "transferred": ByteDescriptorFromJSON(json["transferred"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/OSFileStreamingRead.ts
function OSFileStreamingReadFromJSON(json) {
  return OSFileStreamingReadFromJSONTyped(json, false);
}
function OSFileStreamingReadFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "status": ModelDownloadProgressStatusEnumFromJSON(json["status"]),
    "percentage": !exists(json, "percentage") ? void 0 : json["percentage"],
    "path": json["path"],
    "id": json["id"],
    "bytes": !exists(json, "bytes") ? void 0 : TransferableBytesFromJSON(json["bytes"]),
    "progress": !exists(json, "progress") ? void 0 : OSFileStreamingReadProgressFromJSON(json["progress"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/OSFileStreamingReadAttempt.ts
function OSFileStreamingReadAttemptToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "path": value.path
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/OSProcessingPermissions.ts
function OSProcessingPermissionsFromJSON(json) {
  return OSProcessingPermissionsFromJSONTyped(json, false);
}
function OSProcessingPermissionsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "vision": !exists(json, "vision") ? void 0 : json["vision"],
    "accessibility": !exists(json, "accessibility") ? void 0 : json["accessibility"]
  };
}
function OSProcessingPermissionsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "vision": value.vision,
    "accessibility": value.accessibility
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/OSPermissions.ts
function OSPermissionsFromJSON(json) {
  return OSPermissionsFromJSONTyped(json, false);
}
function OSPermissionsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "processing": !exists(json, "processing") ? void 0 : OSProcessingPermissionsFromJSON(json["processing"])
  };
}
function OSPermissionsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "processing": OSProcessingPermissionsToJSON(value.processing)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TrackedSummaryTotals.ts
function TrackedSummaryTotalsFromJSON(json) {
  return TrackedSummaryTotalsFromJSONTyped(json, false);
}
function TrackedSummaryTotalsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "assets": json["assets"],
    "tags": json["tags"],
    "websites": json["websites"],
    "persons": json["persons"],
    "sensitives": json["sensitives"],
    "shares": json["shares"],
    "copilotSends": json["copilot_sends"],
    "copilotReceives": json["copilot_receives"],
    "copilotSessions": json["copilot_sessions"],
    "copilotConversations": json["copilot_conversations"],
    "productivityScore": json["productivity_score"],
    "searches": json["searches"],
    "references": json["references"],
    "reuses": json["reuses"],
    "anchorFiles": json["anchor_files"],
    "anchorFolders": json["anchor_folders"],
    "isrReports": json["isr_reports"]
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/OSServerMetadata.ts
function OSServerMetadataFromJSON(json) {
  return OSServerMetadataFromJSONTyped(json, false);
}
function OSServerMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "totals": !exists(json, "totals") ? void 0 : TrackedSummaryTotalsFromJSON(json["totals"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/OSServerSettings.ts
function OSServerSettingsFromJSON(json) {
  return OSServerSettingsFromJSONTyped(json, false);
}
function OSServerSettingsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "autoboot": !exists(json, "autoboot") ? void 0 : json["autoboot"]
  };
}
function OSServerSettingsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "autoboot": value.autoboot
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/UpdatingStatusEnum.ts
var UpdatingStatusEnum = {
  ReadyToRestart: "READY_TO_RESTART",
  Available: "AVAILABLE",
  Downloading: "DOWNLOADING",
  Unknown: "UNKNOWN",
  UpToDate: "UP_TO_DATE",
  ReinstallRequired: "REINSTALL_REQUIRED",
  ContactSupport: "CONTACT_SUPPORT"
};
function UpdatingStatusEnumFromJSON(json) {
  return UpdatingStatusEnumFromJSONTyped(json, false);
}
function UpdatingStatusEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// ../generated_runtime/sdk/http/typescript/core/models/OSServerUpdateStatus.ts
function OSServerUpdateStatusFromJSON(json) {
  return OSServerUpdateStatusFromJSONTyped(json, false);
}
function OSServerUpdateStatusFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "status": UpdatingStatusEnumFromJSON(json["status"]),
    "updated": !exists(json, "updated") ? void 0 : GroupedTimestampFromJSON(json["updated"]),
    "percentage": !exists(json, "percentage") ? void 0 : json["percentage"]
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Seeds.ts
function SeedsFromJSON(json) {
  return SeedsFromJSONTyped(json, false);
}
function SeedsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(SeedFromJSON)
  };
}
function SeedsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(SeedToJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededModel.ts
function SeededModelToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "version": value.version,
    "created": GroupedTimestampToJSON(value.created),
    "name": value.name,
    "description": value.description,
    "cloud": value.cloud,
    "type": ModelTypeEnumToJSON(value.type),
    "usage": ModelUsageEnumToJSON(value.usage),
    "bytes": ByteDescriptorToJSON(value.bytes),
    "ram": ByteDescriptorToJSON(value.ram),
    "quantization": value.quantization,
    "foundation": ModelFoundationEnumToJSON(value.foundation),
    "downloaded": value.downloaded,
    "unique": value.unique,
    "parameters": value.parameters,
    "provider": ExternalMLProviderEnumToJSON(value.provider),
    "cpu": value.cpu,
    "maxTokens": ModelMaxTokensToJSON(value.maxTokens),
    "custom": value.custom,
    "capabilities": ModelCapabilitiesToJSON(value.capabilities)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/PseudoAssets.ts
function PseudoAssetsFromJSON(json) {
  return PseudoAssetsFromJSONTyped(json, false);
}
function PseudoAssetsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "identifiers": !exists(json, "identifiers") ? void 0 : FlattenedAssetsFromJSON(json["identifiers"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTAgentRelatedRoutes.ts
function QGPTAgentRelatedRoutesFromJSON(json) {
  return QGPTAgentRelatedRoutesFromJSONTyped(json, false);
}
function QGPTAgentRelatedRoutesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "people": !exists(json, "people") ? void 0 : json["people"]
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTAgentRoutes.ts
function QGPTAgentRoutesFromJSON(json) {
  return QGPTAgentRoutesFromJSONTyped(json, false);
}
function QGPTAgentRoutesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "related": !exists(json, "related") ? void 0 : QGPTAgentRelatedRoutesFromJSON(json["related"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTConversationMessage.ts
function QGPTConversationMessageToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "text": value.text,
    "role": QGPTConversationMessageRoleEnumToJSON(value.role),
    "timestamp": GroupedTimestampToJSON(value.timestamp)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTConversation.ts
function QGPTConversationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable === void 0 ? void 0 : value.iterable.map(QGPTConversationMessageToJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTQuestionAnswer.ts
function QGPTQuestionAnswerFromJSON(json) {
  return QGPTQuestionAnswerFromJSONTyped(json, false);
}
function QGPTQuestionAnswerFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "score": json["score"],
    "text": json["text"]
  };
}
function QGPTQuestionAnswerToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "score": value.score,
    "text": value.text
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/RelevantQGPTSeed.ts
function RelevantQGPTSeedFromJSON(json) {
  return RelevantQGPTSeedFromJSONTyped(json, false);
}
function RelevantQGPTSeedFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": !exists(json, "id") ? void 0 : json["id"],
    "seed": !exists(json, "seed") ? void 0 : SeedFromJSON(json["seed"]),
    "path": !exists(json, "path") ? void 0 : json["path"],
    "anchor": !exists(json, "anchor") ? void 0 : ReferencedAnchorFromJSON(json["anchor"]),
    "asset": !exists(json, "asset") ? void 0 : ReferencedAssetFromJSON(json["asset"])
  };
}
function RelevantQGPTSeedToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "seed": SeedToJSON(value.seed),
    "path": value.path,
    "anchor": ReferencedAnchorToJSON(value.anchor),
    "asset": ReferencedAssetToJSON(value.asset)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/RelevantQGPTSeeds.ts
function RelevantQGPTSeedsFromJSON(json) {
  return RelevantQGPTSeedsFromJSONTyped(json, false);
}
function RelevantQGPTSeedsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(RelevantQGPTSeedFromJSON)
  };
}
function RelevantQGPTSeedsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(RelevantQGPTSeedToJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTHintsInput.ts
function QGPTHintsInputToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "query": value.query,
    "answer": QGPTQuestionAnswerToJSON(value.answer),
    "relevant": RelevantQGPTSeedsToJSON(value.relevant),
    "application": value.application,
    "model": value.model
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTPersonsRelatedInput.ts
function QGPTPersonsRelatedInputToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "seed": SeedToJSON(value.seed),
    "conversation": QGPTConversationToJSON(value.conversation),
    "application": value.application,
    "model": value.model
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTPersonsRelatedOutput.ts
function QGPTPersonsRelatedOutputFromJSON(json) {
  return QGPTPersonsRelatedOutputFromJSONTyped(json, false);
}
function QGPTPersonsRelatedOutputFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "persons": PersonsFromJSON(json["persons"]),
    "explanations": !exists(json, "explanations") ? void 0 : json["explanations"]
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTQuestionAnswers.ts
function QGPTQuestionAnswersFromJSON(json) {
  return QGPTQuestionAnswersFromJSONTyped(json, false);
}
function QGPTQuestionAnswersFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(QGPTQuestionAnswerFromJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTQuestionInput.ts
function QGPTQuestionInputToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "relevant": RelevantQGPTSeedsToJSON(value.relevant),
    "query": value.query,
    "application": value.application,
    "model": value.model,
    "messages": FlattenedConversationMessagesToJSON(value.messages),
    "pipeline": QGPTPromptPipelineToJSON(value.pipeline),
    "temporal": TemporalRangeGroundingToJSON(value.temporal)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTQuestionOutput.ts
function QGPTQuestionOutputFromJSON(json) {
  return QGPTQuestionOutputFromJSONTyped(json, false);
}
function QGPTQuestionOutputFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "answers": QGPTQuestionAnswersFromJSON(json["answers"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTRelevanceInputOptions.ts
function QGPTRelevanceInputOptionsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "database": value.database,
    "question": value.question,
    "pipeline": QGPTPromptPipelineToJSON(value.pipeline)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTRelevanceInput.ts
function QGPTRelevanceInputToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "query": value.query,
    "paths": value.paths,
    "seeds": SeedsToJSON(value.seeds),
    "assets": FlattenedAssetsToJSON(value.assets),
    "messages": FlattenedConversationMessagesToJSON(value.messages),
    "options": QGPTRelevanceInputOptionsToJSON(value.options),
    "application": value.application,
    "model": value.model,
    "temporal": TemporalRangeGroundingToJSON(value.temporal),
    "anchors": FlattenedAnchorsToJSON(value.anchors)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTRelevanceOutput.ts
function QGPTRelevanceOutputFromJSON(json) {
  return QGPTRelevanceOutputFromJSONTyped(json, false);
}
function QGPTRelevanceOutputFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "answer": !exists(json, "answer") ? void 0 : QGPTQuestionOutputFromJSON(json["answer"]),
    "relevant": RelevantQGPTSeedsFromJSON(json["relevant"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTRepromptInput.ts
function QGPTRepromptInputToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "query": value.query,
    "conversation": QGPTConversationToJSON(value.conversation),
    "application": value.application,
    "model": value.model,
    "pipeline": QGPTPromptPipelineToJSON(value.pipeline)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTRepromptOutput.ts
function QGPTRepromptOutputFromJSON(json) {
  return QGPTRepromptOutputFromJSONTyped(json, false);
}
function QGPTRepromptOutputFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "query": json["query"]
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTStreamEnum.ts
function QGPTStreamEnumFromJSON(json) {
  return QGPTStreamEnumFromJSONTyped(json, false);
}
function QGPTStreamEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTStreamInput.ts
function QGPTStreamInputToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "relevance": QGPTRelevanceInputToJSON(value.relevance),
    "question": QGPTQuestionInputToJSON(value.question),
    "request": value.request,
    "conversation": value.conversation,
    "stop": value.stop,
    "reset": value.reset,
    "agent": value.agent
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TextuallyExtractedMaterial.ts
function TextuallyExtractedMaterialFromJSON(json) {
  return TextuallyExtractedMaterialFromJSONTyped(json, false);
}
function TextuallyExtractedMaterialFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "match": TextLocationFromJSON(json["match"]),
    "websites": !exists(json, "websites") ? void 0 : FlattenedWebsitesFromJSON(json["websites"]),
    "anchors": !exists(json, "anchors") ? void 0 : FlattenedAnchorsFromJSON(json["anchors"]),
    "persons": !exists(json, "persons") ? void 0 : FlattenedPersonsFromJSON(json["persons"]),
    "seeds": !exists(json, "seeds") ? void 0 : SeedsFromJSON(json["seeds"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TextuallyExtractedMaterials.ts
function TextuallyExtractedMaterialsFromJSON(json) {
  return TextuallyExtractedMaterialsFromJSONTyped(json, false);
}
function TextuallyExtractedMaterialsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(TextuallyExtractedMaterialFromJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTStreamedOutputExtractedTextualMaterials.ts
function QGPTStreamedOutputExtractedTextualMaterialsFromJSON(json) {
  return QGPTStreamedOutputExtractedTextualMaterialsFromJSONTyped(json, false);
}
function QGPTStreamedOutputExtractedTextualMaterialsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "message": !exists(json, "message") ? void 0 : TextuallyExtractedMaterialsFromJSON(json["message"]),
    "workstream": !exists(json, "workstream") ? void 0 : TextuallyExtractedMaterialsFromJSON(json["workstream"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTStreamedOutputExtractedMaterials.ts
function QGPTStreamedOutputExtractedMaterialsFromJSON(json) {
  return QGPTStreamedOutputExtractedMaterialsFromJSONTyped(json, false);
}
function QGPTStreamedOutputExtractedMaterialsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "textual": !exists(json, "textual") ? void 0 : QGPTStreamedOutputExtractedTextualMaterialsFromJSON(json["textual"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/QGPTStreamOutput.ts
function QGPTStreamOutputFromJSON(json) {
  return QGPTStreamOutputFromJSONTyped(json, false);
}
function QGPTStreamOutputFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "request": !exists(json, "request") ? void 0 : json["request"],
    "relevance": !exists(json, "relevance") ? void 0 : QGPTRelevanceOutputFromJSON(json["relevance"]),
    "question": !exists(json, "question") ? void 0 : QGPTQuestionOutputFromJSON(json["question"]),
    "status": !exists(json, "status") ? void 0 : QGPTStreamEnumFromJSON(json["status"]),
    "conversation": json["conversation"],
    "statusCode": !exists(json, "statusCode") ? void 0 : json["statusCode"],
    "errorMessage": !exists(json, "errorMessage") ? void 0 : json["errorMessage"],
    "agentRoutes": !exists(json, "agentRoutes") ? void 0 : QGPTAgentRoutesFromJSON(json["agentRoutes"]),
    "extracted": !exists(json, "extracted") ? void 0 : QGPTStreamedOutputExtractedMaterialsFromJSON(json["extracted"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ReuseReaction.ts
function ReuseReactionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "asset": value.asset
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededConnectorAsset.ts
function SeededConnectorAssetFromJSON(json) {
  return SeededConnectorAssetFromJSONTyped(json, false);
}
function SeededConnectorAssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "metadata": !exists(json, "metadata") ? void 0 : SeededAssetMetadataFromJSON(json["metadata"]),
    "format": SeededFormatFromJSON(json["format"])
  };
}
function SeededConnectorAssetToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "metadata": SeededAssetMetadataToJSON(value.metadata),
    "format": SeededFormatToJSON(value.format)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededConnectorCreation.ts
function SeededConnectorCreationFromJSON(json) {
  return SeededConnectorCreationFromJSONTyped(json, false);
}
function SeededConnectorCreationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "asset": !exists(json, "asset") ? void 0 : SeededConnectorAssetFromJSON(json["asset"])
  };
}
function SeededConnectorCreationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "asset": SeededConnectorAssetToJSON(value.asset)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Reaction.ts
function ReactionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "save": value.save,
    "reuse": ReuseReactionToJSON(value.reuse),
    "seed": SeededConnectorCreationToJSON(value.seed)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ReferencedApplication.ts
function ReferencedApplicationFromJSON(json) {
  return ReferencedApplicationFromJSONTyped(json, false);
}
function ReferencedApplicationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "id": json["id"],
    "reference": !exists(json, "reference") ? void 0 : FlattenedApplicationFromJSON(json["reference"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ReferencedUser.ts
function ReferencedUserToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "id": value.id,
    "reference": FlattenedUserProfileToJSON(value.reference)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ReturnedUserProfile.ts
function ReturnedUserProfileFromJSON(json) {
  return ReturnedUserProfileFromJSONTyped(json, false);
}
function ReturnedUserProfileFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "user": !exists(json, "user") ? void 0 : UserProfileFromJSON(json["user"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/ReuseSuggestion.ts
function ReuseSuggestionFromJSON(json) {
  return ReuseSuggestionFromJSONTyped(json, false);
}
function ReuseSuggestionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "suggested": json["suggested"],
    "assets": AssetsFromJSON(json["assets"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SaveSuggestion.ts
function SaveSuggestionFromJSON(json) {
  return SaveSuggestionFromJSONTyped(json, false);
}
function SaveSuggestionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "suggested": json["suggested"]
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SearchEngines.ts
function SearchEnginesToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(SearchEngineToJSON),
    "type": FilterOperationTypeEnumToJSON(value.type)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TemporalSearchOptions.ts
function TemporalSearchOptionsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "created": AnonymousTemporalRangeToJSON(value.created),
    "updated": AnonymousTemporalRangeToJSON(value.updated)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/WorkstreamPatternEngineSource.ts
function WorkstreamPatternEngineSourceToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "name": value.name
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/WorkstreamPatternEngineSources.ts
function WorkstreamPatternEngineSourcesToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(WorkstreamPatternEngineSourceToJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/WorkstreamSearchOptions.ts
function WorkstreamSearchOptionsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "sources": WorkstreamPatternEngineSourcesToJSON(value.sources)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SearchEngine.ts
function SearchEngineToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "query": value.query,
    "embeddings": EmbeddingsSearchOptionsToJSON(value.embeddings),
    "full_text": FullTextSearchOptionsToJSON(value.fullText),
    "temporal": TemporalSearchOptionsToJSON(value.temporal),
    "workstream": WorkstreamSearchOptionsToJSON(value.workstream),
    "operations": SearchEnginesToJSON(value.operations)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SearchInput.ts
function SearchInputToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "engines": SearchEnginesToJSON(value.engines)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SearchedAnchorPoint.ts
function SearchedAnchorPointFromJSON(json) {
  return SearchedAnchorPointFromJSONTyped(json, false);
}
function SearchedAnchorPointFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "point": !exists(json, "point") ? void 0 : AnchorPointFromJSON(json["point"]),
    "exact": json["exact"],
    "similarity": json["similarity"],
    "temporal": !exists(json, "temporal") ? void 0 : json["temporal"],
    "identifier": json["identifier"]
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SearchedAnchorPoints.ts
function SearchedAnchorPointsFromJSON(json) {
  return SearchedAnchorPointsFromJSONTyped(json, false);
}
function SearchedAnchorPointsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(SearchedAnchorPointFromJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SearchedAnchor.ts
function SearchedAnchorFromJSON(json) {
  return SearchedAnchorFromJSONTyped(json, false);
}
function SearchedAnchorFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "anchor": !exists(json, "anchor") ? void 0 : AnchorFromJSON(json["anchor"]),
    "points": !exists(json, "points") ? void 0 : SearchedAnchorPointsFromJSON(json["points"]),
    "exact": json["exact"],
    "similarity": json["similarity"],
    "temporal": !exists(json, "temporal") ? void 0 : json["temporal"],
    "identifier": json["identifier"]
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SearchedAnchors.ts
function SearchedAnchorsFromJSON(json) {
  return SearchedAnchorsFromJSONTyped(json, false);
}
function SearchedAnchorsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(SearchedAnchorFromJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SearchedAnnotation.ts
function SearchedAnnotationFromJSON(json) {
  return SearchedAnnotationFromJSONTyped(json, false);
}
function SearchedAnnotationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "annotation": !exists(json, "annotation") ? void 0 : AnnotationFromJSON(json["annotation"]),
    "exact": json["exact"],
    "similarity": json["similarity"],
    "temporal": !exists(json, "temporal") ? void 0 : json["temporal"],
    "identifier": json["identifier"]
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SearchedAnnotations.ts
function SearchedAnnotationsFromJSON(json) {
  return SearchedAnnotationsFromJSONTyped(json, false);
}
function SearchedAnnotationsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(SearchedAnnotationFromJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SearchedConversationMessage.ts
function SearchedConversationMessageFromJSON(json) {
  return SearchedConversationMessageFromJSONTyped(json, false);
}
function SearchedConversationMessageFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "message": !exists(json, "message") ? void 0 : ConversationMessageFromJSON(json["message"]),
    "exact": json["exact"],
    "similarity": json["similarity"],
    "temporal": !exists(json, "temporal") ? void 0 : json["temporal"],
    "identifier": json["identifier"]
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SearchedConversationMessages.ts
function SearchedConversationMessagesFromJSON(json) {
  return SearchedConversationMessagesFromJSONTyped(json, false);
}
function SearchedConversationMessagesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(SearchedConversationMessageFromJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SearchedConversation.ts
function SearchedConversationFromJSON(json) {
  return SearchedConversationFromJSONTyped(json, false);
}
function SearchedConversationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "conversation": !exists(json, "conversation") ? void 0 : ConversationFromJSON(json["conversation"]),
    "messages": !exists(json, "messages") ? void 0 : SearchedConversationMessagesFromJSON(json["messages"]),
    "annotations": !exists(json, "annotations") ? void 0 : SearchedAnnotationsFromJSON(json["annotations"]),
    "exact": json["exact"],
    "similarity": json["similarity"],
    "temporal": !exists(json, "temporal") ? void 0 : json["temporal"],
    "identifier": json["identifier"]
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SearchedConversations.ts
function SearchedConversationsFromJSON(json) {
  return SearchedConversationsFromJSONTyped(json, false);
}
function SearchedConversationsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(SearchedConversationFromJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededAccessor.ts
function SeededAccessorToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "os": value.os,
    "user": FlattenedUserProfileToJSON(value.user),
    "share": value.share
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededActivity.ts
function SeededActivityToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "event": SeededConnectorTrackingToJSON(value.event),
    "application": ApplicationToJSON(value.application),
    "asset": ReferencedAssetToJSON(value.asset),
    "user": ReferencedUserToJSON(value.user),
    "format": ReferencedFormatToJSON(value.format),
    "mechanism": MechanismEnumToJSON(value.mechanism),
    "conversation": ReferencedConversationToJSON(value.conversation)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededAssetTags.ts
function SeededAssetTagsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "iterable": value.iterable.map(SeededAssetTagToJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededAssetsRecommendation.ts
function SeededAssetsRecommendationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "assets": AssetsToJSON(value.assets),
    "interactions": InteractedAssetsToJSON(value.interactions)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededTrackedApplication.ts
function SeededTrackedApplicationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "name": ApplicationNameEnumToJSON(value.name),
    "version": value.version,
    "platform": PlatformEnumToJSON(value.platform),
    "capabilities": CapabilitiesEnumToJSON(value.capabilities),
    "privacy": PrivacyEnumToJSON(value.privacy),
    "automaticUnload": value.automaticUnload
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededConnectorConnection.ts
function SeededConnectorConnectionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "application": SeededTrackedApplicationToJSON(value.application)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededConversationMessage.ts
function SeededConversationMessageToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "created": GroupedTimestampToJSON(value.created),
    "model": ModelToJSON(value.model),
    "fragment": FragmentFormatToJSON(value.fragment),
    "conversation": ReferencedConversationToJSON(value.conversation),
    "sentiment": ConversationMessageSentimentEnumToJSON(value.sentiment),
    "role": QGPTConversationMessageRoleEnumToJSON(value.role)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededConversation.ts
function SeededConversationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "name": value.name,
    "favorited": value.favorited,
    "application": ApplicationToJSON(value.application),
    "annotations": value.annotations === void 0 ? void 0 : value.annotations.map(SeededAnnotationToJSON),
    "messages": value.messages === void 0 ? void 0 : value.messages.map(SeededConversationMessageToJSON),
    "model": ReferencedModelToJSON(value.model),
    "assets": FlattenedAssetsToJSON(value.assets),
    "websites": FlattenedWebsitesToJSON(value.websites),
    "anchors": value.anchors === void 0 ? void 0 : value.anchors.map(SeededAnchorToJSON),
    "type": ConversationTypeEnumToJSON(value.type),
    "pipeline": QGPTPromptPipelineToJSON(value.pipeline),
    "demo": value.demo
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededDiscoverableAsset.ts
function SeededDiscoverableAssetToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "file": SeededFileToJSON(value.file),
    "fragment": SeededFragmentToJSON(value.fragment),
    "directory": value.directory,
    "filters": TLPDirectedDiscoveryFiltersToJSON(value.filters)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededDiscoverableAssets.ts
function SeededDiscoverableAssetsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "application": value.application,
    "iterable": value.iterable.map(SeededDiscoverableAssetToJSON),
    "filters": TLPDirectedDiscoveryFiltersToJSON(value.filters)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededDiscoverableHtmlWebpage.ts
function SeededDiscoverableHtmlWebpageToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "url": value.url,
    "page": value.page
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededDiscoverableHtmlWebpages.ts
function SeededDiscoverableHtmlWebpagesToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(SeededDiscoverableHtmlWebpageToJSON),
    "application": value.application
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededDiscoverableRelatedTag.ts
function SeededDiscoverableRelatedTagToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "text": value.text,
    "asset": value.asset,
    "mechanism": MechanismEnumToJSON(value.mechanism),
    "format": value.format,
    "category": TagCategoryEnumToJSON(value.category)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededDiscoverableRelatedTags.ts
function SeededDiscoverableRelatedTagsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(SeededDiscoverableRelatedTagToJSON),
    "application": value.application
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededDiscoverableSensitive.ts
function SeededDiscoverableSensitiveToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "asset": value.asset,
    "text": value.text,
    "mechanism": MechanismEnumToJSON(value.mechanism),
    "category": SensitiveCategoryEnumToJSON(value.category),
    "severity": SensitiveSeverityEnumToJSON(value.severity),
    "name": value.name,
    "description": value.description,
    "metadata": SensitiveMetadataToJSON(value.metadata)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededDiscoverableSensitives.ts
function SeededDiscoverableSensitivesToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "iterable": value.iterable.map(SeededDiscoverableSensitiveToJSON),
    "application": value.application
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededExternalProvider.ts
function SeededExternalProviderToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": ExternalProviderTypeEnumToJSON(value.type)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededScore.ts
function SeededScoreToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "reuse": value.reuse,
    "update": value.update,
    "reference": value.reference,
    "priority": value.priority,
    "searched": value.searched
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SeededScoreIncrement.ts
function SeededScoreIncrementToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "asset": SeededScoreToJSON(value.asset),
    "assets": SeededScoreToJSON(value.assets),
    "website": SeededScoreToJSON(value.website),
    "websites": SeededScoreToJSON(value.websites),
    "anchor": SeededScoreToJSON(value.anchor),
    "anchors": SeededScoreToJSON(value.anchors),
    "anchorPoint": SeededScoreToJSON(value.anchorPoint),
    "anchorPoints": SeededScoreToJSON(value.anchorPoints),
    "annotation": SeededScoreToJSON(value.annotation),
    "annotations": SeededScoreToJSON(value.annotations),
    "conversation": SeededScoreToJSON(value.conversation),
    "conversations": SeededScoreToJSON(value.conversations),
    "conversationMessage": SeededScoreToJSON(value.conversationMessage),
    "conversationMessages": SeededScoreToJSON(value.conversationMessages),
    "share": SeededScoreToJSON(value.share),
    "shares": SeededScoreToJSON(value.shares),
    "sensitive": SeededScoreToJSON(value.sensitive),
    "sensitives": SeededScoreToJSON(value.sensitives),
    "hint": SeededScoreToJSON(value.hint),
    "hints": SeededScoreToJSON(value.hints),
    "person": SeededScoreToJSON(value.person),
    "persons": SeededScoreToJSON(value.persons),
    "tag": SeededScoreToJSON(value.tag),
    "tags": SeededScoreToJSON(value.tags),
    "workstream_summary": SeededScoreToJSON(value.workstreamSummary),
    "workstream_summaries": SeededScoreToJSON(value.workstreamSummaries),
    "workstream_events": SeededScoreToJSON(value.workstreamEvents),
    "workstream_event": SeededScoreToJSON(value.workstreamEvent),
    "ranges": SeededScoreToJSON(value.ranges),
    "range": SeededScoreToJSON(value.range)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Session.ts
function SessionFromJSON(json) {
  return SessionFromJSONTyped(json, false);
}
function SessionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "opened": GroupedTimestampFromJSON(json["opened"]),
    "closed": !exists(json, "closed") ? void 0 : GroupedTimestampFromJSON(json["closed"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/StreamedIdentifier.ts
function StreamedIdentifierFromJSON(json) {
  return StreamedIdentifierFromJSONTyped(json, false);
}
function StreamedIdentifierFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "asset": !exists(json, "asset") ? void 0 : ReferencedAssetFromJSON(json["asset"]),
    "conversation": !exists(json, "conversation") ? void 0 : ReferencedConversationFromJSON(json["conversation"]),
    "annotation": !exists(json, "annotation") ? void 0 : ReferencedAnnotationFromJSON(json["annotation"]),
    "activity": !exists(json, "activity") ? void 0 : ReferencedActivityFromJSON(json["activity"]),
    "anchor": !exists(json, "anchor") ? void 0 : ReferencedAnchorFromJSON(json["anchor"]),
    "anchorPoint": !exists(json, "anchorPoint") ? void 0 : ReferencedAnchorPointFromJSON(json["anchorPoint"]),
    "hint": !exists(json, "hint") ? void 0 : ReferencedHintFromJSON(json["hint"]),
    "conversationMessage": !exists(json, "conversationMessage") ? void 0 : ReferencedConversationMessageFromJSON(json["conversationMessage"]),
    "format": !exists(json, "format") ? void 0 : ReferencedFormatFromJSON(json["format"]),
    "person": !exists(json, "person") ? void 0 : ReferencedPersonFromJSON(json["person"]),
    "range": !exists(json, "range") ? void 0 : ReferencedRangeFromJSON(json["range"]),
    "sensitive": !exists(json, "sensitive") ? void 0 : ReferencedSensitiveFromJSON(json["sensitive"]),
    "tag": !exists(json, "tag") ? void 0 : ReferencedTagFromJSON(json["tag"]),
    "website": !exists(json, "website") ? void 0 : ReferencedWebsiteFromJSON(json["website"]),
    "application": !exists(json, "application") ? void 0 : ReferencedApplicationFromJSON(json["application"]),
    "model": !exists(json, "model") ? void 0 : ReferencedModelFromJSON(json["model"]),
    "deleted": !exists(json, "deleted") ? void 0 : json["deleted"]
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/StreamedIdentifiers.ts
function StreamedIdentifiersFromJSON(json) {
  return StreamedIdentifiersFromJSONTyped(json, false);
}
function StreamedIdentifiersFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": json["iterable"].map(StreamedIdentifierFromJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/SuggestionTarget.ts
function SuggestionTargetFromJSON(json) {
  return SuggestionTargetFromJSONTyped(json, false);
}
function SuggestionTargetFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "seed": SeededConnectorCreationFromJSON(json["seed"]),
    "vector": json["vector"]
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Suggestion.ts
function SuggestionFromJSON(json) {
  return SuggestionFromJSONTyped(json, false);
}
function SuggestionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "reuse": ReuseSuggestionFromJSON(json["reuse"]),
    "save": SaveSuggestionFromJSON(json["save"]),
    "target": SuggestionTargetFromJSON(json["target"]),
    "assets": AssetsFromJSON(json["assets"]),
    "distribution": !exists(json, "distribution") ? void 0 : json["distribution"]
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/TerminatingOSServerApplet.ts
function TerminatingOSServerAppletToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "parent": ApplicationToJSON(value.parent),
    "port": value.port,
    "type": OSAppletEnumToJSON(value.type)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/UncheckedOSServerUpdate.ts
function UncheckedOSServerUpdateToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/UserBetaStatus.ts
function UserBetaStatusFromJSON(json) {
  return UserBetaStatusFromJSONTyped(json, false);
}
function UserBetaStatusFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "auth0": !exists(json, "auth0") ? void 0 : Auth0UserBetaStatusFromJSON(json["auth0"]),
    "user": json["user"]
  };
}
function UserBetaStatusToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "schema": EmbeddedModelSchemaToJSON(value.schema),
    "auth0": Auth0UserBetaStatusToJSON(value.auth0),
    "user": value.user
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/Users.ts
function UsersFromJSON(json) {
  return UsersFromJSONTyped(json, false);
}
function UsersFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "iterable": !exists(json, "iterable") ? void 0 : json["iterable"].map(UserProfileFromJSON)
  };
}

// ../generated_runtime/sdk/http/typescript/core/models/VerifiedOSFilesystemPath.ts
function VerifiedOSFilesystemPathFromJSON(json) {
  return VerifiedOSFilesystemPathFromJSONTyped(json, false);
}
function VerifiedOSFilesystemPathFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "schema": !exists(json, "schema") ? void 0 : EmbeddedModelSchemaFromJSON(json["schema"]),
    "path": json["path"],
    "file": !exists(json, "file") ? void 0 : json["file"],
    "directory": !exists(json, "directory") ? void 0 : json["directory"],
    "verified": json["verified"],
    "denied": !exists(json, "denied") ? void 0 : json["denied"],
    "bytes": !exists(json, "bytes") ? void 0 : ByteDescriptorFromJSON(json["bytes"])
  };
}

// ../generated_runtime/sdk/http/typescript/core/apis/ActivitiesApi.ts
var ActivitiesApi = class extends BaseAPI {
  /**
   * This will create a new Activity.
   * /activities/create [POST]
   */
  async activitiesCreateNewActivityRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/activities/create`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SeededActivityToJSON(requestParameters.seededActivity)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ActivityFromJSON(jsonValue));
  }
  /**
   * This will create a new Activity.
   * /activities/create [POST]
   */
  async activitiesCreateNewActivity(requestParameters = {}, initOverrides) {
    const response = await this.activitiesCreateNewActivityRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will delete a specific activity.  important note: if we delete an activity: that is going to be a generic or a specific/ we will also delete its counter part i.e the specific. and vise versa, this ensures that the references are always cleaned.
   * /activities/{activity}/delete [POST]
   */
  async activitiesDeleteSpecificActivityRaw(requestParameters, initOverrides) {
    if (requestParameters.activity === null || requestParameters.activity === void 0) {
      throw new RequiredError("activity", "Required parameter requestParameters.activity was null or undefined when calling activitiesDeleteSpecificActivity.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/activities/{activity}/delete`.replace(`{${"activity"}}`, encodeURIComponent(String(requestParameters.activity))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will delete a specific activity.  important note: if we delete an activity: that is going to be a generic or a specific/ we will also delete its counter part i.e the specific. and vise versa, this ensures that the references are always cleaned.
   * /activities/{activity}/delete [POST]
   */
  async activitiesDeleteSpecificActivity(requestParameters, initOverrides) {
    await this.activitiesDeleteSpecificActivityRaw(requestParameters, initOverrides);
  }
  /**
   * This will get a snapshot of all of the activities
   * /activities [GET]
   */
  async activitiesSnapshotRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    if (requestParameters.pseudo !== void 0) {
      queryParameters["pseudo"] = requestParameters.pseudo;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/activities`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ActivitiesFromJSON(jsonValue));
  }
  /**
   * This will get a snapshot of all of the activities
   * /activities [GET]
   */
  async activitiesSnapshot(requestParameters = {}, initOverrides) {
    const response = await this.activitiesSnapshotRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Provides a WebSocket connection that emits changes to your activity identifiers (UUIDs).
   * /activities/stream/identifiers [WS]
   */
  async activitiesStreamIdentifiersRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/activities/stream/identifiers`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => StreamedIdentifiersFromJSON(jsonValue));
  }
  /**
   * Provides a WebSocket connection that emits changes to your activity identifiers (UUIDs).
   * /activities/stream/identifiers [WS]
   */
  async activitiesStreamIdentifiers(initOverrides) {
    const response = await this.activitiesStreamIdentifiersRaw(initOverrides);
    return await response.value();
  }
};

// ../generated_runtime/sdk/http/typescript/core/apis/ActivityApi.ts
var ActivityApi = class extends BaseAPI {
  /**
   * This will attempt to get a specific activity.
   * /activity/{activity} [GET]
   */
  async activitiesSpecificActivitySnapshotRaw(requestParameters, initOverrides) {
    if (requestParameters.activity === null || requestParameters.activity === void 0) {
      throw new RequiredError("activity", "Required parameter requestParameters.activity was null or undefined when calling activitiesSpecificActivitySnapshot.");
    }
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/activity/{activity}`.replace(`{${"activity"}}`, encodeURIComponent(String(requestParameters.activity))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ActivityFromJSON(jsonValue));
  }
  /**
   * This will attempt to get a specific activity.
   * /activity/{activity} [GET]
   */
  async activitiesSpecificActivitySnapshot(requestParameters, initOverrides) {
    const response = await this.activitiesSpecificActivitySnapshotRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This is going to return all the identifiers of the activity event in order of most recent -> oldest.
   * /activity/identifiers [GET]
   */
  async activityIdentifiersSnapshotRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.pseudo !== void 0) {
      queryParameters["pseudo"] = requestParameters.pseudo;
    }
    if (requestParameters.activityFilterEnum !== void 0) {
      queryParameters["activity_filter_enum"] = requestParameters.activityFilterEnum;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/activity/identifiers`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FlattenedActivitiesFromJSON(jsonValue));
  }
  /**
   * This is going to return all the identifiers of the activity event in order of most recent -> oldest.
   * /activity/identifiers [GET]
   */
  async activityIdentifiersSnapshot(requestParameters = {}, initOverrides) {
    const response = await this.activityIdentifiersSnapshotRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * this will update a specific activity.
   * /activity/update [POST]
   */
  async activityUpdateRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/activity/update`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: ActivityToJSON(requestParameters.activity)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ActivityFromJSON(jsonValue));
  }
  /**
   * this will update a specific activity.
   * /activity/update [POST]
   */
  async activityUpdate(requestParameters = {}, initOverrides) {
    const response = await this.activityUpdateRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// ../generated_runtime/sdk/http/typescript/core/apis/AllocationsApi.ts
var AllocationsApi = class extends BaseAPI {
  /**
   * This will attempt to connect to a specific users cloud.(Required that the current user is logged in.)
   * /allocations/connect [POST]
   */
  async allocationsConnectNewCloudRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/allocations/connect`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: UserProfileToJSON(requestParameters.userProfile)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AllocationCloudFromJSON(jsonValue));
  }
  /**
   * This will attempt to connect to a specific users cloud.(Required that the current user is logged in.)
   * /allocations/connect [POST]
   */
  async allocationsConnectNewCloud(requestParameters = {}, initOverrides) {
    const response = await this.allocationsConnectNewCloudRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This is unimplemented locally. This will create an allocation. ONLY used within the cloud.
   * /allocations/create [POST]
   */
  async allocationsCreateNewAllocationRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/allocations/create`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: AllocationCloudToJSON(requestParameters.allocationCloud)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AllocationCloudFromJSON(jsonValue));
  }
  /**
   * This is unimplemented locally. This will create an allocation. ONLY used within the cloud.
   * /allocations/create [POST]
   */
  async allocationsCreateNewAllocation(requestParameters = {}, initOverrides) {
    const response = await this.allocationsCreateNewAllocationRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This is unimplemented locally. This will delete an allocation. ONLY used within the cloud.
   * /allocations/delete [POST]
   */
  async allocationsDeleteAllocationRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/allocations/delete`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: AllocationCloudToJSON(requestParameters.allocationCloud)
    }, initOverrides);
    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new JSONApiResponse(response);
    } else {
      return new TextApiResponse(response);
    }
  }
  /**
   * This is unimplemented locally. This will delete an allocation. ONLY used within the cloud.
   * /allocations/delete [POST]
   */
  async allocationsDeleteAllocation(requestParameters = {}, initOverrides) {
    const response = await this.allocationsDeleteAllocationRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will attempt to disconnect to a specific users cloud.
   * /allocations/disconnect [POST]
   */
  async allocationsDisconnectCloudRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/allocations/disconnect`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: AllocationCloudToJSON(requestParameters.allocationCloud)
    }, initOverrides);
    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new JSONApiResponse(response);
    } else {
      return new TextApiResponse(response);
    }
  }
  /**
   * This will attempt to disconnect to a specific users cloud.
   * /allocations/disconnect [POST]
   */
  async allocationsDisconnectCloud(requestParameters = {}, initOverrides) {
    const response = await this.allocationsDisconnectCloudRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will attempt to reconnect to a users cloud. This will ensure that we are connected to a users cloud and will ensure that all the data associated with a user\'s cloud is up-to-date.
   * /allocations/reconnect [POST]
   */
  async allocationsReconnectCloudRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/allocations/reconnect`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: AllocationCloudToJSON(requestParameters.allocationCloud)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AllocationCloudFromJSON(jsonValue));
  }
  /**
   * This will attempt to reconnect to a users cloud. This will ensure that we are connected to a users cloud and will ensure that all the data associated with a user\'s cloud is up-to-date.
   * /allocations/reconnect [POST]
   */
  async allocationsReconnectCloud(requestParameters = {}, initOverrides) {
    const response = await this.allocationsReconnectCloudRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This is going to get a snapshot of all of the connected allocations.
   * /allocations [GET]
   */
  async allocationsSnapshotRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/allocations`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AllocationsFromJSON(jsonValue));
  }
  /**
   * This is going to get a snapshot of all of the connected allocations.
   * /allocations [GET]
   */
  async allocationsSnapshot(initOverrides) {
    const response = await this.allocationsSnapshotRaw(initOverrides);
    return await response.value();
  }
};

// ../generated_runtime/sdk/http/typescript/core/apis/AnchorApi.ts
var AnchorApi = class extends BaseAPI {
  /**
   * associates an anchor and an asset. It performs the same action as the asset equivalent.
   * /anchor/{anchor}/assets/associate/{asset} [POST]
   */
  async anchorAssociateAssetRaw(requestParameters, initOverrides) {
    if (requestParameters.anchor === null || requestParameters.anchor === void 0) {
      throw new RequiredError("anchor", "Required parameter requestParameters.anchor was null or undefined when calling anchorAssociateAsset.");
    }
    if (requestParameters.asset === null || requestParameters.asset === void 0) {
      throw new RequiredError("asset", "Required parameter requestParameters.asset was null or undefined when calling anchorAssociateAsset.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/anchor/{anchor}/assets/associate/{asset}`.replace(`{${"anchor"}}`, encodeURIComponent(String(requestParameters.anchor))).replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * associates an anchor and an asset. It performs the same action as the asset equivalent.
   * /anchor/{anchor}/assets/associate/{asset} [POST]
   */
  async anchorAssociateAsset(requestParameters, initOverrides) {
    await this.anchorAssociateAssetRaw(requestParameters, initOverrides);
  }
  /**
   * associates an anchor and a conversation. It performs the same action as the conversation equivalent.
   * /anchor/{anchor}/conversations/associate/{conversation} [POST]
   */
  async anchorAssociateConversationRaw(requestParameters, initOverrides) {
    if (requestParameters.anchor === null || requestParameters.anchor === void 0) {
      throw new RequiredError("anchor", "Required parameter requestParameters.anchor was null or undefined when calling anchorAssociateConversation.");
    }
    if (requestParameters.conversation === null || requestParameters.conversation === void 0) {
      throw new RequiredError("conversation", "Required parameter requestParameters.conversation was null or undefined when calling anchorAssociateConversation.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/anchor/{anchor}/conversations/associate/{conversation}`.replace(`{${"anchor"}}`, encodeURIComponent(String(requestParameters.anchor))).replace(`{${"conversation"}}`, encodeURIComponent(String(requestParameters.conversation))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * associates an anchor and a conversation. It performs the same action as the conversation equivalent.
   * /anchor/{anchor}/conversations/associate/{conversation} [POST]
   */
  async anchorAssociateConversation(requestParameters, initOverrides) {
    await this.anchorAssociateConversationRaw(requestParameters, initOverrides);
  }
  /**
   * This will associate a anchor with a message.
   * /anchor/{anchor}/messages/associate/{message} [POST]
   */
  async anchorAssociateMessageRaw(requestParameters, initOverrides) {
    if (requestParameters.anchor === null || requestParameters.anchor === void 0) {
      throw new RequiredError("anchor", "Required parameter requestParameters.anchor was null or undefined when calling anchorAssociateMessage.");
    }
    if (requestParameters.message === null || requestParameters.message === void 0) {
      throw new RequiredError("message", "Required parameter requestParameters.message was null or undefined when calling anchorAssociateMessage.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/anchor/{anchor}/messages/associate/{message}`.replace(`{${"anchor"}}`, encodeURIComponent(String(requestParameters.anchor))).replace(`{${"message"}}`, encodeURIComponent(String(requestParameters.message))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will associate a anchor with a message.
   * /anchor/{anchor}/messages/associate/{message} [POST]
   */
  async anchorAssociateMessage(requestParameters, initOverrides) {
    await this.anchorAssociateMessageRaw(requestParameters, initOverrides);
  }
  /**
   * associates an anchor and a person. It performs the same action as the person equivalent.
   * /anchor/{anchor}/persons/associate/{person} [POST]
   */
  async anchorAssociatePersonRaw(requestParameters, initOverrides) {
    if (requestParameters.anchor === null || requestParameters.anchor === void 0) {
      throw new RequiredError("anchor", "Required parameter requestParameters.anchor was null or undefined when calling anchorAssociatePerson.");
    }
    if (requestParameters.person === null || requestParameters.person === void 0) {
      throw new RequiredError("person", "Required parameter requestParameters.person was null or undefined when calling anchorAssociatePerson.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/anchor/{anchor}/persons/associate/{person}`.replace(`{${"anchor"}}`, encodeURIComponent(String(requestParameters.anchor))).replace(`{${"person"}}`, encodeURIComponent(String(requestParameters.person))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * associates an anchor and a person. It performs the same action as the person equivalent.
   * /anchor/{anchor}/persons/associate/{person} [POST]
   */
  async anchorAssociatePerson(requestParameters, initOverrides) {
    await this.anchorAssociatePersonRaw(requestParameters, initOverrides);
  }
  /**
   * This will associate a anchor with a workstream summary. This will do the same thing as the workstreamSummary equivalent.
   * /anchor/{anchor}/workstream_summaries/associate/{workstream_summary} [POST]
   */
  async anchorAssociateWorkstreamSummaryRaw(requestParameters, initOverrides) {
    if (requestParameters.anchor === null || requestParameters.anchor === void 0) {
      throw new RequiredError("anchor", "Required parameter requestParameters.anchor was null or undefined when calling anchorAssociateWorkstreamSummary.");
    }
    if (requestParameters.workstreamSummary === null || requestParameters.workstreamSummary === void 0) {
      throw new RequiredError("workstreamSummary", "Required parameter requestParameters.workstreamSummary was null or undefined when calling anchorAssociateWorkstreamSummary.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/anchor/{anchor}/workstream_summaries/associate/{workstream_summary}`.replace(`{${"anchor"}}`, encodeURIComponent(String(requestParameters.anchor))).replace(`{${"workstream_summary"}}`, encodeURIComponent(String(requestParameters.workstreamSummary))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will associate a anchor with a workstream summary. This will do the same thing as the workstreamSummary equivalent.
   * /anchor/{anchor}/workstream_summaries/associate/{workstream_summary} [POST]
   */
  async anchorAssociateWorkstreamSummary(requestParameters, initOverrides) {
    await this.anchorAssociateWorkstreamSummaryRaw(requestParameters, initOverrides);
  }
  /**
   * Disassociates an anchor from an asset. It performs the same action as the asset equivalent.
   * /anchor/{anchor}/assets/disassociate/{asset} [POST]
   */
  async anchorDisassociateAssetRaw(requestParameters, initOverrides) {
    if (requestParameters.anchor === null || requestParameters.anchor === void 0) {
      throw new RequiredError("anchor", "Required parameter requestParameters.anchor was null or undefined when calling anchorDisassociateAsset.");
    }
    if (requestParameters.asset === null || requestParameters.asset === void 0) {
      throw new RequiredError("asset", "Required parameter requestParameters.asset was null or undefined when calling anchorDisassociateAsset.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/anchor/{anchor}/assets/disassociate/{asset}`.replace(`{${"anchor"}}`, encodeURIComponent(String(requestParameters.anchor))).replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Disassociates an anchor from an asset. It performs the same action as the asset equivalent.
   * /anchor/{anchor}/assets/disassociate/{asset} [POST]
   */
  async anchorDisassociateAsset(requestParameters, initOverrides) {
    await this.anchorDisassociateAssetRaw(requestParameters, initOverrides);
  }
  /**
   * Disassociates an anchor from a conversation. It performs the same action as the conversation equivalent.
   * /anchor/{anchor}/conversations/disassociate/{conversation} [POST]
   */
  async anchorDisassociateConversationRaw(requestParameters, initOverrides) {
    if (requestParameters.anchor === null || requestParameters.anchor === void 0) {
      throw new RequiredError("anchor", "Required parameter requestParameters.anchor was null or undefined when calling anchorDisassociateConversation.");
    }
    if (requestParameters.conversation === null || requestParameters.conversation === void 0) {
      throw new RequiredError("conversation", "Required parameter requestParameters.conversation was null or undefined when calling anchorDisassociateConversation.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/anchor/{anchor}/conversations/disassociate/{conversation}`.replace(`{${"anchor"}}`, encodeURIComponent(String(requestParameters.anchor))).replace(`{${"conversation"}}`, encodeURIComponent(String(requestParameters.conversation))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Disassociates an anchor from a conversation. It performs the same action as the conversation equivalent.
   * /anchor/{anchor}/conversations/disassociate/{conversation} [POST]
   */
  async anchorDisassociateConversation(requestParameters, initOverrides) {
    await this.anchorDisassociateConversationRaw(requestParameters, initOverrides);
  }
  /**
   * This will enable us to disassociate a anchor from a message.
   * /anchor/{anchor}/messages/disassociate/{message} [POST]
   */
  async anchorDisassociateMessageRaw(requestParameters, initOverrides) {
    if (requestParameters.anchor === null || requestParameters.anchor === void 0) {
      throw new RequiredError("anchor", "Required parameter requestParameters.anchor was null or undefined when calling anchorDisassociateMessage.");
    }
    if (requestParameters.message === null || requestParameters.message === void 0) {
      throw new RequiredError("message", "Required parameter requestParameters.message was null or undefined when calling anchorDisassociateMessage.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/anchor/{anchor}/messages/disassociate/{message}`.replace(`{${"anchor"}}`, encodeURIComponent(String(requestParameters.anchor))).replace(`{${"message"}}`, encodeURIComponent(String(requestParameters.message))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will enable us to disassociate a anchor from a message.
   * /anchor/{anchor}/messages/disassociate/{message} [POST]
   */
  async anchorDisassociateMessage(requestParameters, initOverrides) {
    await this.anchorDisassociateMessageRaw(requestParameters, initOverrides);
  }
  /**
   * Disassociates an anchor from a person. It performs the same action as the person equivalent.
   * /anchor/{anchor}/persons/disassociate/{person} [POST]
   */
  async anchorDisassociatePersonRaw(requestParameters, initOverrides) {
    if (requestParameters.anchor === null || requestParameters.anchor === void 0) {
      throw new RequiredError("anchor", "Required parameter requestParameters.anchor was null or undefined when calling anchorDisassociatePerson.");
    }
    if (requestParameters.person === null || requestParameters.person === void 0) {
      throw new RequiredError("person", "Required parameter requestParameters.person was null or undefined when calling anchorDisassociatePerson.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/anchor/{anchor}/persons/disassociate/{person}`.replace(`{${"anchor"}}`, encodeURIComponent(String(requestParameters.anchor))).replace(`{${"person"}}`, encodeURIComponent(String(requestParameters.person))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Disassociates an anchor from a person. It performs the same action as the person equivalent.
   * /anchor/{anchor}/persons/disassociate/{person} [POST]
   */
  async anchorDisassociatePerson(requestParameters, initOverrides) {
    await this.anchorDisassociatePersonRaw(requestParameters, initOverrides);
  }
  /**
   * This will enable us to disassociate a anchor from a workstream summary. This will do the same thing as the workstreamSummary equivalent.
   * /anchor/{anchor}/workstream_summaries/disassociate/{workstream_summary} [POST]
   */
  async anchorDisassociateWorkstreamSummaryRaw(requestParameters, initOverrides) {
    if (requestParameters.anchor === null || requestParameters.anchor === void 0) {
      throw new RequiredError("anchor", "Required parameter requestParameters.anchor was null or undefined when calling anchorDisassociateWorkstreamSummary.");
    }
    if (requestParameters.workstreamSummary === null || requestParameters.workstreamSummary === void 0) {
      throw new RequiredError("workstreamSummary", "Required parameter requestParameters.workstreamSummary was null or undefined when calling anchorDisassociateWorkstreamSummary.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/anchor/{anchor}/workstream_summaries/disassociate/{workstream_summary}`.replace(`{${"anchor"}}`, encodeURIComponent(String(requestParameters.anchor))).replace(`{${"workstream_summary"}}`, encodeURIComponent(String(requestParameters.workstreamSummary))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will enable us to disassociate a anchor from a workstream summary. This will do the same thing as the workstreamSummary equivalent.
   * /anchor/{anchor}/workstream_summaries/disassociate/{workstream_summary} [POST]
   */
  async anchorDisassociateWorkstreamSummary(requestParameters, initOverrides) {
    await this.anchorDisassociateWorkstreamSummaryRaw(requestParameters, initOverrides);
  }
  /**
   * This will rename a specific anchor.
   * /anchor/{anchor}/rename [POST]
   */
  async anchorRenameRaw(requestParameters, initOverrides) {
    if (requestParameters.anchor === null || requestParameters.anchor === void 0) {
      throw new RequiredError("anchor", "Required parameter requestParameters.anchor was null or undefined when calling anchorRename.");
    }
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/anchor/{anchor}/rename`.replace(`{${"anchor"}}`, encodeURIComponent(String(requestParameters.anchor))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AnchorFromJSON(jsonValue));
  }
  /**
   * This will rename a specific anchor.
   * /anchor/{anchor}/rename [POST]
   */
  async anchorRename(requestParameters, initOverrides) {
    const response = await this.anchorRenameRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will take in a SeededScoreIncrement and will increment the material relative to the incoming body.
   * \'/anchor/{anchor}/scores/increment\' [POST]
   */
  async anchorScoresIncrementRaw(requestParameters, initOverrides) {
    if (requestParameters.anchor === null || requestParameters.anchor === void 0) {
      throw new RequiredError("anchor", "Required parameter requestParameters.anchor was null or undefined when calling anchorScoresIncrement.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/anchor/{anchor}/scores/increment`.replace(`{${"anchor"}}`, encodeURIComponent(String(requestParameters.anchor))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SeededScoreIncrementToJSON(requestParameters.seededScoreIncrement)
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will take in a SeededScoreIncrement and will increment the material relative to the incoming body.
   * \'/anchor/{anchor}/scores/increment\' [POST]
   */
  async anchorScoresIncrement(requestParameters, initOverrides) {
    await this.anchorScoresIncrementRaw(requestParameters, initOverrides);
  }
  /**
   * This will get a snapshot of a single anchor.
   * /anchor/{anchor} [GET]
   */
  async anchorSpecificAnchorSnapshotRaw(requestParameters, initOverrides) {
    if (requestParameters.anchor === null || requestParameters.anchor === void 0) {
      throw new RequiredError("anchor", "Required parameter requestParameters.anchor was null or undefined when calling anchorSpecificAnchorSnapshot.");
    }
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/anchor/{anchor}`.replace(`{${"anchor"}}`, encodeURIComponent(String(requestParameters.anchor))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AnchorFromJSON(jsonValue));
  }
  /**
   * This will get a snapshot of a single anchor.
   * /anchor/{anchor} [GET]
   */
  async anchorSpecificAnchorSnapshot(requestParameters, initOverrides) {
    const response = await this.anchorSpecificAnchorSnapshotRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will update a specific anchor.
   * /anchor/update [POST]
   */
  async anchorUpdateRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/anchor/update`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: AnchorToJSON(requestParameters.anchor)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AnchorFromJSON(jsonValue));
  }
  /**
   * This will update a specific anchor.
   * /anchor/update [POST]
   */
  async anchorUpdate(requestParameters = {}, initOverrides) {
    const response = await this.anchorUpdateRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// ../generated_runtime/sdk/http/typescript/core/apis/AnchorPointApi.ts
var AnchorPointApi = class extends BaseAPI {
  /**
   * This will take in a SeededScoreIncrement and will increment the material relative to the incoming body.
   * \'/anchor_point/{anchor_point}/scores/increment\' [POST]
   */
  async anchorPointScoresIncrementRaw(requestParameters, initOverrides) {
    if (requestParameters.anchorPoint === null || requestParameters.anchorPoint === void 0) {
      throw new RequiredError("anchorPoint", "Required parameter requestParameters.anchorPoint was null or undefined when calling anchorPointScoresIncrement.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/anchor_point/{anchor_point}/scores/increment`.replace(`{${"anchor_point"}}`, encodeURIComponent(String(requestParameters.anchorPoint))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SeededScoreIncrementToJSON(requestParameters.seededScoreIncrement)
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will take in a SeededScoreIncrement and will increment the material relative to the incoming body.
   * \'/anchor_point/{anchor_point}/scores/increment\' [POST]
   */
  async anchorPointScoresIncrement(requestParameters, initOverrides) {
    await this.anchorPointScoresIncrementRaw(requestParameters, initOverrides);
  }
  /**
   * This will get a snapshot of a single anchorPoint.
   * /anchor_point/{anchor_point} [GET]
   */
  async anchorPointSpecificAnchorPointSnapshotRaw(requestParameters, initOverrides) {
    if (requestParameters.anchorPoint === null || requestParameters.anchorPoint === void 0) {
      throw new RequiredError("anchorPoint", "Required parameter requestParameters.anchorPoint was null or undefined when calling anchorPointSpecificAnchorPointSnapshot.");
    }
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/anchor_point/{anchor_point}`.replace(`{${"anchor_point"}}`, encodeURIComponent(String(requestParameters.anchorPoint))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AnchorPointFromJSON(jsonValue));
  }
  /**
   * This will get a snapshot of a single anchorPoint.
   * /anchor_point/{anchor_point} [GET]
   */
  async anchorPointSpecificAnchorPointSnapshot(requestParameters, initOverrides) {
    const response = await this.anchorPointSpecificAnchorPointSnapshotRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will update a specific anchorPoint.
   * /anchor_point/update [POST]
   */
  async anchorPointUpdateRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/anchor_point/update`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: AnchorPointToJSON(requestParameters.anchorPoint)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AnchorPointFromJSON(jsonValue));
  }
  /**
   * This will update a specific anchorPoint.
   * /anchor_point/update [POST]
   */
  async anchorPointUpdate(requestParameters = {}, initOverrides) {
    const response = await this.anchorPointUpdateRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// ../generated_runtime/sdk/http/typescript/core/apis/AnchorsApi.ts
var AnchorsApi = class extends BaseAPI {
  /**
   * This will create a anchor and attach it to a specific asset(s) This will also ensure the anchor is normalized.
   * /anchors/create [POST]
   */
  async anchorsCreateNewAnchorRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/anchors/create`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SeededAnchorToJSON(requestParameters.seededAnchor)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AnchorFromJSON(jsonValue));
  }
  /**
   * This will create a anchor and attach it to a specific asset(s) This will also ensure the anchor is normalized.
   * /anchors/create [POST]
   */
  async anchorsCreateNewAnchor(requestParameters = {}, initOverrides) {
    const response = await this.anchorsCreateNewAnchorRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will delete a specific anchor!
   * /anchors/{anchor}/delete [POST]
   */
  async anchorsDeleteSpecificAnchorRaw(requestParameters, initOverrides) {
    if (requestParameters.anchor === null || requestParameters.anchor === void 0) {
      throw new RequiredError("anchor", "Required parameter requestParameters.anchor was null or undefined when calling anchorsDeleteSpecificAnchor.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/anchors/{anchor}/delete`.replace(`{${"anchor"}}`, encodeURIComponent(String(requestParameters.anchor))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will delete a specific anchor!
   * /anchors/{anchor}/delete [POST]
   */
  async anchorsDeleteSpecificAnchor(requestParameters, initOverrides) {
    await this.anchorsDeleteSpecificAnchorRaw(requestParameters, initOverrides);
  }
  /**
   * This will get a snapshot of all your anchors.
   * /anchors [GET]
   */
  async anchorsSnapshotRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/anchors`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AnchorsFromJSON(jsonValue));
  }
  /**
   * This will get a snapshot of all your anchors.
   * /anchors [GET]
   */
  async anchorsSnapshot(requestParameters = {}, initOverrides) {
    const response = await this.anchorsSnapshotRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Provides a WebSocket connection that emits changes to your anchor identifiers (UUIDs).
   * /anchors/stream/identifiers [WS]
   */
  async anchorsStreamIdentifiersRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/anchors/stream/identifiers`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => StreamedIdentifiersFromJSON(jsonValue));
  }
  /**
   * Provides a WebSocket connection that emits changes to your anchor identifiers (UUIDs).
   * /anchors/stream/identifiers [WS]
   */
  async anchorsStreamIdentifiers(initOverrides) {
    const response = await this.anchorsStreamIdentifiersRaw(initOverrides);
    return await response.value();
  }
  /**
   * This will search your anchors for a specific anchor  note: we will search all the anchor points
   * /anchors/search [POST]
   */
  async searchAnchorsRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/anchors/search`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SearchInputToJSON(requestParameters.searchInput)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SearchedAnchorsFromJSON(jsonValue));
  }
  /**
   * This will search your anchors for a specific anchor  note: we will search all the anchor points
   * /anchors/search [POST]
   */
  async searchAnchors(requestParameters = {}, initOverrides) {
    const response = await this.searchAnchorsRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// ../generated_runtime/sdk/http/typescript/core/apis/AnnotationApi.ts
var AnnotationApi = class extends BaseAPI {
  /**
   * This will take in a SeededScoreIncrement and will increment the material relative to the incoming body.
   * \'/annotation/{annotation}/scores/increment\' [POST]
   */
  async annotationScoresIncrementRaw(requestParameters, initOverrides) {
    if (requestParameters.annotation === null || requestParameters.annotation === void 0) {
      throw new RequiredError("annotation", "Required parameter requestParameters.annotation was null or undefined when calling annotationScoresIncrement.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/annotation/{annotation}/scores/increment`.replace(`{${"annotation"}}`, encodeURIComponent(String(requestParameters.annotation))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SeededScoreIncrementToJSON(requestParameters.seededScoreIncrement)
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will take in a SeededScoreIncrement and will increment the material relative to the incoming body.
   * \'/annotation/{annotation}/scores/increment\' [POST]
   */
  async annotationScoresIncrement(requestParameters, initOverrides) {
    await this.annotationScoresIncrementRaw(requestParameters, initOverrides);
  }
  /**
   * This will get a snapshot of a specific annotation.
   * /annotation/{annotation} [GET]
   */
  async annotationSpecificAnnotationSnapshotRaw(requestParameters, initOverrides) {
    if (requestParameters.annotation === null || requestParameters.annotation === void 0) {
      throw new RequiredError("annotation", "Required parameter requestParameters.annotation was null or undefined when calling annotationSpecificAnnotationSnapshot.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/annotation/{annotation}`.replace(`{${"annotation"}}`, encodeURIComponent(String(requestParameters.annotation))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AnnotationFromJSON(jsonValue));
  }
  /**
   * This will get a snapshot of a specific annotation.
   * /annotation/{annotation} [GET]
   */
  async annotationSpecificAnnotationSnapshot(requestParameters, initOverrides) {
    const response = await this.annotationSpecificAnnotationSnapshotRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will update a specific annotation.
   * /annotation/update [POST]
   */
  async annotationUpdateRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/annotation/update`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: AnnotationToJSON(requestParameters.annotation)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AnnotationFromJSON(jsonValue));
  }
  /**
   * This will update a specific annotation.
   * /annotation/update [POST]
   */
  async annotationUpdate(requestParameters = {}, initOverrides) {
    const response = await this.annotationUpdateRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// ../generated_runtime/sdk/http/typescript/core/apis/AnnotationsApi.ts
var AnnotationsApi = class extends BaseAPI {
  /**
   * This will create an annotation.
   * /annotations/create [POST]
   */
  async annotationsCreateNewAnnotationRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/annotations/create`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SeededAnnotationToJSON(requestParameters.seededAnnotation)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AnnotationFromJSON(jsonValue));
  }
  /**
   * This will create an annotation.
   * /annotations/create [POST]
   */
  async annotationsCreateNewAnnotation(requestParameters = {}, initOverrides) {
    const response = await this.annotationsCreateNewAnnotationRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * this will delete a specific annotation
   * /annotations/{annotation}/delete [POST]
   */
  async annotationsDeleteSpecificAnnotationRaw(requestParameters, initOverrides) {
    if (requestParameters.annotation === null || requestParameters.annotation === void 0) {
      throw new RequiredError("annotation", "Required parameter requestParameters.annotation was null or undefined when calling annotationsDeleteSpecificAnnotation.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/annotations/{annotation}/delete`.replace(`{${"annotation"}}`, encodeURIComponent(String(requestParameters.annotation))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * this will delete a specific annotation
   * /annotations/{annotation}/delete [POST]
   */
  async annotationsDeleteSpecificAnnotation(requestParameters, initOverrides) {
    await this.annotationsDeleteSpecificAnnotationRaw(requestParameters, initOverrides);
  }
  /**
   * This will get a snapshot of all the annotations.  This will take an optional filter as a query param.
   * /annotations [GET]
   */
  async annotationsSnapshotRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.annotationTypeFilter !== void 0) {
      queryParameters["annotation_type_filter"] = requestParameters.annotationTypeFilter;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/annotations`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AnnotationsFromJSON(jsonValue));
  }
  /**
   * This will get a snapshot of all the annotations.  This will take an optional filter as a query param.
   * /annotations [GET]
   */
  async annotationsSnapshot(requestParameters = {}, initOverrides) {
    const response = await this.annotationsSnapshotRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Provides a WebSocket connection that emits changes to your annotation identifiers (UUIDs).
   * /annotations/stream/identifiers [WS]
   */
  async annotationsStreamIdentifiersRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/annotations/stream/identifiers`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => StreamedIdentifiersFromJSON(jsonValue));
  }
  /**
   * Provides a WebSocket connection that emits changes to your annotation identifiers (UUIDs).
   * /annotations/stream/identifiers [WS]
   */
  async annotationsStreamIdentifiers(initOverrides) {
    const response = await this.annotationsStreamIdentifiersRaw(initOverrides);
    return await response.value();
  }
  /**
   * This will search your annotations for a specific annotation  note: we will just search the annotation value
   * /annotations/search [POST]
   */
  async searchAnnotationsRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/annotations/search`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SearchInputToJSON(requestParameters.searchInput)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SearchedAnnotationsFromJSON(jsonValue));
  }
  /**
   * This will search your annotations for a specific annotation  note: we will just search the annotation value
   * /annotations/search [POST]
   */
  async searchAnnotations(requestParameters = {}, initOverrides) {
    const response = await this.searchAnnotationsRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// ../generated_runtime/sdk/http/typescript/core/apis/ApplicationApi.ts
var ApplicationApi = class extends BaseAPI {
  /**
   * This is an endpoint for updating an application.
   * /application/update [GET]
   */
  async applicationUpdateRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/application/update`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: ApplicationToJSON(requestParameters.application)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ApplicationFromJSON(jsonValue));
  }
  /**
   * This is an endpoint for updating an application.
   * /application/update [GET]
   */
  async applicationUpdate(requestParameters = {}, initOverrides) {
    const response = await this.applicationUpdateRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// ../generated_runtime/sdk/http/typescript/core/apis/ApplicationsApi.ts
var ApplicationsApi = class extends BaseAPI {
  /**
   * Retrieves a list of external applications installed on the user\'s machine that have potential integrations with Pieces, including those not yet installed by the user and those anticipated to be supported in the future.
   * /applications/external/related [GET]
   */
  async applicationsExternalRelatedRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/applications/external/related`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => DetectedExternalApplicationsFromJSON(jsonValue));
  }
  /**
   * Retrieves a list of external applications installed on the user\'s machine that have potential integrations with Pieces, including those not yet installed by the user and those anticipated to be supported in the future.
   * /applications/external/related [GET]
   */
  async applicationsExternalRelated(initOverrides) {
    const response = await this.applicationsExternalRelatedRaw(initOverrides);
    return await response.value();
  }
  /**
   * Provides a snapshot of all external applications detected on the user\'s machine, such as Microsoft Teams classic, Google Chat, Obsidian, etc.
   * /applications/external [GET]
   */
  async applicationsExternalSnapshotRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/applications/external`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => DetectedExternalApplicationsFromJSON(jsonValue));
  }
  /**
   * Provides a snapshot of all external applications detected on the user\'s machine, such as Microsoft Teams classic, Google Chat, Obsidian, etc.
   * /applications/external [GET]
   */
  async applicationsExternalSnapshot(initOverrides) {
    const response = await this.applicationsExternalSnapshotRaw(initOverrides);
    return await response.value();
  }
  /**
   * Registers a new application within the Pieces ecosystem.
   * /applications/register [POST]
   * @deprecated
   */
  async applicationsRegisterRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/applications/register`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: ApplicationToJSON(requestParameters.application)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ApplicationFromJSON(jsonValue));
  }
  /**
   * Registers a new application within the Pieces ecosystem.
   * /applications/register [POST]
   * @deprecated
   */
  async applicationsRegister(requestParameters = {}, initOverrides) {
    const response = await this.applicationsRegisterRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Closes an active session, identified by a session UUID, marking the end of the user\'s current interaction with the Pieces application.
   * /applications/session/close [POST]
   * @deprecated
   */
  async applicationsSessionCloseRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/applications/session/close`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SessionFromJSON(jsonValue));
  }
  /**
   * Closes an active session, identified by a session UUID, marking the end of the user\'s current interaction with the Pieces application.
   * /applications/session/close [POST]
   * @deprecated
   */
  async applicationsSessionClose(requestParameters = {}, initOverrides) {
    const response = await this.applicationsSessionCloseRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Initiates a new session, marking the start of a user\'s interaction with the Pieces application.
   * /applications/session/open [POST]
   * @deprecated
   */
  async applicationsSessionOpenRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/applications/session/open`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SessionFromJSON(jsonValue));
  }
  /**
   * Initiates a new session, marking the start of a user\'s interaction with the Pieces application.
   * /applications/session/open [POST]
   * @deprecated
   */
  async applicationsSessionOpen(initOverrides) {
    const response = await this.applicationsSessionOpenRaw(initOverrides);
    return await response.value();
  }
  /**
   * Retrieves a comprehensive overview of all applications tracked by the Pieces system, including status, version, and engagement metrics.
   * /applications [GET]
   */
  async applicationsSnapshotRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/applications`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ApplicationsFromJSON(jsonValue));
  }
  /**
   * Retrieves a comprehensive overview of all applications tracked by the Pieces system, including status, version, and engagement metrics.
   * /applications [GET]
   */
  async applicationsSnapshot(initOverrides) {
    const response = await this.applicationsSnapshotRaw(initOverrides);
    return await response.value();
  }
  /**
   * Obtains a snapshot with information about a specific application, identified by its UUID.
   * /applications/{application} [GET]
   */
  async applicationsSpecificApplicationSnapshotRaw(requestParameters, initOverrides) {
    if (requestParameters.application === null || requestParameters.application === void 0) {
      throw new RequiredError("application", "Required parameter requestParameters.application was null or undefined when calling applicationsSpecificApplicationSnapshot.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/applications/{application}`.replace(`{${"application"}}`, encodeURIComponent(String(requestParameters.application))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ApplicationFromJSON(jsonValue));
  }
  /**
   * Obtains a snapshot with information about a specific application, identified by its UUID.
   * /applications/{application} [GET]
   */
  async applicationsSpecificApplicationSnapshot(requestParameters, initOverrides) {
    const response = await this.applicationsSpecificApplicationSnapshotRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Provides a WebSocket connection that emits changes to your application identifiers (UUIDs).
   * /applications/stream/identifiers [WS]
   */
  async applicationsStreamIdentifiersRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/applications/stream/identifiers`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => StreamedIdentifiersFromJSON(jsonValue));
  }
  /**
   * Provides a WebSocket connection that emits changes to your application identifiers (UUIDs).
   * /applications/stream/identifiers [WS]
   */
  async applicationsStreamIdentifiers(initOverrides) {
    const response = await this.applicationsStreamIdentifiersRaw(initOverrides);
    return await response.value();
  }
};

// ../generated_runtime/sdk/http/typescript/core/apis/AssetApi.ts
var AssetApi = class extends BaseAPI {
  /**
   * associates an anchor and an asset. It performs the same action as the anchor equivalent.
   * /asset/{asset}/persons/associate/{anchor} [POST]
   */
  async assetAssociateAnchorRaw(requestParameters, initOverrides) {
    if (requestParameters.asset === null || requestParameters.asset === void 0) {
      throw new RequiredError("asset", "Required parameter requestParameters.asset was null or undefined when calling assetAssociateAnchor.");
    }
    if (requestParameters.anchor === null || requestParameters.anchor === void 0) {
      throw new RequiredError("anchor", "Required parameter requestParameters.anchor was null or undefined when calling assetAssociateAnchor.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/asset/{asset}/anchors/associate/{anchor}`.replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))).replace(`{${"anchor"}}`, encodeURIComponent(String(requestParameters.anchor))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * associates an anchor and an asset. It performs the same action as the anchor equivalent.
   * /asset/{asset}/persons/associate/{anchor} [POST]
   */
  async assetAssociateAnchor(requestParameters, initOverrides) {
    await this.assetAssociateAnchorRaw(requestParameters, initOverrides);
  }
  /**
   * associates a conversation and an asset. It performs the same action as the conversation equivalent.
   * /asset/{asset}/conversations/associate/{conversation} [POST]
   */
  async assetAssociateConversationRaw(requestParameters, initOverrides) {
    if (requestParameters.asset === null || requestParameters.asset === void 0) {
      throw new RequiredError("asset", "Required parameter requestParameters.asset was null or undefined when calling assetAssociateConversation.");
    }
    if (requestParameters.conversation === null || requestParameters.conversation === void 0) {
      throw new RequiredError("conversation", "Required parameter requestParameters.conversation was null or undefined when calling assetAssociateConversation.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/asset/{asset}/conversations/associate/{conversation}`.replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))).replace(`{${"conversation"}}`, encodeURIComponent(String(requestParameters.conversation))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * associates a conversation and an asset. It performs the same action as the conversation equivalent.
   * /asset/{asset}/conversations/associate/{conversation} [POST]
   */
  async assetAssociateConversation(requestParameters, initOverrides) {
    await this.assetAssociateConversationRaw(requestParameters, initOverrides);
  }
  /**
   * associates an asset and a hint. It performs the same action as the hint equivalent.
   * /asset/{asset}/hints/associate/{hint} [POST]
   */
  async assetAssociateHintRaw(requestParameters, initOverrides) {
    if (requestParameters.asset === null || requestParameters.asset === void 0) {
      throw new RequiredError("asset", "Required parameter requestParameters.asset was null or undefined when calling assetAssociateHint.");
    }
    if (requestParameters.hint === null || requestParameters.hint === void 0) {
      throw new RequiredError("hint", "Required parameter requestParameters.hint was null or undefined when calling assetAssociateHint.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/asset/{asset}/hints/associate/{hint}`.replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))).replace(`{${"hint"}}`, encodeURIComponent(String(requestParameters.hint))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * associates an asset and a hint. It performs the same action as the hint equivalent.
   * /asset/{asset}/hints/associate/{hint} [POST]
   */
  async assetAssociateHint(requestParameters, initOverrides) {
    await this.assetAssociateHintRaw(requestParameters, initOverrides);
  }
  /**
   * associates a person and an asset. It performs the same action as the person equivalent.
   * /asset/{asset}/persons/associate/{person} [POST]
   */
  async assetAssociatePersonRaw(requestParameters, initOverrides) {
    if (requestParameters.asset === null || requestParameters.asset === void 0) {
      throw new RequiredError("asset", "Required parameter requestParameters.asset was null or undefined when calling assetAssociatePerson.");
    }
    if (requestParameters.person === null || requestParameters.person === void 0) {
      throw new RequiredError("person", "Required parameter requestParameters.person was null or undefined when calling assetAssociatePerson.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/asset/{asset}/persons/associate/{person}`.replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))).replace(`{${"person"}}`, encodeURIComponent(String(requestParameters.person))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * associates a person and an asset. It performs the same action as the person equivalent.
   * /asset/{asset}/persons/associate/{person} [POST]
   */
  async assetAssociatePerson(requestParameters, initOverrides) {
    await this.assetAssociatePersonRaw(requestParameters, initOverrides);
  }
  /**
   * Associates a tag with a specified asset. It performs the same action as the tag equivalent.
   * /asset/{asset}/tags/associate/{tag} [POST]
   */
  async assetAssociateTagRaw(requestParameters, initOverrides) {
    if (requestParameters.asset === null || requestParameters.asset === void 0) {
      throw new RequiredError("asset", "Required parameter requestParameters.asset was null or undefined when calling assetAssociateTag.");
    }
    if (requestParameters.tag === null || requestParameters.tag === void 0) {
      throw new RequiredError("tag", "Required parameter requestParameters.tag was null or undefined when calling assetAssociateTag.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/asset/{asset}/tags/associate/{tag}`.replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))).replace(`{${"tag"}}`, encodeURIComponent(String(requestParameters.tag))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Associates a tag with a specified asset. It performs the same action as the tag equivalent.
   * /asset/{asset}/tags/associate/{tag} [POST]
   */
  async assetAssociateTag(requestParameters, initOverrides) {
    await this.assetAssociateTagRaw(requestParameters, initOverrides);
  }
  /**
   * Associates a website with an asset. It performs the same action as its website equivalent.
   * /asset/{asset}/websites/associate/{website} [POST]
   */
  async assetAssociateWebsiteRaw(requestParameters, initOverrides) {
    if (requestParameters.asset === null || requestParameters.asset === void 0) {
      throw new RequiredError("asset", "Required parameter requestParameters.asset was null or undefined when calling assetAssociateWebsite.");
    }
    if (requestParameters.website === null || requestParameters.website === void 0) {
      throw new RequiredError("website", "Required parameter requestParameters.website was null or undefined when calling assetAssociateWebsite.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/asset/{asset}/websites/associate/{website}`.replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))).replace(`{${"website"}}`, encodeURIComponent(String(requestParameters.website))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Associates a website with an asset. It performs the same action as its website equivalent.
   * /asset/{asset}/websites/associate/{website} [POST]
   */
  async assetAssociateWebsite(requestParameters, initOverrides) {
    await this.assetAssociateWebsiteRaw(requestParameters, initOverrides);
  }
  /**
   * This will associate a asset with a workstream summary. This will do the same thing as the workstreamSummary equivalent.
   * /asset/{asset}/workstream_summaries/associate/{workstream_summary} [POST]
   */
  async assetAssociateWorkstreamSummaryRaw(requestParameters, initOverrides) {
    if (requestParameters.asset === null || requestParameters.asset === void 0) {
      throw new RequiredError("asset", "Required parameter requestParameters.asset was null or undefined when calling assetAssociateWorkstreamSummary.");
    }
    if (requestParameters.workstreamSummary === null || requestParameters.workstreamSummary === void 0) {
      throw new RequiredError("workstreamSummary", "Required parameter requestParameters.workstreamSummary was null or undefined when calling assetAssociateWorkstreamSummary.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/asset/{asset}/workstream_summaries/associate/{workstream_summary}`.replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))).replace(`{${"workstream_summary"}}`, encodeURIComponent(String(requestParameters.workstreamSummary))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will associate a asset with a workstream summary. This will do the same thing as the workstreamSummary equivalent.
   * /asset/{asset}/workstream_summaries/associate/{workstream_summary} [POST]
   */
  async assetAssociateWorkstreamSummary(requestParameters, initOverrides) {
    await this.assetAssociateWorkstreamSummaryRaw(requestParameters, initOverrides);
  }
  /**
   * Disassociates a anchor from an asset. It performs the same action as the anchor equivalent.
   * /asset/{asset}/anchors/disassociate/{anchor} [POST]
   */
  async assetDisassociateAnchorRaw(requestParameters, initOverrides) {
    if (requestParameters.asset === null || requestParameters.asset === void 0) {
      throw new RequiredError("asset", "Required parameter requestParameters.asset was null or undefined when calling assetDisassociateAnchor.");
    }
    if (requestParameters.anchor === null || requestParameters.anchor === void 0) {
      throw new RequiredError("anchor", "Required parameter requestParameters.anchor was null or undefined when calling assetDisassociateAnchor.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/asset/{asset}/anchors/disassociate/{anchor}`.replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))).replace(`{${"anchor"}}`, encodeURIComponent(String(requestParameters.anchor))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Disassociates a anchor from an asset. It performs the same action as the anchor equivalent.
   * /asset/{asset}/anchors/disassociate/{anchor} [POST]
   */
  async assetDisassociateAnchor(requestParameters, initOverrides) {
    await this.assetDisassociateAnchorRaw(requestParameters, initOverrides);
  }
  /**
   * Disassociates a conversation from an asset. It performs the same action as the conversation equivalent.
   * /asset/{asset}/conversations/disassociate/{conversation} [POST]
   */
  async assetDisassociateConversationRaw(requestParameters, initOverrides) {
    if (requestParameters.asset === null || requestParameters.asset === void 0) {
      throw new RequiredError("asset", "Required parameter requestParameters.asset was null or undefined when calling assetDisassociateConversation.");
    }
    if (requestParameters.conversation === null || requestParameters.conversation === void 0) {
      throw new RequiredError("conversation", "Required parameter requestParameters.conversation was null or undefined when calling assetDisassociateConversation.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/asset/{asset}/conversations/disassociate/{conversation}`.replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))).replace(`{${"conversation"}}`, encodeURIComponent(String(requestParameters.conversation))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Disassociates a conversation from an asset. It performs the same action as the conversation equivalent.
   * /asset/{asset}/conversations/disassociate/{conversation} [POST]
   */
  async assetDisassociateConversation(requestParameters, initOverrides) {
    await this.assetDisassociateConversationRaw(requestParameters, initOverrides);
  }
  /**
   * Disassociates an asset from a hint. It performs the same action as the hint equivalent.
   * /asset/{asset}/hints/disassociate/{hint} [POST]
   */
  async assetDisassociateHintRaw(requestParameters, initOverrides) {
    if (requestParameters.asset === null || requestParameters.asset === void 0) {
      throw new RequiredError("asset", "Required parameter requestParameters.asset was null or undefined when calling assetDisassociateHint.");
    }
    if (requestParameters.hint === null || requestParameters.hint === void 0) {
      throw new RequiredError("hint", "Required parameter requestParameters.hint was null or undefined when calling assetDisassociateHint.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/asset/{asset}/hints/disassociate/{hint}`.replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))).replace(`{${"hint"}}`, encodeURIComponent(String(requestParameters.hint))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Disassociates an asset from a hint. It performs the same action as the hint equivalent.
   * /asset/{asset}/hints/disassociate/{hint} [POST]
   */
  async assetDisassociateHint(requestParameters, initOverrides) {
    await this.assetDisassociateHintRaw(requestParameters, initOverrides);
  }
  /**
   * Disassociates a person from an asset. It performs the same action as the person equivalent.
   * /asset/{asset}/persons/disassociate/{person} [POST]
   */
  async assetDisassociatePersonRaw(requestParameters, initOverrides) {
    if (requestParameters.asset === null || requestParameters.asset === void 0) {
      throw new RequiredError("asset", "Required parameter requestParameters.asset was null or undefined when calling assetDisassociatePerson.");
    }
    if (requestParameters.person === null || requestParameters.person === void 0) {
      throw new RequiredError("person", "Required parameter requestParameters.person was null or undefined when calling assetDisassociatePerson.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/asset/{asset}/persons/disassociate/{person}`.replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))).replace(`{${"person"}}`, encodeURIComponent(String(requestParameters.person))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Disassociates a person from an asset. It performs the same action as the person equivalent.
   * /asset/{asset}/persons/disassociate/{person} [POST]
   */
  async assetDisassociatePerson(requestParameters, initOverrides) {
    await this.assetDisassociatePersonRaw(requestParameters, initOverrides);
  }
  /**
   * Disassociates a tag from an asset. It performs the same action as the tag equivalent.
   * /asset/{asset}/tags/disassociate/{tag} [POST]
   */
  async assetDisassociateTagRaw(requestParameters, initOverrides) {
    if (requestParameters.tag === null || requestParameters.tag === void 0) {
      throw new RequiredError("tag", "Required parameter requestParameters.tag was null or undefined when calling assetDisassociateTag.");
    }
    if (requestParameters.asset === null || requestParameters.asset === void 0) {
      throw new RequiredError("asset", "Required parameter requestParameters.asset was null or undefined when calling assetDisassociateTag.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/asset/{asset}/tags/disassociate/{tag}`.replace(`{${"tag"}}`, encodeURIComponent(String(requestParameters.tag))).replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Disassociates a tag from an asset. It performs the same action as the tag equivalent.
   * /asset/{asset}/tags/disassociate/{tag} [POST]
   */
  async assetDisassociateTag(requestParameters, initOverrides) {
    await this.assetDisassociateTagRaw(requestParameters, initOverrides);
  }
  /**
   * Disassociates a website from an asset. It performs the same action as the website equivalent.
   * /asset/{asset}/websites/disassociate/{website} [POST]
   */
  async assetDisassociateWebsiteRaw(requestParameters, initOverrides) {
    if (requestParameters.website === null || requestParameters.website === void 0) {
      throw new RequiredError("website", "Required parameter requestParameters.website was null or undefined when calling assetDisassociateWebsite.");
    }
    if (requestParameters.asset === null || requestParameters.asset === void 0) {
      throw new RequiredError("asset", "Required parameter requestParameters.asset was null or undefined when calling assetDisassociateWebsite.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/asset/{asset}/websites/disassociate/{website}`.replace(`{${"website"}}`, encodeURIComponent(String(requestParameters.website))).replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Disassociates a website from an asset. It performs the same action as the website equivalent.
   * /asset/{asset}/websites/disassociate/{website} [POST]
   */
  async assetDisassociateWebsite(requestParameters, initOverrides) {
    await this.assetDisassociateWebsiteRaw(requestParameters, initOverrides);
  }
  /**
   * This will enable us to disassociate an asset from a workstream summary. This will do the same thing as the workstreamSummary equivalent.
   * /asset/{asset}/workstream_summaries/disassociate/{workstream_summary} [POST]
   */
  async assetDisassociateWorkstreamSummaryRaw(requestParameters, initOverrides) {
    if (requestParameters.asset === null || requestParameters.asset === void 0) {
      throw new RequiredError("asset", "Required parameter requestParameters.asset was null or undefined when calling assetDisassociateWorkstreamSummary.");
    }
    if (requestParameters.workstreamSummary === null || requestParameters.workstreamSummary === void 0) {
      throw new RequiredError("workstreamSummary", "Required parameter requestParameters.workstreamSummary was null or undefined when calling assetDisassociateWorkstreamSummary.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/asset/{asset}/workstream_summaries/disassociate/{workstream_summary}`.replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))).replace(`{${"workstream_summary"}}`, encodeURIComponent(String(requestParameters.workstreamSummary))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will enable us to disassociate an asset from a workstream summary. This will do the same thing as the workstreamSummary equivalent.
   * /asset/{asset}/workstream_summaries/disassociate/{workstream_summary} [POST]
   */
  async assetDisassociateWorkstreamSummary(requestParameters, initOverrides) {
    await this.assetDisassociateWorkstreamSummaryRaw(requestParameters, initOverrides);
  }
  /**
   * Retrieves the formats available for a specified asset.
   * /asset/{asset}/formats [GET] Scoped To Asset
   */
  async assetFormatsRaw(requestParameters, initOverrides) {
    if (requestParameters.asset === null || requestParameters.asset === void 0) {
      throw new RequiredError("asset", "Required parameter requestParameters.asset was null or undefined when calling assetFormats.");
    }
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/asset/{asset}/formats`.replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FormatsFromJSON(jsonValue));
  }
  /**
   * Retrieves the formats available for a specified asset.
   * /asset/{asset}/formats [GET] Scoped To Asset
   */
  async assetFormats(requestParameters, initOverrides) {
    const response = await this.assetFormatsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Retrieves the formats available for a specified asset.
   * /asset/reclassify [POST]
   */
  async assetReclassifyRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/asset/reclassify`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: AssetReclassificationToJSON(requestParameters.assetReclassification)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AssetFromJSON(jsonValue));
  }
  /**
   * Retrieves the formats available for a specified asset.
   * /asset/reclassify [POST]
   */
  async assetReclassify(requestParameters = {}, initOverrides) {
    const response = await this.assetReclassifyRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Increments the scores associated with the specified asset based on the provided SeededScoreIncrement data in the request body.
   * /asset/{asset}/scores/increment [POST]
   */
  async assetScoresIncrementRaw(requestParameters, initOverrides) {
    if (requestParameters.asset === null || requestParameters.asset === void 0) {
      throw new RequiredError("asset", "Required parameter requestParameters.asset was null or undefined when calling assetScoresIncrement.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/asset/{asset}/scores/increment`.replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SeededScoreIncrementToJSON(requestParameters.seededScoreIncrement)
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Increments the scores associated with the specified asset based on the provided SeededScoreIncrement data in the request body.
   * /asset/{asset}/scores/increment [POST]
   */
  async assetScoresIncrement(requestParameters, initOverrides) {
    await this.assetScoresIncrementRaw(requestParameters, initOverrides);
  }
  /**
   * Retrieves the snapshot of a specific asset
   * /asset/{asset} [GET] Scoped To Asset
   */
  async assetSnapshotRaw(requestParameters, initOverrides) {
    if (requestParameters.asset === null || requestParameters.asset === void 0) {
      throw new RequiredError("asset", "Required parameter requestParameters.asset was null or undefined when calling assetSnapshot.");
    }
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/asset/{asset}`.replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AssetFromJSON(jsonValue));
  }
  /**
   * Retrieves the snapshot of a specific asset
   * /asset/{asset} [GET] Scoped To Asset
   */
  async assetSnapshot(requestParameters, initOverrides) {
    const response = await this.assetSnapshotRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Retrieves a snapshot of a specific asset, along with the user requesting the snapshot.
   * /asset/{asset} [POST] Scoped to an Asset
   */
  async assetSnapshotPostRaw(requestParameters, initOverrides) {
    if (requestParameters.asset === null || requestParameters.asset === void 0) {
      throw new RequiredError("asset", "Required parameter requestParameters.asset was null or undefined when calling assetSnapshotPost.");
    }
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/asset/{asset}`.replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SeededAccessorToJSON(requestParameters.seededAccessor)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AssetFromJSON(jsonValue));
  }
  /**
   * Retrieves a snapshot of a specific asset, along with the user requesting the snapshot.
   * /asset/{asset} [POST] Scoped to an Asset
   */
  async assetSnapshotPost(requestParameters, initOverrides) {
    const response = await this.assetSnapshotPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Retrieves activity events specific to the given asset.
   * /asset/{asset}/activities [GET]
   */
  async assetSpecificAssetActivitiesRaw(requestParameters, initOverrides) {
    if (requestParameters.asset === null || requestParameters.asset === void 0) {
      throw new RequiredError("asset", "Required parameter requestParameters.asset was null or undefined when calling assetSpecificAssetActivities.");
    }
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/asset/{asset}/activities`.replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ActivitiesFromJSON(jsonValue));
  }
  /**
   * Retrieves activity events specific to the given asset.
   * /asset/{asset}/activities [GET]
   */
  async assetSpecificAssetActivities(requestParameters, initOverrides) {
    const response = await this.assetSpecificAssetActivitiesRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Retrieves conversations specific to the given asset.
   * /asset/{asset}/conversations [GET]
   */
  async assetSpecificAssetConversationsRaw(requestParameters, initOverrides) {
    if (requestParameters.asset === null || requestParameters.asset === void 0) {
      throw new RequiredError("asset", "Required parameter requestParameters.asset was null or undefined when calling assetSpecificAssetConversations.");
    }
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/asset/{asset}/conversations`.replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ConversationsFromJSON(jsonValue));
  }
  /**
   * Retrieves conversations specific to the given asset.
   * /asset/{asset}/conversations [GET]
   */
  async assetSpecificAssetConversations(requestParameters, initOverrides) {
    const response = await this.assetSpecificAssetConversationsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Retrieves an export version of the specified asset.
   * /asset/{asset}/export [GET]
   */
  async assetSpecificAssetExportRaw(requestParameters, initOverrides) {
    if (requestParameters.asset === null || requestParameters.asset === void 0) {
      throw new RequiredError("asset", "Required parameter requestParameters.asset was null or undefined when calling assetSpecificAssetExport.");
    }
    if (requestParameters.exportType === null || requestParameters.exportType === void 0) {
      throw new RequiredError("exportType", "Required parameter requestParameters.exportType was null or undefined when calling assetSpecificAssetExport.");
    }
    const queryParameters = {};
    if (requestParameters.exportType !== void 0) {
      queryParameters["export_type"] = requestParameters.exportType;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/asset/{asset}/export`.replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ExportedAssetFromJSON(jsonValue));
  }
  /**
   * Retrieves an export version of the specified asset.
   * /asset/{asset}/export [GET]
   */
  async assetSpecificAssetExport(requestParameters, initOverrides) {
    const response = await this.assetSpecificAssetExportRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Allows the user to update an existing Asset. It accepts the Asset object that needs updating and returns the fully updated Asset.
   * /asset/update [POST] Scoped to Asset
   */
  async assetUpdateRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/asset/update`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: AssetToJSON(requestParameters.asset)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AssetFromJSON(jsonValue));
  }
  /**
   * Allows the user to update an existing Asset. It accepts the Asset object that needs updating and returns the fully updated Asset.
   * /asset/update [POST] Scoped to Asset
   */
  async assetUpdate(requestParameters = {}, initOverrides) {
    const response = await this.assetUpdateRaw(requestParameters, initOverrides);
    return await response.value();
  }
};
var AssetSpecificAssetExportExportTypeEnum = {
  Html: "HTML",
  Md: "MD"
};

// ../generated_runtime/sdk/http/typescript/core/apis/AssetsApi.ts
var AssetsApi = class extends BaseAPI {
  /**
   * Accepts a seeded (a structure that comes before an asset, and will be used in creation) asset and uploads it to Pieces. The response will be the newly created Asset object.
   * /assets/create [POST] Scoped to Asset
   */
  async assetsCreateNewAssetRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/assets/create`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SeedToJSON(requestParameters.seed)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AssetFromJSON(jsonValue));
  }
  /**
   * Accepts a seeded (a structure that comes before an asset, and will be used in creation) asset and uploads it to Pieces. The response will be the newly created Asset object.
   * /assets/create [POST] Scoped to Asset
   */
  async assetsCreateNewAsset(requestParameters = {}, initOverrides) {
    const response = await this.assetsCreateNewAssetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Deletes a specific asset from the system by providing its unique identifier (UID). Upon successful deletion, it returns the UID of the deleted asset.
   * /assets/{asset}/delete [POST] Scoped to Asset
   */
  async assetsDeleteAssetRaw(requestParameters, initOverrides) {
    if (requestParameters.asset === null || requestParameters.asset === void 0) {
      throw new RequiredError("asset", "Required parameter requestParameters.asset was null or undefined when calling assetsDeleteAsset.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/assets/{asset}/delete`.replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new JSONApiResponse(response);
    } else {
      return new TextApiResponse(response);
    }
  }
  /**
   * Deletes a specific asset from the system by providing its unique identifier (UID). Upon successful deletion, it returns the UID of the deleted asset.
   * /assets/{asset}/delete [POST] Scoped to Asset
   */
  async assetsDeleteAsset(requestParameters, initOverrides) {
    const response = await this.assetsDeleteAssetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Allows developers to input a Seed and receive a drafted asset with preprocessed information. No data is persisted; this is solely an input/output endpoint.  For images, it returns the original Seed.
   * /assets/draft [POST]
   */
  async assetsDraftRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/assets/draft`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SeedToJSON(requestParameters.seed)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SeedFromJSON(jsonValue));
  }
  /**
   * Allows developers to input a Seed and receive a drafted asset with preprocessed information. No data is persisted; this is solely an input/output endpoint.  For images, it returns the original Seed.
   * /assets/draft [POST]
   */
  async assetsDraft(requestParameters = {}, initOverrides) {
    const response = await this.assetsDraftRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Expects a SeededAssetsRecommendation Model in the request body, containing assets and interactions. Returns an Assets Model suitable for UI.
   * Your GET endpoint
   */
  async assetsGetRecommendedAssetsRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/assets/recommended`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters,
      body: SeededAssetsRecommendationToJSON(requestParameters.seededAssetsRecommendation)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AssetsFromJSON(jsonValue));
  }
  /**
   * Expects a SeededAssetsRecommendation Model in the request body, containing assets and interactions. Returns an Assets Model suitable for UI.
   * Your GET endpoint
   */
  async assetsGetRecommendedAssets(requestParameters = {}, initOverrides) {
    const response = await this.assetsGetRecommendedAssetsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Retrieves one or more related assets when provided with one or more input assets.
   * /assets/related [GET]
   */
  async assetsGetRelatedAssetsRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/assets/related`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters,
      body: AssetsToJSON(requestParameters.assets)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AssetsFromJSON(jsonValue));
  }
  /**
   * Retrieves one or more related assets when provided with one or more input assets.
   * /assets/related [GET]
   */
  async assetsGetRelatedAssets(requestParameters = {}, initOverrides) {
    const response = await this.assetsGetRelatedAssetsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Retrieves all asset IDs associated with your account.
   * /assets/identifiers [GET]
   */
  async assetsIdentifiersSnapshotRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.pseudo !== void 0) {
      queryParameters["pseudo"] = requestParameters.pseudo;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/assets/identifiers`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FlattenedAssetsFromJSON(jsonValue));
  }
  /**
   * Retrieves all asset IDs associated with your account.
   * /assets/identifiers [GET]
   */
  async assetsIdentifiersSnapshot(requestParameters = {}, initOverrides) {
    const response = await this.assetsIdentifiersSnapshotRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Retrieves a snapshot exclusively containing pseudo Assets from your Pieces drive.
   * /assets/pseudo [GET]
   */
  async assetsPseudoSnapshotRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/assets/pseudo`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PseudoAssetsFromJSON(jsonValue));
  }
  /**
   * Retrieves a snapshot exclusively containing pseudo Assets from your Pieces drive.
   * /assets/pseudo [GET]
   */
  async assetsPseudoSnapshot(initOverrides) {
    const response = await this.assetsPseudoSnapshotRaw(initOverrides);
    return await response.value();
  }
  /**
   * Enables searching through your pieces and returns Assets (the results) based on your query.  When sending a query in the request body, fuzzy search is applied.  Additionally, the request body can include a search space, currently as a list of UUIDs (and potentially Seeds in the future). Optional filters can also be included in the request body, represented as an iterable of filters, all of which are combined using AND operations.
   * /assets/search [POST]
   */
  async assetsSearchWithFiltersRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    if (requestParameters.pseudo !== void 0) {
      queryParameters["pseudo"] = requestParameters.pseudo;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/assets/search`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: AssetsSearchWithFiltersInputToJSON(requestParameters.assetsSearchWithFiltersInput)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AssetsSearchWithFiltersOutputFromJSON(jsonValue));
  }
  /**
   * Enables searching through your pieces and returns Assets (the results) based on your query.  When sending a query in the request body, fuzzy search is applied.  Additionally, the request body can include a search space, currently as a list of UUIDs (and potentially Seeds in the future). Optional filters can also be included in the request body, represented as an iterable of filters, all of which are combined using AND operations.
   * /assets/search [POST]
   */
  async assetsSearchWithFilters(requestParameters = {}, initOverrides) {
    const response = await this.assetsSearchWithFiltersRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get all of the users Assets.
   * /assets [GET] Scoped to Assets
   */
  async assetsSnapshotRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    if (requestParameters.suggested !== void 0) {
      queryParameters["suggested"] = requestParameters.suggested;
    }
    if (requestParameters.pseudo !== void 0) {
      queryParameters["pseudo"] = requestParameters.pseudo;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/assets`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AssetsFromJSON(jsonValue));
  }
  /**
   * Get all of the users Assets.
   * /assets [GET] Scoped to Assets
   */
  async assetsSnapshot(requestParameters = {}, initOverrides) {
    const response = await this.assetsSnapshotRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Retrieves the available formats for a specific asset identified by its ID
   * /assets/{asset}/formats [GET] Scoped To Assets
   */
  async assetsSpecificAssetFormatsSnapshotRaw(requestParameters, initOverrides) {
    if (requestParameters.asset === null || requestParameters.asset === void 0) {
      throw new RequiredError("asset", "Required parameter requestParameters.asset was null or undefined when calling assetsSpecificAssetFormatsSnapshot.");
    }
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/assets/{asset}/formats`.replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FormatsFromJSON(jsonValue));
  }
  /**
   * Retrieves the available formats for a specific asset identified by its ID
   * /assets/{asset}/formats [GET] Scoped To Assets
   */
  async assetsSpecificAssetFormatsSnapshot(requestParameters, initOverrides) {
    const response = await this.assetsSpecificAssetFormatsSnapshotRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Allows clients to retrieve details of a specific asset by providing its UUID in the path.
   * /assets/{asset} [GET] Scoped to Assets
   */
  async assetsSpecificAssetSnapshotRaw(requestParameters, initOverrides) {
    if (requestParameters.asset === null || requestParameters.asset === void 0) {
      throw new RequiredError("asset", "Required parameter requestParameters.asset was null or undefined when calling assetsSpecificAssetSnapshot.");
    }
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/assets/{asset}`.replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AssetFromJSON(jsonValue));
  }
  /**
   * Allows clients to retrieve details of a specific asset by providing its UUID in the path.
   * /assets/{asset} [GET] Scoped to Assets
   */
  async assetsSpecificAssetSnapshot(requestParameters, initOverrides) {
    const response = await this.assetsSpecificAssetSnapshotRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Provides a WebSocket connection that emits changes to your asset\'s identifiers (UUIDs).
   * /assets/stream/identifiers [WS]
   */
  async assetsStreamIdentifiersRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/assets/stream/identifiers`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => StreamedIdentifiersFromJSON(jsonValue));
  }
  /**
   * Provides a WebSocket connection that emits changes to your asset\'s identifiers (UUIDs).
   * /assets/stream/identifiers [WS]
   */
  async assetsStreamIdentifiers(initOverrides) {
    const response = await this.assetsStreamIdentifiersRaw(initOverrides);
    return await response.value();
  }
  /**
   * Provides a WebSocket connection that emits changes to your assets, including their transferable.
   * /assets/stream/transferables [WS]
   */
  async getAssetsStreamTransferablesRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/assets/stream/transferables`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AssetsFromJSON(jsonValue));
  }
  /**
   * Provides a WebSocket connection that emits changes to your assets, including their transferable.
   * /assets/stream/transferables [WS]
   */
  async getAssetsStreamTransferables(initOverrides) {
    const response = await this.getAssetsStreamTransferablesRaw(initOverrides);
    return await response.value();
  }
  /**
   * Performs a search across your pieces and returns Assets (the results) based on your query. Presently, it only requires your query to be sent in the body. It is mandatory to include searchable_tags (comma-separated values of tags) or a query string.  If a query is provided, a fuzzy search will be conducted. If searchable tags are provided, a tag-based search will be executed.  If neither are included, a 500 error will be returned.
   * /assets/search?query=string [GET]
   */
  async searchAssetsRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.query !== void 0) {
      queryParameters["query"] = requestParameters.query;
    }
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    if (requestParameters.searchableTags !== void 0) {
      queryParameters["searchable_tags"] = requestParameters.searchableTags;
    }
    if (requestParameters.pseudo !== void 0) {
      queryParameters["pseudo"] = requestParameters.pseudo;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/assets/search`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SearchedAssetsFromJSON(jsonValue));
  }
  /**
   * Performs a search across your pieces and returns Assets (the results) based on your query. Presently, it only requires your query to be sent in the body. It is mandatory to include searchable_tags (comma-separated values of tags) or a query string.  If a query is provided, a fuzzy search will be conducted. If searchable tags are provided, a tag-based search will be executed.  If neither are included, a 500 error will be returned.
   * /assets/search?query=string [GET]
   */
  async searchAssets(requestParameters = {}, initOverrides) {
    const response = await this.searchAssetsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Provides a WebSocket connection that emits changes to your assets.
   * /assets/stream [WS]
   */
  async streamAssetsRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/assets/stream`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AssetsFromJSON(jsonValue));
  }
  /**
   * Provides a WebSocket connection that emits changes to your assets.
   * /assets/stream [WS]
   */
  async streamAssets(initOverrides) {
    const response = await this.streamAssetsRaw(initOverrides);
    return await response.value();
  }
};

// ../generated_runtime/sdk/http/typescript/core/apis/ConnectorApi.ts
var ConnectorApi = class extends BaseAPI {
  /**
   * Abstracts a bootup/connection for a specific context.
   * /connect [POST]
   */
  async connectRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/connect`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SeededConnectorConnectionToJSON(requestParameters.seededConnectorConnection)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ContextFromJSON(jsonValue));
  }
  /**
   * Abstracts a bootup/connection for a specific context.
   * /connect [POST]
   */
  async connect(requestParameters = {}, initOverrides) {
    const response = await this.connectRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Allows you to send a SeededAsset for future comparison.
   * /{application}/intention [POST]
   */
  async intentionRaw(requestParameters, initOverrides) {
    if (requestParameters.application === null || requestParameters.application === void 0) {
      throw new RequiredError("application", "Required parameter requestParameters.application was null or undefined when calling intention.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/{application}/intention`.replace(`{${"application"}}`, encodeURIComponent(String(requestParameters.application))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SeededConnectorAssetToJSON(requestParameters.seededConnectorAsset)
    }, initOverrides);
    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new JSONApiResponse(response);
    } else {
      return new TextApiResponse(response);
    }
  }
  /**
   * Allows you to send a SeededAsset for future comparison.
   * /{application}/intention [POST]
   */
  async intention(requestParameters, initOverrides) {
    const response = await this.intentionRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * A central endpoint to manage updates to the onboarding process.
   * /onboarded [POST]
   */
  async onboardedRaw(requestParameters, initOverrides) {
    if (requestParameters.application === null || requestParameters.application === void 0) {
      throw new RequiredError("application", "Required parameter requestParameters.application was null or undefined when calling onboarded.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/{application}/onboarded`.replace(`{${"application"}}`, encodeURIComponent(String(requestParameters.application))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    }, initOverrides);
    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new JSONApiResponse(response);
    } else {
      return new TextApiResponse(response);
    }
  }
  /**
   * A central endpoint to manage updates to the onboarding process.
   * /onboarded [POST]
   */
  async onboarded(requestParameters, initOverrides) {
    const response = await this.onboardedRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will respond to the output generated by the /suggest endpoint.
   * /{application}/reaction [POST]
   */
  async reactRaw(requestParameters, initOverrides) {
    if (requestParameters.application === null || requestParameters.application === void 0) {
      throw new RequiredError("application", "Required parameter requestParameters.application was null or undefined when calling react.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/{application}/reaction`.replace(`{${"application"}}`, encodeURIComponent(String(requestParameters.application))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: ReactionToJSON(requestParameters.reaction)
    }, initOverrides);
    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new JSONApiResponse(response);
    } else {
      return new TextApiResponse(response);
    }
  }
  /**
   * This will respond to the output generated by the /suggest endpoint.
   * /{application}/reaction [POST]
   */
  async react(requestParameters, initOverrides) {
    const response = await this.reactRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Invoked whenever a code snippet is copied from an integration. For instance, if a JetBrains user copies code, this endpoint can be called to assess whether to suggest reusing a piece (if reuse is true, the endpoint provides assets that the user may consider using), saving the code snippet, or taking no action.   **Note: This endpoint could potentially accept a SeededFormat for the request body if required.
   * /{application}/suggestion [POST]
   */
  async suggestRaw(requestParameters, initOverrides) {
    if (requestParameters.application === null || requestParameters.application === void 0) {
      throw new RequiredError("application", "Required parameter requestParameters.application was null or undefined when calling suggest.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/{application}/suggestion`.replace(`{${"application"}}`, encodeURIComponent(String(requestParameters.application))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SeededConnectorCreationToJSON(requestParameters.seededConnectorCreation)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuggestionFromJSON(jsonValue));
  }
  /**
   * Invoked whenever a code snippet is copied from an integration. For instance, if a JetBrains user copies code, this endpoint can be called to assess whether to suggest reusing a piece (if reuse is true, the endpoint provides assets that the user may consider using), saving the code snippet, or taking no action.   **Note: This endpoint could potentially accept a SeededFormat for the request body if required.
   * /{application}/suggestion [POST]
   */
  async suggest(requestParameters, initOverrides) {
    const response = await this.suggestRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Abstracts the process of packaging segments on a per-context basis.
   * /{application}/track [POST]
   */
  async trackRaw(requestParameters, initOverrides) {
    if (requestParameters.application === null || requestParameters.application === void 0) {
      throw new RequiredError("application", "Required parameter requestParameters.application was null or undefined when calling track.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/{application}/track`.replace(`{${"application"}}`, encodeURIComponent(String(requestParameters.application))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SeededConnectorTrackingToJSON(requestParameters.seededConnectorTracking)
    }, initOverrides);
    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new JSONApiResponse(response);
    } else {
      return new TextApiResponse(response);
    }
  }
  /**
   * Abstracts the process of packaging segments on a per-context basis.
   * /{application}/track [POST]
   */
  async track(requestParameters, initOverrides) {
    const response = await this.trackRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// ../generated_runtime/sdk/http/typescript/core/apis/ConversationApi.ts
var ConversationApi = class extends BaseAPI {
  /**
   * Updates both the anchor and the conversation, associating them together.
   * /conversation/{conversation}/anchors/associate/{anchor} [POST]
   */
  async conversationAssociateAnchorRaw(requestParameters, initOverrides) {
    if (requestParameters.conversation === null || requestParameters.conversation === void 0) {
      throw new RequiredError("conversation", "Required parameter requestParameters.conversation was null or undefined when calling conversationAssociateAnchor.");
    }
    if (requestParameters.anchor === null || requestParameters.anchor === void 0) {
      throw new RequiredError("anchor", "Required parameter requestParameters.anchor was null or undefined when calling conversationAssociateAnchor.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/conversation/{conversation}/anchors/associate/{anchor}`.replace(`{${"conversation"}}`, encodeURIComponent(String(requestParameters.conversation))).replace(`{${"anchor"}}`, encodeURIComponent(String(requestParameters.anchor))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Updates both the anchor and the conversation, associating them together.
   * /conversation/{conversation}/anchors/associate/{anchor} [POST]
   */
  async conversationAssociateAnchor(requestParameters, initOverrides) {
    await this.conversationAssociateAnchorRaw(requestParameters, initOverrides);
  }
  /**
   * Updates both the asset and the conversation, associating the two together.
   * /conversation/{conversation}/assets/associate/{asset} [POST]
   */
  async conversationAssociateAssetRaw(requestParameters, initOverrides) {
    if (requestParameters.conversation === null || requestParameters.conversation === void 0) {
      throw new RequiredError("conversation", "Required parameter requestParameters.conversation was null or undefined when calling conversationAssociateAsset.");
    }
    if (requestParameters.asset === null || requestParameters.asset === void 0) {
      throw new RequiredError("asset", "Required parameter requestParameters.asset was null or undefined when calling conversationAssociateAsset.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/conversation/{conversation}/assets/associate/{asset}`.replace(`{${"conversation"}}`, encodeURIComponent(String(requestParameters.conversation))).replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Updates both the asset and the conversation, associating the two together.
   * /conversation/{conversation}/assets/associate/{asset} [POST]
   */
  async conversationAssociateAsset(requestParameters, initOverrides) {
    await this.conversationAssociateAssetRaw(requestParameters, initOverrides);
  }
  /**
   * This will associate a workstream(range) with a conversation. This will do the same thing as the range equivalent.
   * /conversation/{conversation}/grounding/temporal/ranges/associate/{range} [POST]
   */
  async conversationAssociateGroundingTemporalRangeWorkstreamRaw(requestParameters, initOverrides) {
    if (requestParameters.conversation === null || requestParameters.conversation === void 0) {
      throw new RequiredError("conversation", "Required parameter requestParameters.conversation was null or undefined when calling conversationAssociateGroundingTemporalRangeWorkstream.");
    }
    if (requestParameters.range === null || requestParameters.range === void 0) {
      throw new RequiredError("range", "Required parameter requestParameters.range was null or undefined when calling conversationAssociateGroundingTemporalRangeWorkstream.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/conversation/{conversation}/grounding/temporal_range/workstreams/associate/{range}`.replace(`{${"conversation"}}`, encodeURIComponent(String(requestParameters.conversation))).replace(`{${"range"}}`, encodeURIComponent(String(requestParameters.range))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will associate a workstream(range) with a conversation. This will do the same thing as the range equivalent.
   * /conversation/{conversation}/grounding/temporal/ranges/associate/{range} [POST]
   */
  async conversationAssociateGroundingTemporalRangeWorkstream(requestParameters, initOverrides) {
    await this.conversationAssociateGroundingTemporalRangeWorkstreamRaw(requestParameters, initOverrides);
  }
  /**
   * Updates both the website and the conversation, and associate them together.
   * /conversation/{conversation}/websites/associate/{website} [POST]
   */
  async conversationAssociateWebsiteRaw(requestParameters, initOverrides) {
    if (requestParameters.conversation === null || requestParameters.conversation === void 0) {
      throw new RequiredError("conversation", "Required parameter requestParameters.conversation was null or undefined when calling conversationAssociateWebsite.");
    }
    if (requestParameters.website === null || requestParameters.website === void 0) {
      throw new RequiredError("website", "Required parameter requestParameters.website was null or undefined when calling conversationAssociateWebsite.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/conversation/{conversation}/websites/associate/{website}`.replace(`{${"conversation"}}`, encodeURIComponent(String(requestParameters.conversation))).replace(`{${"website"}}`, encodeURIComponent(String(requestParameters.website))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Updates both the website and the conversation, and associate them together.
   * /conversation/{conversation}/websites/associate/{website} [POST]
   */
  async conversationAssociateWebsite(requestParameters, initOverrides) {
    await this.conversationAssociateWebsiteRaw(requestParameters, initOverrides);
  }
  /**
   * This will associate a conversation with a workstream summary. This will do the same thing as the workstreamSummary equivalent.
   * /conversation/{conversation}/workstream_summaries/associate/{workstream_summary} [POST]
   */
  async conversationAssociateWorkstreamSummaryRaw(requestParameters, initOverrides) {
    if (requestParameters.conversation === null || requestParameters.conversation === void 0) {
      throw new RequiredError("conversation", "Required parameter requestParameters.conversation was null or undefined when calling conversationAssociateWorkstreamSummary.");
    }
    if (requestParameters.workstreamSummary === null || requestParameters.workstreamSummary === void 0) {
      throw new RequiredError("workstreamSummary", "Required parameter requestParameters.workstreamSummary was null or undefined when calling conversationAssociateWorkstreamSummary.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/conversation/{conversation}/workstream_summaries/associate/{workstream_summary}`.replace(`{${"conversation"}}`, encodeURIComponent(String(requestParameters.conversation))).replace(`{${"workstream_summary"}}`, encodeURIComponent(String(requestParameters.workstreamSummary))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will associate a conversation with a workstream summary. This will do the same thing as the workstreamSummary equivalent.
   * /conversation/{conversation}/workstream_summaries/associate/{workstream_summary} [POST]
   */
  async conversationAssociateWorkstreamSummary(requestParameters, initOverrides) {
    await this.conversationAssociateWorkstreamSummaryRaw(requestParameters, initOverrides);
  }
  /**
   * Updates both the anchor and the conversation, deleting (disassociating) them simultaneously.
   * /conversation/{conversation}/anchors/disassociate/{anchor} [POST]
   */
  async conversationDisassociateAnchorRaw(requestParameters, initOverrides) {
    if (requestParameters.conversation === null || requestParameters.conversation === void 0) {
      throw new RequiredError("conversation", "Required parameter requestParameters.conversation was null or undefined when calling conversationDisassociateAnchor.");
    }
    if (requestParameters.anchor === null || requestParameters.anchor === void 0) {
      throw new RequiredError("anchor", "Required parameter requestParameters.anchor was null or undefined when calling conversationDisassociateAnchor.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/conversation/{conversation}/anchors/disassociate/{anchor}`.replace(`{${"conversation"}}`, encodeURIComponent(String(requestParameters.conversation))).replace(`{${"anchor"}}`, encodeURIComponent(String(requestParameters.anchor))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Updates both the anchor and the conversation, deleting (disassociating) them simultaneously.
   * /conversation/{conversation}/anchors/disassociate/{anchor} [POST]
   */
  async conversationDisassociateAnchor(requestParameters, initOverrides) {
    await this.conversationDisassociateAnchorRaw(requestParameters, initOverrides);
  }
  /**
   * Updates both the asset and the conversation, effectively disassociating them.
   * /conversation/{conversation}/assets/disassociate/{asset} [POST]
   */
  async conversationDisassociateAssetRaw(requestParameters, initOverrides) {
    if (requestParameters.conversation === null || requestParameters.conversation === void 0) {
      throw new RequiredError("conversation", "Required parameter requestParameters.conversation was null or undefined when calling conversationDisassociateAsset.");
    }
    if (requestParameters.asset === null || requestParameters.asset === void 0) {
      throw new RequiredError("asset", "Required parameter requestParameters.asset was null or undefined when calling conversationDisassociateAsset.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/conversation/{conversation}/assets/disassociate/{asset}`.replace(`{${"conversation"}}`, encodeURIComponent(String(requestParameters.conversation))).replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Updates both the asset and the conversation, effectively disassociating them.
   * /conversation/{conversation}/assets/disassociate/{asset} [POST]
   */
  async conversationDisassociateAsset(requestParameters, initOverrides) {
    await this.conversationDisassociateAssetRaw(requestParameters, initOverrides);
  }
  /**
   * This will enable us to disassociate a workstream(range) from a conversation. This will do the same thing as the range equivalent.
   * /conversation/{conversation}/grounding/temporal_range/workstreams/disassociate/{range} [POST]
   */
  async conversationDisassociateGroundingTemporalRangeWorkstreamRaw(requestParameters, initOverrides) {
    if (requestParameters.conversation === null || requestParameters.conversation === void 0) {
      throw new RequiredError("conversation", "Required parameter requestParameters.conversation was null or undefined when calling conversationDisassociateGroundingTemporalRangeWorkstream.");
    }
    if (requestParameters.range === null || requestParameters.range === void 0) {
      throw new RequiredError("range", "Required parameter requestParameters.range was null or undefined when calling conversationDisassociateGroundingTemporalRangeWorkstream.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/conversation/{conversation}/grounding/temporal_range/workstreams/disassociate/{range}`.replace(`{${"conversation"}}`, encodeURIComponent(String(requestParameters.conversation))).replace(`{${"range"}}`, encodeURIComponent(String(requestParameters.range))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will enable us to disassociate a workstream(range) from a conversation. This will do the same thing as the range equivalent.
   * /conversation/{conversation}/grounding/temporal_range/workstreams/disassociate/{range} [POST]
   */
  async conversationDisassociateGroundingTemporalRangeWorkstream(requestParameters, initOverrides) {
    await this.conversationDisassociateGroundingTemporalRangeWorkstreamRaw(requestParameters, initOverrides);
  }
  /**
   * Allows us to disassociate a conversation from a specific website
   * /website/{website}/websites/disassociate/{website} [POST]
   */
  async conversationDisassociateWebsiteRaw(requestParameters, initOverrides) {
    if (requestParameters.conversation === null || requestParameters.conversation === void 0) {
      throw new RequiredError("conversation", "Required parameter requestParameters.conversation was null or undefined when calling conversationDisassociateWebsite.");
    }
    if (requestParameters.website === null || requestParameters.website === void 0) {
      throw new RequiredError("website", "Required parameter requestParameters.website was null or undefined when calling conversationDisassociateWebsite.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/conversation/{conversation}/websites/disassociate/{website}`.replace(`{${"conversation"}}`, encodeURIComponent(String(requestParameters.conversation))).replace(`{${"website"}}`, encodeURIComponent(String(requestParameters.website))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Allows us to disassociate a conversation from a specific website
   * /website/{website}/websites/disassociate/{website} [POST]
   */
  async conversationDisassociateWebsite(requestParameters, initOverrides) {
    await this.conversationDisassociateWebsiteRaw(requestParameters, initOverrides);
  }
  /**
   * This will enable us to disassociate an conversation from a workstream summary. This will do the same thing as the workstreamSummary equivalent.
   * /conversation/{conversation}/workstream_summaries/disassociate/{workstream_summary} [POST]
   */
  async conversationDisassociateWorkstreamSummaryRaw(requestParameters, initOverrides) {
    if (requestParameters.conversation === null || requestParameters.conversation === void 0) {
      throw new RequiredError("conversation", "Required parameter requestParameters.conversation was null or undefined when calling conversationDisassociateWorkstreamSummary.");
    }
    if (requestParameters.workstreamSummary === null || requestParameters.workstreamSummary === void 0) {
      throw new RequiredError("workstreamSummary", "Required parameter requestParameters.workstreamSummary was null or undefined when calling conversationDisassociateWorkstreamSummary.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/conversation/{conversation}/workstream_summaries/disassociate/{workstream_summary}`.replace(`{${"conversation"}}`, encodeURIComponent(String(requestParameters.conversation))).replace(`{${"workstream_summary"}}`, encodeURIComponent(String(requestParameters.workstreamSummary))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will enable us to disassociate an conversation from a workstream summary. This will do the same thing as the workstreamSummary equivalent.
   * /conversation/{conversation}/workstream_summaries/disassociate/{workstream_summary} [POST]
   */
  async conversationDisassociateWorkstreamSummary(requestParameters, initOverrides) {
    await this.conversationDisassociateWorkstreamSummaryRaw(requestParameters, initOverrides);
  }
  /**
   * Retrieves a specific conversation.
   * /conversation/{conversation} [GET]
   */
  async conversationGetSpecificConversationRaw(requestParameters, initOverrides) {
    if (requestParameters.conversation === null || requestParameters.conversation === void 0) {
      throw new RequiredError("conversation", "Required parameter requestParameters.conversation was null or undefined when calling conversationGetSpecificConversation.");
    }
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/conversation/{conversation}`.replace(`{${"conversation"}}`, encodeURIComponent(String(requestParameters.conversation))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ConversationFromJSON(jsonValue));
  }
  /**
   * Retrieves a specific conversation.
   * /conversation/{conversation} [GET]
   */
  async conversationGetSpecificConversation(requestParameters, initOverrides) {
    const response = await this.conversationGetSpecificConversationRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Stores the grounding context for a conversation. It allows to associate a message with the conversation\'s grounding object, facilitating contextual understanding and management of the conversation.
   * /conversation/{conversation}/grounding/messages/associate/{message} [POST]
   */
  async conversationGroundingMessagesAssociateMessageRaw(requestParameters, initOverrides) {
    if (requestParameters.conversation === null || requestParameters.conversation === void 0) {
      throw new RequiredError("conversation", "Required parameter requestParameters.conversation was null or undefined when calling conversationGroundingMessagesAssociateMessage.");
    }
    if (requestParameters.message === null || requestParameters.message === void 0) {
      throw new RequiredError("message", "Required parameter requestParameters.message was null or undefined when calling conversationGroundingMessagesAssociateMessage.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/conversation/{conversation}/grounding/messages/associate/{message}`.replace(`{${"conversation"}}`, encodeURIComponent(String(requestParameters.conversation))).replace(`{${"message"}}`, encodeURIComponent(String(requestParameters.message))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Stores the grounding context for a conversation. It allows to associate a message with the conversation\'s grounding object, facilitating contextual understanding and management of the conversation.
   * /conversation/{conversation}/grounding/messages/associate/{message} [POST]
   */
  async conversationGroundingMessagesAssociateMessage(requestParameters, initOverrides) {
    await this.conversationGroundingMessagesAssociateMessageRaw(requestParameters, initOverrides);
  }
  /**
   * Removes a specific grounding context for a conversation, and allows us to disassociate a message from the conversation\'s grounding object.
   * /conversation/{conversation}/grounding/messages/disassociate/{message} [POST]
   */
  async conversationGroundingMessagesDisassociateMessageRaw(requestParameters, initOverrides) {
    if (requestParameters.conversation === null || requestParameters.conversation === void 0) {
      throw new RequiredError("conversation", "Required parameter requestParameters.conversation was null or undefined when calling conversationGroundingMessagesDisassociateMessage.");
    }
    if (requestParameters.message === null || requestParameters.message === void 0) {
      throw new RequiredError("message", "Required parameter requestParameters.message was null or undefined when calling conversationGroundingMessagesDisassociateMessage.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/conversation/{conversation}/grounding/messages/disassociate/{message}`.replace(`{${"conversation"}}`, encodeURIComponent(String(requestParameters.conversation))).replace(`{${"message"}}`, encodeURIComponent(String(requestParameters.message))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Removes a specific grounding context for a conversation, and allows us to disassociate a message from the conversation\'s grounding object.
   * /conversation/{conversation}/grounding/messages/disassociate/{message} [POST]
   */
  async conversationGroundingMessagesDisassociateMessage(requestParameters, initOverrides) {
    await this.conversationGroundingMessagesDisassociateMessageRaw(requestParameters, initOverrides);
  }
  /**
   * Increment scores associated with a conversation. It accepts a SeededScoreIncrement object as input to adjust the scores accordingly based on the provided data.
   * /conversation/{conversation}/scores/increment [POST]
   */
  async conversationScoresIncrementRaw(requestParameters, initOverrides) {
    if (requestParameters.conversation === null || requestParameters.conversation === void 0) {
      throw new RequiredError("conversation", "Required parameter requestParameters.conversation was null or undefined when calling conversationScoresIncrement.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/conversation/{conversation}/scores/increment`.replace(`{${"conversation"}}`, encodeURIComponent(String(requestParameters.conversation))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SeededScoreIncrementToJSON(requestParameters.seededScoreIncrement)
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Increment scores associated with a conversation. It accepts a SeededScoreIncrement object as input to adjust the scores accordingly based on the provided data.
   * /conversation/{conversation}/scores/increment [POST]
   */
  async conversationScoresIncrement(requestParameters, initOverrides) {
    await this.conversationScoresIncrementRaw(requestParameters, initOverrides);
  }
  /**
   * Retrieves messages specific to a particular conversation.
   * /conversation/{conversation}/messages [GET]
   */
  async conversationSpecificConversationMessagesRaw(requestParameters, initOverrides) {
    if (requestParameters.conversation === null || requestParameters.conversation === void 0) {
      throw new RequiredError("conversation", "Required parameter requestParameters.conversation was null or undefined when calling conversationSpecificConversationMessages.");
    }
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/conversation/{conversation}/messages`.replace(`{${"conversation"}}`, encodeURIComponent(String(requestParameters.conversation))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ConversationMessagesFromJSON(jsonValue));
  }
  /**
   * Retrieves messages specific to a particular conversation.
   * /conversation/{conversation}/messages [GET]
   */
  async conversationSpecificConversationMessages(requestParameters, initOverrides) {
    const response = await this.conversationSpecificConversationMessagesRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Renames a specific conversation using machine learning (ML) techniques.
   * /conversation/{conversation}/rename [POST]
   */
  async conversationSpecificConversationRenameRaw(requestParameters, initOverrides) {
    if (requestParameters.conversation === null || requestParameters.conversation === void 0) {
      throw new RequiredError("conversation", "Required parameter requestParameters.conversation was null or undefined when calling conversationSpecificConversationRename.");
    }
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/conversation/{conversation}/rename`.replace(`{${"conversation"}}`, encodeURIComponent(String(requestParameters.conversation))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ConversationFromJSON(jsonValue));
  }
  /**
   * Renames a specific conversation using machine learning (ML) techniques.
   * /conversation/{conversation}/rename [POST]
   */
  async conversationSpecificConversationRename(requestParameters, initOverrides) {
    const response = await this.conversationSpecificConversationRenameRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Generates a summary of a given conversation and saves it as an annotation associated with the conversation. It returns a reference to the annotation, which serves as the summary.
   * /conversation/{conversation}/summarize [POST]
   */
  async conversationSummarizeRaw(requestParameters, initOverrides) {
    if (requestParameters.conversation === null || requestParameters.conversation === void 0) {
      throw new RequiredError("conversation", "Required parameter requestParameters.conversation was null or undefined when calling conversationSummarize.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/conversation/{conversation}/summarize`.replace(`{${"conversation"}}`, encodeURIComponent(String(requestParameters.conversation))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: ConversationSummarizeInputToJSON(requestParameters.conversationSummarizeInput)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ConversationSummarizeOutputFromJSON(jsonValue));
  }
  /**
   * Generates a summary of a given conversation and saves it as an annotation associated with the conversation. It returns a reference to the annotation, which serves as the summary.
   * /conversation/{conversation}/summarize [POST]
   */
  async conversationSummarize(requestParameters, initOverrides) {
    const response = await this.conversationSummarizeRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Updates a specific conversation.
   * /conversation/update [POST]
   */
  async conversationUpdateRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/conversation/update`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: ConversationToJSON(requestParameters.conversation)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ConversationFromJSON(jsonValue));
  }
  /**
   * Updates a specific conversation.
   * /conversation/update [POST]
   */
  async conversationUpdate(requestParameters = {}, initOverrides) {
    const response = await this.conversationUpdateRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will search a specific conversation for a match  note: here we will only search the conversationMessages for this given Conversation
   * /conversation/{conversation}/search [POST]
   */
  async searchConversationSpecificMessagesRaw(requestParameters, initOverrides) {
    if (requestParameters.conversation === null || requestParameters.conversation === void 0) {
      throw new RequiredError("conversation", "Required parameter requestParameters.conversation was null or undefined when calling searchConversationSpecificMessages.");
    }
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/conversation/{conversation}/search`.replace(`{${"conversation"}}`, encodeURIComponent(String(requestParameters.conversation))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SearchInputToJSON(requestParameters.searchInput)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SearchedConversationMessagesFromJSON(jsonValue));
  }
  /**
   * This will search a specific conversation for a match  note: here we will only search the conversationMessages for this given Conversation
   * /conversation/{conversation}/search [POST]
   */
  async searchConversationSpecificMessages(requestParameters, initOverrides) {
    const response = await this.searchConversationSpecificMessagesRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// ../generated_runtime/sdk/http/typescript/core/apis/ConversationMessageApi.ts
var ConversationMessageApi = class extends BaseAPI {
  /**
   * This will associate a message with an anchor.
   * /message/{message}/anchors/associate/{anchor} [POST]
   */
  async messageAssociateAnchorRaw(requestParameters, initOverrides) {
    if (requestParameters.message === null || requestParameters.message === void 0) {
      throw new RequiredError("message", "Required parameter requestParameters.message was null or undefined when calling messageAssociateAnchor.");
    }
    if (requestParameters.anchor === null || requestParameters.anchor === void 0) {
      throw new RequiredError("anchor", "Required parameter requestParameters.anchor was null or undefined when calling messageAssociateAnchor.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/message/{message}/anchors/associate/{anchor}`.replace(`{${"message"}}`, encodeURIComponent(String(requestParameters.message))).replace(`{${"anchor"}}`, encodeURIComponent(String(requestParameters.anchor))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will associate a message with an anchor.
   * /message/{message}/anchors/associate/{anchor} [POST]
   */
  async messageAssociateAnchor(requestParameters, initOverrides) {
    await this.messageAssociateAnchorRaw(requestParameters, initOverrides);
  }
  /**
   * This will associate a message with an annotation.
   * /message/{message}/annotations/associate/{annotation} [POST]
   */
  async messageAssociateAnnotationRaw(requestParameters, initOverrides) {
    if (requestParameters.annotation === null || requestParameters.annotation === void 0) {
      throw new RequiredError("annotation", "Required parameter requestParameters.annotation was null or undefined when calling messageAssociateAnnotation.");
    }
    if (requestParameters.message === null || requestParameters.message === void 0) {
      throw new RequiredError("message", "Required parameter requestParameters.message was null or undefined when calling messageAssociateAnnotation.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/message/{message}/annotations/associate/{annotation}`.replace(`{${"annotation"}}`, encodeURIComponent(String(requestParameters.annotation))).replace(`{${"message"}}`, encodeURIComponent(String(requestParameters.message))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will associate a message with an annotation.
   * /message/{message}/annotations/associate/{annotation} [POST]
   */
  async messageAssociateAnnotation(requestParameters, initOverrides) {
    await this.messageAssociateAnnotationRaw(requestParameters, initOverrides);
  }
  /**
   * This will associate a message with a person.
   * /message/{message}/persons/associate/{person} [POST]
   */
  async messageAssociatePersonRaw(requestParameters, initOverrides) {
    if (requestParameters.message === null || requestParameters.message === void 0) {
      throw new RequiredError("message", "Required parameter requestParameters.message was null or undefined when calling messageAssociatePerson.");
    }
    if (requestParameters.person === null || requestParameters.person === void 0) {
      throw new RequiredError("person", "Required parameter requestParameters.person was null or undefined when calling messageAssociatePerson.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/message/{message}/persons/associate/{person}`.replace(`{${"message"}}`, encodeURIComponent(String(requestParameters.message))).replace(`{${"person"}}`, encodeURIComponent(String(requestParameters.person))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will associate a message with a person.
   * /message/{message}/persons/associate/{person} [POST]
   */
  async messageAssociatePerson(requestParameters, initOverrides) {
    await this.messageAssociatePersonRaw(requestParameters, initOverrides);
  }
  /**
   * This will associate a message with a website.
   * Associate a message with a website
   */
  async messageAssociateWebsiteRaw(requestParameters, initOverrides) {
    if (requestParameters.message === null || requestParameters.message === void 0) {
      throw new RequiredError("message", "Required parameter requestParameters.message was null or undefined when calling messageAssociateWebsite.");
    }
    if (requestParameters.website === null || requestParameters.website === void 0) {
      throw new RequiredError("website", "Required parameter requestParameters.website was null or undefined when calling messageAssociateWebsite.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/message/{message}/websites/associate/{website}`.replace(`{${"message"}}`, encodeURIComponent(String(requestParameters.message))).replace(`{${"website"}}`, encodeURIComponent(String(requestParameters.website))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will associate a message with a website.
   * Associate a message with a website
   */
  async messageAssociateWebsite(requestParameters, initOverrides) {
    await this.messageAssociateWebsiteRaw(requestParameters, initOverrides);
  }
  /**
   * This will enable us to disassociate a message from an anchor.
   * /message/{message}/anchors/disassociate/{anchor} [POST]
   */
  async messageDisassociateAnchorRaw(requestParameters, initOverrides) {
    if (requestParameters.message === null || requestParameters.message === void 0) {
      throw new RequiredError("message", "Required parameter requestParameters.message was null or undefined when calling messageDisassociateAnchor.");
    }
    if (requestParameters.anchor === null || requestParameters.anchor === void 0) {
      throw new RequiredError("anchor", "Required parameter requestParameters.anchor was null or undefined when calling messageDisassociateAnchor.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/message/{message}/anchors/disassociate/{anchor}`.replace(`{${"message"}}`, encodeURIComponent(String(requestParameters.message))).replace(`{${"anchor"}}`, encodeURIComponent(String(requestParameters.anchor))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will enable us to disassociate a message from an anchor.
   * /message/{message}/anchors/disassociate/{anchor} [POST]
   */
  async messageDisassociateAnchor(requestParameters, initOverrides) {
    await this.messageDisassociateAnchorRaw(requestParameters, initOverrides);
  }
  /**
   * This will enable us to dissassociate a message from an annotation.
   * /message/{message}/annotations/disassociate/{annotation} [POST]
   */
  async messageDisassociateAnnotationRaw(requestParameters, initOverrides) {
    if (requestParameters.annotation === null || requestParameters.annotation === void 0) {
      throw new RequiredError("annotation", "Required parameter requestParameters.annotation was null or undefined when calling messageDisassociateAnnotation.");
    }
    if (requestParameters.message === null || requestParameters.message === void 0) {
      throw new RequiredError("message", "Required parameter requestParameters.message was null or undefined when calling messageDisassociateAnnotation.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/message/{message}/annotations/disassociate/{annotation}`.replace(`{${"annotation"}}`, encodeURIComponent(String(requestParameters.annotation))).replace(`{${"message"}}`, encodeURIComponent(String(requestParameters.message))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will enable us to dissassociate a message from an annotation.
   * /message/{message}/annotations/disassociate/{annotation} [POST]
   */
  async messageDisassociateAnnotation(requestParameters, initOverrides) {
    await this.messageDisassociateAnnotationRaw(requestParameters, initOverrides);
  }
  /**
   * This will enable us to disassociate a message from a person.
   * /message/{message}/persons/disassociate/{person} [POST]
   */
  async messageDisassociatePersonRaw(requestParameters, initOverrides) {
    if (requestParameters.message === null || requestParameters.message === void 0) {
      throw new RequiredError("message", "Required parameter requestParameters.message was null or undefined when calling messageDisassociatePerson.");
    }
    if (requestParameters.person === null || requestParameters.person === void 0) {
      throw new RequiredError("person", "Required parameter requestParameters.person was null or undefined when calling messageDisassociatePerson.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/message/{message}/persons/disassociate/{person}`.replace(`{${"message"}}`, encodeURIComponent(String(requestParameters.message))).replace(`{${"person"}}`, encodeURIComponent(String(requestParameters.person))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will enable us to disassociate a message from a person.
   * /message/{message}/persons/disassociate/{person} [POST]
   */
  async messageDisassociatePerson(requestParameters, initOverrides) {
    await this.messageDisassociatePersonRaw(requestParameters, initOverrides);
  }
  /**
   * This will enable us to disassociate a message from a website.
   * /message/{message}/websites/disassociate/{website} [POST]
   */
  async messageDisassociateWebsiteRaw(requestParameters, initOverrides) {
    if (requestParameters.message === null || requestParameters.message === void 0) {
      throw new RequiredError("message", "Required parameter requestParameters.message was null or undefined when calling messageDisassociateWebsite.");
    }
    if (requestParameters.website === null || requestParameters.website === void 0) {
      throw new RequiredError("website", "Required parameter requestParameters.website was null or undefined when calling messageDisassociateWebsite.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/message/{message}/websites/disassociate/{website}`.replace(`{${"message"}}`, encodeURIComponent(String(requestParameters.message))).replace(`{${"website"}}`, encodeURIComponent(String(requestParameters.website))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will enable us to disassociate a message from a website.
   * /message/{message}/websites/disassociate/{website} [POST]
   */
  async messageDisassociateWebsite(requestParameters, initOverrides) {
    await this.messageDisassociateWebsiteRaw(requestParameters, initOverrides);
  }
  /**
   * This will take in a SeededScoreIncrement and will increment the material relative to the incoming body.
   * \'/message/{message}/scores/increment\' [POST]
   */
  async messageScoresIncrementRaw(requestParameters, initOverrides) {
    if (requestParameters.message === null || requestParameters.message === void 0) {
      throw new RequiredError("message", "Required parameter requestParameters.message was null or undefined when calling messageScoresIncrement.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/message/{message}/scores/increment`.replace(`{${"message"}}`, encodeURIComponent(String(requestParameters.message))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SeededScoreIncrementToJSON(requestParameters.seededScoreIncrement)
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will take in a SeededScoreIncrement and will increment the material relative to the incoming body.
   * \'/message/{message}/scores/increment\' [POST]
   */
  async messageScoresIncrement(requestParameters, initOverrides) {
    await this.messageScoresIncrementRaw(requestParameters, initOverrides);
  }
  /**
   * This will get a specific snapshot of a message
   * /message/{message} [GET]
   */
  async messageSpecificMessageSnapshotRaw(requestParameters, initOverrides) {
    if (requestParameters.message === null || requestParameters.message === void 0) {
      throw new RequiredError("message", "Required parameter requestParameters.message was null or undefined when calling messageSpecificMessageSnapshot.");
    }
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/message/{message}`.replace(`{${"message"}}`, encodeURIComponent(String(requestParameters.message))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ConversationMessageFromJSON(jsonValue));
  }
  /**
   * This will get a specific snapshot of a message
   * /message/{message} [GET]
   */
  async messageSpecificMessageSnapshot(requestParameters, initOverrides) {
    const response = await this.messageSpecificMessageSnapshotRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will update a conversation message.
   * /message/update [GET]
   */
  async messageSpecificMessageUpdateRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/message/update`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: ConversationMessageToJSON(requestParameters.conversationMessage)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ConversationMessageFromJSON(jsonValue));
  }
  /**
   * This will update a conversation message.
   * /message/update [GET]
   */
  async messageSpecificMessageUpdate(requestParameters = {}, initOverrides) {
    const response = await this.messageSpecificMessageUpdateRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will update the value of a conversation message.
   * /message/update/value [POST]
   */
  async messageUpdateValueRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/message/update/value`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: ConversationMessageToJSON(requestParameters.conversationMessage)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ConversationMessageFromJSON(jsonValue));
  }
  /**
   * This will update the value of a conversation message.
   * /message/update/value [POST]
   */
  async messageUpdateValue(requestParameters = {}, initOverrides) {
    const response = await this.messageUpdateValueRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// ../generated_runtime/sdk/http/typescript/core/apis/ConversationMessagesApi.ts
var ConversationMessagesApi = class extends BaseAPI {
  /**
   * Provides a WebSocket connection that emits changes to your conversation messages identifiers (UUIDs).
   * /messages/stream/identifiers [WS]
   */
  async conversationMessagesStreamIdentifiersRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/messages/stream/identifiers`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => StreamedIdentifiersFromJSON(jsonValue));
  }
  /**
   * Provides a WebSocket connection that emits changes to your conversation messages identifiers (UUIDs).
   * /messages/stream/identifiers [WS]
   */
  async conversationMessagesStreamIdentifiers(initOverrides) {
    const response = await this.conversationMessagesStreamIdentifiersRaw(initOverrides);
    return await response.value();
  }
  /**
   * This will create a Message on a specific conversation.
   * /messages/create [POST]
   */
  async messagesCreateSpecificMessageRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/messages/create`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SeededConversationMessageToJSON(requestParameters.seededConversationMessage)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ConversationMessageFromJSON(jsonValue));
  }
  /**
   * This will create a Message on a specific conversation.
   * /messages/create [POST]
   */
  async messagesCreateSpecificMessage(requestParameters = {}, initOverrides) {
    const response = await this.messagesCreateSpecificMessageRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will delete a specific message.
   * /messages/{message}/delete [POST]
   */
  async messagesDeleteSpecificMessageRaw(requestParameters, initOverrides) {
    if (requestParameters.message === null || requestParameters.message === void 0) {
      throw new RequiredError("message", "Required parameter requestParameters.message was null or undefined when calling messagesDeleteSpecificMessage.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/messages/{message}/delete`.replace(`{${"message"}}`, encodeURIComponent(String(requestParameters.message))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will delete a specific message.
   * /messages/{message}/delete [POST]
   */
  async messagesDeleteSpecificMessage(requestParameters, initOverrides) {
    await this.messagesDeleteSpecificMessageRaw(requestParameters, initOverrides);
  }
  /**
   * This will get all the messages.
   * /messages [GET]
   */
  async messagesSnapshotRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/messages`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ConversationMessagesFromJSON(jsonValue));
  }
  /**
   * This will get all the messages.
   * /messages [GET]
   */
  async messagesSnapshot(requestParameters = {}, initOverrides) {
    const response = await this.messagesSnapshotRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will search your conversationMessages for a specific conversation_message  note: we will just search the conversation message values
   * /messages/search [POST]
   */
  async searchMessagesRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/messages/search`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SearchInputToJSON(requestParameters.searchInput)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SearchedConversationMessagesFromJSON(jsonValue));
  }
  /**
   * This will search your conversationMessages for a specific conversation_message  note: we will just search the conversation message values
   * /messages/search [POST]
   */
  async searchMessages(requestParameters = {}, initOverrides) {
    const response = await this.searchMessagesRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// ../generated_runtime/sdk/http/typescript/core/apis/ConversationsApi.ts
var ConversationsApi = class extends BaseAPI {
  /**
   * Creates a conversation based on an asset. It initiates a conversation and generates an initial message that includes a summary of the asset used as contextual grounding.
   * /conversations/create/from_asset/{asset} [POST]
   */
  async conversationsCreateFromAssetRaw(requestParameters, initOverrides) {
    if (requestParameters.asset === null || requestParameters.asset === void 0) {
      throw new RequiredError("asset", "Required parameter requestParameters.asset was null or undefined when calling conversationsCreateFromAsset.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/conversations/create/from_asset/{asset}`.replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ConversationsCreateFromAssetOutputFromJSON(jsonValue));
  }
  /**
   * Creates a conversation based on an asset. It initiates a conversation and generates an initial message that includes a summary of the asset used as contextual grounding.
   * /conversations/create/from_asset/{asset} [POST]
   */
  async conversationsCreateFromAsset(requestParameters, initOverrides) {
    const response = await this.conversationsCreateFromAssetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Creates a specific conversation.
   * /conversations/create [POST]
   */
  async conversationsCreateSpecificConversationRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/conversations/create`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SeededConversationToJSON(requestParameters.seededConversation)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ConversationFromJSON(jsonValue));
  }
  /**
   * Creates a specific conversation.
   * /conversations/create [POST]
   */
  async conversationsCreateSpecificConversation(requestParameters = {}, initOverrides) {
    const response = await this.conversationsCreateSpecificConversationRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Deletes a specific conversation.
   * /conversations/{conversation}/delete [POST]
   */
  async conversationsDeleteSpecificConversationRaw(requestParameters, initOverrides) {
    if (requestParameters.conversation === null || requestParameters.conversation === void 0) {
      throw new RequiredError("conversation", "Required parameter requestParameters.conversation was null or undefined when calling conversationsDeleteSpecificConversation.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/conversations/{conversation}/delete`.replace(`{${"conversation"}}`, encodeURIComponent(String(requestParameters.conversation))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Deletes a specific conversation.
   * /conversations/{conversation}/delete [POST]
   */
  async conversationsDeleteSpecificConversation(requestParameters, initOverrides) {
    await this.conversationsDeleteSpecificConversationRaw(requestParameters, initOverrides);
  }
  /**
   * Retrieves all the UUIDs associated with a Conversation.
   * /conversations/identifiers [GET]
   */
  async conversationsIdentifiersSnapshotRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/conversations/identifiers`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FlattenedConversationsFromJSON(jsonValue));
  }
  /**
   * Retrieves all the UUIDs associated with a Conversation.
   * /conversations/identifiers [GET]
   */
  async conversationsIdentifiersSnapshot(initOverrides) {
    const response = await this.conversationsIdentifiersSnapshotRaw(initOverrides);
    return await response.value();
  }
  /**
   * Retrieves a snapshot of a specific conversation.
   * /conversations [GET]
   */
  async conversationsSnapshotRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/conversations`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ConversationsFromJSON(jsonValue));
  }
  /**
   * Retrieves a snapshot of a specific conversation.
   * /conversations [GET]
   */
  async conversationsSnapshot(requestParameters = {}, initOverrides) {
    const response = await this.conversationsSnapshotRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Provides a WebSocket connection that emits changes to your conversation identifiers (UUIDs).
   * /conversations/stream/identifiers [WS]
   */
  async conversationsStreamIdentifiersRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/conversations/stream/identifiers`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Provides a WebSocket connection that emits changes to your conversation identifiers (UUIDs).
   * /conversations/stream/identifiers [WS]
   */
  async conversationsStreamIdentifiers(initOverrides) {
    await this.conversationsStreamIdentifiersRaw(initOverrides);
  }
  /**
   * This will search your conversations for a specific conversation  note: we will search annotations, the name of the conversation, and the conversation messages
   * /conversations/search [POST]
   */
  async searchConversationsRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/conversations/search`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SearchInputToJSON(requestParameters.searchInput)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SearchedConversationsFromJSON(jsonValue));
  }
  /**
   * This will search your conversations for a specific conversation  note: we will search annotations, the name of the conversation, and the conversation messages
   * /conversations/search [POST]
   */
  async searchConversations(requestParameters = {}, initOverrides) {
    const response = await this.searchConversationsRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// ../generated_runtime/sdk/http/typescript/core/apis/DiscoveryApi.ts
var DiscoveryApi = class extends BaseAPI {
  /**
   * This is the endpoint used for bulk import. In both cases of the bulk import flow, fragments or files. When we already have \"snippets\" or fragments to discover and now our job is to check if they are actually valid snippets(clustering). Otherwise, we should have a file to parse && snippitize and then run through the clustering.
   * /discovery/discover/assets [POST]
   */
  async discoveryDiscoverAssetsRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.automatic !== void 0) {
      queryParameters["automatic"] = requestParameters.automatic;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/discovery/discover/assets`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SeededDiscoverableAssetsToJSON(requestParameters.seededDiscoverableAssets)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => DiscoveredAssetsFromJSON(jsonValue));
  }
  /**
   * This is the endpoint used for bulk import. In both cases of the bulk import flow, fragments or files. When we already have \"snippets\" or fragments to discover and now our job is to check if they are actually valid snippets(clustering). Otherwise, we should have a file to parse && snippitize and then run through the clustering.
   * /discovery/discover/assets [POST]
   */
  async discoveryDiscoverAssets(requestParameters = {}, initOverrides) {
    const response = await this.discoveryDiscoverAssetsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This is the discover discover assets html endpoint. The goal of this endpoint is to either take an iterable of urls and pages(an html string) and extract all the assets from the iterable.
   * /discovery/discover/assets/html[POST]
   */
  async discoveryDiscoverAssetsHtmlRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.automatic !== void 0) {
      queryParameters["automatic"] = requestParameters.automatic;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/discovery/discover/assets/html`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SeededDiscoverableHtmlWebpagesToJSON(requestParameters.seededDiscoverableHtmlWebpages)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => DiscoveredHtmlWebpagesFromJSON(jsonValue));
  }
  /**
   * This is the discover discover assets html endpoint. The goal of this endpoint is to either take an iterable of urls and pages(an html string) and extract all the assets from the iterable.
   * /discovery/discover/assets/html[POST]
   */
  async discoveryDiscoverAssetsHtml(requestParameters = {}, initOverrides) {
    const response = await this.discoveryDiscoverAssetsHtmlRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This endpoint will accept an array of text values, and attampt to extract sensitive data out of it.
   * /discovery/discover/sensitives [POST]
   */
  async discoveryDiscoverSensitivesRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.automatic !== void 0) {
      queryParameters["automatic"] = requestParameters.automatic;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/discovery/discover/sensitives`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SeededDiscoverableSensitivesToJSON(requestParameters.seededDiscoverableSensitives)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => DiscoveredSensitivesFromJSON(jsonValue));
  }
  /**
   * This endpoint will accept an array of text values, and attampt to extract sensitive data out of it.
   * /discovery/discover/sensitives [POST]
   */
  async discoveryDiscoverSensitives(requestParameters = {}, initOverrides) {
    const response = await this.discoveryDiscoverSensitivesRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will take in a tag or multiple tags and return all the tags that are related to the tag or tag provide in the body.
   * /discovery/discover/tags/related [POST]
   */
  async discoveryDiscoverTagsRelatedRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.automatic !== void 0) {
      queryParameters["automatic"] = requestParameters.automatic;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/discovery/discover/tags/related`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SeededDiscoverableRelatedTagsToJSON(requestParameters.seededDiscoverableRelatedTags)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => DiscoveredRelatedTagsFromJSON(jsonValue));
  }
  /**
   * This will take in a tag or multiple tags and return all the tags that are related to the tag or tag provide in the body.
   * /discovery/discover/tags/related [POST]
   */
  async discoveryDiscoverTagsRelated(requestParameters = {}, initOverrides) {
    const response = await this.discoveryDiscoverTagsRelatedRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// ../generated_runtime/sdk/http/typescript/core/apis/FormatApi.ts
var FormatApi = class extends BaseAPI {
  /**
   * This will get an analysis from a format\'s id.
   * /format/{format}/analysis [GET]
   */
  async formatAnalysisRaw(requestParameters, initOverrides) {
    if (requestParameters.format === null || requestParameters.format === void 0) {
      throw new RequiredError("format", "Required parameter requestParameters.format was null or undefined when calling formatAnalysis.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/format/{format}/analysis`.replace(`{${"format"}}`, encodeURIComponent(String(requestParameters.format))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AnalysisFromJSON(jsonValue));
  }
  /**
   * This will get an analysis from a format\'s id.
   * /format/{format}/analysis [GET]
   */
  async formatAnalysis(requestParameters, initOverrides) {
    const response = await this.formatAnalysisRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This endpoint will be used to reclassify a single Format.
   * /format/reclassify [POST]
   */
  async formatReclassifyRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.transferable !== void 0) {
      queryParameters["transferable"] = requestParameters.transferable;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/format/reclassify`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: FormatReclassificationToJSON(requestParameters.formatReclassification)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FormatFromJSON(jsonValue));
  }
  /**
   * This endpoint will be used to reclassify a single Format.
   * /format/reclassify [POST]
   */
  async formatReclassify(requestParameters = {}, initOverrides) {
    const response = await this.formatReclassifyRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get a snapshot of a specific format.
   * /format/{format} [GET] Scoped to Format
   */
  async formatSnapshotRaw(requestParameters, initOverrides) {
    if (requestParameters.format === null || requestParameters.format === void 0) {
      throw new RequiredError("format", "Required parameter requestParameters.format was null or undefined when calling formatSnapshot.");
    }
    const queryParameters = {};
    if (requestParameters.transferable !== void 0) {
      queryParameters["transferable"] = requestParameters.transferable;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/format/{format}`.replace(`{${"format"}}`, encodeURIComponent(String(requestParameters.format))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FormatFromJSON(jsonValue));
  }
  /**
   * Get a snapshot of a specific format.
   * /format/{format} [GET] Scoped to Format
   */
  async formatSnapshot(requestParameters, initOverrides) {
    const response = await this.formatSnapshotRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will update a format\'s value, ie, a formats fragment or file depending on what is provided.  code/text fragment behavior: If this format is an asset.preview.base we will update the asset.original\'s value. if this format is an asset.preview.original we will update the asset.preview.base\'s value.  code/text file behavior: If the the format that is update is the asset.preview.base is a fragment and the asset.original is file then we will update the asset.original\'s value to be bytes or string respectively. This goes the same for orignal to preview but will be go the reverse order so if the original is a file we will update the preview base\'s fragment string.  image fragment/file: We will not modify preview -> orignal or original -> preview here. so there are zero side effects in this case, and will update as normal. (this will be the case for all other value updates.)
   * [POST] /format/update/value
   */
  async formatUpdateValueRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.transferable !== void 0) {
      queryParameters["transferable"] = requestParameters.transferable;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/format/update/value`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: FormatToJSON(requestParameters.format)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FormatFromJSON(jsonValue));
  }
  /**
   * This will update a format\'s value, ie, a formats fragment or file depending on what is provided.  code/text fragment behavior: If this format is an asset.preview.base we will update the asset.original\'s value. if this format is an asset.preview.original we will update the asset.preview.base\'s value.  code/text file behavior: If the the format that is update is the asset.preview.base is a fragment and the asset.original is file then we will update the asset.original\'s value to be bytes or string respectively. This goes the same for orignal to preview but will be go the reverse order so if the original is a file we will update the preview base\'s fragment string.  image fragment/file: We will not modify preview -> orignal or original -> preview here. so there are zero side effects in this case, and will update as normal. (this will be the case for all other value updates.)
   * [POST] /format/update/value
   */
  async formatUpdateValue(requestParameters = {}, initOverrides) {
    const response = await this.formatUpdateValueRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// ../generated_runtime/sdk/http/typescript/core/apis/LinkifyApi.ts
var LinkifyApi = class extends BaseAPI {
  /**
   * 
   * /linkify [POST]
   */
  async linkifyRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/linkify`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: LinkifyToJSON(requestParameters.linkify)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SharesFromJSON(jsonValue));
  }
  /**
   * 
   * /linkify [POST]
   */
  async linkify(requestParameters = {}, initOverrides) {
    const response = await this.linkifyRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * - assumption that you have already backed up the asset\'s that you are sending to this endpoint.(b/c the assets are ids.)
   * /linkify/multiple [POST]
   */
  async linkifyMultipleRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/linkify/multiple`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: LinkifyMultipleToJSON(requestParameters.linkifyMultiple)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SharesFromJSON(jsonValue));
  }
  /**
   * - assumption that you have already backed up the asset\'s that you are sending to this endpoint.(b/c the assets are ids.)
   * /linkify/multiple [POST]
   */
  async linkifyMultiple(requestParameters = {}, initOverrides) {
    const response = await this.linkifyMultipleRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will revoke a link.
   * [POST} /linkify/{share}/revoke
   */
  async linkifyShareRevokeRaw(requestParameters, initOverrides) {
    if (requestParameters.share === null || requestParameters.share === void 0) {
      throw new RequiredError("share", "Required parameter requestParameters.share was null or undefined when calling linkifyShareRevoke.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/linkify/{share}/revoke`.replace(`{${"share"}}`, encodeURIComponent(String(requestParameters.share))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new JSONApiResponse(response);
    } else {
      return new TextApiResponse(response);
    }
  }
  /**
   * This will revoke a link.
   * [POST} /linkify/{share}/revoke
   */
  async linkifyShareRevoke(requestParameters, initOverrides) {
    const response = await this.linkifyShareRevokeRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// ../generated_runtime/sdk/http/typescript/core/apis/ModelApi.ts
var ModelApi = class extends BaseAPI {
  /**
   * Downloads a specific model to your local machine.
   * /model/{model}/download [POST]
   */
  async modelSpecificModelDownloadRaw(requestParameters, initOverrides) {
    if (requestParameters.model === null || requestParameters.model === void 0) {
      throw new RequiredError("model", "Required parameter requestParameters.model was null or undefined when calling modelSpecificModelDownload.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/model/{model}/download`.replace(`{${"model"}}`, encodeURIComponent(String(requestParameters.model))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ModelFromJSON(jsonValue));
  }
  /**
   * Downloads a specific model to your local machine.
   * /model/{model}/download [POST]
   */
  async modelSpecificModelDownload(requestParameters, initOverrides) {
    const response = await this.modelSpecificModelDownloadRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Cancels a specific model download that is currently in progress.
   * /model/{model}/download/cancel [POST]
   */
  async modelSpecificModelDownloadCancelRaw(requestParameters, initOverrides) {
    if (requestParameters.model === null || requestParameters.model === void 0) {
      throw new RequiredError("model", "Required parameter requestParameters.model was null or undefined when calling modelSpecificModelDownloadCancel.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/model/{model}/download/cancel`.replace(`{${"model"}}`, encodeURIComponent(String(requestParameters.model))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ModelFromJSON(jsonValue));
  }
  /**
   * Cancels a specific model download that is currently in progress.
   * /model/{model}/download/cancel [POST]
   */
  async modelSpecificModelDownloadCancel(requestParameters, initOverrides) {
    const response = await this.modelSpecificModelDownloadCancelRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This is a WebSocket connection that provides real-time updates on the download progress of a specific model.
   * /model/{model}/download/progress [WS]
   */
  async modelSpecificModelDownloadProgressRaw(requestParameters, initOverrides) {
    if (requestParameters.model === null || requestParameters.model === void 0) {
      throw new RequiredError("model", "Required parameter requestParameters.model was null or undefined when calling modelSpecificModelDownloadProgress.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/model/{model}/download/progress`.replace(`{${"model"}}`, encodeURIComponent(String(requestParameters.model))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ModelDownloadProgressFromJSON(jsonValue));
  }
  /**
   * This is a WebSocket connection that provides real-time updates on the download progress of a specific model.
   * /model/{model}/download/progress [WS]
   */
  async modelSpecificModelDownloadProgress(requestParameters, initOverrides) {
    const response = await this.modelSpecificModelDownloadProgressRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Loads a previously downloaded model into memory. It differs from downloading, as downloading involves transferring the entire model to your machine, while loading simply loads the model into memory.
   * /model/{model}/load [POST]
   */
  async modelSpecificModelLoadRaw(requestParameters, initOverrides) {
    if (requestParameters.model === null || requestParameters.model === void 0) {
      throw new RequiredError("model", "Required parameter requestParameters.model was null or undefined when calling modelSpecificModelLoad.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/model/{model}/load`.replace(`{${"model"}}`, encodeURIComponent(String(requestParameters.model))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ModelFromJSON(jsonValue));
  }
  /**
   * Loads a previously downloaded model into memory. It differs from downloading, as downloading involves transferring the entire model to your machine, while loading simply loads the model into memory.
   * /model/{model}/load [POST]
   */
  async modelSpecificModelLoad(requestParameters, initOverrides) {
    const response = await this.modelSpecificModelLoadRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Unloads a previously loaded model from memory and effectively frees up the RAM consumed by the model.
   * /model/{model}/unload [POST]
   */
  async modelSpecificModelUnloadRaw(requestParameters, initOverrides) {
    if (requestParameters.model === null || requestParameters.model === void 0) {
      throw new RequiredError("model", "Required parameter requestParameters.model was null or undefined when calling modelSpecificModelUnload.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/model/{model}/unload`.replace(`{${"model"}}`, encodeURIComponent(String(requestParameters.model))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ModelFromJSON(jsonValue));
  }
  /**
   * Unloads a previously loaded model from memory and effectively frees up the RAM consumed by the model.
   * /model/{model}/unload [POST]
   */
  async modelSpecificModelUnload(requestParameters, initOverrides) {
    const response = await this.modelSpecificModelUnloadRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Updates a machine learning model. This functionality is exclusively available for models with the \'custom:true\' setting.
   * /model/update [POST]
   */
  async modelUpdateRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/model/update`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: ModelToJSON(requestParameters.model)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ModelFromJSON(jsonValue));
  }
  /**
   * Updates a machine learning model. This functionality is exclusively available for models with the \'custom:true\' setting.
   * /model/update [POST]
   */
  async modelUpdate(requestParameters = {}, initOverrides) {
    const response = await this.modelUpdateRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Retrieves a specific ML model.
   * /model/{model} [GET]
   */
  async modelsSpecificModelSnapshotRaw(requestParameters, initOverrides) {
    if (requestParameters.model === null || requestParameters.model === void 0) {
      throw new RequiredError("model", "Required parameter requestParameters.model was null or undefined when calling modelsSpecificModelSnapshot.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/model/{model}`.replace(`{${"model"}}`, encodeURIComponent(String(requestParameters.model))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ModelFromJSON(jsonValue));
  }
  /**
   * Retrieves a specific ML model.
   * /model/{model} [GET]
   */
  async modelsSpecificModelSnapshot(requestParameters, initOverrides) {
    const response = await this.modelsSpecificModelSnapshotRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// ../generated_runtime/sdk/http/typescript/core/apis/ModelsApi.ts
var ModelsApi = class extends BaseAPI {
  /**
   * Creates a machine learning model. By default, all models created through this endpoint will have the \'custom\' attribute set to true. Additionally, the endpoint ensures that no duplicate models exist before creating a new one.
   * /models/create [POST]
   */
  async modelsCreateNewModelRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/models/create`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SeededModelToJSON(requestParameters.seededModel)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ModelFromJSON(jsonValue));
  }
  /**
   * Creates a machine learning model. By default, all models created through this endpoint will have the \'custom\' attribute set to true. Additionally, the endpoint ensures that no duplicate models exist before creating a new one.
   * /models/create [POST]
   */
  async modelsCreateNewModel(requestParameters = {}, initOverrides) {
    const response = await this.modelsCreateNewModelRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Deletes a specific model. It is exclusively available for custom models with the \'custom: true\' attribute.
   * /models/{model}/delete [POST]
   */
  async modelsDeleteSpecificModelRaw(requestParameters, initOverrides) {
    if (requestParameters.model === null || requestParameters.model === void 0) {
      throw new RequiredError("model", "Required parameter requestParameters.model was null or undefined when calling modelsDeleteSpecificModel.");
    }
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/models/{model}/delete`.replace(`{${"model"}}`, encodeURIComponent(String(requestParameters.model))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Deletes a specific model. It is exclusively available for custom models with the \'custom: true\' attribute.
   * /models/{model}/delete [POST]
   */
  async modelsDeleteSpecificModel(requestParameters, initOverrides) {
    await this.modelsDeleteSpecificModelRaw(requestParameters, initOverrides);
  }
  /**
   * Deletes the data associated with a specific model, such as assets or libraries downloaded specifically for this model.   Note: This functionality is currently only available for LLM models.
   * /models/{model}/delete/cache [POST]
   */
  async modelsDeleteSpecificModelCacheRaw(requestParameters, initOverrides) {
    if (requestParameters.model === null || requestParameters.model === void 0) {
      throw new RequiredError("model", "Required parameter requestParameters.model was null or undefined when calling modelsDeleteSpecificModelCache.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/models/{model}/delete/cache`.replace(`{${"model"}}`, encodeURIComponent(String(requestParameters.model))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: ModelDeleteCacheInputToJSON(requestParameters.modelDeleteCacheInput)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ModelDeleteCacheOutputFromJSON(jsonValue));
  }
  /**
   * Deletes the data associated with a specific model, such as assets or libraries downloaded specifically for this model.   Note: This functionality is currently only available for LLM models.
   * /models/{model}/delete/cache [POST]
   */
  async modelsDeleteSpecificModelCache(requestParameters, initOverrides) {
    const response = await this.modelsDeleteSpecificModelCacheRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will get a snapshot of all of your models.
   * /models [GET]
   */
  async modelsSnapshotRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/models`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ModelsFromJSON(jsonValue));
  }
  /**
   * This will get a snapshot of all of your models.
   * /models [GET]
   */
  async modelsSnapshot(initOverrides) {
    const response = await this.modelsSnapshotRaw(initOverrides);
    return await response.value();
  }
  /**
   * Provides a WebSocket connection that emits changes to your model identifiers (UUIDs).
   * /models/stream/identifiers [WS]
   */
  async modelsStreamIdentifiersRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/models/stream/identifiers`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => StreamedIdentifiersFromJSON(jsonValue));
  }
  /**
   * Provides a WebSocket connection that emits changes to your model identifiers (UUIDs).
   * /models/stream/identifiers [WS]
   */
  async modelsStreamIdentifiers(initOverrides) {
    const response = await this.modelsStreamIdentifiersRaw(initOverrides);
    return await response.value();
  }
  /**
   * Unloads all available machine learning models that are unloadable.
   * /models/unload [POST]
   */
  async unloadModelsRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/models/unload`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Unloads all available machine learning models that are unloadable.
   * /models/unload [POST]
   */
  async unloadModels(initOverrides) {
    await this.unloadModelsRaw(initOverrides);
  }
};

// ../generated_runtime/sdk/http/typescript/core/apis/OSApi.ts
var OSApi = class extends BaseAPI {
  /**
   * This will link an external provider to your current auth0 account.  Will throw errors if your user is not signed in.
   * /os/link_provider [POST]
   */
  async linkProviderRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/os/link_provider`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SeededExternalProviderToJSON(requestParameters.seededExternalProvider)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ReturnedUserProfileFromJSON(jsonValue));
  }
  /**
   * This will link an external provider to your current auth0 account.  Will throw errors if your user is not signed in.
   * /os/link_provider [POST]
   */
  async linkProvider(requestParameters = {}, initOverrides) {
    const response = await this.linkProviderRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will attempt to launch(serve) a micro_application. If one is already spun up we will just return the port number. TODO: take in an application and return a port number at minimum.
   * /os/applet/launch [POST]
   */
  async osAppletLaunchRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/os/applet/launch`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: InactiveOSServerAppletToJSON(requestParameters.inactiveOSServerApplet)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ActiveOSServerAppletFromJSON(jsonValue));
  }
  /**
   * This will attempt to launch(serve) a micro_application. If one is already spun up we will just return the port number. TODO: take in an application and return a port number at minimum.
   * /os/applet/launch [POST]
   */
  async osAppletLaunch(requestParameters = {}, initOverrides) {
    const response = await this.osAppletLaunchRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will attempt to restart a micro_application.(this will shut down the copilot and then rehost it)
   * /os/applet/restart [POST]
   */
  async osAppletRestartRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/os/applet/restart`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: InactiveOSServerAppletToJSON(requestParameters.inactiveOSServerApplet)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ActiveOSServerAppletFromJSON(jsonValue));
  }
  /**
   * This will attempt to restart a micro_application.(this will shut down the copilot and then rehost it)
   * /os/applet/restart [POST]
   */
  async osAppletRestart(requestParameters = {}, initOverrides) {
    const response = await this.osAppletRestartRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will attempt to shutdown or terminate a specified micro_application.
   * /os/applet/terminate [POST]
   */
  async osAppletTerminateRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/os/applet/terminate`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: TerminatingOSServerAppletToJSON(requestParameters.terminatingOSServerApplet)
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will attempt to shutdown or terminate a specified micro_application.
   * /os/applet/terminate [POST]
   */
  async osAppletTerminate(requestParameters = {}, initOverrides) {
    await this.osAppletTerminateRaw(requestParameters, initOverrides);
  }
  /**
   * This will accept a url and launch this in an external browser.
   * /os/browser/url/open [POST]
   */
  async osBrowserUrlOpenRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/os/browser/url/open`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will accept a url and launch this in an external browser.
   * /os/browser/url/open [POST]
   */
  async osBrowserUrlOpen(requestParameters = {}, initOverrides) {
    await this.osBrowserUrlOpenRaw(requestParameters, initOverrides);
  }
  /**
   * This will get information related to your specific device.
   * /os/device/information [GET]
   */
  async osDeviceInformationRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/os/device/information`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => OSDeviceInformationReturnableFromJSON(jsonValue));
  }
  /**
   * This will get information related to your specific device.
   * /os/device/information [GET]
   */
  async osDeviceInformation(initOverrides) {
    const response = await this.osDeviceInformationRaw(initOverrides);
    return await response.value();
  }
  /**
   * This will accept a path and will launch a path in a given finder/file explorer window  note: TODO in the future add an endpoint for open/in || open/with (browser,files,...etc)       && if so we will want /os/open_with/file
   * /os/filesystem/file/open [POST]
   */
  async osFilesystemFileOpenRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/os/filesystem/file/open`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will accept a path and will launch a path in a given finder/file explorer window  note: TODO in the future add an endpoint for open/in || open/with (browser,files,...etc)       && if so we will want /os/open_with/file
   * /os/filesystem/file/open [POST]
   */
  async osFilesystemFileOpen(requestParameters = {}, initOverrides) {
    await this.osFilesystemFileOpenRaw(requestParameters, initOverrides);
  }
  /**
   * This will stream(via a WS the contents of a file back to the client, given a file, it will read the contents and return to the client.  NOTE: will NOT support relative paths. only ABSOLUTE paths. NOTE: needs to be a File.(will not stream a folder) NOTE: we might want to put a limit on the size of the file(IE no more than a GB or something like that??) TODO: would be nice to cancel stream NOTE: for v2 we could have two query params i.e. find which could take in a relative path and or file name and        the other could be compress i.e. streaming a gzip vs the raw bytes..        the caveat here would be mack would need to decompress em.
   * /os/filesystem/file/read/streamed [WS]
   */
  async osFilesystemFileReadStreamedRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/os/filesystem/file/read/streamed`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters,
      body: OSFileStreamingReadAttemptToJSON(requestParameters.oSFileStreamingReadAttempt)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => OSFileStreamingReadFromJSON(jsonValue));
  }
  /**
   * This will stream(via a WS the contents of a file back to the client, given a file, it will read the contents and return to the client.  NOTE: will NOT support relative paths. only ABSOLUTE paths. NOTE: needs to be a File.(will not stream a folder) NOTE: we might want to put a limit on the size of the file(IE no more than a GB or something like that??) TODO: would be nice to cancel stream NOTE: for v2 we could have two query params i.e. find which could take in a relative path and or file name and        the other could be compress i.e. streaming a gzip vs the raw bytes..        the caveat here would be mack would need to decompress em.
   * /os/filesystem/file/read/streamed [WS]
   */
  async osFilesystemFileReadStreamed(requestParameters = {}, initOverrides) {
    const response = await this.osFilesystemFileReadStreamedRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will determine in a given path is a file/a directory or invalid.
   * /os/filesystem/path/verify [POST]
   */
  async osFilesystemPathVerifyRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/os/filesystem/path/verify`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters.body
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => VerifiedOSFilesystemPathFromJSON(jsonValue));
  }
  /**
   * This will determine in a given path is a file/a directory or invalid.
   * /os/filesystem/path/verify [POST]
   */
  async osFilesystemPathVerify(requestParameters = {}, initOverrides) {
    const response = await this.osFilesystemPathVerifyRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will trigger a filer picker and return the string paths of the files that were selected.
   * /os/filesystem/files/pick [POST]
   */
  async osFilesystemPickFilesRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/os/filesystem/files/pick`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: FilePickerInputToJSON(requestParameters.filePickerInput)
    }, initOverrides);
    return new JSONApiResponse(response);
  }
  /**
   * This will trigger a filer picker and return the string paths of the files that were selected.
   * /os/filesystem/files/pick [POST]
   */
  async osFilesystemPickFiles(requestParameters = {}, initOverrides) {
    const response = await this.osFilesystemPickFilesRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will trigger a folder picker and return the string paths of the folders that were selected.
   * /os/filesystem/folders/pick [POST]
   */
  async osFilesystemPickFoldersRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/os/filesystem/folders/pick`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response);
  }
  /**
   * This will trigger a folder picker and return the string paths of the folders that were selected.
   * /os/filesystem/folders/pick [POST]
   */
  async osFilesystemPickFolders(initOverrides) {
    const response = await this.osFilesystemPickFoldersRaw(initOverrides);
    return await response.value();
  }
  /**
   * This will optimize memory across PiecesOS.(TODO in the future might want to accept a body, so this will be a POST)
   * /os/memory/optimize [POST]
   */
  async osMemoryOptimizeRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/os/memory/optimize`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will optimize memory across PiecesOS.(TODO in the future might want to accept a body, so this will be a POST)
   * /os/memory/optimize [POST]
   */
  async osMemoryOptimize(initOverrides) {
    await this.osMemoryOptimizeRaw(initOverrides);
  }
  /**
   * This will return metadata (total materials) in your pieces drive.
   * /os/metadata [GET]
   */
  async osMetadataRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/os/metadata`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => OSServerMetadataFromJSON(jsonValue));
  }
  /**
   * This will return metadata (total materials) in your pieces drive.
   * /os/metadata [GET]
   */
  async osMetadata(initOverrides) {
    const response = await this.osMetadataRaw(initOverrides);
    return await response.value();
  }
  /**
   * This will only work on Macos and Windows.  And will get the permissions of the user\'s local machine w/ regard to anything needed to effectively run PiecesOS.  Note: this will let us know if we need to tell them to take action to enable any given permissions
   * /os/permissions [GET]
   */
  async osPermissionsRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/os/permissions`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => OSPermissionsFromJSON(jsonValue));
  }
  /**
   * This will only work on Macos and Windows.  And will get the permissions of the user\'s local machine w/ regard to anything needed to effectively run PiecesOS.  Note: this will let us know if we need to tell them to take action to enable any given permissions
   * /os/permissions [GET]
   */
  async osPermissions(initOverrides) {
    const response = await this.osPermissionsRaw(initOverrides);
    return await response.value();
  }
  /**
   * This will only work on Macos and Windows.  This will request permissions for the given inputs
   * /os/permissions/request [POST]
   */
  async osPermissionsRequestRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/os/permissions/request`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: OSPermissionsToJSON(requestParameters.oSPermissions)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => OSPermissionsFromJSON(jsonValue));
  }
  /**
   * This will only work on Macos and Windows.  This will request permissions for the given inputs
   * /os/permissions/request [POST]
   */
  async osPermissionsRequest(requestParameters = {}, initOverrides) {
    const response = await this.osPermissionsRequestRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will restart PiecesOS, if successfull with return a 204. This is a LOCALOS Only Endpoint.
   * Your GET endpoint
   */
  async osRestartRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/os/restart`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will restart PiecesOS, if successfull with return a 204. This is a LOCALOS Only Endpoint.
   * Your GET endpoint
   */
  async osRestart(initOverrides) {
    await this.osRestartRaw(initOverrides);
  }
  /**
   * This is a snapshot of the piecesOS settings
   * /os/settings [GET]
   */
  async osSettingsSnapshotRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/os/settings`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => OSServerSettingsFromJSON(jsonValue));
  }
  /**
   * This is a snapshot of the piecesOS settings
   * /os/settings [GET]
   */
  async osSettingsSnapshot(initOverrides) {
    const response = await this.osSettingsSnapshotRaw(initOverrides);
    return await response.value();
  }
  /**
   * This is a websocket that will emit a change on the update of the OSSettings.
   * /os/settings/stream [WS]
   */
  async osSettingsStreamRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/os/settings/stream`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => OSServerSettingsFromJSON(jsonValue));
  }
  /**
   * This is a websocket that will emit a change on the update of the OSSettings.
   * /os/settings/stream [WS]
   */
  async osSettingsStream(initOverrides) {
    const response = await this.osSettingsStreamRaw(initOverrides);
    return await response.value();
  }
  /**
   * This will ensure that we update the os settings.  This will emit a change via the setting stream as well.
   * /os/settings/update [POST]
   */
  async osSettingsUpdateRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/os/settings/update`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: OSServerSettingsToJSON(requestParameters.oSServerSettings)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => OSServerSettingsFromJSON(jsonValue));
  }
  /**
   * This will ensure that we update the os settings.  This will emit a change via the setting stream as well.
   * /os/settings/update [POST]
   */
  async osSettingsUpdate(requestParameters = {}, initOverrides) {
    const response = await this.osSettingsUpdateRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will force quit PiecesOS
   * /os/terminate [POST]
   */
  async osTerminateRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/os/terminate`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * This will force quit PiecesOS
   * /os/terminate [POST]
   */
  async osTerminate(initOverrides) {
    await this.osTerminateRaw(initOverrides);
  }
  /**
   * This is a helper endpoint that will check the status of an update for PiecesOS. IE if there is an update downloading, if there is one available, but the downloading has not started... etc
   * /os/update/check [POST]
   */
  async osUpdateCheckRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/os/update/check`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: UncheckedOSServerUpdateToJSON(requestParameters.uncheckedOSServerUpdate)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => OSServerUpdateStatusFromJSON(jsonValue));
  }
  /**
   * This is a helper endpoint that will check the status of an update for PiecesOS. IE if there is an update downloading, if there is one available, but the downloading has not started... etc
   * /os/update/check [POST]
   */
  async osUpdateCheck(requestParameters = {}, initOverrides) {
    const response = await this.osUpdateCheckRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will first kick off the check.  Then will stream the progress.  **TODO lets think about if we want to have a closing NOTE: it is reccommended to use the stream instead of pulling(via the normal check endpoint).
   * /os/update/check/stream [WS]
   */
  async osUpdateCheckStreamRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/os/update/check/stream`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => OSServerUpdateStatusFromJSON(jsonValue));
  }
  /**
   * This will first kick off the check.  Then will stream the progress.  **TODO lets think about if we want to have a closing NOTE: it is reccommended to use the stream instead of pulling(via the normal check endpoint).
   * /os/update/check/stream [WS]
   */
  async osUpdateCheckStream(initOverrides) {
    const response = await this.osUpdateCheckStreamRaw(initOverrides);
    return await response.value();
  }
  /**
   * A trigger that launches a Sign into OS Server
   * 
   */
  async signIntoOSRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/os/sign_in`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => UserProfileFromJSON(jsonValue));
  }
  /**
   * A trigger that launches a Sign into OS Server
   * 
   */
  async signIntoOS(initOverrides) {
    const response = await this.signIntoOSRaw(initOverrides);
    return await response.value();
  }
  /**
   * A trigger that signs out a user from the OS
   * /os/sign_out [POST]
   */
  async signOutOfOSRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/os/sign_out`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => UsersFromJSON(jsonValue));
  }
  /**
   * A trigger that signs out a user from the OS
   * /os/sign_out [POST]
   */
  async signOutOfOS(initOverrides) {
    const response = await this.signOutOfOSRaw(initOverrides);
    return await response.value();
  }
};

// ../generated_runtime/sdk/http/typescript/core/apis/QGPTApi.ts
var QGPTApi = class extends BaseAPI {
  /**
   * Generates suggested questions that users can ask. It accepts the answer displayed to the user, relevant code snippets used for the answer, and the previous query as inputs. In return, it provides a list of questions that can be presented to the user.
   * /qgpt/hints [POST]
   */
  async hintsRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/qgpt/hints`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: QGPTHintsInputToJSON(requestParameters.qGPTHintsInput)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => QGPTQuestionOutputFromJSON(jsonValue));
  }
  /**
   * Generates suggested questions that users can ask. It accepts the answer displayed to the user, relevant code snippets used for the answer, and the previous query as inputs. In return, it provides a list of questions that can be presented to the user.
   * /qgpt/hints [POST]
   */
  async hints(requestParameters = {}, initOverrides) {
    const response = await this.hintsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Utilize this endpoint for Who Support, identifying individuals who can provide assistance when given context such as a Seed or a QGPT Conversation, for example.  Input:   - (optional) seed: Seed - Only supports fragments for now.   - (optional) conversation: QGPTConversation.  Output:   - persons: Persons
   * /qgpt/persons/related [POST]
   */
  async personsRelatedRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.transferables !== void 0) {
      queryParameters["transferables"] = requestParameters.transferables;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/qgpt/persons/related`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: QGPTPersonsRelatedInputToJSON(requestParameters.qGPTPersonsRelatedInput)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => QGPTPersonsRelatedOutputFromJSON(jsonValue));
  }
  /**
   * Utilize this endpoint for Who Support, identifying individuals who can provide assistance when given context such as a Seed or a QGPT Conversation, for example.  Input:   - (optional) seed: Seed - Only supports fragments for now.   - (optional) conversation: QGPTConversation.  Output:   - persons: Persons
   * /qgpt/persons/related [POST]
   */
  async personsRelated(requestParameters = {}, initOverrides) {
    const response = await this.personsRelatedRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Provides a WebSocket connection that streams inputs to the qGPT model. It handles relevance and questions, but will throw an error if both are passed in simultaneously. However, if you wish to utilize both question and relevance, you can obtain stream results by passing relevance with the option \'question:true\'. It is designed to manage multiple conversations.
   * /qgpt/stream [WS]
   */
  async qgptStreamRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/qgpt/stream`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters,
      body: QGPTStreamInputToJSON(requestParameters.qGPTStreamInput)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => QGPTStreamOutputFromJSON(jsonValue));
  }
  /**
   * Provides a WebSocket connection that streams inputs to the qGPT model. It handles relevance and questions, but will throw an error if both are passed in simultaneously. However, if you wish to utilize both question and relevance, you can obtain stream results by passing relevance with the option \'question:true\'. It is designed to manage multiple conversations.
   * /qgpt/stream [WS]
   */
  async qgptStream(requestParameters = {}, initOverrides) {
    const response = await this.qgptStreamRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Processes relevant code snippets or UUIDs returned from the /qgpt/relevance endpoint, along with a question query, to provide possible answers.  Note:   - Relevant seeds must either include an ID used within the /qgpt/relevance endpoint or a seed with a fragment/string; otherwise, an error will be thrown.   - This endpoint utilizes your query and relevant snippets to generate multiple answers, each accompanied by a score.
   * /qgpt/question [POST]
   */
  async questionRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/qgpt/question`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: QGPTQuestionInputToJSON(requestParameters.qGPTQuestionInput)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => QGPTQuestionOutputFromJSON(jsonValue));
  }
  /**
   * Processes relevant code snippets or UUIDs returned from the /qgpt/relevance endpoint, along with a question query, to provide possible answers.  Note:   - Relevant seeds must either include an ID used within the /qgpt/relevance endpoint or a seed with a fragment/string; otherwise, an error will be thrown.   - This endpoint utilizes your query and relevant snippets to generate multiple answers, each accompanied by a score.
   * /qgpt/question [POST]
   */
  async question(requestParameters = {}, initOverrides) {
    const response = await this.questionRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This is the first phase to the QGPT flow.  Please one of the following. 1. provide an absolute path on the users machine that we can use locally. 2. provide Seeds that you want to compare to, which will be ONLY fragment/string values(all other values will be ignored) 3. provide assets, here you can provide an iterable of the asset id, and we will do the rest 4. you can set your database boolean to true which will tell us to use your entire DB as the query space.  required - query: string; This is the question of the user. optional - question: boolean; This will by-pass the second endpoint and just ask the question and return the results(as an ease of use bool)  This endpoint will embed everything. and will return the relevance snippets that we will use in the next phase, to answer your question.  on the UI: we can show this to users (around this is the snippets we used to answer your question.)  Next: feed this information to the /qgpt/question [POST] endpoint to get your question answered.(unless you included the question:true optional boolean, then you will get the results from here.)
   * /qgpt/relevance [POST]
   */
  async relevanceRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/qgpt/relevance`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: QGPTRelevanceInputToJSON(requestParameters.qGPTRelevanceInput)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => QGPTRelevanceOutputFromJSON(jsonValue));
  }
  /**
   * This is the first phase to the QGPT flow.  Please one of the following. 1. provide an absolute path on the users machine that we can use locally. 2. provide Seeds that you want to compare to, which will be ONLY fragment/string values(all other values will be ignored) 3. provide assets, here you can provide an iterable of the asset id, and we will do the rest 4. you can set your database boolean to true which will tell us to use your entire DB as the query space.  required - query: string; This is the question of the user. optional - question: boolean; This will by-pass the second endpoint and just ask the question and return the results(as an ease of use bool)  This endpoint will embed everything. and will return the relevance snippets that we will use in the next phase, to answer your question.  on the UI: we can show this to users (around this is the snippets we used to answer your question.)  Next: feed this information to the /qgpt/question [POST] endpoint to get your question answered.(unless you included the question:true optional boolean, then you will get the results from here.)
   * /qgpt/relevance [POST]
   */
  async relevance(requestParameters = {}, initOverrides) {
    const response = await this.relevanceRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will take in a followup question and the history of the conversation, and emit your a prompt or query that you can pass to the /qgpt/relevance and then the /qgpt/question endpoint to get your next answer.
   * /qgpt/reprompt [POST]
   */
  async repromptRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/qgpt/reprompt`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: QGPTRepromptInputToJSON(requestParameters.qGPTRepromptInput)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => QGPTRepromptOutputFromJSON(jsonValue));
  }
  /**
   * This will take in a followup question and the history of the conversation, and emit your a prompt or query that you can pass to the /qgpt/relevance and then the /qgpt/question endpoint to get your next answer.
   * /qgpt/reprompt [POST]
   */
  async reprompt(requestParameters = {}, initOverrides) {
    const response = await this.repromptRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// ../generated_runtime/sdk/http/typescript/core/apis/SearchApi.ts
var SearchApi = class extends BaseAPI {
  /**
   * This will run FTS for exact search, and will NOT run fuzzy matching. This will only search the content within the 
   * /search/full_text [GET]
   */
  async fullTextSearchRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.query !== void 0) {
      queryParameters["query"] = requestParameters.query;
    }
    if (requestParameters.pseudo !== void 0) {
      queryParameters["pseudo"] = requestParameters.pseudo;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/search/full_text`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SearchedAssetsFromJSON(jsonValue));
  }
  /**
   * This will run FTS for exact search, and will NOT run fuzzy matching. This will only search the content within the 
   * /search/full_text [GET]
   */
  async fullTextSearch(requestParameters = {}, initOverrides) {
    const response = await this.fullTextSearchRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will run ncs on your assets. This will simply return FlattenedAssets, but will just be the assetuuids that match.
   * /search/neural_code [GET]
   */
  async neuralCodeSearchRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.query !== void 0) {
      queryParameters["query"] = requestParameters.query;
    }
    if (requestParameters.pseudo !== void 0) {
      queryParameters["pseudo"] = requestParameters.pseudo;
    }
    const headerParameters = {};
    const response = await this.request({
      path: `/search/neural_code`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SearchedAssetsFromJSON(jsonValue));
  }
  /**
   * This will run ncs on your assets. This will simply return FlattenedAssets, but will just be the assetuuids that match.
   * /search/neural_code [GET]
   */
  async neuralCodeSearch(requestParameters = {}, initOverrides) {
    const response = await this.neuralCodeSearchRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will run our tag based search, and return the assets that best match your passed in tags. This will simply return FlattenedAssets, but will just be the assetuuids that match.
   * /search/tag_based [POST]
   */
  async tagBasedSearchRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.pseudo !== void 0) {
      queryParameters["pseudo"] = requestParameters.pseudo;
    }
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/search/tag_based`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SeededAssetTagsToJSON(requestParameters.seededAssetTags)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SearchedAssetsFromJSON(jsonValue));
  }
  /**
   * This will run our tag based search, and return the assets that best match your passed in tags. This will simply return FlattenedAssets, but will just be the assetuuids that match.
   * /search/tag_based [POST]
   */
  async tagBasedSearch(requestParameters = {}, initOverrides) {
    const response = await this.tagBasedSearchRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// ../generated_runtime/sdk/http/typescript/core/apis/UserApi.ts
var UserApi = class extends BaseAPI {
  /**
   * An endpoint to clear the current user. 
   * /user/clear
   */
  async clearUserRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/user/clear`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * An endpoint to clear the current user. 
   * /user/clear
   */
  async clearUser(initOverrides) {
    await this.clearUserRaw(initOverrides);
  }
  /**
   * This will refresh a user.
   * /user/refresh [GET]
   */
  async refreshUserRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/user/refresh`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => UserProfileFromJSON(jsonValue));
  }
  /**
   * This will refresh a user.
   * /user/refresh [GET]
   */
  async refreshUser(initOverrides) {
    const response = await this.refreshUserRaw(initOverrides);
    return await response.value();
  }
  /**
   * This will select the current user.
   * /user/select [POST]
   */
  async selectUserRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      headerParameters["Authorization"] = await this.configuration.accessToken("auth0", []);
    }
    if (this.configuration && this.configuration.accessToken) {
      headerParameters["Authorization"] = await this.configuration.accessToken("auth0", []);
    }
    if (this.configuration && this.configuration.accessToken) {
      headerParameters["Authorization"] = await this.configuration.accessToken("auth0", []);
    }
    const response = await this.request({
      path: `/user/select`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: Auth0UserToJSON(requestParameters.auth0User)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => UserProfileFromJSON(jsonValue));
  }
  /**
   * This will select the current user.
   * /user/select [POST]
   */
  async selectUser(requestParameters = {}, initOverrides) {
    const response = await this.selectUserRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Provides a WebSocket connection that streams user data.
   * /user/stream [WS]
   */
  async streamUserRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/user/stream`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => UserProfileFromJSON(jsonValue));
  }
  /**
   * Provides a WebSocket connection that streams user data.
   * /user/stream [WS]
   */
  async streamUser(initOverrides) {
    const response = await this.streamUserRaw(initOverrides);
    return await response.value();
  }
  /**
   * This will update a specific user in the database.
   * /user/update [POST]
   */
  async updateUserRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/user/update`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: UserProfileToJSON(requestParameters.userProfile)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => UserProfileFromJSON(jsonValue));
  }
  /**
   * This will update a specific user in the database.
   * /user/update [POST]
   */
  async updateUser(requestParameters = {}, initOverrides) {
    const response = await this.updateUserRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will be an endpoint to give access or remove access immediately from a given user.(isomorphic from the given provider)
   * /user/beta/status [POST]
   */
  async userBetaStatusRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/user/beta/status`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: UserBetaStatusToJSON(requestParameters.userBetaStatus)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => UserBetaStatusFromJSON(jsonValue));
  }
  /**
   * This will be an endpoint to give access or remove access immediately from a given user.(isomorphic from the given provider)
   * /user/beta/status [POST]
   */
  async userBetaStatus(requestParameters = {}, initOverrides) {
    const response = await this.userBetaStatusRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This will retrieve all the users Providers that are connected to this account.  If called locally. we will 501 - because it is not implemented locally yet.  If called in the cloud, we will refresh && get your access tokens to access these providers.
   * Your GET endpoint
   */
  async userProvidersRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/user/providers`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ReturnedUserProfileFromJSON(jsonValue));
  }
  /**
   * This will retrieve all the users Providers that are connected to this account.  If called locally. we will 501 - because it is not implemented locally yet.  If called in the cloud, we will refresh && get your access tokens to access these providers.
   * Your GET endpoint
   */
  async userProviders(initOverrides) {
    const response = await this.userProvidersRaw(initOverrides);
    return await response.value();
  }
  /**
   * This will return a snapshot of the current user. This will return our ReturnUserProfile and the user on that object is just a UserProfile and can potentially be null.
   * /user [GET]
   */
  async userSnapshotRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/user`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ReturnedUserProfileFromJSON(jsonValue));
  }
  /**
   * This will return a snapshot of the current user. This will return our ReturnUserProfile and the user on that object is just a UserProfile and can potentially be null.
   * /user [GET]
   */
  async userSnapshot(initOverrides) {
    const response = await this.userSnapshotRaw(initOverrides);
    return await response.value();
  }
  /**
   * This is a local route to update your vanityname. ie mark.pieces.cloud, where \"mark\" is the vanityname.
   * /user/update/vanity [POST]
   */
  async userUpdateVanityRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    const response = await this.request({
      path: `/user/update/vanity`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: UserProfileToJSON(requestParameters.userProfile)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => UserProfileFromJSON(jsonValue));
  }
  /**
   * This is a local route to update your vanityname. ie mark.pieces.cloud, where \"mark\" is the vanityname.
   * /user/update/vanity [POST]
   */
  async userUpdateVanity(requestParameters = {}, initOverrides) {
    const response = await this.userUpdateVanityRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// ../generated_runtime/sdk/http/typescript/core/apis/WellKnownApi.ts
var WellKnownApi = class extends BaseAPI {
  /**
   * Retrieves the health status of the server.
   * /.well-known/health [GET]
   */
  async getWellKnownHealthRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/.well-known/health`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new JSONApiResponse(response);
    } else {
      return new TextApiResponse(response);
    }
  }
  /**
   * Retrieves the health status of the server.
   * /.well-known/health [GET]
   */
  async getWellKnownHealth(initOverrides) {
    const response = await this.getWellKnownHealthRaw(initOverrides);
    return await response.value();
  }
  /**
   * This is a Streamed endpoint please use a WS connection to call this Endpoint.
   * /.well-known/stream/health [WS]
   */
  async getWellKnownStreamHealthRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/.well-known/stream/health`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new JSONApiResponse(response);
    } else {
      return new TextApiResponse(response);
    }
  }
  /**
   * This is a Streamed endpoint please use a WS connection to call this Endpoint.
   * /.well-known/stream/health [WS]
   */
  async getWellKnownStreamHealth(initOverrides) {
    const response = await this.getWellKnownStreamHealthRaw(initOverrides);
    return await response.value();
  }
  /**
   * /.well-known/version [Get]
   */
  async getWellKnownVersionRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/.well-known/version`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new JSONApiResponse(response);
    } else {
      return new TextApiResponse(response);
    }
  }
  /**
   * /.well-known/version [Get]
   */
  async getWellKnownVersion(initOverrides) {
    const response = await this.getWellKnownVersionRaw(initOverrides);
    return await response.value();
  }
};

// package.json
var version = "1.18.0";

// src/connection/notification_handler.ts
var import_obsidian = require("obsidian");
var Notifications = class {
  constructor() {
  }
  static getInstance() {
    if (!Notifications.instance) {
      Notifications.instance = new Notifications();
    }
    return Notifications.instance;
  }
  information({
    message,
    actions
  }) {
    const notice = new import_obsidian.Notice(message);
    this.appendActions(notice, actions);
  }
  error({
    message,
    actions
  }) {
    const notice = new import_obsidian.Notice(`ERROR: ${message}`);
    this.appendActions(notice, actions);
  }
  appendActions(notice, actions) {
    for (const action of actions ?? []) {
      if (action.type === "OPEN_LINK" /* OPEN_LINK */) {
        const aEl = document.createElement("a");
        aEl.innerText = action.title;
        aEl.href = action.params.url;
        notice.noticeEl.appendChild(document.createElement("br"));
        notice.noticeEl.appendChild(aEl);
      }
    }
  }
};

// src/connection/connector_singleton.ts
var portNumber = process.platform == "linux" ? 5323 : 1e3;
var ConnectorSingleton = class {
  constructor() {
    this._platform = process.platform;
    this._platformMap = {
      win32: PlatformEnum.Windows,
      darwin: PlatformEnum.Macos,
      linux: PlatformEnum.Linux
    };
    this.parameters = {
      basePath: `http://localhost:${portNumber}`,
      fetchApi: fetch
    };
    this.configuration = new Configuration(this.parameters);
    this.api = new ConnectorApi(this.configuration);
    this.conversationApi = new ConversationApi(
      new Configuration({ fetchApi: fetch, basePath: this.parameters.basePath })
    );
    this.conversationsApi = new ConversationsApi(
      new Configuration({ fetchApi: fetch, basePath: this.parameters.basePath })
    );
    this.anchorApi = new AnchorApi(
      new Configuration({ fetchApi: fetch, basePath: this.parameters.basePath })
    );
    this.anchorsApi = new AnchorsApi(
      new Configuration({ fetchApi: fetch, basePath: this.parameters.basePath })
    );
    this.anchorPointApi = new AnchorPointApi(
      new Configuration({ fetchApi: fetch, basePath: this.parameters.basePath })
    );
    this.conversationMessagesApi = new ConversationMessagesApi(
      new Configuration({ fetchApi: fetch, basePath: this.parameters.basePath })
    );
    this.conversationMessageApi = new ConversationMessageApi(
      new Configuration({ fetchApi: fetch, basePath: this.parameters.basePath })
    );
    this.modelApi = new ModelApi(
      new Configuration({ fetchApi: fetch, basePath: this.parameters.basePath })
    );
    this.modelsApi = new ModelsApi(
      new Configuration({ fetchApi: fetch, basePath: this.parameters.basePath })
    );
    this.searchApi = new SearchApi(
      new Configuration({ fetchApi: fetch, basePath: this.parameters.basePath })
    );
    this.allocationsApi = new AllocationsApi(
      new Configuration({ fetchApi: fetch, basePath: this.parameters.basePath })
    );
    this.applicationApi = new ApplicationApi(
      new Configuration({ fetchApi: fetch, basePath: this.parameters.basePath })
    );
    this.applicationsApi = new ApplicationsApi(
      new Configuration({ fetchApi: fetch, basePath: this.parameters.basePath })
    );
    this.linkifyApi = new LinkifyApi(
      new Configuration({ fetchApi: fetch, basePath: this.parameters.basePath })
    );
    this.assetsApi = new AssetsApi(
      new Configuration({ fetchApi: fetch, basePath: this.parameters.basePath })
    );
    this.formatApi = new FormatApi(
      new Configuration({ fetchApi: fetch, basePath: this.parameters.basePath })
    );
    this.userApi = new UserApi(
      new Configuration({ fetchApi: fetch, basePath: this.parameters.basePath })
    );
    this.osApi = new OSApi(
      new Configuration({ fetchApi: fetch, basePath: this.parameters.basePath })
    );
    this.assetApi = new AssetApi(
      new Configuration({ fetchApi: fetch, basePath: this.parameters.basePath })
    );
    this.DiscoveryApi = new DiscoveryApi(
      new Configuration({ fetchApi: fetch, basePath: this.parameters.basePath })
    );
    this.wellKnownApi = new WellKnownApi(
      new Configuration({ fetchApi: fetch, basePath: this.parameters.basePath })
    );
    this.QGPTApi = new QGPTApi(
      new Configuration({ fetchApi: fetch, basePath: this.parameters.basePath })
    );
    this.annotationsApi = new AnnotationsApi(
      new Configuration({ fetchApi: fetch, basePath: this.parameters.basePath })
    );
    this.annotationApi = new AnnotationApi(
      new Configuration({ fetchApi: fetch, basePath: this.parameters.basePath })
    );
    this.activityApi = new ActivityApi(
      new Configuration({ fetchApi: fetch, basePath: this.parameters.basePath })
    );
    this.activitiesApi = new ActivitiesApi(
      new Configuration({ fetchApi: fetch, basePath: this.parameters.basePath })
    );
    this.application = {
      name: ApplicationNameEnum.Obsidian,
      version,
      platform: this._platformMap[this._platform] || PlatformEnum.Unknown
    };
    this.seeded = {
      application: this.application
    };
  }
  static getInstance() {
    if (!ConnectorSingleton.instance) {
      ConnectorSingleton.instance = new ConnectorSingleton();
    }
    return ConnectorSingleton.instance;
  }
  static async checkConnection({
    notification = true
  }) {
    try {
      await fetch(`http://localhost:${portNumber}/.well-known/health`);
      return true;
    } catch (e3) {
      const notifications = Notifications.getInstance();
      if (notification) {
        notifications.information({
          message: Constants.CORE_PLATFORM_MSG
        });
      }
      return false;
    }
  }
};

// src/connection/version_check.ts
var import_semver = __toESM(require_semver2());

// src/actions/launch_runtime.ts
var launchRuntime = async (wait) => {
  try {
    await fetch(`http://localhost:${portNumber}/.well-known/health`);
  } catch (error) {
    window.open("pieces://launch", "_blank");
    if (wait) {
      return new Promise((resolve2) => setTimeout(resolve2, 3e3));
    }
  }
};

// src/connection/version_check.ts
var config = ConnectorSingleton.getInstance();
var currentMinVersion = "10.1.4";
var currentMaxVersion = "11.0.0";
var toUpdatePlugin = false;
var versionValid = false;
var versionCheck = async ({
  retry: retry2,
  minVersion = currentMinVersion
}) => {
  try {
    const osVersion = await config.wellKnownApi.getWellKnownVersion();
    if (osVersion.includes("staging") || osVersion.includes("debug")) {
      versionValid = true;
      return true;
    }
    if (!(0, import_semver.lt)(osVersion, currentMaxVersion)) {
      toUpdatePlugin = true;
    }
    versionValid = (0, import_semver.gte)(osVersion, minVersion) && (0, import_semver.lt)(osVersion, currentMaxVersion);
    return versionValid;
  } catch (error) {
    if (retry2) {
      return false;
    }
    if (error.code === "ECONNREFUSED") {
      await launchRuntime(true);
    }
    return await versionCheck({ retry: true });
  }
};

// src/const.ts
var Constants = class {
};
Constants.PIECES_LOGO = `<path fill='currentColor' stroke:none fill-rule:nonzero fill-opacity:1 d='M 41 1.601562 C 30.199219 4.601562 21.101562 12.101562 16.199219 22 L 13.5 27.5 L 13.199219 54.699219 L 12.898438 82 L 15.699219 87.199219 C 25.5 105.101562 51.101562 102.800781 57.300781 83.300781 C 58.199219 80.699219 59 77.398438 59.199219 76.101562 C 59.398438 74.398438 60.601562 73.300781 63.699219 72.101562 C 77.898438 66.601562 87 53.101562 87 37.5 C 87 28.699219 84.898438 22.398438 79.601562 15.199219 C 71.199219 3.699219 54.601562 -2.199219 41 1.601562 Z M 62.699219 11.800781 C 83.199219 22.300781 84.101562 51.5 64.199219 62.300781 L 59.199219 65 L 58.800781 52.5 C 58.398438 39 57.699219 37.101562 51.699219 32.601562 C 48 29.898438 40.199219 30 36.199219 32.898438 C 31.300781 36.300781 29.699219 41.101562 30.199219 50.398438 C 30.898438 62.898438 35.5 69.898438 45.601562 73.300781 C 48.800781 74.398438 49.5 75.199219 49.800781 77.601562 C 50.101562 81.300781 47 86.398438 42.800781 89.101562 C 40.300781 90.601562 38.300781 91 34.898438 90.699219 C 29.398438 90.199219 25.898438 87.898438 23 82.699219 C 20.898438 79 20.800781 78 21.199219 54.699219 C 21.5 31.699219 21.601562 30.300781 23.800781 25.800781 C 26.699219 20 34.601562 12.699219 40.300781 10.601562 C 46.199219 8.398438 57.199219 9 62.699219 11.800781 Z M 49 40.898438 C 50.101562 43.101562 50.398438 66 49.300781 66 C 47.5 66 42 61.898438 40.398438 59.5 C 38.199219 56.199219 37.800781 43.101562 39.898438 40.699219 C 41.800781 38.300781 47.699219 38.5 49 40.898438 Z M 49 40.898438 '/>`;
Constants.PIECES_LOGO_ALT = "M 8.199219 0.320312 C 6.039062 0.921875 4.21875 2.421875 3.238281 4.398438 L 2.699219 5.5 L 2.640625 10.941406 L 2.578125 16.398438 L 3.140625 17.441406 C 5.101562 21.019531 10.21875 20.558594 11.460938 16.660156 C 11.640625 16.140625 11.800781 15.480469 11.839844 15.21875 C 11.878906 14.878906 12.121094 14.660156 12.738281 14.421875 C 15.578125 13.320312 17.398438 10.621094 17.398438 7.5 C 17.398438 5.738281 16.980469 4.480469 15.921875 3.039062 C 14.238281 0.738281 10.921875 -0.441406 8.199219 0.320312 Z M 12.539062 2.359375 C 16.640625 4.460938 16.820312 10.300781 12.839844 12.460938 L 11.839844 13 L 11.761719 10.5 C 11.679688 7.800781 11.539062 7.421875 10.339844 6.519531 C 9.601562 5.980469 8.039062 6 7.238281 6.578125 C 6.261719 7.261719 5.941406 8.21875 6.039062 10.078125 C 6.179688 12.578125 7.101562 13.980469 9.121094 14.660156 C 9.761719 14.878906 9.898438 15.039062 9.960938 15.519531 C 10.019531 16.261719 9.398438 17.28125 8.558594 17.820312 C 8.058594 18.121094 7.660156 18.199219 6.980469 18.140625 C 5.878906 18.039062 5.179688 17.578125 4.601562 16.539062 C 4.179688 15.800781 4.160156 15.601562 4.238281 10.941406 C 4.300781 6.339844 4.320312 6.058594 4.761719 5.160156 C 5.339844 4 6.921875 2.539062 8.058594 2.121094 C 9.238281 1.679688 11.441406 1.800781 12.539062 2.359375 Z M 9.800781 8.179688 C 10.019531 8.621094 10.078125 13.199219 9.859375 13.199219 C 9.5 13.199219 8.398438 12.378906 8.078125 11.898438 C 7.640625 11.238281 7.558594 8.621094 7.980469 8.140625 C 8.359375 7.660156 9.539062 7.699219 9.800781 8.179688 Z M 9.800781 8.179688";
Constants.USER_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-user-circle-2"><path d="M18 20a6 6 0 0 0-12 0"/><circle cx="12" cy="10" r="4"/><circle cx="12" cy="12" r="10"/></svg>`;
Constants.AI_ICON = `<svg width="70" height="70" viewBox="0 0 70 70" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M45.9446 47.7533C46.0136 46.0459 45.0592 44.621 43.8131 44.5707C42.5673 44.5205 41.5012 45.8637 41.4322 47.5714C41.3636 49.2788 42.3176 50.7038 43.5637 50.7541C44.8094 50.8043 45.8756 49.4611 45.9446 47.7533Z" fill="currentColor"/>
  <path d="M58.3479 42.078C58.4169 40.3707 57.4625 38.9457 56.2164 38.8954C54.9706 38.8452 53.9045 40.1884 53.8355 41.8958C53.7669 43.6035 54.7209 45.0285 55.967 45.0788C57.2128 45.129 58.2789 43.7854 58.3479 42.078Z" fill="currentColor"/>
  <path d="M65.2761 21.7362C65.2761 21.7362 65.1925 21.7362 65.1925 21.6526L44.3699 11.1158C42.8646 10.3632 40.9412 10.4468 39.6032 11.5339C38.8505 12.1193 38.0979 12.621 37.178 12.8719C38.0979 18.3076 39.3523 25.2485 39.6868 26.5865C39.8541 27.3392 39.9377 28.0918 39.9377 28.928C39.9377 32.7748 37.6798 35.2 34.8365 35.2C31.9933 35.2 29.7353 32.6912 29.7353 28.928C29.7353 28.0918 29.819 27.2555 30.0699 26.5865C30.4044 25.4158 31.5751 18.4749 32.5786 12.9555C31.7424 12.621 30.9061 12.2029 30.1535 11.6175C28.8155 10.5304 26.9757 10.3632 25.3868 11.1994L4.56406 21.7362C4.56406 21.7362 4.48043 21.7362 4.48043 21.8199C3.89505 22.1544 3.56055 22.7397 3.56055 23.3251V50.5036C3.56055 51.1726 3.89505 51.758 4.48043 52.0925L34.0003 68.483C34.0839 68.5666 34.1675 68.5666 34.2512 68.5666C34.3348 68.5666 34.3348 68.6502 34.4184 68.6502C34.5857 68.6502 34.7529 68.7339 34.8365 68.7339C35.0038 68.7339 35.171 68.7339 35.2547 68.6502C35.3383 68.6502 35.3383 68.6502 35.4219 68.5666C35.5055 68.5666 35.5892 68.483 35.6728 68.483L65.1925 52.0925C65.7779 51.758 66.1124 51.1726 66.1124 50.5036V23.3251C66.196 22.6561 65.8615 22.0707 65.2761 21.7362ZM7.15644 26.3357L33.0804 40.7191V63.8L7.15644 49.4165V26.3357ZM62.6001 49.4165L36.6763 63.8V40.7191L62.6001 26.3357V49.4165Z" fill="currentColor"/>
  <path d="M34.8372 9.52983C37.1926 9.52983 39.1021 7.62036 39.1021 5.26491C39.1021 2.90946 37.1926 1 34.8372 1C32.4817 1 30.5723 2.90946 30.5723 5.26491C30.5723 7.62036 32.4817 9.52983 34.8372 9.52983Z" fill="currentColor"/>
  <path d="M61.4261 3.16895H36.0876H34.6659H8.32387C-0.874953 3.16895 2.97182 10.6116 11.3344 10.6116C20.1151 10.6116 23.6274 6.84849 30.5683 7.01574C32.408 7.01574 34.1642 7.01574 35.2513 7.01574C36.0039 7.01574 37.3419 7.01574 39.1817 7.01574C46.2064 6.84849 49.7186 10.6116 58.4156 10.6116C66.7781 10.6116 70.6249 3.16895 61.4261 3.16895Z" fill="currentColor"/>
  </svg>
  `;
Constants.SEND_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-send-horizontal"><path d="m3 3 3 9-3 9 19-9Z"/><path d="M6 12h16"/></svg>`;
Constants.ENRICH_ICON = '<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.75" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-sparkles"><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z"/><path d="M5 3v4"/><path d="M19 17v4"/><path d="M3 5h4"/><path d="M17 19h4"/></svg>';
Constants.CODE_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.0" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-braces"><path d="M8 3H7a2 2 0 0 0-2 2v5a2 2 0 0 1-2 2 2 2 0 0 1 2 2v5c0 1.1.9 2 2 2h1"/><path d="M16 21h1a2 2 0 0 0 2-2v-5c0-1.1.9-2 2-2a2 2 0 0 1-2-2V5a2 2 0 0 0-2-2h-1"/></svg>`;
Constants.OPEN_ICON = '<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-panel-right-open"><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><line x1="15" x2="15" y1="3" y2="21"/><path d="m10 15-3-3 3-3"/></svg>';
Constants.SAVE_ALL_ICON = `<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-save-all"><path d="M6 4a2 2 0 0 1 2-2h10l4 4v10.2a2 2 0 0 1-2 1.8H8a2 2 0 0 1-2-2Z"/><path d="M10 2v4h6"/><path d="M18 18v-7h-8v7"/><path d="M18 22H4a2 2 0 0 1-2-2V6"/></svg>`;
Constants.META_SVG = '<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 287.56 191"><defs><style>.cls-1{fill:#0081fb;}.cls-2{fill:url(#linear-gradient);}.cls-3{fill:url(#linear-gradient-2);}</style><linearGradient id="linear-gradient" x1="62.34" y1="101.45" x2="260.34" y2="91.45" gradientTransform="matrix(1, 0, 0, -1, 0, 192)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#0064e1"/><stop offset="0.4" stop-color="#0064e1"/><stop offset="0.83" stop-color="#0073ee"/><stop offset="1" stop-color="#0082fb"/></linearGradient><linearGradient id="linear-gradient-2" x1="41.42" y1="53" x2="41.42" y2="126" gradientTransform="matrix(1, 0, 0, -1, 0, 192)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#0082fb"/><stop offset="1" stop-color="#0064e0"/></linearGradient></defs><title>facebook-meta</title><path class="cls-1" d="M31.06,126c0,11,2.41,19.41,5.56,24.51A19,19,0,0,0,53.19,160c8.1,0,15.51-2,29.79-21.76,11.44-15.83,24.92-38,34-52l15.36-23.6c10.67-16.39,23-34.61,37.18-47C181.07,5.6,193.54,0,206.09,0c21.07,0,41.14,12.21,56.5,35.11,16.81,25.08,25,56.67,25,89.27,0,19.38-3.82,33.62-10.32,44.87C271,180.13,258.72,191,238.13,191V160c17.63,0,22-16.2,22-34.74,0-26.42-6.16-55.74-19.73-76.69-9.63-14.86-22.11-23.94-35.84-23.94-14.85,0-26.8,11.2-40.23,31.17-7.14,10.61-14.47,23.54-22.7,38.13l-9.06,16c-18.2,32.27-22.81,39.62-31.91,51.75C84.74,183,71.12,191,53.19,191c-21.27,0-34.72-9.21-43-23.09C3.34,156.6,0,141.76,0,124.85Z"/><path class="cls-2" d="M24.49,37.3C38.73,15.35,59.28,0,82.85,0c13.65,0,27.22,4,41.39,15.61,15.5,12.65,32,33.48,52.63,67.81l7.39,12.32c17.84,29.72,28,45,33.93,52.22,7.64,9.26,13,12,19.94,12,17.63,0,22-16.2,22-34.74l27.4-.86c0,19.38-3.82,33.62-10.32,44.87C271,180.13,258.72,191,238.13,191c-12.8,0-24.14-2.78-36.68-14.61-9.64-9.08-20.91-25.21-29.58-39.71L146.08,93.6c-12.94-21.62-24.81-37.74-31.68-45C107,40.71,97.51,31.23,82.35,31.23c-12.27,0-22.69,8.61-31.41,21.78Z"/><path class="cls-3" d="M82.35,31.23c-12.27,0-22.69,8.61-31.41,21.78C38.61,71.62,31.06,99.34,31.06,126c0,11,2.41,19.41,5.56,24.51L10.14,167.91C3.34,156.6,0,141.76,0,124.85,0,94.1,8.44,62.05,24.49,37.3,38.73,15.35,59.28,0,82.85,0Z"/></svg>';
Constants.OPENAI_SVG = `<?xml version="1.0" encoding="UTF-8"?>
  <svg width="256px" height="260px" viewBox="0 0 256 260" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" preserveAspectRatio="xMidYMid">
      <title>OpenAI</title>
      <g>
          <path d="M239.183914,106.202783 C245.054304,88.5242096 243.02228,69.1733805 233.607599,53.0998864 C219.451678,28.4588021 190.999703,15.7836129 163.213007,21.739505 C147.554077,4.32145883 123.794909,-3.42398554 100.87901,1.41873898 C77.9631105,6.26146349 59.3690093,22.9572536 52.0959621,45.2214219 C33.8436494,48.9644867 18.0901721,60.392749 8.86672513,76.5818033 C-5.443491,101.182962 -2.19544431,132.215255 16.8986662,153.320094 C11.0060865,170.990656 13.0197283,190.343991 22.4238231,206.422991 C36.5975553,231.072344 65.0680342,243.746566 92.8695738,237.783372 C105.235639,251.708249 123.001113,259.630942 141.623968,259.52692 C170.105359,259.552169 195.337611,241.165718 204.037777,214.045661 C222.28734,210.296356 238.038489,198.869783 247.267014,182.68528 C261.404453,158.127515 258.142494,127.262775 239.183914,106.202783 L239.183914,106.202783 Z M141.623968,242.541207 C130.255682,242.559177 119.243876,238.574642 110.519381,231.286197 L112.054146,230.416496 L163.724595,200.590881 C166.340648,199.056444 167.954321,196.256818 167.970781,193.224005 L167.970781,120.373788 L189.815614,133.010026 C190.034132,133.121423 190.186235,133.330564 190.224885,133.572774 L190.224885,193.940229 C190.168603,220.758427 168.442166,242.484864 141.623968,242.541207 Z M37.1575749,197.93062 C31.456498,188.086359 29.4094818,176.546984 31.3766237,165.342426 L32.9113895,166.263285 L84.6329973,196.088901 C87.2389349,197.618207 90.4682717,197.618207 93.0742093,196.088901 L156.255402,159.663793 L156.255402,184.885111 C156.243557,185.149771 156.111725,185.394602 155.89729,185.550176 L103.561776,215.733903 C80.3054953,229.131632 50.5924954,221.165435 37.1575749,197.93062 Z M23.5493181,85.3811273 C29.2899861,75.4733097 38.3511911,67.9162648 49.1287482,64.0478825 L49.1287482,125.438515 C49.0891492,128.459425 50.6965386,131.262556 53.3237748,132.754232 L116.198014,169.025864 L94.3531808,181.662102 C94.1132325,181.789434 93.8257461,181.789434 93.5857979,181.662102 L41.3526015,151.529534 C18.1419426,138.076098 10.1817681,108.385562 23.5493181,85.125333 L23.5493181,85.3811273 Z M203.0146,127.075598 L139.935725,90.4458545 L161.7294,77.8607748 C161.969348,77.7334434 162.256834,77.7334434 162.496783,77.8607748 L214.729979,108.044502 C231.032329,117.451747 240.437294,135.426109 238.871504,154.182739 C237.305714,172.939368 225.050719,189.105572 207.414262,195.67963 L207.414262,134.288998 C207.322521,131.276867 205.650697,128.535853 203.0146,127.075598 Z M224.757116,94.3850867 L223.22235,93.4642272 L171.60306,63.3828173 C168.981293,61.8443751 165.732456,61.8443751 163.110689,63.3828173 L99.9806554,99.8079259 L99.9806554,74.5866077 C99.9533004,74.3254088 100.071095,74.0701869 100.287609,73.9215426 L152.520805,43.7889738 C168.863098,34.3743518 189.174256,35.2529043 204.642579,46.0434841 C220.110903,56.8340638 227.949269,75.5923959 224.757116,94.1804513 L224.757116,94.3850867 Z M88.0606409,139.097931 L66.2158076,126.512851 C65.9950399,126.379091 65.8450965,126.154176 65.8065367,125.898945 L65.8065367,65.684966 C65.8314495,46.8285367 76.7500605,29.6846032 93.8270852,21.6883055 C110.90411,13.6920079 131.063833,16.2835462 145.5632,28.338998 L144.028434,29.2086986 L92.3579852,59.0343142 C89.7419327,60.5687513 88.1282597,63.3683767 88.1117998,66.4011901 L88.0606409,139.097931 Z M99.9294965,113.5185 L128.06687,97.3011417 L156.255402,113.5185 L156.255402,145.953218 L128.169187,162.170577 L99.9806554,145.953218 L99.9294965,113.5185 Z" fill="currentColor"></path>
      </g>
  </svg>
  `;
Constants.COPILOT_INTRO = `<svg height="48px" viewBox="0 0 1784 643" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M321.407 133.742C255.032 133.742 199.425 183.363 191.256 248.467L191.07 250.425V250.798V251.172C190.606 254.063 190.42 256.954 190.328 259.939V443.031C190.328 479.221 219.198 508.695 255.125 509.254H256.331C292.35 509.254 321.685 480.247 322.242 444.151V434.357C270.627 429.6 230.988 386.509 230.153 334.463V295.382C230.802 259.193 260.509 230.279 296.528 230.838C331.711 231.398 360.118 259.939 360.768 295.382V390.146C414.425 373.357 452.672 323.271 452.672 264.882C452.579 192.504 393.816 133.742 321.407 133.742Z" fill="currentColor"/>
  <path d="M296.179 270.062H295.735C281.876 270.062 270.504 281.165 270.059 295.134V330.862C270.059 360.68 291.471 386.11 320.7 390.856L321.499 390.946V295.94C321.499 281.792 310.216 270.33 296.179 270.062Z" fill="currentColor"/>
  <path d="M321.5 0C143.936 0 0 143.936 0 321.5C0 499.064 143.936 643 321.5 643C499.064 643 643 499.064 643 321.5C643 143.936 499.064 0 321.5 0ZM363.35 428.482L361.133 429.036L360.579 429.129V441.785C360.579 497.863 316.142 543.778 260.064 545.626H258.401H256.646C199.921 545.626 153.729 500.173 152.805 443.541V441.785V261.45C152.805 256.738 153.082 252.119 153.729 247.407L153.821 246.576L154.098 244.451C164.353 162.505 233.365 99.8682 316.511 97.3738L319.006 97.2815H321.592C414.809 97.2815 490.38 172.575 490.38 265.515C490.287 343.395 436.889 409.82 363.35 428.482Z" fill="currentColor"/>
  <path d="M1585.97 443.811C1586.62 427.602 1577.56 414.074 1565.73 413.597C1553.9 413.119 1543.79 425.872 1543.13 442.082C1542.48 458.291 1551.53 471.818 1563.36 472.296C1575.19 472.773 1585.31 460.02 1585.97 443.811Z" fill="currentColor"/>
  <path d="M1703.74 389.948C1704.4 373.739 1695.34 360.211 1683.51 359.734C1671.68 359.256 1661.56 372.009 1660.91 388.218C1660.25 404.428 1669.31 417.955 1681.14 418.433C1692.97 418.91 1703.09 406.157 1703.74 389.948Z" fill="currentColor"/>
  <path d="M1769.51 196.847C1769.51 196.847 1768.72 196.847 1768.72 196.053L1571.04 96.0268C1556.75 88.8821 1538.5 89.6759 1525.79 99.9962C1518.65 105.553 1511.5 110.316 1502.77 112.698C1511.5 164.299 1523.41 230.19 1526.59 242.891C1528.18 250.036 1528.97 257.181 1528.97 265.119C1528.97 301.637 1507.53 324.659 1480.54 324.659C1453.55 324.659 1432.12 300.843 1432.12 265.119C1432.12 257.181 1432.91 249.242 1435.29 242.891C1438.47 231.777 1449.58 165.887 1459.11 113.492C1451.17 110.316 1443.23 106.347 1436.09 100.79C1423.39 90.4698 1405.92 88.8821 1390.84 96.8207L1193.17 196.847C1193.17 196.847 1192.37 196.847 1192.37 197.641C1186.81 200.817 1183.64 206.374 1183.64 211.931V469.936C1183.64 476.287 1186.81 481.844 1192.37 485.019L1472.6 640.616C1473.4 641.41 1474.19 641.41 1474.99 641.41C1475.78 641.41 1475.78 642.204 1476.57 642.204C1478.16 642.204 1479.75 642.998 1480.54 642.998C1482.13 642.998 1483.72 642.998 1484.51 642.204C1485.31 642.204 1485.31 642.204 1486.1 641.41C1486.89 641.41 1487.69 640.616 1488.48 640.616L1768.72 485.019C1774.27 481.844 1777.45 476.287 1777.45 469.936V211.931C1778.24 205.58 1775.07 200.023 1769.51 196.847ZM1217.78 240.51L1463.87 377.054V596.16L1217.78 459.616V240.51ZM1744.11 459.616L1498.01 596.16V377.054L1744.11 240.51V459.616Z" fill="currentColor"/>
  <path d="M1480.52 80.9739C1502.88 80.9739 1521.01 62.8473 1521.01 40.487C1521.01 18.1266 1502.88 0 1480.52 0C1458.16 0 1440.03 18.1266 1440.03 40.487C1440.03 62.8473 1458.16 80.9739 1480.52 80.9739Z" fill="currentColor"/>
  <path d="M1732.96 20.634H1492.42H1478.93H1228.86C1141.54 20.634 1178.05 91.2878 1257.44 91.2878C1340.79 91.2878 1374.14 55.5639 1440.03 57.1517C1457.49 57.1517 1474.16 57.1517 1484.48 57.1517C1491.63 57.1517 1504.33 57.1517 1521.8 57.1517C1588.48 55.5639 1621.82 91.2878 1704.38 91.2878C1783.77 91.2878 1820.29 20.634 1732.96 20.634Z" fill="currentColor"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M854.029 259.703C858.681 255.05 866.225 255.05 870.878 259.703L974.052 362.877C978.704 367.529 978.704 375.073 974.052 379.726C969.399 384.378 961.855 384.378 957.203 379.726L854.029 276.552C849.376 271.899 849.376 264.355 854.029 259.703Z" fill="currentColor"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M852.616 378.839C847.963 374.187 847.963 366.643 852.616 361.99L955.79 258.816C960.443 254.164 967.986 254.164 972.639 258.816C977.292 263.469 977.292 271.013 972.639 275.665L869.465 378.839C864.812 383.492 857.269 383.492 852.616 378.839Z" fill="currentColor"/>
  </svg>`;
Constants.CHECK_SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-check"><polyline points="20 6 9 17 4 12"/></svg>`;
Constants.CLOUD_SVG = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-cloud"><path d="M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z"/></svg>';
Constants.LAPTOP_SVG = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-laptop"><path d="M20 16V7a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v9m16 0H4m16 0 1.28 2.55a1 1 0 0 1-.9 1.45H3.62a1 1 0 0 1-.9-1.45L4 16"/></svg>';
Constants.DOWNLOAD_SVG = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-download"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></svg>';
Constants.PLUG_SVG = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-plug"><path d="M12 22v-5"/><path d="M9 8V2"/><path d="M15 8V2"/><path d="M18 8v5a4 4 0 0 1-4 4h-4a4 4 0 0 1-4-4V8Z"/></svg>';
Constants.PALM2_SVG = `<svg version="1.1" id="Standard_product_icon__x28_1:1_x29_"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="192px" height="192px"
  viewBox="0 0 192 192" enable-background="new 0 0 192 192" xml:space="preserve">
<symbol  id="material_x5F_product_x5F_standard_x5F_icon_x5F_keylines_00000077318920148093339210000006245950728745084294_" viewBox="-96 -96 192 192">
 <g opacity="0.4">
   <defs>
     <path id="SVGID_1_" opacity="0.4" d="M-96,96V-96H96V96H-96z"/>
   </defs>
   <clipPath id="SVGID_00000071517564283228984050000017848131202901217410_">
     <use xlink:href="#SVGID_1_"  overflow="visible"/>
   </clipPath>
   <g clip-path="url(#SVGID_00000071517564283228984050000017848131202901217410_)">
     <g>
       <path d="M95.75,95.75v-191.5h-191.5v191.5H95.75 M96,96H-96V-96H96V96L96,96z"/>
     </g>
     <circle fill="none" stroke="#000000" stroke-width="0.25" stroke-miterlimit="10" cx="0" cy="0" r="64"/>
   </g>
   
     <circle clip-path="url(#SVGID_00000071517564283228984050000017848131202901217410_)" fill="none" stroke="#000000" stroke-width="0.25" stroke-miterlimit="10" cx="0" cy="0" r="88"/>
   
     <path clip-path="url(#SVGID_00000071517564283228984050000017848131202901217410_)" fill="none" stroke="#000000" stroke-width="0.25" stroke-miterlimit="10" d="
     M64,76H-64c-6.6,0-12-5.4-12-12V-64c0-6.6,5.4-12,12-12H64c6.6,0,12,5.4,12,12V64C76,70.6,70.6,76,64,76z"/>
   
     <path clip-path="url(#SVGID_00000071517564283228984050000017848131202901217410_)" fill="none" stroke="#000000" stroke-width="0.25" stroke-miterlimit="10" d="
     M52,88H-52c-6.6,0-12-5.4-12-12V-76c0-6.6,5.4-12,12-12H52c6.6,0,12,5.4,12,12V76C64,82.6,58.6,88,52,88z"/>
   
     <path clip-path="url(#SVGID_00000071517564283228984050000017848131202901217410_)" fill="none" stroke="#000000" stroke-width="0.25" stroke-miterlimit="10" d="
     M76,64H-76c-6.6,0-12-5.4-12-12V-52c0-6.6,5.4-12,12-12H76c6.6,0,12,5.4,12,12V52C88,58.6,82.6,64,76,64z"/>
 </g>
</symbol>
<rect id="bounding_box_1_" display="none" fill="none" width="192" height="192"/>
<g id="art_layer">
 <g>
   <path fill="#F9AB00" d="M96,181.92L96,181.92c6.63,0,12-5.37,12-12v-104H84v104C84,176.55,89.37,181.92,96,181.92z"/>
   <g>
     <path fill="#5BB974" d="M143.81,103.87C130.87,90.94,111.54,88.32,96,96l51.37,51.37c2.12,2.12,5.77,1.28,6.67-1.57
       C158.56,131.49,155.15,115.22,143.81,103.87z"/>
   </g>
   <g>
     <path fill="#129EAF" d="M48.19,103.87C61.13,90.94,80.46,88.32,96,96l-51.37,51.37c-2.12,2.12-5.77,1.28-6.67-1.57
       C33.44,131.49,36.85,115.22,48.19,103.87z"/>
   </g>
   <g>
     <path fill="#AF5CF7" d="M140,64c-20.44,0-37.79,13.4-44,32h81.24c3.33,0,5.55-3.52,4.04-6.49C173.56,74.36,157.98,64,140,64z"/>
   </g>
   <g>
     <path fill="#FF8BCB" d="M104.49,42.26C90.03,56.72,87.24,78.45,96,96l57.45-57.45c2.36-2.36,1.44-6.42-1.73-7.45
       C135.54,25.85,117.2,29.55,104.49,42.26z"/>
   </g>
   <g>
     <path fill="#FA7B17" d="M87.51,42.26C101.97,56.72,104.76,78.45,96,96L38.55,38.55c-2.36-2.36-1.44-6.42,1.73-7.45
       C56.46,25.85,74.8,29.55,87.51,42.26z"/>
   </g>
   <g>
     <g>
       <path fill="#4285F4" d="M52,64c20.44,0,37.79,13.4,44,32H14.76c-3.33,0-5.55-3.52-4.04-6.49C18.44,74.36,34.02,64,52,64z"/>
     </g>
   </g>
 </g>
</g>
<g id="keylines" display="none">
 
   <use xlink:href="#material_x5F_product_x5F_standard_x5F_icon_x5F_keylines_00000077318920148093339210000006245950728745084294_"  width="192" height="192" id="material_x5F_product_x5F_standard_x5F_icon_x5F_keylines" x="-96" y="-96" transform="matrix(1 0 0 -1 96 96)" display="inline" overflow="visible"/>
</g>
</svg>
`;
/*
       -------------
       |   Views   |
       -------------
       View types for different views
    */
Constants.PIECES_ONBOARDING_VIEW_TYPE = "pieces-onboarding";
Constants.PIECES_EXPANDED_SNIPPET_VIEW_TYPE = "pieces-expanded-snippet";
Constants.PIECES_SNIPPET_LIST_VIEW_TYPE = "pieces-snippet-list";
/*
       ----------------
       |   SETTINGS   |
       ----------------
       Front end text within the Pieces plugin settings tab
   */
Constants.ENRICH_PERSISTENCE = "Confirm double enrichment";
Constants.ENRICH_PERSISTENCE_DESC = "Receive a confirmation prompt if you attempt to enrich a code block that has already been processed.";
Constants.CLOUD_SELECT = "Cloud capabilities";
Constants.CLOUD_SELECT_DESC = "Select if you'd like to utilize cloud only, local only, or a blend of both.";
Constants.PORT_PROMPT = "Pieces server port:";
Constants.PORT_DESCRIPTION = "Pieces' default port is 1000.";
Constants.PORT_VALUE = process.platform == "linux" ? "5323" : "1000";
Constants.SHOW_TUTORIAL = "Show plugin usage tutorials";
Constants.TUTORIAL_DESCRIPTION = "Display some useful information about using Pieces in Obsidian.";
Constants.LOGIN_TITLE = "Login";
Constants.LOGIN_DESC = "Start generating shareable links for your code snippets";
Constants.LOGOUT_TITLE = "Logout";
Constants.LOGOUT_DESC = "You will no longer have the ability to generate shareable links or share via GitHub Gist.";
Constants.TOGGLE_AUTOOPEN = "Auto-Open Pieces list on snippet save";
Constants.TOGGLE_AUTOOPEN_DESC = "Automatically open the Pieces snippet list view when saving a snippet.";
Constants.TOGGLE_AUTODISCOVER = "Auto-Discover snippets from your vault";
Constants.TOGGLE_AUTODISCOVER_DESC = "Automatically discover snippets from your vault when opening Pieces.";
Constants.TOGGLE_AUTODISCOVER_MAX = "Maximum number of snippets to discover";
Constants.TOGGLE_AUTODISCOVER_DESC_MAX = "Change the maximum number of snippets that Pieces will discover.";
Constants.TOGGLE_USE_NOTE_TITLE = "Use note page title for saved snippets";
Constants.TOGGLE_USE_NOTE_TITLE_DESC = "Assign the title of your note page to the snippets you save.";
/*
     ---------------------
     |   SAVE SNIPPETS   |
     ---------------------
     notification text for saving a piece
   */
Constants.NO_SAVE_SELECTION = "Make sure you select some text before you save a snippet";
Constants.NO_SELECTION_SAVE = "Make sure to select some snippets before you try to save";
Constants.SAVE_SUCCESS = "Success saving to Pieces";
Constants.SAVE_FAIL = "Failed saving to Pieces";
/*
       ------------------------
       |   SIGNIN / SIGNOUT   |
       ------------------------
       notification text for Pieces login / logout
   */
Constants.SIGNIN_SUCCESS = "Successfully signed in!";
Constants.SIGNIN_FAIL = "Unable to sign in.";
Constants.SIGNOUT_SUCCESS = "Successfully signed out.";
Constants.SIGNOUT_FAIL = "Unable to sign out.";
Constants.CONNECTION_FAIL = "Failed to connect to Pieces OS. Please check that Pieces OS is installed and running.";
/*
       ----------------------
       |   SNIPPET DELETE   |
       ----------------------
       notification text for snippet deletions
   */
Constants.SNIPPET_DELETE_SUCCESS = "Your snippet was successfully deleted!";
Constants.SNIPPET_IS_DELETED = "Snippet has already been deleted.";
Constants.SNIPPET_DELETE_FAILURE = "Failed to delete snippet. Please ensure that Pieces OS is up-to-date, installed and running. If the problem persists please reach out to support.";
/*
       ---------------------------------
       |  CLOUD CONNECT / DISCONNECT   |
       ---------------------------------
       notification text for cloud handling
   */
Constants.LOGIN_TO_POS_CLOUD = "Please login to Pieces OS in order to connect to Pieces cloud.";
Constants.CLOUD_CONNECT_FAIL = "Unable to connect to Pieces cloud, please wait a minute an try again.";
Constants.CLOUD_CONNECT_SUCCESS = "Successfully connected to Pieces cloud.";
Constants.CLOUD_CONNECT_INPROG = "Pieces cloud is still connecting please try again later.";
Constants.CLOUD_DISCONNECT_ALR = "Already disconnected from Pieces cloud.";
Constants.CLOUD_DISCONNECT_SUCCESS = "Successfully disconnected from Pieces cloud.";
Constants.CLOUD_DISCONNECT_FAIL = "Failed to disconnect from Pieces cloud, please try again.";
Constants.CORE_PLATFORM_MSG = "Pieces for Developers \u23B8 Core Platform runs offline and on-device to power our IDE and Browser extensions.";
Constants.LOGIN_TO_POS = "Please login to Pieces OS";
Constants.LINK_GEN_SUCCESS = "Shareable link generated!";
Constants.LINK_GEN_COPY = "Sharable link copied to clipboard!";
Constants.LINK_GEN_FAIL = "Failed to generate link. Please ensure that Pieces OS is up-to-date, installed and running. If the problem persists please reach out to support.";
/*
       -----------------------------------
       |   TEXT FOR ExpandView Problem   |
       -----------------------------------
       This is shown in the 'general text view'
       if we are not able to expand their snippet
   */
Constants.EXPAND_ERROR = "Error expanding snippet, check the `Snippet ID` and try again.";
/*
       -----------------------
       |   SEARCH SNIPPETS   |
       -----------------------
   */
Constants.SEARCH_SUCCESS = "Snippet search success!";
Constants.SEARCH_FAILURE = "Something went wrong while searching for your snippets, if the issue persists please reach out to support.";
/*
       -----------------------------------
       |   TEXT FOR Pieces OS DOWNLOAD MODAL   |
       -----------------------------------
       This is shown in the 'download-pos-modal'
       if we are not able to contact Pieces OS on their machine
   */
Constants.INSTALL_TEXT = "Please download, install, and run our core dependency to use Pieces with Obsidian:";
Constants.PIECES_ONDEVICE_COPY = "Pieces for Developers | Core Platform runs offline and on-device to power our IDE and Browser Extensions";
/*
       ------------------------------
       |   TEXT FOR WELCOME MODAL   |
       ------------------------------
       This is shown within 'onboarding-modal'
       if it is the first time the user is loading the extension
   */
Constants.WELCOME_TEXT = "Welcome to Pieces for Developers!";
Constants.SAVE_INSERT_SEARCH = "Save, insert, and search your snippets.";
// Saving snippets
Constants.SAVE_SNIPPET = "Save a snippet";
Constants.SAVE_EXPLANATION = 'Select the snippet you would like to save to Pieces, right click, and click the "Save to pieces" button';
Constants.SAVE_SHORTCUT_EX = "Or you can use the keyboard shortcut: MOD + SHIFT + P";
// Viewing Snippets
Constants.VIEW_SNIPPETS = "Viewing your snippets";
Constants.VIEW_SNIPPET_EXPLANATION = 'In order to view your saved snippets, just click on the "Pieces" icon on your ribbon bar.';
// Inserting Snippets
Constants.INSERT_SNIPPET = "Insert a snippet";
Constants.INSERT_SNIPPET_EXPLANATION = 'In order to insert a snippet, navigate to the snippet on the Pieces view, click the "copy snippet" button, and paste it into your editor';
// Searching Snippets
Constants.SEARCH_SNIPPET = "Search for a snippet";
Constants.SEARCH_SNIPPET_EXPLANATION = 'To search for a snippet, navigate to the Pieces view, and type your query into the search box. Once you are done, click the "X" and it will clear your search.';
Constants.UPDATE_OS = `In order to use the Pieces for Developers Obsidian Plugin, you must have Pieces OS version ${currentMinVersion} or greater! Please update your Pieces OS`;
/*
	|------------------|
	|	UPDATE ASSET   |
	|------------------|
*/
Constants.RECLASSIFY_SUCCESS = "Snippet successfully reclassified";
Constants.UPDATE_SUCCESS = "Snippet successfully updated";
Constants.UPDATE_FAILURE = "Error updating snippet, please try again... or contact support.";
Constants.UPDATE_CODE_SUCCESS = "Snippet code successfully updated";
Constants.GPT_DEFAULT_LANGUAGE = "txt";
/*
	|------------------|
	|	COPILOT        |
	|------------------|
*/
Constants.askQGPTTitle = "Ask copilot about your selection";
Constants.LLMDisclaimer = "Running LLM's locally requires a large amount of computer resources. Please thoroughly review your system's hardware to make sure it aligns with the requirements to run the local model(s).";

// src/cache/pieces_cache.ts
var import_crypto = __toESM(require("crypto"));

// src/database/pieces_database.ts
var import_obsidian17 = require("obsidian");

// src/ui/views/DisplayController.ts
var import_obsidian13 = require("obsidian");

// assets/classifications/batchfile-white.png
var batchfile_white_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAH/SURBVHgB7ZiLccIwDIaVXgeADcIGjAAbsAFhgmQD6AYwAbBBmACYADZINoANXMk95ZyHctCEntvqu9Mp59hGin/LCQCKoiiKoii/B2NMjJYZv8jQomeSiIzfJNWYAyGRDF0I/pIHQTByG6REDHgOJlKK/Q3+CJqIb/y/REajEW2wkg2HQ5hOp7Df78Vxi8Wi6Hu/34v20+lUm6/JaPy3aSrcYRhSJRNtvV7XxmRZJvY5Ho+t87FFUfOR1jkRd2IKlNvJV9lut6WgJpOJkaB5pXkeSaTTHsEfBQxOvM+SwyCtJzldr1d4BZ0SyfPcBkdUE3LvxXFc3D8cDvBjmBZpDQYDe+3umfF4bGXmkiRJSSqr1aoY7420SFJsBMnlfD6X+qRpav1sNrN+Pp9bT5WLV6pPnk6EAsOKYw1XAfDJ23byXF4pUJIWgSsAu93OtnHibeW6V9qkVS2H+OQLibG8WCaSkbxut1uv0nqHjrCECHr6tCrcRhvcLQJ0D88S62lVqAi8lLYVcTc7XUPl4HLPjsvlUpuHzhJoOFO6rsjTiUCDTJbLZSEVDlQKiKsXOFLsI5GHP6x487qQlMikfry5pbnc8SQ3LhbSOJfqh5V+IfqGJuIbUiKveUXtj1p8UiIf4DebakMg9TRff03Sm14I/pCjbbBgpaAoiqIoiuI/nzQheYPhf7t6AAAAAElFTkSuQmCC";

// assets/classifications/coffeescript-white.png
var coffeescript_white_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAALoSURBVHgB7ZndkdowEIDXN3mPU8G5g9DBORWEdEAquOvgoIIjFQAVQCowqQCuAjkVkA42u+PVWAjZksH28aBvZkfY+ttdSStZAEQikUgkcj0J9AAippRkJJwekyT558ifkjyR5FIulexSZEOyp7oljA0pOCFRJCdJtWSSn5K8Sn4IXHcKQ0AN5+JRV15BsmvIm4piJmzQ3G6TDZf3ukwKPRrA3nwjWbWUeZGOZ6LcVEagsAzg51zqcLlXcBuuyT16bfWohxiylUYPnnJzdMMGrmyljFFS0sfKMnzp6S/TzoFAQw5G46rNA+KlqYwMywSbpyMrspb2lQj/XraNhNTNDUe0OtjuUOHlFOHpNIEREAex8m94HjBOtg7e8MsepoTndGZlcYg9ivyVlCl1vh2Gm5SFOhxPpJ9H+T1x9PmLZGm3nbR0kFPhvfHMjeYk36WD/iJLM9pZ7yQ7S5/UNKbNEF50n0kWrk1KDMugMuoR6g3RFJ+SWpHSeH7XBlC/R0e/3O4zCTv6G/iQRWuujRmGhryeaVgrZ9tC24hklChHFnupJPmjf/d5rMD6uMMj/RXqtWKP8A/qd6cfEk+jCi4XeRNslDlVQkgbJIQv5hr55Cn8G6r5GMIoIVnY21HrwVNhB/fJxn7hM+QJ7pN9cElaH894nzjPWA8NRvB8X8rjAu6LTXBJrM9YhTzP8T5QXYwwN8KZvOMNKfQrb0hmXQwpjIqZ8f4FP5YVdAHPPZ+1GDkmCj3HI9diN3dWe5P7CfXuPSYL3zHIZYipaG5mSGNjR7E19buGrmD9rc6cXEOK400xhdeeuLE6Lpvw93RqlclwnCiWwy1gdRFgovBy4Q+9t3SLUh2M4RF4xfNbxCFHJYO+wOqKZ2sozGmB9UY51KiEXfX0aGiGwzCDscHqsq1Pxh0NyxieYgpvp8A+L7CvNIanGR84Dx2V53XH6zCHG+jljx4brCKOvvdyebiE+u6qhEgkEolEPpj/B7H21TJSgLQAAAAASUVORK5CYII=";

// assets/classifications/batchfile-black.png
var batchfile_black_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAIASURBVHgB7ZeBkYIwEEXXmytAKxA70A60Au1AOsAStAM70BK0ArGCowPoQDvI5edmmQCCCHjmvH0zO4EkMPvZzYYQCYIgCIIg/CkCbbE25ZB9afPpAXwierXTVbaimnwRvdzZKovzDvdKhChyn4zvH/QmiBDX+H9C1us1KaUKFscx7XY78jzv5nPo57mn06nWO/OG93cmpAw46vu+cbLf7xfGp9Np5vrWnGdSqN366ynG7t9ut2m/FlR4TgtUNngPlewPPFdHuc5ekqF1RLSQ0jFEiyOy3+9NGwQBPYPWQpbLZXodhmFmbLX6+ZNIkoQ2m425RmrZ6dYVn9QALHAGX/16vRpH4bDNfD437fF4NGMQChGLxaIgui2tIsILF+1wOMyMwWGuZJxW5/PZtIhi14u+kZDRaGRsMBjQbDYzfUgjlFOGUw7R4nTiiOEeUfkNalctGKoMOBwO5l47qi6Xi6oCFYo6rFqN1ogN0odTSDtvWnxtTp0oikxUGPSPx+N0T7HH2tBIiL3T2ilirwGAVJpMJplnIZqLRT4dn0FlauVBGmmnzDztaNqvBT+08bVJrdoHK6QDLA++up0+9iaIEpsvycCuaHpdpc9yP+7Rf4de6U2VEAeRE6LTvL2QkNwmqjsRm4Ny2Ar/N707YnB48MgdEm04D4QkCIIgCILgPt8+7VkQV32VtgAAAABJRU5ErkJggg==";

// assets/classifications/coffeescript-black.png
var coffeescript_black_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAKWSURBVHgB7ZiLkdMwEIZ/aIBQwakD3AGmg9CBOiAdxFQAVOCjglwHhgoOKrCpINdB0J7X47VOlmXHj9yMvpl/YluytC8piYBIJBKJRLZnZ5QYpXztatdGuVFpdDa6sOi+4HaFjUjQGlYKKW4nB47oGu4TvbvHQqRwR5mgSD70tJFBZJg0lBzKHGMqft706ZtvEjTYN9Tl0MeBJ9ZsHBlPGSjQdaDgdvDn0THWXvRP4bfrhBFleOJBHwf6ZXCXCTmYO4xqslTyHNRHOv59YD6FNjhBPKJbu8rTl6JEEdWsBP3loYzuefxmTdE1OZDCT4o2EEMB7kxo1zhF4cCGrgEFI0Vd4nLDONs2vAkYTKOuaWU9fzL6w/rHn08sWNdDxjZKeJ47vk4cc/5Anb2QsZ9JrXsalLJBWQndTq/VmedzlV2ndH0ZoZffGX01qhztCm3U7vh+Z8mHzFgl7v+im20bGvcLasc+IQCN7trQ2O6b17VWctnBlxGFerHbUJQqo9/iusJ87NBm+wParNsZ/gzxZTy02Ie2XUmz2Ikq8J1dj0J4jxELntbJ5QZV2Ia+hZ8H3CY/7QdDjnzEbfJrTGfa4l5FWflIxIsZsKqhQ9IYQYmu9xmwusEulRiBxkvvaUtc62fJbNkoxItKPD8AqxnsUo6RnHscsZ1cu6QURiIH2FttCtuUmMYEpKGuv51rl1iOiZzEIOSUcvQpgEWNv6qkGlJrMPpvbP+QU1inxPa4EvvHoisyGYDLgsoxE7YzlIEjuqeIS2ZFYUYotSfL4ALtLpIBizgRfNQzFwrLOKKxAfd45dmQZHh5mDdFBWY+wJ6CQl0S8qg1RLT+aB2muIKQk8YpKLSnhq4IV2jPripEIpFIJLIx/wFKF8Q4XL9q0wAAAABJRU5ErkJggg==";

// assets/classifications/erlang.png
var erlang_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAALISURBVHgB7ZhNUtswFMf/sq00UxalJ6h7goaPznQZbkA2ZbKinAA4AeQEtDegKyawgBuQ7rqANr2Bj5DuMrGlV4kyNDiWbalpE2b0m8nY8/SR97eepCcBHo/H4/F4PEsHyxv6fIPyNslYrzu5OYYD5ytvW5iIFguDJEOUdMdfE1hyFm22A0bXeftOevvgf6UQBjZ4n95swZJ+Y2MbhBP1Gj/uD6ci5D1bQcqvU/XYnbZNCwmqOhBhtgdLLqL1IyXiEjkRGvWVPgQivb5EaxUWyFAcl5WXCtFfrzseJrDgornZVqF4XFEtTnl4Agu0H8qfgam8VIgIRQ+WkKCjWvWAbdtRUa0+m0qMQvTcsB0N7ZhysF2z+mq6wmNYwFN5ZSqLTAUC0qi+DEms9sLQ5GkCCzoYjvpYV21YnC8zCkEoB0hhhf4jZOY4nmEEexj7ouIyzpuLQ4shsQ2r/wVRsfxCIYxYgiWFMVZfiAT9wBOjeEQMqpeZCHPknKu8CqKFfwhJejObWM1ZCDFS+RWrtSE6w4rNlbnWU6F4joBewQFGMsGCMKxaeAkHBAUJFoRhH8EbONDMsiEWhGmOxPaZ6X2KAkowD1R2cferiXGyp5xvwwUKnJLNPJKotzO5fa025706gkpWLbkLBxpZ9hF/yd2BLv12qt/1s44goxB9rnANL5XYfYIrylm+Ig7z5ipBpfvIpBEdwIFnmTpfW8T3A6qNDMRWZzQ0p0hhYwCaNZdviET7rqOiHbISQ7hqPBdrVceHQEz2gbrnkT+sTnjklHJoh+7EAOWTX4+CCped7LZTOhL4fbGhGhwUd5Oj6IJO1eqo+DSel6s4a7ZiiKCt7gFaAQteaJsk+ZOIXXWzm0G9Pt7F+hoJU6NhdUF3z0iGfM3llnBe9PnmdxV/jzLraSEz2a/58mCMRaHn6ZhwaEx9PR6Px+PxeJaTX1SrFRf+V9jPAAAAAElFTkSuQmCC";

// assets/classifications/haskell.png
var haskell_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAANwSURBVHgB7Vkxb9NAFH53KaFjRsZ064TaDVVCuCogtvoPADEVEiMeGNolzgCVACnthoTauuIH1BuopdSoasVGYepGfkLYStv4eC9xwGnuHF/iRIrkT4p89nt3vu/ed+/uHIAMGTJkyJChf7Dozd25pR0GwpR7spO9o41ZKpbMV88DgKq8SahzYLOut1yDEYJHby7zDYs6IvUUYub+3BOHiq63ssaA+SBHQQBswYjRQcT33XqQY5bKGTtYvjf3dIbKGEolaQHCeIhRgxGCX32wf7jhCWCesgYLmqNN0sHKFaUbki6Zq0UYEbjs4ThKTEpkHCXGVYZxkxiPM46TxGKJjJPEeC+HcZEYS+JkGKXCtXP+C4sFRSOV3eNNh8qPzdUDioDcj/nb3vI8lavmGwNDVYZ+wS4tO7J7SESEsHB7yeQNsaP2yM3uHb8/oVEPQHwHBWmUo/0B5xSVq4tvD3CuGdAP+OVUlEhPabUxFImxCwsf1CEFJCZCSDuLNUeUqUnrQIvIMLKY7b1Yw521DwNCiwhhWBJjeEzAKNaS/iTt6WMYWWxQaEeEMHk2SQQKKjtKrEbXkunQfCiq/dJbKCegDzT4+YHSyMDdO9p0qSggj+uEKEIMQol57RNl1XyNc4wVoCcmTmzP/jcHtYlgZiqrRhk7VePXgua8wM4ZuJ4kGe12FgslxgwIlMfo/+BnUxBJJlrSenDrWRFf6qjsaKt88t0aSSrQ2CimkcW0iPSU1HFySXVXH2yhTEyEJAUxkspFJIWRUUoKM5WrMA20UCYikp6kxDqmW0u16g8isUSTPY0sRVFjcOGEZQvJSzeWHVmMJBbkDfmLJ+tX6sUjzFIOKDrH88F8KxrNLKUkjB/t5rFzfvv+kfnSwRbK8nb1F8pcnJEkFbCGF+Ni7x5u+S1JTXwE5SJJklp5F33y4/SLPzO9QF81b0gqFG9OL/z+ebr/DRIido6kkaWaUQsl1W1jNiib1ztRKomkmKUs13OkqbQlNbGuqKr10UJKJM0sFZ0X8g5cOLLdbOs9yfdiUiLDllQUFK3w7KJ4XTKJdREZhaSuIozatsKcSGIdREYpqe6OnNOg9P1drGNBbLA/DjDuSxsT4uvnUFIA103WPHPItM1QKmcOaIKih38gVfD0uSizY4Tv4GUNMmTIkCFDhiHgL48kFDQ+kghYAAAAAElFTkSuQmCC";

// assets/classifications/lua.png
var lua_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAVdSURBVHgB7Vm/b+M2FH69Fmh7kwIU6G2RpzZTnOluO2Vqt3OnjnGm9ibbYyfLW29KMmaK/RecPRRopshbOxRRthxQwMrUZijipWgOKJB7H0XpJIqSKEsObsgH0KTJR4qP7wcfSaIHPGAt+IjWBNd1bZkHMm9zZnHyubykhvGIGgJPzkqUDznrcrITJCiDmU6CzokYzhm1y+mM0x2nG1lu6yhrS4Qn0pcT9Lg8rtjXoZDhKZenSusQPzldB9x0mKxogpE2J58agJSq7bpiYU4KSKGaO9wjiCoqqxZUgdNB4n8jTMixMEHn8WPqlZCC4W6y4hOq9iGsVF8mkx6W/Gj0PyjtIexLqFUZUrbSsNdyo5V6zsmhFBMxfJnmTD/OGWdBaUehw4zpYsdhJJHRaNS7u7ub5LtNYbRYRad8NLGSSF258h4+oUjrgsoZSTmHUhvhyXeYiQ09E5CAsBd2i0ZMqLAplOBZ6GrfD1zSL1ClaWTszISrqbX555yM7aUQNgkv5Z7IxYHqfUehd1IRcNpVK1e0EWH0kIJFK8KyPqN2+0uR+/41BUE8Zz+cKDRALBbsYFu2QeXGYVsauYzIzUoTTojBwYRNK6LXe8bjPxdMRJhOL2kwOI0YSjBjhiLV6mmYgARqMTEcOnR4+E2KCaDT+ZrOzvaiekhc64Jhs7r6RznEXc6OdPOgGkzYtiUkYdjel94wQ6brW8FGhEotqAYgCahVEZbLW9rYeBX9Dfi7LTJAlRDFpZpQ1cmAxlbcci4yjEi1Umtt/tmjmsBqr0CT+S7sRDqjGDqJOIZ1lTGdvjGguaTstzNnFni1VKylYyTQ1NWWBuB5AR0d/ZbbDtc7Gs11TSlPJU+dqT3M0NhxOkt3xGa2XL5NbmTGgFYMh2nvBSb392d544251z4VwIARsXfcqLWLRY8mE58nNadVAFfbbj+RO/vfIhWAVcndKSJIqZY87TkKzcphSBGw8rCH8dgvY0I7B3nEjqGG8W1qCFhxeKCkF1LrIA3H2RQ56jzvysiz6eaqGntA+oizMhBudDpf5daBqfPzH+jkpEN7e206OPhW/M/Za5ZldSmJsLi8LD08hEtNo99/KvJW60hIAQwsFn3qdrc5AvhdJc8woqqW6c4eUMOAk9jZOU6p0nL5X55ELqgEhjs7reaaStDrPaXXr78XHhAJ6pYDT61Q52m6s3vUACzr87iMALLbbdNs9oZ2dyciUMRekoPUlZPGs2oZ8eW1TxJTqukEsNqW9Wn8/8WLLd7FPeF+o00wRyIzzTWSuNlMVmRuUeS9rVqLYyfOJ6nDDg5Dm5sbKUro/GDwq5gcDlHIofdROYLv/yVC+qgdZeTb208EQwnaQ5M5fkzGcCDeHzkJa2y1LLq5eZuhur39n05P/6T5/ErQwLViB3/58he6vv6XLi//EZNE+9bWF3E7Yqzj4z/E4lxcxGd41gT3lcnstCGKvCF3spfSwuUd0P2hpaoVjNzVXJbnHXUDChlRlFaIdEL3g4GGCZtyjrpF+8iY9CELpOLTejEi0tmq8KhjXYdV77Wi25TGYrMEwIRLFVFq7HDFjuPcep6XiOZQ9o55geCynlEzgHX/xF/82WwOaZiEKPjASdZexCegZjjwBFQPHoUPNzpXa3M2dEveHU0usQMS4s5TI3gQcWUDhqrajkfhjeIu5b+dOHLsQjT8PgLE97U4y4qntEQjGL2S+bTKlWjjgA/XxTpNAu8xapi+FrghHFoD5Ngdum/Ix1GbakC+t1tUA5UeQ4vngkd9GpR5F6WTQ+GLVUA1N9k1GHs8QajHJqd9MCfrcNGHvacvveEDHvCh4x2Z4ijqcdSNfwAAAABJRU5ErkJggg==";

// assets/classifications/markdown-white.png
var markdown_white_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAHOSURBVHgB7ZiBccIwDEVFrwOwQT0CbEA3SCconQCYoGECygTQCegGZIOyQTJCN3AlsDmjksSGXOL09O50cWzZ548txQZAEARBEAQhfrTWCdpex8032rRKxFT3i8TO/YFpmUG/OM934NaSROgZA4SeD/BPECGx8Rjgu0A7OO8bNFXhv0b7ct4pMJMK/0+0bcD45dSkugnznVT45lfG3taMnzL/XHtg/W/eWpgsMnwsrzT9oD1Dy9wVIygmxUfGqhdYX0DLNBHsb2iFKa9RxBY64CYhJj5GVDa//lEMlueuD7TIPSuyw8kOqWDiZWwb9OlA9w4tEpJ+OQpOKfKFXlAMBTmJoHoSUdT0XzKfA2undD903il9j8AH7Zl+9WXqnbMxclO/Z/U8/eZGtM+8ZmWTsj5NBPvKxgs+aSWUZz/yO2/PMszYH1BDU0eUnVmZFMKgSW7KGs2K7cGDpoQotBXcBt1I//R1RAx9Bonl0Dg32/KI2W4kQvkOENPpN0UBr6YcfGAMSb+Jk2WUh7/Sl38QPHn0ocxGJ+QEApGrbmyIkNjgQjLoF5kt8GCnL633R6hj6JA6tpe4AW81KTYFv3TZFQXasoubqCAIgiAIbfALrIXK9ZfS3fwAAAAASUVORK5CYII=";

// assets/classifications/markdown-black.png
var markdown_black_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAJISURBVHgB7ZiPVcIwEMYvwQFYwDYj6Aa6QZ1AmUCYQJhAmUCcQDfQERwh1AVcwMbv2gZihZICr7a+/N7jkT/XJl97uVxKFAgEAoFAINA5RLXh9FQlUppbY+iCusu7MWL+8aEXtuGHEIi4EcI8Uk+AmCuIeeGydDsg4pZ6BHvOqlzpO6Me4bq/pH9CENI1TvxNxURKerc1Y8wjfFRttzdzKeWLY88hPamxf4L9wtayLI+eijzxFsIitNZvtq6UGmFyr5tshSC9XKZjty2K1A0mSzUjaPf+URRTE/Z2rWJQMau2Q8SnEOKSWuagNZKmeoqJv7ltEDHhR0stc/Bix8RH7EpFzcyhYUF/wF5CsD4u8Ms3T376VkyartcF21CL7P1GEFWeMdkhl3m9QMy57eOcDYHgjlqkQfj9heIQjP8rrkDMZ94IIJJF6LqLpRSzr6+1zWCwDu1l/wT9w3U9D99bU6hDhHCukyCsjrHoH2wbRHBIVrRDCOyuBwNxuS0woHm1B2GMWhHMEXZ2c2/XCwbkN6E8L1Sue241yu9tHnbc6zgpCk+I3wwGnFIzzkr33Ejppq/kwbFyLcVvhvagcM/o17WOiKHPfTqSNIoxxKyiHLubs9a86FD2K6YQcM2l0t1Uk6u9o1aWZQn2B1WUvQZRvJ/YCo7RsTG7xjCLOI6T+ix5Mz8+PiDjNNQz0nSZawgnxK7xP4VUzxZdx51vRYiY8AmPekB5Eh2t6lWDYkfNcPKTzQ7NLYLwrPENYfYXJ9FAIBAIBAJt8A09lOdCQTlsTgAAAABJRU5ErkJggg==";

// assets/classifications/matlab.png
var matlab_default = "data:image/png;base64,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";

// assets/classifications/objective-c.png
var objective_c_default = "data:image/png;base64,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";

// assets/classifications/c.png
var c_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAYfSURBVHgB7ZpbTBRXGMf/sxcXFlBUqOJa3bS1gm2sUURbg0JtbaV9EB9bGzGtpt4KmPShaRvlwb70AbDGJj6UNUVjbOulibc0DVCbBuslWXpxKUgXZVmRXWDZG+xtes7gGrrMzpzZy4MJv2QzszPn7M5v5/u+M3NmgWmmSQsc0si2PW3VnIqv4XmMRHi+8dSxchPSRFpEtu1rKePBNXE8jJO38xysHPja5qPl55FiUipCBcjRHiSrZVLteMCk1fJ1poZyK1JESkSqalpyg0E0cOC2K+mXSqGkRKhAKKCqBsfXkLe5SAAh3CKcqfnYhjokQcIi7+xpqVJxXD0SFIiFCvERvi7RgqBYhDUPEuVRQdhBCkKrkn7MIlUfthhDaq4JDAJ5c3Uoem62sMyfmwGfLwSvP4R7fV4MDvmFpRxK80dWhOZBOKg6yEPIg7jo9Rq8UWbA+jXziUCGVFM4hsbwS/sDXLs+AIdzTLItqxAnJcCSyFGBN8sXQp+pgVLOXrLi3KVeyTY03BDmG09+Xd4Qr42oCA2joIZriR3QYqG/fO2uF7HIkIVkoGfocKNZ/uwQIafDX37l9GZr7D6VWAeaCywSn1avSFpC+Kw59LNekgzJMX8Q9v4R48jIqOhZUSGRL34kkTdHh1QRTyYUiqDfPgIbefmJDDjVLLH+CYmkWiIKland+QKySK5FIjyGh7243zc0ISCD4uzcWrGYWYLG/ODQRNzTQrB4YbZsn0WkTcFTM/Bn2wNBhhVFIvS0V1YYZdtdI6X1aqsNvX2eKf23bl6M0rXzRfvd7hjEN6f+FpZKUSSyfs08yf0+Mug1HP8Ld7pGRPfTM3S8uRO3OpzY9d7Sx+XaPuDD4fobCQlEUSRSurZAcj89yHgSk7nV4SDCIez/YBnOnO8SXm6vfB5IwSxCY1cqN2g43TI7wEr7TTvafrUmLRCFWSRfJsHPXpYenaPQ8eChw41gMIxUouiMxOOezSM7KtPx4OHgKFMpTQRmEanrKC+5uo0HLaEulw9Op4eMZQkNW0ykRCQeAwMOPOh3QK3VIVMvP4YkA/PROYbih05+zGWF201G5F47uQ/xC++D5IY+MO5HRmY2dBmZSAfsIs7xuPvopQXNoe67w/i3574gEkskHIbP4yLJ7kmLEHPQ3umWHh/WrcpFh9kiKjGZqJDbNYQsvfJwjQezCK1KUmel4vVnUbLSAFY2rFuIn77fgs8OFKNgXvK3AorKyLXrdsn9R7+swMYNz0COklUGfPH5RmG94jUjfmjajPffXZaUkFps4/KSqiqyMMZu7yWTBhtLF0CrFffX6TSo2LQEhgUzYekaJGEW+N/+wufzcGDvK/jkQKnQdjIrl+dj/csGeLwBdPW4IIG1r/u7E7EbmYM0TAa0zs57aGrWYu/OEsm2lW8VCi/LPw6MuifC0VCQIwhKUTBPT0JtNbTqIM5cuKuoIDCJ0PHAbntIRucwTpz24FUSPkXk15WjkKFNLDa7G6aTt4V1WuH02bNIBMyQ7SeZI7QC/WHuFMYEKjGxbRz7P74IW/8oUg2V2L777OP3tMJ5SHXzkipH16UQFfH6/K7OOz2gr/HxQJwvPJdSmaiErd89ZV9gzA/X8KAgFA6FrGL9RZMdGcXtgfHQFnKnH3c+y+0J4Oe2HqFKzcxJ7v6d5tKumh9FJSYTCgfNgaB7t6Pv6pRBTXKmsXD1kSrS4iCZUDJKtdtHkl+uAIhBC8G3p80k78xCyMaDzAWTJ16qus6b+5RN0E3GuKI+N0OjqRGEJKBVqfLtImwh1UquOtGQPH/RwiTA81zjWHaowdpaK3lpwTyJXbi23oiw5hBZlX2YQ6sVlSlakoccEnY52ToyNzUq5MHvt/tkQ+jRoZmgDtZZ2mutDI2VP1agQnxYc450XIG0wLWC5+ssN/e3KuqFBGHNH/Yj4a2IcDuUCjzujiRZWnykhlOhOlGhaB4QgUNIAjWSxNl/uT3v6U0XwKtmQ2G4kXnExrGscGX3b9VXkCQpfTzNXhBIHqiDO1gTmYW0/GGgsPirMqj4pqnhllgis5DWv3DQgsBDVU2+hIwBkROWGx+ZMM00Txb/AbB6vsCg96grAAAAAElFTkSuQmCC";

// assets/classifications/cpp.png
var cpp_default = "data:image/png;base64,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";

// assets/classifications/c-sharp.png
var c_sharp_default = "data:image/png;base64,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";

// assets/classifications/css.png
var css_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAQoSURBVHgB7ZnLTxNBGMC/2dYK8mhLYxWiQAwmHooQw8GEAxDDhQtX/gATPRg1HpDEC0f04MmDZy96xINeDBEOJh5NiCckblsTE0Jwl0fotuyMM9W2s7vdmdl2QRL7Szbp7OzuzPecb6YALVq0+C9Aok5tfuUhQWgWTgGI2Gv42fSiX38UxK+PIiCTcBpAmi7q1kAI0eG0QCAr6hZaBBHQidD51EDpXmgE8msboFSqNA3RsxLXConuODSEuVP9iSXeIXQtm4j98tipWYPOlAgtIo6RKOjwL8G49luLNiFIQeyXx8pRydmOiZUqDWXt8Qrx65u5GofMhXMgo73vkvSZtZ8WvYq1G5YFJP+92sRPbwnnqhDsSKf5Y7BeDxNifvwiyEgmu6TPPPqMHYIQbPPduux9TfYAzd++7mUWbAgLw3IZngt0UlamGKkghGDfhWjXCk+Q7L7rWzjYt6WuhZBmMJ3UI2da8Cm3L/sEdBU6PPdGUmcgERO4PZexaJmkExCjECP+CxETYja3ATLQUMRz7+h2n6NtFF0W4NcQSXnCkMcInEwKNosunTvTr3QOUkEQCV+QgU6vhfQ9u6k5SF2LlSkaYFDlcjzmHaTLOUw9QTxwFrEjWJc9Lo8RVqbIIo3jxcwAjPd3Ou4lk0nhO0axjqIcdVa0edc6CQx3fLhTLw4hRmBpSocA5HeLEJSsOz4wDjwHRYvIV9YwIaVgGYsR+sbq3rts+eJBQ9cc7fuZTnh+s7va9sQIZxECalsJJYuofkwV94ruEcTmXQ2FZxHEVlafauLuWBrujJ2vtt9vmPBk5Yfoc1QQp/5MS7QYYhMUUHMt5O+n3W0Rx9rB2jLiMos46ixNV8n+asFO/PfLedOZpTLpdogLhEmcRTCaci6aHkEcdRYJ1bWUj4WGqSCbD67Dm/Ud6mZG2dXY5Ed6YjTIO2Ci96w3Riz/dYSNDQoouhbTSn1J/DZXc8M95Yv1J1IpYcluelyr9k2V8oSh5Fo2ieh+fXm6JxHB3Ey474A6K3upBEFRs0iEBrtPxK1vHcKNl1/L9dVcJuWps/xg+/O3egFefTuo41q8haI6KKB8ICo6TeHppxnMLVSlaBROvgJNvUTfrDZlpycVgqzsLHskZA/laBbL0UB/Ta+KUOkrEfHkeWzsHlOJAIKwFZZIBeGpCIUO08rvuI6BlAVRLuPDLlM832cuZdBD6+0tbkz1YlXZIqIypSFoQBOrAHBAT2EO9nwylVp5wlAWhA77hcoxQa9BaBCmddjf+zN5JgT230JTDzDo337LoEhwHS98mNSwNkkHmVD+Wy7RI9B6DepKqwjR/woBVmFpehUC0JyzLHwcpGqlgpG/ggWzFtM6fWcZI1iDNm0ZFqcaPrEJ0+uVrNWM1kWEKwgPZy167krC0HqLFi1awG+IdMFOp/EA8wAAAABJRU5ErkJggg==";

// assets/classifications/go.png
var go_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAM4SURBVHgB7ZdNTttAFMf/4wQ1RaLyDRqWoYvCCZqeoEEUqq4gJwBOQDgB4QTQVVWSKukJGk6QdNE4O8wJarVFpErt6XtOCtgeO9gJC6T5SSB/TN68N+/TgEaj0Wg0Go1Go3lkCDwEJxcmFq/LEMKc7GLjd6GH6rKDB2J+hrDyz4a7kCjTXTlm1SlGOMT7kp0oq2GVYWB7Iqt481yKHqR3DlfUwzLmYwhvLHAS2DQeG67cx7uVduRNa7AL16uRWuZUKQI1bJQOb29n5bN1QCdXQ1o8bw1bL3r+NXtzaXhEVztIgyAPb5SqfGlgFvgEsxjh72y0bq6X/rA3d5AWSb9pDPgAFB7hE54WIj8L+ygMTSzIbkwYdCDlF4ppB0KalPS7SpmuXEdevEw4jLEcX1PjFWleUa4aYTloSKtrYlSoIAkpHT++G/1TUnA7+p6SebNUizxvDsgDchUeK0ZJe1Vojw8DF1AZMEI1UhT8XJStyOF58ljg7Psq+XkV92WrdIqPVlGpQJwRcagOw8M32iNen4ZVozg6CO4renlyWYUy5XlI2KVaihz3gQW5p4hKO2DEp34FOT+kkihHnrhIjoj8sA63EDSEwjcfe4JcScxh0IXO00lDo7iOYHQCtznBSVhEOjpTe8z6moNm3wmHV165mHPlL1se8tTi9TH9bysVlN6tF8+sHaQ3ghPanrqGdXNDOUJFRW0IW522HEp5K1xwdXmY6ccvRpGm4V1m263Rb1OSvgk97eBt6XXsb5oWF4ciEqFy/evJcuxMNi4yXyNyPFQzNkTRUzwsT3pQEM61pqUaX+yoCMnz2hFUxBnBcqiSZvOIH6eFHzFvbQqzY78Z5ijHpB+ixcgqamKkGBtYjpXBB+ZxQ8V4iFQ1X/JGdkOYZr9OgqeVVzX/+w33MMPoIit3+tZsGdkcdP1unXFzn0Z/j/LtCGkJyZltaMxdU3JzCNxrZ5q7KAzCfWtzpU5htH/TbO8jh9eH5Mzxe4TDTDnU0eCHc/pCrCd+IXIy58HjBw2HyupGeYMPcXLmX+w57oVhUoN0cLVoZ/q89XNHFOEJ0/9MztPf+pSOr9FoNBqNRqPRaB4b/wCCQTSOvNHp2wAAAABJRU5ErkJggg==";

// assets/classifications/html.png
var html_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAO2SURBVHgB7ZlNT9RAHMaf7m40rEGXtxDlJZCY6E28iok9ewD0xqeQk1w9magHD34Bbx4tMep1SfTgCaMeTPRQIEJCQFdQF2HbcWZJ2c50OzNtB9jE/pImOzvT7Tz9PzPzn1kgJyfnv8CSVa7NYI62mEYHQAgWhxzci6svSW8GJqhSGx1AoQBXWg85LjoE38eyrF4aEarSJchOpRep2NkGvMbBZ+qMmqytVIgpuspIxa+d1meCDNZqnLC1gmgwfEVEpEJKJyyEhHxtZRGyq7j5KPE8vryveKnSdYSxdgux471waZJe16FiYLBL2QZfq8CX6mFxfw/Y3GhVX3gu76vOYHfpNdauwuofRWl6Hkp6etRtXoMTQkikD1JU6wjjeOxV5x8jWMuFAqUQ+mJiFyLy5yeMIQjxPSRCbS1CIxLnzjZC/M9vou0GuqHk23v+seEZy1JHRHeMtEcQwiK092gq2m4YiQlbS5WeMJTWks3fpL7Nty2fgykaDb0+BGQS0rZ93yhM42v0QWktlqYUY+rI5krkO6t/BBCXnr64Xwix5XLFsLUIDIyRUsIM+NTdF9EvVesIm7Hm+TaeaWupIFsryIww9RKfry6aEHLeOYbE8bvLFX2SvA+6EXHjKtqNk6yEbQXNySbzxmrv4ZS6kbiO2HPA7cetsrAe+by1XGiQOSKp6Krw5foPrigkjOYiQn942YpJU0qz91G8evOw7L19hsbCA0iJCOEjwlmLQCuh0xNC34olqQwvgloLYkSIkDCGrOWbtJZ0Hhf8zfYoVvlsbHOUqYjhK/x3khTeMmkt2bGQuI6wXePpJ27TYv7SS3hLrw46PzRBB/kd4KKdKCJEMyJaQuh+uZZ0eitOzjavEotYbyXa+TAGhGhZqyBbR1Y+QkYzI5aJYIjWaiAxWi+apQhx1vJXP+Hv/ETTUsVrsyhcVh9GNGGHDR8WgHdPoykK4TroQgPlKUqA7DSF+0E62EVRPUHSKOl8ABvoG+utsur0JCCJ9dmTK6pGLGXx2EUHeyAK44PSzocR9uraeyHjQsIEotQb1dA9KVZ1RpI03sURwgb4b3povV1L90ztiMjSlDSwPcc+ndd36bnsbj1mptJMTxjaQqgGdl5zAzGnjjqwzrJOs84zEeIGSqBGqx3o9y8ZqzOwqR9tGh0myta550y35K3zVNl/hVRAdcRBFQnIZJb1mWZ0bL8lbAzJqNH7HM/HIg2QM+6kP5416HrtaKV+6zKMCgkTjhb9R5aYeOs5OTk5+Af4FnG5qOs16gAAAABJRU5ErkJggg==";

// assets/classifications/java.png
var java_default = "data:image/png;base64,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";

// assets/classifications/javascript.png
var javascript_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAJDSURBVHgB7Zm9M/RQFMafa7TvO7Q0dEaDgtHZHaNf/gC7ag2djwIFo7PNai1qY9XGV2co2MboaGjt0LvyTESSXYlcsZtr3d9MZpPcZJMn5zznns0CBoPB8JsQQQPyBnnrow860YJr0YPZz4ZaQ06jiBR04jV4qAVNghGiG0aIbhghumGE6IYRohtGiG40jZBW1JH7B3e97Z+1/A8+Lmw8CnWLCG+ue0x8LAfHteOz6wLtw/a487lSEN+6XiKpRRHpnEB+B6g8+/cvF4CBCeHbH4VEhEwtCl/adXVKX1pd3wIHR1Ci4UIqL8Dphbu9NC1xdwg8nUvMTEpLFHBSlMiOQ4nGC6lKmYEed31pGrjak0gNQZmGC+ET96bRcsFNsziVKxGP9HuiQD+wWk0t+H2jSiJCtlZtL3gpluIJSkSIY+hcRtaMURDLLyOlQmItCsVsrcGqWLWCWNnSWbW5JPFeyysoM+rup5jtUvTv+TEhKhclbEW8T9wW5I/M/SMiE7tp5OTmzNRcshnbyNslf8/E0krKVu7nFmwPVJ4FNubdm1dtS7zEFrKy6VYZ9kmcFzgXVN9U33vJZX/lGDm/az2IS4HcuC2muO8XnxpEZML+VjhBhLfxTgMYVjJpZvqAMPdZlb4qsYwqfVPFqehF+rPjY3vEKaXV84JDakhiY87dZooFlV7vOTxGhdgR8UK/nF3aJu3qAEYGEdo3MSrsch1T8xymYMg5gRH5USENoH6ppQt/4OWDRBnf+/lcT8owGAyGpuAN79/EyYODhyMAAAAASUVORK5CYII=";

// assets/classifications/typescript.png
var typescript_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAJ6SURBVHgB7ZfPa9NgGMe/7aa0TKoFQTY6xHlQrLiDA3F48CC4P0Dr0ZN6nYjgSa96EHqVinerXjwpHt0UwYEFK162S8sGY2tpYLRsrFm+GRlN9mb50cH7rrwfCDR5kzTfPM/3eZ4AGo1Gc5RI+C2MPq0UgeQkVCJp/ll5deWxaGn4gKsmkTBvQiHMru97RxIDghaiGlqIamghqqGFqIYWohpaiGoMjJBh9MF49hii0mp3YXS2hWuZ1BBOppOoNbcQldhCxrPH8evZBUSlvNDEbLm+t387n8GDG6dxeSxlC3Gg2L/LHdSbm67z/egrIv3y7v5ZzFzKCNcoanpiBEY7hTBI88iTW2eEIoxO17Xf8klDL7Ejwj+Y/eAOeX40ZaeJA1Pj7fya65x6Yzf/C1OnXMeZcs8/r+z5J2+lGoVOnz+BMMQWYrS3Uf7ddB27bqVCrxA+lPccQn9x6+X1t1VXEahaL4FbaW4dYVC+/BohU0uKkJpVibwP+PHRuX1RioK0iJS+u73jlPNiIRdLkDwh8+vCxle4mo0lSJoQFos7b5bwY2lDuE5BTDdWrzBINTu9QjHs3KLoMCKfHk64Or4fSlQt9pBrL/8LBWXSQ7jn6TkilCq/FMQIecXkx9KB10oT4mdkplt5oYGoSBNCIxemsvsE0Q80ei+tdnBTlDb9UkDxbs7+zcrFcZ3MWGO919xf/hmB95M6xjtwXAdGhGv0zc/FjcB7yOsjnnFdRGluzZ6Iw3CoEalb1YZv0KHW2PQ99+KLqt3sclaK8evQ8Qr9wPu8t6bmsAMjOVQhtZCfpQ7OqP61GuyBIA4SUjHNBFQigW4FGo1GMxDsAMFM5II16/BzAAAAAElFTkSuQmCC";

// assets/classifications/dart.png
var dart_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAJdSURBVHgB7dhNaxNBAMbxZ6ab0CCFFa3iy2HrxZPSi3js1i+geBTEFdRr+gVCN3jzUryqkIr06Fcw6VkEUc82Bz1IPUYTot1xR6gszb7MzM5sJ7j/S142CfyYyezsAnV1df9FBIbye8yli5M2GFtlgEsYG0ZT2h3cbw1hIO2Qf4DoYCP+effo8YjQYHCn9RKa0wq5sTMK4oetNEAyExgtEP/V2Kc06sVPPdHv6MaUgnAAWWCb8fz3oZBOjBLE3xmtEkK3VAHJdGGkIH5v7JHGQUgIuQeN6cAIQ64+2Wv/nkxDskBdaK652AR1msG79jlljBDEDfreypVLe78mU3wbfoWxCAn2n60pYajIh5oO/TuVznjncda7AGMxtr38aFdp2hZC4tFwGWHB4WtbMYWQRgO3cOT8YCNGYGqRzbR3bcPkQpYf9gPknK1twhSMSPpoJLMFkwkpGo1kNmByRkTu7H3cmFTI6Qd9P37wIVkFmCDrUNaIbEAx45iMZiB8OxJvCm+iRMeBmYE0HITQUNWY2alVcjSSVYlJ+49o3aZXhUmDvIfmqsCkQNhTGMg0Zgay/3x9mzHWhYFMYlLPI99frIfzhsncoswbJnf3O0+YwgurQ8x49BO604kRuvnAMQ6lVo+MEIT3qXM5RBRZixGG8N7cXbIW40Ayjrn9+gdOnqCFl8GyrZy6iM9LGHz88GU37TghGGZ9V/lu/OO345AKXNPLFkWs27neCiGZ1NRK1rnWCiOYWZpVUobwbMKUgvBswZSG8GzASK9aWXFMvADEqwdZQ4lozspUV1dXhz8+geQ+r15A3wAAAABJRU5ErkJggg==";

// assets/classifications/scala.png
var scala_default = "data:image/png;base64,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";

// assets/classifications/sql.png
var sql_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAnZSURBVHgB7VkLcFTVGf7PuXezEZI0vAIk2bDJbpJdwCSblwPKI1SRp4hFkI48Sh9KsYOtdaw4HUCqOIqC1PKwWGXEitiCQE3I0BJAXqUhCZjHRvLYsGwEAaFCkn3dc/rdaDpMp4U8NumMk2/mzj33PO79v3P+1zmXqBe96MX/BVJKA/UgGIUI9fX14VduBMeqKpsoGI3Di7NJKokOe6KLegAqdRGlVWfHM0aLrvq08YqBlQopjyukPCpI7qUeRKeJfOqsSwuSeB3F8ZLoiEryZ4rmLxgxYoRfby+pqvmUMy0RRRf1ADh1AmVVtSkg8SFJsZVazUHeCBJ7zq+GXyx11hwFiQLOaBjjPJt6CJ0icmnB3O+37Mvf7bCnvAMev+CMxfRLtYx1pFr6CeKLYR9ukEvThJZLPYROGfu++PhcCHqUFOUDJsSh/pvfeshgtXxBYQOWSt+VlSRphqKIOULwP5NRGelITLxG3YxOey2QWQrbWIviIWKsP+NKmsFmIzVhmNdbXLxSXvy8KvqV1+aFZWadybQnP0/djC6534L4+BWMsdnGqKjcpuvXDWFSWjQpp6JpBch9BevxMUNYpAz4z6FfA4gXMynL4dnqpng8JyiE6HIcKTCZXoHA0ZPPn/9xflzcfLxwJUishtDVKK9AfV5+QsJwqGAM6hej72wMa0a7rm5OhbH3fJwXPdDQUE9dQJeJ5FutRtbS4oSQR3HdrTL23fvOnauDoAwkG2NiYhIuXL5sVTRtLdoHgUgVhkWoTU0LghER4/A8HfXTsFInMOZ1ED9InUBIIvu+uLjHJWMbIVA9hDnJhfiYDRiwU1y5Uo667ejyKFTrhUlu9yb0/QBuedf9bvf2tvH7hw61BxXlPRQdIFQVIJo73eM53QERQkNkl9kcHR4MVgqDYZTi94+VnE8AoQchVDSIuISijJrqcl0oMJvNpGlFAU0bYVSUbIE+WJGF6FOHvn/DqyZiQsro6yBbREbjk1Nqar5qjwydiiP/iZku1zXdsMnvN07yeN6FMDu5lKpOQjdurmnHoWYLmaYtx3OjgfMzcN+rMOafXlVNmux2Z7NAQB8XfT0q6rGEqKhUtF1iPt/pVvLtQMiSRniwg7itgID3IkDOxmznK8iA7/d4loBEDgQ7gPYIXMdA8EkI/4+2sXtiY/sYFKUCfZbARvLb6vNNpsUg/jSumZNuo2ohWREdsIGruK2D/o9vUdVcfHyGVNU/Id6sJCF2oM2IGV+DjrEQeIq86dsq579Fn103k9Axxe3eKBhbCFX9qNBkGnnL71OIgBU5AOEcUKnxeEyH0Jvxchfuf4GQXhB9cNL583fuHTAgTr3jjnXo04LnhftMpmUg9hDKWegvsToD+yDABjgfjfeNRN0AtN+LsgdER+NZdDeRRqjV76BWj2HWI7EiRRDmlwrnAgZ+AOnMhMkul+vf/ePi3kE/M4o5EPL3uhqC9ARImQChyjEhxRpR4zfOoqQ5IsI9u6Lixv/6fpf3IzoKY2PvgwCXOOcDQcYEQWoghJiGeALVKoV6bJkCEq2xJT5+LNrzMGwYZvpu3E+AvBfCloqWllVTL126QJ1ASFYEwhXidg8uBS+s9wuRBb0/DiM4i7o+ILeDOJ+Jthw1LX2w5jm/SXz55ftezstbPV4I0OUVKUhIWAA1ysXsvoHHKTDw6ViNMEMw+BlWYBaPjJSqyZQgKiqW+qEiMWvWrWZMHnPYko9QCNG1pFH38cHgYdLzK6LlUKEXoevTQCAdxr0/etWLE41Z2VulwTAHZM8xlV6SQcpC3ziHPfkJCiE67X4LLRaTHqVJz2ql3ISqqLAky+rwqQ808v79bUhHFhlHjQ6ofY3rM21WK1P4G1Kj5ej/AtSsL4UYnVKtj83mIZrPp/t83cOYYeS7+61ZO1VNS5vDSVnq2Lyhyel0RnoR3e9MslzUx2SkWHaWVdemSClGQg1jKcTo8IrsNplikckeAAE9QO3BlT7kr0VbDWnph7PsKTvhrHwQ+Oct3DAW+44SfUyZsyYPe/kahAmHJuCxGA2iEKNDK6Krk/D7DyjDzBFRjy++1hw39+G8PBYsFbSBc8Orep+Agf3QEKTDrbkSsYoS59mPUJ3EFGVJRnJiYYnzHFbDr1CI0W4ihVlZNjXBvCM8J2d/xOw5e0RQrL7LxoKnq+vGCKnFZqSad+n9cq1W9+nP6h8RQjuBmc9B1ZZwCs6zJVuv6+0i4LtDUamFQox2ETm+q8DMpe+QcWT6rzNSEt88NesRO2cyslUwKTbDQz2rl0uraxGl5VM4PZmB1XDh4O5tHET8pJnUpNLKs3sF1860bq5Itis17whu634rXa6hPq92TGiBZ7JG2PTkj4qLiw1KxHf0SP0uk5QJL1QEVZrISA4hzjbAi/UnwQc57JYnUOal1TXT8KUMJthPcR+Mz25z2CzzKIS47Yr4vdpvIOC2NhJnGhr6iWZ/riDmwSw8A8H1vUglrpUZ9uSDEFwpq66DYXM9DdGzYgFjvy40OVUy6cSYT1D9OYUYtyRSXe2Oa5a+H0BFPCXO2h/hZHFgsNn/BU4Rz4BcjpSsAVH64MC+xmdNJlOr3pc5a+fpBw+ZOLzWz4VRtRzq1kcjvjLHbskvrar5Iyf+CYUYt3S/zcKbDF0/IoUyhkk+qplp/XFGFSckr8RMv5ppt5pJsMbLTf7Kkuqa+UcQO6A6yxmXx+Fui6ByLyOZfC0j1XpPznDL13sNJsdo0nuGQoxbrghm8YoiRTx03dVWV1Jd+yuk2ONuyGCr6qBtWXFV7fs41tnSV6rrQKQfpH0YKclTGTZr4c3vO1ldnYQJueEYPryBQozbGntpVe0hyeXGzFTrdrja+QhyOBLlefp/j9L6+mjyBjNgJ0gc6XtCUhPntAd9JsNbeTixk5zxI0Hy1zNpvMyYtgh7DhVnxMsoxGgHkSozMUMRuu6GrSyG9b4MnY+UQtqgXqNg5KcksQ/hUlcpXHk+PSVxvT7uVFVNlqJQthT44cPYLP0QT6/ncMXpNnOXDuP+G26bojjsdhf+POVBkGx4pDAEuiypiQtQnZeiw/hgh806ASSmgdSbbSR0l8tBFiuXggmYiIrTmAT9HOt4d5DQ0aE0XlctTYrn4KlakI6v79PXUNTiDayC98phJFZzRbUKISZA8DSo0N+xEoeCinxbj/a68SMDfisjOWkbdQM6tR8pq6jLlTyI4MbH4DHpmzfpO70iBL0/yHB+5OZfCSXOulnIBJ7OSLXcRd2ELm91iyvPZkLIRKTyE6UkpOmyH+NsGMpuuNqrTDLETpYR1OSYnOHWcuomhOwU5WaADCsvr48JsMAQUngf4kpzZmpSh85ye9GLXvTi241/ARhyZLLPiUD8AAAAAElFTkSuQmCC";

// assets/classifications/perl.png
var perl_default = "data:image/png;base64,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";

// assets/classifications/php.png
var php_default = "data:image/png;base64,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";

// assets/classifications/python.png
var python_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAOaSURBVHgB7ZlNUhNBFMf/r4MQy01u4HAC8ADKpBS34gmMJ5BU+cGOZAdsxBMQTmBYCzVIuTfcYI4QFipozXu+mUHlY2Yyk25SVJnfJp3u6Um/fp/dAaZMmfJfQHBJJ2jgG1YMsadvvi8g7/KP8TGEQjamj41mCIe4EWQt8EhkhyB+hVk9JtN1JZC9ICqEEf6qrQaqE/Jd8wCd5hCWGFhiRFYxnhAxnvnOq3CAtSACLJx/hixoQ2S30nyiJThgBo4QQhebj3usbXqz3yBDz8rMU7/yBPZYa+Tvi3hs83KCM43o1q6bdwcLursNjSCltOESd4KkDt9ym5jKYy2I5o891UZY9EycGMvkGAnutK68XcOyGVDzNBw1dyIbWHtz0BKDnZzhkDcfz8cN+TyX7fdGOvTwZxcFlNPIauBhFou6tWM5tFDkW+0ZU0eCuRNqnm3nPVIsyOvAp5qsa43kJ9/HXosDxRusS9DoUXM4zB7OofZ2f8XUOKhYP90kag0/WnmD2YJo/aQZ9z1uH37eQKYgtSgxJQ8TQCNamHwGJfzPYCl/KAOGrGBCiPCHtFVfLPF4Q4K6lzWQKYjWSU4KuZEQd7H1pJ+uhFvlJkWZmrsetVb1lAe+sbopNiUNIIdMvIuN5cOkL0mE9KLkK2LNDa52XhfkTnXf0CzWF1ITOV9Yief/tYMZH8Y+sMxk/EolbRBFL3njaQ8VSQUwrQqa+DMzzOq1q7WE29FmKkTihCY5LcaVr4cbgzIT4kxGT4gSJx219YFsLSclg3ypv0DE2qYbP5NQ89cgq/+6IKcYYg4jEZIkbCaaiKQ3kfpTcJg3dD38bsc3GmmSKsSYdGcMdzApBMd5Q3m11h5GwUhtlcx9TAzKrX6zMztFfdw2GO2iA1a2RjQfxNc7uA3EfsHULDqLxOSGXxFpE9FHWC1C+oiPwmNR/pgbk59H4hpo7VMXYtYxLuqcGi57mACFCZE3ljt6NumBo0UtIy7niDpG39cSrchRfUQwkCE9OmvDEuvgrwsN1Hx8jE9IS2fzsMTZTWNpEudFnExDOMTlBd1oVAjyz5pJM5g9VHO1CyYXmKxGLv2asf5P5CL2GhE5Kf8sfDma3dHa7Fgr5VfnnU4EsheEqa+LKn9pLdRSk7rwHQM4wEnJahW5mObLJr0i3PhIdPocXO2fqjR68QMXQsQ4PUScX9X42lrUZLhwZThM/YnVlO71864+p0yZMqWQ314aQwrgmDAEAAAAAElFTkSuQmCC";

// assets/classifications/powershell.png
var powershell_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAATrSURBVHgB7ZhrTFxFFMfPueyWpQisbaVgqGxBFFp8RKQvtGmLWA1ttCaWYuKDfjAx0Q+tj0j54iOtb61JY7XaDxptsEk/aAOBFim1UBFjTFq72EJ4VFoEKksBy2vvHOdiWnf37p07dxfSL/f3YbN75pH9z5w558wA2NjY2NjY2ABa6ex85dgKVVFLETEHGDgCmsYNZif+OWE4IaHCP+aAFZAG+bhv1XcKDweaHbLjnS/W5auoNvBJ5hBJDqKoO4QZgtoCbeDf3IFmRXY8c8IHfAZrqzdbkH4F5ITs+DGVCO8TdUG+ULctiIPUxNnXyjelJdQm5Vox5M8XOYHCVRwszcbi7PnTvyuOdsGHJ3oi8Bs5kMAbOrnUjhCwXFH7k/ckw1URGjuLPPDE3ckwW/DNrw+1SQlBwkJR+8XhSZ1tz8ZbMT8tAWYDVXE2h9rMhbxQHcu38X5Rl6NtPtjX0htki3MqcPippZg53wUzClIvvLV6INRsKsQZ71zCfcv0LG2v6qDac4NBtiSXA6qezsWMeTMpBpvCWU2FMMB8kEDlyeWxA1460XU5yJ7udkH1M7mYlhQLM4JCx8OawRR8BCRhDGBzZSu19l8JsmtivudulhgnnX8N4X/Ya2AXw8+HBywwdMUPm77xUvdQcNWSc9NcqNycjQ7FUlUUit8/J9W6a7leql3MleSARbp947DhqzN0iYsKZG2mGz7emBmxEl6ZNcJrSyfDtQmFTDlj8iBC2i+NQSl3Mz8LTl1b81LgvYczIhJDDNqN2hTxQFwOUdDID/726g5dhn9+5c2wrSDNshhEVmvUJhSCCq6BKPmc55dXazt1Ynau98DCBCdYQVWw0ahNIISQGEXsWlfRisj1WW7d6p/nwcAXcoZM+Bt2PdBn1GgYDx3lx1Zp4TQaCjxJcKAkG5Pjg1f+SPsgbD3URpOqfF3JK/dGUbuhEMboIYiCHWsWYcXaW6Yr40DKuZvtbroAVuGzNIhkOwQDCyKpw9NvdMG+R7Nw9eKkIHsnD8mbvj5DZwfGIBIUhq0iBzEUwk/IkulrpQWKs+fBp1zEgrnBrrT/1z6qONIJl8csnYn/QZryx6c2iLqEFeIsr1+uMpK+UGjZ+o2idOQhNcg+PKHC6z900yfNFyEa+DWi2SgRXvsP4YxMxVztGiaDh7vSl4/fjstC7h7e/n+gpPIP0hJjtHDv6DTrE961kK0DCUruSobdxRnodgVPs/fnXnqzvhsSXTH8zBhXvWNTDPpHp8AMBFZl1iesEL4Xq0SD3LyK3fWgB8t4uRHI0Lgfyg6dm65+vdvu1QkMx8s1nbTnpDiKqQx/BxP0CbG8Trt8pxsNiHUoUFuWqxPxS88wrNj7G9Wc5TkibyHIiNB4Nj9FHFEQ+uDdolYwQSckBliBaIB227sz5YZrv3lQgI+aemjdF6ep2/ffo+LxrmGQ5afzI8LDyAPnSZBAt2xEMcLz0TE4Di1/jsCyRQnw1+gkPPddG98FX1Cf+nYfzxle0gKBiAmVwcFTA8I+PJ82yIQdnRAkuoMET8ITfgaF+09RFn+M6x2ZhCGD3FATcn+PFIWx0zKVkn5HAFeaDdLuGKHX2dkBu/xvFzXI9NQfdjR4Wb8eIH0m21W3I0yFLYrCtiAq2mv3DD9KSTFKxC4oKlT53y+qAxsbGxsbGxt5/gW3OamiCvVtEAAAAABJRU5ErkJggg==";

// assets/classifications/r.png
var r_default = "data:image/png;base64,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";

// assets/classifications/bash-white.png
var bash_white_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAKtSURBVHgB7ZmNUeMwEIWXmyuADk4lQAe+Co6rAF8Flw4SKiAdhFRAqMB0kFCBQwXQwWOFN2MjR4nkSJYY+GZ2ktiRpfU+afVD9M0XAYBiW7C9oKGW34oi8IMCww09Z5vy1zXbM9vlGcOff9n0Zy3384UbWEoE9Js/t/xHR+pOIlRSTnCDCraKbaO/O5YpxZn7WHJzRmR0K1GY0AC43Ez60NQWxahwpf/FgfmpDUgit46MKlcZeTz7SpxZR5NbCBl51DWJMlyHlJFHneHkJjLaiIwuKAG6XnGmHhQdLnQtUSgpAzpyK3wKKXFCUUaIQl6c5S3avKWMkMFm129mroXqVH3CZDd3Qzv5fO+zroVBGSBSqtGndn1AUkckCnewk78jnZyFT+mI5IsKbuTnCNqpjw95OYJ2kuhLz5GflAA0iXbBVlAggq/Zj4F2PV9QQEaLiERBJzJFERjFEXFCRyHaEmAsaen+EHUdM5YjheX6EwVi9M7e4YZtToFI6ciGbSW7kK90IknyCDUOrNDMbguK1X9CZ/Y9mVkvkKYYTi+zp5DWI0djy58lBSRlH7lk+832j2Ih4QumW0MWvU0NHF5EnSStLVusNbt+QTVkJ/HIf22j2da8YHNkyXZNcVHUJspfxj2dKLXsHixll+QCmsWOfmNB9ngt8tAS0+sRZVyboL9zclBWxypXCLSRbDYE0v86dewoYd852ZVV5As+biQPjo7RmEoaeyENNxu6Dx2ZGU4dgMShtVR0RZ5YGjeH22hVIfTWLdpzv4XPwzGMGoEPksxGKXmbOtxOx8zwI4yMXBGHVnA4iHH3IeEJLxzk5uCALl9QDqBzzLzn3iEZRT2PHAQs535oRjyTBVKcq/vQkVuFJlNPOg5UMWR0RhGRqPyhZqK4ZVvyWuSRvrHzBrxJGT586qY9AAAAAElFTkSuQmCC";

// assets/classifications/bash-black.png
var bash_black_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAQUSURBVHgB7VpdUuJAEO4G9gV4wDcFf+IJVk8gnkA9gXoC5QTACXRPIJ5APYHcQDyBsUpKq3yQfeBFJbNfk+APJMskmRBqa78qMYRMyDf99XRPN0T/MV9gSgiLi5aVzVKdSO3ibQl/No7bg0Gm+fRk22QYGTKMUskqlcur9WxW3TDT/Y8fvNnt3mPCeA9fxzh/J5/TPKNSsQ4qlbUX/D8TQn7XiKXweQvX3cn1ZAhGpLW8bFWVUjLLC8x8/PBgt6eNcUmoulLUcRyuJSE3bcisVyqrJ54VjikCMAkNjFcityAr6iCyj+ABjgoFdYdD7vd5vdu1TykCYL3GYMDrzJl13O8mqtxCS+tTRkxw5qaOjHSxsmLtOo46wWEP5PYSkZsJGelC7u8uBqtnsjjojNGSlikZ6ULuD4tse8v1tY7c/iotT0Z4aH7B2xq+oEMzBkhsYHW7kGMhF1puuMG+J6MDmgOM5CaTqz3IDVprL7r6nBWEhDyX3zLt6yPZrNOAnFqpBqkxyMPncpKv8VWx6EwsNjn/Ybz1+kp7NAcQAvm8c8Ssjt/ehsnnrVK8Nn5dABGynp9n79jj8BabM0ys9eX0Txpm0t+RozmEWKFQcE5BYl93zNwRkZgFAg1YIVTeNTdEvHhxAhJVioDUiXgykp1krLQnVSJLS9ZuJiNJIlsUE6kQcffzshpFk5EfjO/Zp2G0n8dhlQxiZhbxrHCNQ4sSwEyIeCTECpG3stMwE2mhvgV/SI6EYEY+EujUt2QIM3f2EVA2auLV2E4zNSKDAXX6fbp0q5DUo5hIJY7AGpePj/alZLf5vOz4VGz/SYXI+zvVymWrLskhGyqjpyGttuw8sVE6IINIzUdQVtqExFDy4UMygEAiceqwU7AhAbLXs3tSpUSJqQUy5xQTQUTsYpE2KBmU3B6JW0mccm3QamaPn/AlApOfK+VobzOjAE5u4bXqvR0vJtx6srsKGD1hQV8iKLtIdbGK/UKSNd6e9EXc2tlH5IcFuAb/qTqOs4XzOz7jbFeO3+FLxLZtqYZvY9NzFKaQrAkbD7qAQLggTR4vI/bANViqI+0FWKRBk/mZ7daEJxHo7LJEfi0kG7TO0P9kj45kskrf0nrpYPmm+j1JaWSlCyoaaoUjsUgupy4wgyWRwyOiMoWAdKQmz6pfNJxxnuKLjE4wHU6reoaKq6O+X9g2sz+RqUDQ5EPdRlKogChOJnJDm+y3bJQSajN/yChMNyxypuPKjaQaiBImN/1WkhF0LSLJpORhUYrnsVM2HblpEAklIz/EzrXEElhKpSt7H+FXDcO4IePjNlWNJY1f28zjv2qQ2DA5glsm+5GJ/KjmU25uY8Y9O2w7y1e2Tbe1h3elBCGE8NA7En9o6Ad0bprAP4c/MFbK2j4n8gAAAAAASUVORK5CYII=";

// assets/classifications/swift.png
var swift_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAPiSURBVHgB7ZlPSBRRHMe/s7tpm6aiZtkfsqhLYX8IijqtUFBRtFR0qIMGeet/h+pQ6q1DommXFPwDGSSZdrLIaLtknhKqkyaWViQquiqrqTu934yuq87b3XkzuyjMBxZ9++ax7/t+/968B1hYWFgsJ6RwD/ScWOdyyLZcGXIWdJCa2Y945yRMYAh21EqlaAr1UEghf46vL2ACCiGAzeZH2voBOOKnYAoSCqUyFPG7Ofw8mel2TKMRBjBdjIwc6TE8mr/FG2P3Iw8G8fttGPidhqkJB0xBQi6vy8Yfg2SYgMlisngdNsSAWTHTa/chWsRECEFihkY2A8cKEA1iJoT496UVvrgdwNX3gDMFZqJbiJSQNK9tz9gEPYzUFQPbXMDtz0BaFsxCtxB5zIv47IOB9nRfDxJO5S8SyGP6bw+zzEdWMbOAS42mWUbItab6epF6rzpgDV/Lc9auitg6461v1H827AHOlMAMhITQqo7UPQxM3s+sNFRyAyk3S+DYujPs+PFPr+ca+/MA13UYRTjYJ7u+YfRVJTKq25DgzlfEeSsKkP6gAasv3Ao5lp4lFw1AmcygixnKWr6WeiV4k/KLkHKjFP5RL4Yr7iPx/C2lHSpu/KPDcw0SYdAqhtPv6LNi+N7Vw3n4HNIevJhxu2Klvab8LTduKEnMw3XNkFVMqSPeJ/cx1fUV9rWbmJgG2BKTMNZUqbTJ9bRcbZFAErFxD0QxRQgF+8Cds4o1CErHKw8eDbTJ1chawZMnkYvIdkMUrpD0zEFINhmRooi5OyeGJho82bjsQ4qYVczlguvQPJzi+1SukBXOCaSzdwk9YkhEsJiFkLBklgToo4mBSh/StRzxk6aLITTdyiBhYyRaYjQZ6IYoEQU7iVmzO0Hx70gREtP5AaJEnLXs3u9I3rtFCVhusC6ARPRfOYKJ4C1JlNCXfl9eR5yvA6msVmRUqVsTniiq6tSXyGoIZayIOF0iXBT1v0g3qFsJ+/5cZWsyC63+bLWmeiEU0CSCxNRdhF70F0TfEPA0D2ief8REE6eVp4+hrLTLLWQV8creXKiu3GA3TIVE7NJf4Y1tUdpqgLIcwPNItZTI+HI2vmiL+rfTo35Pb486MX7YRBZhSQAeVq23u4ADueo7OQ8S3FarPh9sTaohHR72blIotCjcI1P5CthRB1wQhXaytLLB/v6rHehtDz+WxmiL8UjlyNHqMOksU4PeCCethYBFYnquFU0sIUsNvhAZP7D0GOZ1hLJIDZYaMn9O/PsRuhmS+VddMYfNhc2Je48Y9jJUvgz3zE2RucfnkdPNRNTyrtwsLCwslif/AQDcWngNZ6ZoAAAAAElFTkSuQmCC";

// assets/classifications/ruby.png
var ruby_default = "data:image/png;base64,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";

// assets/classifications/tex.png
var tex_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAASLSURBVHgB7VhvaFtVFD/nJs3a/GFT13W4fXDo6gdRhk7Yp5I/7WQI1QmWtkmrMueKoBM/xH+bG+paxM1/HW6Im11JUkjxi39wrkvqxDqHOEFBRUFBWHWKOJv3XtrkvXc8L0lriE2TLJFGfD/avHPuPb/k/nLPvffcAJgwYcKECRMmTJgwYeI/Btw6emmDKqx3QLWw2j6Kd9vOV0LxnlDWgZWOIvIrQdoilIGJnubpUjz3m7RKNCjHUICdCBMrqOl+K7NvQsCXoEqQngryoyIh8XvsF7xh+XMWsc/wNb3pEj/6S/FYxBAg3MU8Aw+9H8AZAcuMPyX7AQT4NOthny+SDCwV7x1N3M0iBnLx43G//XDG2vbq9yuSa6+7ohhRpOV3OewWnv45zWq/plicqxFm3ulEBS4DHdHUJi2VPssDbOT/aZSlm2M7Wy4Wxm07nmies4nzHLOe3WmLgFsnehyZVMRSH+ILK2cJaAsHzsb8jib4l+COSI8LwqGsRyNxv/O+whhPWDrOyyDXjl08G+PzfcueWvNotjpeAKJY1sN7feFEd36/LyQFFkQIOJwvIttUJxjvQg2t1gdZRMLwCcVBd4RWG3bHsd+u5nV9KBuJ38ra7FOFfCtUCc/YbCeCemUlHCRQY73OUGF7rLvxO084sQdBvAIE6wQqg9z8gNbkOMiztYYXgkqgDZzzXzVTyK1aiCBtL+/lm6EyGAMJLdYx6XcOe8OKh807WcxOb0hezSK2G32k64OTAdeZRccBdQck0SB28+bye9aF7bn2qY2y87lirKpnZAEEim6zX1tOqEWVaan+011NP3lC0iFEHFzgkL7v9V2YLsapnRCW8mEX/gI1wA1RsomU0pmvVgPYwY9YMU4dphZAS3p2LyFsyblfZV4Re7yhxEAxTt0JcYeT7QD6E4aNKE5YNb3dOO2zvTjUFk1uWIxXV0Lao7TSAvQamxYe/IWkqgZP9bt+RaJgJgBxVUNKH96/n/4x7urXSC6RuRbDjrC0qRyKjqDzOfJlYbuWUp7n99lo2AL0Rz9hEYYd8zvDXJ5s5Y/o55S7/Uyr/Ag3v5jPrV6IUa1R5s+uAX5RFoUy58jK/DbP2Fwv6uqujENw9LTfFc3vd6EjKJFyG5stSPiML5Q4GQu4vp7vr4vUcr9F64Wu5u5E+EMK008Wxrzdixe5eA3mXAeh5Yh7khYmopbb7xx/lQPlBGpg+fs84LJARJRhntE1GU+nhz/uW/XHYjw+9Uc9EU4xQj+HtuG0ZGwKzxp9tTwQ1XjAOQIVwjuW3A1GOZJ9k5cn+5zvLRVvTSaDeqO9wxAuQOzxjCqnJvvt55Y1tdpC0o2g0wHD5nXzjd6gPF2KM7GjeZpT7DHDZjE2tOhH+A7fWMaM4BtM+YA3PBVqDGFz/KgDZMqadALkqYBDKofHl64Rd1Q6yUsl47deD1rJG2Ip+CLyZ/wjwGb+euR4wOGEZUJdliiXA1NIvaF22y+Cg29zP5cXSwlesK1QQ9TyQDTErC0vDO1QY1QtRCeMcA04VQmHSCTBhAkTJv7X+AsIVZYZ+By6NQAAAABJRU5ErkJggg==";

// assets/classifications/text.png
var text_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAI6SURBVHgB7Zk/SgNBFId/4waMghrBQhBErSy9gEXwAOoFvICCWmpjrGwttFcvoB5AIljaWFgIgv9AUBBcFYMJuuM8V0FCZvcl685OzH6wJMu8EL7MvJ03eUBKSkpKMyE4QbKYyyFTmocUY+o2B1N8ePuAsyfyb1dhoaEi8qh9Hp4sqFBzAtW0yYIYr6wGhQSKyKPsii9hAR4WRb68rhvWishidkj9EpewBxdex7DIu26twTb95+QU7EIt7dKCblAv4ohJWMfXw6YmATNiIQI9uqHmEgkgw450uoDeCRjl+Rio3LJC+SIDc0D/DIxyvwNcr7FC+SIPuyq6C0a522GH8kVKZ8DFMmylBZOd6Bw1u7wo2ZnUkeyzfsKb5HZDXZusUL7I65mfJ47BGaHvY8IXcQ/8y1L+TbK34FOrT1X1I7xdtiZlVWqcTqvj6wvigD8jmW5EJiYJgj8jVC5QmeI0KPTxjDipb0N8f/EvC2nREuUvGVzyzzfl7/MGnTtotmkJ0ivd/7xnbIzJiZBE+4B/hfGoNuLz4PIouaVVT64xZiQ5Ee5TjIpGKh4JiSddWHIinLP4b4kvxJ4uNLkcCVta1RKeXFV/mW7pwu1cWjUlKgUEkJxIWbO0GpAg9CJSPsE0DUoQehFPnCBOqmckggQRsLTeVC9CuoiL35VwRAlCKyLy1I9wArtEkaAZoWr6Zi2yBBHeeitmC6rhswITNChBMJuhqntFjR8RW8/kSu3a26rpeYiUlJSUluATrdnTssHuhxMAAAAASUVORK5CYII=";

// assets/classifications/rust.png
var rust_default = "data:image/png;base64,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";

// assets/classifications/json.png
var json_default = "data:image/png;base64,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";

// assets/classifications/yaml-white.png
var yaml_white_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAANgSURBVHgB7ZhNbtQwFICf3ZGABVVWVVlQpSeASvyIFekJCido5wS0J5j0Bu0JOj0BwwmaHYgiUU5Qs6ISCyJ2BdWuXxQnHteTTCZvptIonxTFfrYz7837sROAjo6Ojo57gPmESqmP+vbOEW8zxhKYgF4z1LddS5Tqa+vLk03oKXlpy3vXfze30jQFQvgE+UGuiM2JVjbwTdbyCMaNQA614WIFbiJHHvx79DgCYryGoAKoiCMO9bUPfk6cfqKfcZS1FBu4k7nkH4CYSR6BXJHEEQ/0vx/aAt1HRW0ZerKPja/rT/eYPaaMl1V0vh5GQAivGe+DJ8RMIzcqdsYPc48CU9wKN51fjF2Ua6Wbg61gdRO0srG+ueFxgB7TY5jEoSXHkNrGxuf1MLSTXHL+nqNHlDzLRaRJX+cRDLFY34QjHlSFFLIiZVw8A5h4/UuMXl6JpAwvCK4frO4BEbWG5PSdPlav2JEVIYXe0K7eMQOSsaJwSA7Hpr0CbAeImMqQfP84rphSVilABXXJZVCU6huraLAbPiqX0SX9tB5BYrgbYshYSGVYJZcxGL65EsW6V7/FRZb4ZipR0tcmu02+8Z054gPbGzqsol6Z0Agqno7/qApVmV8kSd+DZgiP7GLsgUq6m+Zz3EBsxnsm6dMjaEGT0KoFkxysJJ8WiqRv6pFKspJrghXLrLUB+slCFUzSZ+V5RkgN0Ua8LZocRi+ufvarpp+vbfwpqptSeP5KYEbIQss9V/0Hfli3RjE4tXrR9yAIYEbocqSi5E6CMXtP0cf7h6v7MCNNQwtL5NCVYZJzKRMjkJIfT/MwzIlvaxtD0+eNNoMlpemGiDHsul/oDXHYcE1qNlE9jmOBK58r+P6h/IQVawae+ZfW+KVP3hSqZD/xCXMDZ07gJlAZEuXnMJcYyrCZK5RHlLG3yNwbu7AgKA1xvRI746TfsVzaGvLJ6Wde8XznEp65pLQ1BA+FidU3XnGTv/a40haK0HKVxM+todWv3GeoaG1I/j6fWCK3Ss3dGwhVsk9SdiHeQEgM8XjFMNXhkQLK8ut6RehrBAuC7A0RvaIrFpbYZ7no1HywWwSkr7pa8bbfqLJDad0k/Tt3Tu2kX1Huk6UxZJbQSqy2gOkR1lphyX9As+d0dHR0LAG3B1hohApHX+kAAAAASUVORK5CYII=";

// assets/classifications/toml-white.png
var toml_white_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAFRSURBVHgB7dmBUYMwGAXgB2QARnCEjiAjOIHnCI7gBLqB3cARgGMBRsgIHYAD/2j1OAQuJan9r33fHceVEtLXkqQJABHdhGTuYFmWuTFmt1aw67q2KIoDIgqp18yd7C7W932JdYVsFSIKqTfFlWAQbYzviXLvPsuuHR1qEZlryPhuA1+yLNsNw/DqU9Y7iHC9RYUzOvZG1c/rpmkgQbzK3t6tNUe+rVx2OeI4JEmyeVwKCiLeZHtEHHvZnrARu19t2NiPXBvZL7zn/vxNx4DpWDRmESAoiPQyi4PiQv/fSpkKZ8A2og2DaMMg2jCINgyiDYNowyDaMIg2DKJN6Jx9jcXf+XzUB0Nj3kHSNP2o6/r3g8ii9oOs1S7O2WVubnHigpus9d7Ldd9HdXiXPeUXmS6PxloqnbrDBmzs2szeWvLAxUqbeME6i8guVS8R0f/7BExpYfBxZN8bAAAAAElFTkSuQmCC";

// assets/classifications/yaml-black.png
var yaml_black_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAANESURBVHgB7ZlNbhMxFMf/diMBC6qsqm6ohhNAJT7EiuEEhRPQnoBygqY3SE/QcALCCTo7JIpEOUHNikosiNgV1DF+k3HiceYzeU2qan7SU+1nT+qX92F7ArS0tLS0rABRoP9o5LWne2UkQjEDI2+d/sjI9ufNAB0dn7v6zuWfh9uj0QiMyAL9+3QhLsdGugXzQ2SNIA6NqDVchZ6++/fe/RDMFBmi0oW4BEb2C+Yfe/3ISD9paXHgT5axfAdmZMlYH7OhRIsKKnTkyT1qfNl8sCvcMW29rMPTzSAEI7JifA/5IWYJjPS88SSkqCG0dMJNRBDizPa0jv0cXAhRY04P42/dhXKIPEZJHDj6COOiAJPkgZvksZRvJHlExyepijXpqzxC9JB+ww4HKAkpYi2Oe7YtINTzn2r49EJF0/BC9/LO+i6YqGMI3AXaRaAkpMgbxtU7diAWYlI4Yokj216D2AETdQ2JjBxVjPdtJym5Ylqqr5yiIa7kcPoYX9LXNYToYTbEiExIJTglVwgMXlyoyXPPfqmzJPHtVKakr5PsLqGRE09nEz/BhFXYmSY0QQsfZf+pDvQ0v1iSvoNmqBzdWeYDdexvmo9pA3HJ9mzSj/pYgCahVQklOZwkrwtH0jf1SClJybXBSmXW2QDz0aH9S0mflOc5YTXEGPFy0pQYPrn4sVc2/XRj6/ekumlN568Ic8IWWv656h/kYdUzWuCD0wu/dbtdzAlfjpSU3CKEcPcUc7y/u76POWkaWlQiB76OklzGcWQVcSyP6nwY5cTXja2B7cumm8FtpOl3QDHsu19h1ktVz5Bn7b6xj+nN09VfKwHG+5kvQckzBznz3Tv8eYG+EVzJflygD1B8PWaFy5AwFZ8eil9YrJQA+aFFctJg7o0NLSJE1is9b5z1PZbPooZ88vp2UwyRfc+lcuaysqghdCiMnH6Yip/8lceVReEILX+R9Lo1cPoK5fsMCxyGRMh6xa9S1+4NgivZixarsARvEFyGRMi/S9Q6PHLAWX59rygjQywJzhtihHGJfZT26dKksCR4r7qzPw41JcDMS5ZcZk7trG9RVsmtMWSe0IqctkJ9lPOscvTfscRcamlpabkZ/Ac67AQ8QCDpcwAAAABJRU5ErkJggg==";

// assets/classifications/toml-black.png
var toml_black_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAFYSURBVHgB7dnBTYRAFAbgBzGBIyWsHVgCVmLsQC8k3PAE4aIduJ1oCXbglLBHOAC+SdDgBibDMJiX9f+SOQALb/+FmYWBCAD+hWBpQ1mWBzLI81yRZ0VRJFEUJeRQdzaIDhEEwScZDMNwywd9J4+4bsp138hc93ouTEgXAkGksQ6i+4S+Pr9b27Yf5Jnuc9MauqbtvldkT+0xUp2b1uDOb73fxVxaa87InGRsPpzG5mRrkBdud+THkds9OcLwKw06++iBW7Gw7cDt/L5J/y+ohc87d3Rta5C1I42i5SCboI9IgyDSIIg0CCINgkiDINIgiDQIIg2CSLP1UddEPwIfZ9btwjoIv4B5rarqZzkMw8csy0wT2fpLr5pwq+v6pu/758kq61nMNWcknS50XedrqvTXMfkHS8kBOrs0s5dWHMenpmmeyEyRf4pf7hjr8gum3QYMAIC/8wUdU2wmC7Q9UgAAAABJRU5ErkJggg==";

// assets/classifications/xml.png
var xml_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC4AAAAuCAYAAABXuSs3AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAQySURBVHgB7ZldaBxVFIDPuTtJwFRB86Koj6WipfFJtJukphqT/QFr0yBqLPhUpBq0yU4EFVdRIdndBkR9s4KgoomCMbuTtmlNN9tQsSDFl4LP6oNQMW3SNt25p+duW3rzM7s7P93tQz5IZubce2e/3bn/A7BBbcFKGUbykV1CYB8SbiGkEPgBcSIRzn4EAVBWPFWIvQtEH0CACAHJwXDuffCJo3i6EO0igiNwCwhCXjimEHVDYNCsfiUlJDMno++BD5zFEVsgIAyDXuHDj3rMr7yjOEmq2HCrpTEkLi0Wl16CAOUF1Ihk5+x1eZrQ417layauUPJN90J/EPI1FVcMbLYuByFfc3HFTXn4Xo+7ka+LuKIkf572gkf5uokrBqLe5esqrlDyi/c0v0xE3+lxJZ8qRN5wKld3cUXykfHlpZZNe1fLI2CrUxkDasDSMuwcnYueK5vp3CKQEN/wyPcoC2+BCtREHAi+rmYYRp7VVTHTLnFbVBUvbIjXmg1xblSzZdIu8L+TECCBiCPQaKI920kSE2vSEBZIyN47is09fDkNAeFfHCE11G4Nq1NzRzbNh0EtdYHI7jXD1pH9neMXWL4PAlrH+hLnkS6daMuZemyoLTfGPfEv6hwRv0i0H565kabkpTD2cG99FHziWZyAMmaHtaJq8PiBvDuQZrHOa9f0eiof69fzDLdNnic0evl0BnzgSRwFZsx2a2h1nCdFKT4c0EIGD4eHUoXoi3o+Jd/UQL7k3YsLODgUzq6RTs9FR3iOMbhOiQb++zJTiD+vBwcetxZK8gTHwQOuxLmHGEtsz639pfPRj7l6mI4FCRptkl9l5mN9eljJ25eXd3uRr1qcxf6zwUirvk+Pj56Ib+a77K9Unhtso22TSZRc8Zlvdc38zzf8HFxStTh/8N2Cirmx09336XFzx9Sfsgh7OMNCufLccP8wQmIXYlLq8Uw+/hQ/yUPgErd1vLV4MWQdPBa/Xw8OP5k7WpIHR/kzhiEiB7ZP/aUH1f6kRKk2ie4Cl3jpVVrtRplbV57kblgrf0ZeNKLrSXMVUVsUrqUVXvvxbSX5+VXyHdPHVsmXpIefmfxbz5fOx7q56vzArcWTtMLPyLnNtuX0yKnIA3qwYYl+527xrDrn3cdTZtdP/+jpSloijfPpneADv3OVraKI1ocnnn1QXXz663MtdnNokkfVx9Q1EuxLz8U/SSav9SS87uzhLzOBPqUV/tecBFubxJXpzHyk/9KV5c848sSKdKTXmnf+Fhp9umeKX8fwKp42QQAEtVh+WNriNEut/wSRXkUS+xzTPVBuY1+CKypKuZbmBkyub8b18F+oM+UcnN9IiNBhqDMhQY4OjuKJ8M888cF3EJ0f160CS1N5evvNsHW8TJ7y8EIghgJeYP2HfL+grQSBTYRnWerbREc2CxvcRlwF8v+4j6UGpvYAAAAASUVORK5CYII=";

// assets/classifications/groovy.png
var groovy_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAe2SURBVHgB7Vp9jFTVFT/nvnnDQGkLhG6wQYsy82a7olIEZGfHlhXTGisbKWhaa4ofoWnpH40xtGm3BtOWbL/SpqGJMQZii1JbtKFiSGmroPupEl2R3Z0vlCBZCSEadWBn5+Mez911cN57M/PuG3c1JvwSmHfPPfede94995xzz12AC7iATyesw8n5LX1vzINpBsIUoaXv6DxJRkfJCFyFEq4EoCVMbrILo1NEMEyGOGIQDgrK7RuOLXkLpgAfWRGrL3kzIqwnwlu5GQR/yAHS41iiPcl485PwEdCwIlZP8kYQ0MmviMEUgD9GD5WoKxWP7ocG4FuRxa9kmsRZ2cUD74JpAALuNCC0ZTh2sS+T86VIuHtkNRpiBwu7DKYRBJihEmzKXBs5pDtG6DJGe9MbhCH2+VMCB3kPdPIG/1p+3JybilnIvzNB0rVM28ZfsepXZ6cQFgbta+5PfUtTkJ4i0d7EBkJ6lEXM1uEHohf51etSschXJIq/oKDlwRn5B62+1P9mhAq/ZSVG023WL2SJVvCsB2q8ZbYk+Hukf0RLGU/TCnenVwtD7tNUIocEW5OxyB9498pod+IGaRgP8he+pJKJAE4HpbFiKL74RPhgeqEIwYus/IIa78zKEq71MrO6K7K4lze2oB06SrDJnTAEtifbrN8pJaze5Lc5XvzbqcQkLzQVAvKH6jnTHjnJPH+q8+rZbGYPeQXVuooEUHaxVO89QfCaAbhmZFVkwkzYNcdZmb9CvbhSsQIlxKfqC4BwAcZ+X4+hpiLWQPJG0nCxasOSCeuHY+GMal99eHQWK/EQeAZHzJafZnw2nwFvOXepOdXqr6kIpxmdoAECuie90host98bf+8nLLXZc2BJvlJ+NPOzZoEOCH5Wq6uqIirtIJ2IjfhIKhb9W7mp8i0m/hi8MWoW5j5WbuSyxaWgA8J4uCfRUa1LVJ+fWA8e4KUughnYVkkrknkHd8xxMA6wI/iPTShC51B703nTkgGxFjQhDOOWqnQnQXkHIroVPCBJ7kotvzQBtjmL7zjY8qZRWEcgt04ozm0VIBOt1sNlhubnRyyg0mbQBdGGhVU8WMBJKNBYBydwnlmsELC3sr24LxPmCS93sGWHVl5+in9PXdyT+FIQA8VjsfDpcufSl1+fc26ssIsfQ6CP0EzKKvN62DYfFxuCjr2+e1HOnqUaIK+rwjevuS/1ffXwRrx59Fjbh0qEB9ItrMQBflwJPiEQXXN0rQjb8xUTsbceOOU+1I5FOwnC1UZJgAes/vRVCKVni8XAu0LIBbzirWyb3wN/K3EeBMYVTlrAzURLPPMWSceqjGuqkfEItuvNBGKzYUiYCrCUFrcQN1MTeMEQZ13jEOfCxwT+aK68zKaIKhRAoy8neluHD5HP7QC72dB/w4N+xKTnoAE4c68ANAICVxLJaf5JpPpGOeGCpfHddFv4mTKNU/t7oAEUg+dsi2BrpJZHz4AOiFwpCEnD+8sSdCYrlVDJJTsJaADOuQq3LDgN3ogv4hhQSci0Rf4Ljghug8BfTqT4lbKQbvjgMYfK3DTBnvWU6/VVmI6CN0KBseIdrrGh0t0gsddOpeMsZmN+LNDl4hdijcqeSyDXcetp0AR/7GEnrcqK0KugAfap9y51rEpyWfNoqi38VSSxRhDcCYK+aX6+GJWCDpuhgi0FX/TC0AI+8r5jgLiGzzLHWe69oAmOSa45ujc7waBmbWXhuVxx++qDdKctOPLpMAlwfh9EupPXGwbtmCGwrXLwZ85C9gsQuWnUTP2A851fseA5oAlJYtBJc62IiTNVxS8POiC6/c1g+onm/pFFzq7IC8nLOKJvxwAeYGd24siqyMnK/nzQXDYaTB3kvbPdjxKM3NjkHG1wrYgqjEX70//kuHA7aIAn2UFkfD0ykH6KD2MTJz0kWkZF4NyLAry6khX+h3Mcpylb+P84+AXi4ydb3cW7qnGESD7BI7QU+QAhlLTh/PiyaSLsl4D3ZWLWS5XM9xOJ3f2ZuGdOVwWyVNpTjV71YMWnvr0qMYTGkVVR+7ZVkbWcXrWoiVd2PtqTus6nOU2C55SpUeyuXUVB6oJGgHBGgPgG/z6zuz99QAq4+352ADYWA26GRlBnTjUVSa2K7mcL2Qm+BLFDYbcrZUmwLXcz5XohyRYf+ByykBk3gk+wEe5Uc6rVX7euReP0U/55DfSxt3CR+X/2RLtY8nyVW6EwH7EJlKDO+Xql1w+RMSG/pR5DXUVS7dEzEjlaK5vXAeLR0JulZfy0aLIt/phovfR4uTvan+IS08SByg+yfCLc5HWz5VnEzrR++RB7IWUK3rGF4IvG+PgRNoM/s8/dGvjc+H2KfPnQUJBjyjY2u1+DP+SV7ESr9/WC9v2IKvFzdVyVQeuZhUTlXYP0wG1XW289NpC4hLfLTWDgJlbySvCHLJvhxkTc+pcOs6+LHo7gqzk9UEXtab/oMRA26axEGdoXPQoJNrMAFFaQX2/mA+rqzYTxa/woMTmuQUwUlCX8nF/RBlMBFYA/zstQJzgvU8WyWzg3UymK3/JOTuVOnJbvSbZ+QtfTTqgCdoGCHarAN1kbUyUbe7VDnew4jxsmxFfVccHE/JNT9QcD0w7rYHK++gcXcAGfTrwPASPfQtyJNxgAAAAASUVORK5CYII=";

// assets/classifications/kotlin.png
var kotlin_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAQESURBVHgB7djLaxNbHAfw7+QxSZum2mraq+RStIUW7qJ/wN0Id3W593JVFB970Yq4EKGgYBNx48q614UguBBRu9CdKLgQ3fhAUHzWJ6ZoVUwyk5nMeH4Tx6bJnDNn0qStkC+ESefMSeczc35zZgZop5122vmVovAath56NglFGfVq69NDSOlhyCQdeYhtvbsRVXNYaMpQTibGC5e82iK8TrOqMtpjYINXWy5mgRi9JTFmdfgF/k4ch17qZ8fEQCQ6i0Zjw84mxouXeO0hXsP7uIl3cQvcdoaZiZW57anIU2xKTCCm5J2/NT2NEgM1EkJ0jGsZ0TYRUePnaAWyVvP25tRKe+0wS4ZyDkKFNm99qdTnLFX1A2Qjg6CE/DYgzPNEGWVONRGm+swQYrMHwg1hZM+MLILiC6FoIRvTnf4YF0FLUWQwQRAUKQiFMM8ZxuD0MKMz+Dd5xBfhRoQJiqBIQygGw7zsqMf0Ioc9xXNI6oF+zsFoWnreukYQFO5/NjnrazFxW8NO/TJ67C+Vo6wHuzKZZs9PTKMIChfyuNvE54j35dfFRMNfMaadxYA5N5waxeTzww0jKMKx8JbtrAjzjzmFtVb9pTQoxlaQXXX0bgYLiO+gJozXxHfgyxX8WZjm9iOMrq2BXwiROno7gwVGqjpr54pd+av4q/jAt59hrK4r5uo0C0GJyG7ozuL7cg+wsXhfthtMgxWzHUYs/obdb80djGYiKIGul1s+PsGm3Fvoel+QbqyYu1EsrIdtV25lmo2gcCG1k/je988wxj4UZ/wHxFhW3MGUbbXpCAoX0mnOYaoRbrwmM7+UrY5s/7GbGbQg3BohYSe7udoy+4ghvK9OhrHSWcbZ+PeLDSW7bvJUBi2KsEb++/QOB19NizZxMPn80M/x75VWIyhcyPavd3D4tf8llkLjv1BY54m5a2/AGWvCRovDhYw9jiJIKphBhpnrRwj6sGQy+19PoIXhQnQqZj1YMVuW+uPMRKsRblqKEdaIM5lpA8LxXxvC3DH+r0W4aRnGd0J0JrPiemnMzcQI7ql/iDZpCUZqZncmM8JY4rq50TWCa8lhvHCeV4T13XSM9C2KU8waH0OIG13DzndCLDYm0L2WTcXsgalGuFlsTLCHbNRjrq4crkO4WUxMYAjFxZzvHcGZ1BB7VuG/kVwsTEMQyuX+FC6sGnS+zzgPXkuLaQgytWYFpn5bMW/dUmMCQy56INwsJSYQ5NRAEicGEygp/G2WCiMNIcTpga7KOy321LXcMFIQF1G9I8sN4wupRVTvyHLCCCE8RPWOLBcMdxd2HLo1eS7dPQqJxNiz/VBefHec1iLoNhXBbwBD33xes4WRzUz+fh3ttNNOO798vgOxwWyVHNA/DgAAAABJRU5ErkJggg==";

// assets/classifications/clojure.png
var clojure_default = "data:image/png;base64,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";

// assets/classifications/emacslisp.png
var emacslisp_default = "data:image/png;base64,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";

// assets/classifications/elixir.png
var elixir_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAPXSURBVHgB7ZpbaBxVGMf/35zZ3SRtXFrzIopJ1SBYoSYhYkXxKSBYi6CRor54adE0to1JNulLWVCMrYvVmE2aUvRFpC6C4g28QB4sJdQ0m0IJWBFfRJGIpqWXLDNzvp556b10zsw5Q6H9vczs7P/s8J/vfGfO+c4CN7lBGX39t9zHxak6WMJBCkwMHl4n6o5PAy2whQuL7CwcaFzO9W9KYCuT8+eLxVVLsIQ1IxPD1RYZyIo67Qw/E/gfWMSKkfHCkXul730DonvOXWScgEWM58jk0Eye2fv8IhMII4IAFjEeEZ+prA73X3qdibKwiNGIlAu/9Kou9PyVvmPmJljEmJHR/un7wM7bVxUwmpUZgiWMGKl0sxBOZo86bbyahgjLyv2HWmEJI0YWWqqD6vDotXTkuI/BEomNjA3NrWbIHZHEgh6CJRIbocDfSaD6KFqWcsO+vqMrYYFERsYHZp5Tnf+JqHpluOFMpvYGLBB7FJncNJPx805VPefV0KNGcLt63l3zMwwSOyJenjfFMBGSC9j/bLQw9yAMEstIsVjJOnD6EBOHcJvg4Idy/+wzMEQsI02n7nqZgbuRjDwc3j8+UN0GA2gbCd/ODtNGmEEwyd1jAzNDSIi2EXXTx9VEow0GIaJ3xgqHE0VG24gQYj0sQIzS+GC1GzHRGn7f6ztYn3NzfyPs31ag/z0K1m7b1fkrNNGKSFbknoQ1EyG8IiOdfZXuioAmWkZIONbmSudvgkcWmle9Bk30coTlWqQBieGwG+s0iWxkqjjlqpG3HanAt9e5uZd0WkQ2Mr90S4sq6Vhdd1+ImmB26eijdy3PWYEUkcRd4cQ0qj6yERJSeyRJBKOhlsedUeXRjUj3JFImQ+6tUbWRjXiZwGrJ84pI73RUaWQjW0baFxi8iBTJBN5fUbV6L0TgIFJCLRMWXtn98H9R9XovRBKHkBLqoR3Q0WtGRH6P1CCth6ZlpGdXx7TKkzmkgHDxlY5eez2i1uofwTLM8rtXR9rnddpoG/GXGveqRPwdFiE4ezSb6BvZ8mFrTQ0pg7AF4cvNpY6voUmsKkpvqeMLdfgAxqFFVdePVYiIXaBrWLZyWCX+jzCHmifS5t6RB44hBrGNhFvNnieeVac/ITm+6q49PaW2TxGTREXsvvfbFmt+bb1K/r2Iz78ScoPKi0kkwNhW2MTw7NPS5+3qFzsiN2L5SbYuu2PjW2v+QEKM7umFVcjy9tmnKMA69UnVv6jpMgn4iMqFb33I/VtLnUdhCGubkyFj/fPN7Jy6g1nUq6r34vKGxmMvFFut/nHgJtcLZwGKbyHxYU/YMgAAAABJRU5ErkJggg==";

// assets/classifications/solidity.png
var solidity_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAATmSURBVHgB7ZpdaBxVFMf/98xuPnxobMTUSsVWwZckmw9iGpVSI2gQWtEHfbHUirGSlvjVkOwmtW6LSXYjfqBVxDfpW94ERStCC35iYszuVvShUoqCUjV+FU2yM/d4bmywzW6bzMydh9L+YNjZuXfOnTPnnnvOnBngMpca9487GJctYmKIGGq7qQcnAA0cRIQoRMnzuTrSKIAV69h8A/rafkFEECKEXBoCow7gNeTG9yJCIrNIPJvr8Bif4P+bpR2F24oDTZ8jAqKxSDpNrlaZJfLJBUaQ5kjGjEZo1X2PKcWblx5XjE6qyj2KCLA/tV48Vkvz+pj4xdqy7cw/ap5rxODGX2ER6xYRJYbOq4RBqbXkVA/CMlYtEh/JbfQIH2P5+OQ6rDqKqcSXsIQ9izArl3gEKwuyMVeJ48s5sIQ1RZxsoVtB3bHS/gp8lzkHlrBzR0bzq0lxXvbWwR8/6NlVjUhv+B0hsWIRUcI4r18lDOvoir9SsEB4iwxPtpITN9E6jmAUNcXa0V8/jRCEtAgr5cSNgwdVwhBXupgxshCCUIo42dwOGb0LIZFFossZLTyEEAS/C5nJGkJMIrgK4hulMJ/Uc7MJpDv+RAACW4RUfMCaEgalrqfq6iQCEswimclGQnxC9iphlzkNdTOSiQJ8EsAi4uBqwcFtK2GolEA5jAD4VsQZyW2TdHwLIkKmyFYnM70NPvGtiCa1CxEj02s3fOJbEdbePXLfXl0Yzz7ayOZY1Vb4JPjyO5LbpIgzEgNuhQUY6lMmTqK/6SMEIFyKMs4Oncj3iv9LhYSvQjBmZDugb0gcxAPKQ0DsZL/ZqWuJnbTsdfuQydL1TU1yXn/9TwiJf0XGcpvw98xnSHe6JW2Z6S6ZajLd0HwhEZJVTbFWA0glPixpTB+JoaLuFgzW+5pi/uNI0f3Dqa59PzY2VVIlQbL5MK8utsv9ScnVlkk1WI6pAb4y0VFOidhYfrNTWXsY5Pl+Pgk2tYa/2k0OvSJpxevacw9gsPXnkj6j36wnmntOFHrwzEiHtOM9g77WkyV9TWm1yPsk7+nRnn4cQy2vwSeBfYQyubfkZ7tsp0TKfv1P4g2kVemSnM3fK97Akna8XdImxTqqKvTIqvusXMrVkjge0qnm7QhAcGeX+pUqel9IlL/xP0HqqBejfvQ1TKzo/Ox0u8OUFR1vN39l+T3Oq9COXYnfEIBwq9bwdCcRPpAptlg5MQvAy3pWDyPdUn6em+d7YlPcfgKLFRdmV4PvRKrlKAIS7glxqPkIHNp/1hFzYX1UTXln7Osd55R7ZF/ytEcWihSMPTi7bKRERgglFkQgLDLPVXX+HZlid5cK53c9VKbguMrxdEYCR0kfOfYeDyS2iFVDpTx2AuILhetUUU+KsLoyrXNnxqlY2iBKnOI4tWFP4/cIiZ0CnVyIOG2vubIymOeWEiVMXwb12lDCYK9kmmwel/cGL638BOmbbByHJaxW4/WamkFZRieX6yd9JvQ1NVYr8nZfKzy8YZbnXZM4nr5Ar9PsqW7TFxax/8ZqX2tOQ5+3GrLQNtSYh2UiexlKmYKkMPrcdIMl30o1BUpBlh0PEaEr1FMSDr9b/C+1l+O60nkSERHde/anG2ZYY6dJP8wmSchOcwwXKzSW30uZfKQfCxgi/xZFr/92FJe5BPkXvbyaY/sPuVQAAAAASUVORK5CYII=";

// assets/classifications/system_verilog.png
var system_verilog_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAMJSURBVHgB7ZlPaxNBFMDfS0LF9CYeFVGhiqLNSZBiMU2tV/WkF8GLl9ImUqv4FZSYxAa8ipceBL1LkkrUiieL4r+CouhREA+mqNl5vm2hs7uZNjNhG+N2fpDZzMubmbzd9+btzABYLJZNAUJIUPbEVUA6KwW0gKXqBZ/OpcwdIBz0SGaxWL0OIZCAsECxk8uUR9Jo0SEY4ELqID6BkIhBRIiMIcYxQuMnD0KfMwQkkoGfTnN3w576R9aeCQw3wcUej6DOOg/8KrEG0O/HWKy/BQO0DaHLY/3QdPL89SKEOEmoQQGCbkN82zQW7i3ptNAP9qZzE1aM6AIUY6cfB/wuuDKp00LrztJU5gA48Bq6Dj8ZRwzgTO1DO029YG/CMfgnuE8Gj+to6rrWFn//RFiqbciMR7mM605eT+nXaWfzSK8RGUOUMUK5kRzbuEsKaNCngKhokz4DEDecFBxOfHP311WJ4SnKje6WAvEZi7ViUE0d7Ijn+M8fkfXA70SKRrERN++DCRh3x1/fEKI0l2mP5Dl/WgyxMdJrqF2L8D2XfVIgtrMf7Fitos4LAbrrkcWA0F2PJMGMr9zXN0+/iyolpSFYrJz31imbmeQ4KUmBKkYCrKwQh3yiXGaeL0fBBIIbWKrcaqdmY6TXiHpCHL3Ll0NSshzsYARCivt5EZC6wQ5GIExzP97dmFfBGHZZIyHSPh4v5e2tA5K+HZPO4dmS5IwJ9EulZGOk11gjIdIsu9MzWYfD7F3yfUeZEEWN70sTTCCn3lYHYY7Hf+mRfFKr6YzXmhC7t0IkyHJitQnxvyPiwd4CLfnCCRHZlw0zW4cgNXTU9J5IAp/ynxfQdXjMeELr6EHLEMxX3/CmdduZI3SQCph/+E5HVT9GGj+uuB0v36UNh8cgHuvn3mvaLcAQmhrbD0IM8/weWOkJxbECBo4VSHGsgIFjBT7p+tOsY/mR1pOQzUKCg7/MF7mLQjDfdoWIWMZCZQJCwOaRXiO8U12iL3xstrBaR2rd7UDeVSHc6mtjsVgsJvwF4OPvmATRMMcAAAAASUVORK5CYII=";

// assets/classifications/coldfusion.png
var coldfusion_default = "data:image/png;base64,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";

// assets/classifications/asp.png
var asp_default = "data:image/png;base64,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";

// src/utils/langReadableToExt.ts
var langReadableToExtMap = {
  batch: ClassificationSpecificEnum.Bat,
  coffee: ClassificationSpecificEnum.Coffee,
  erlang: "erl",
  haskell: "hs",
  lua: "lua",
  markdown: "md",
  matlab: "matlab",
  "objective-c": "m",
  c: "c",
  "c++": "cpp",
  "c++ source": "cc",
  "c++ header": "h",
  "c++ h-header": "hh",
  "c#": "cs",
  css: "css",
  go: "go",
  html: "html",
  htm: "htm",
  java: "java",
  javascript: "js",
  typescript: "ts",
  dart: "dart",
  scala: "scala",
  sql: "sql",
  perl: "pl",
  php: "php",
  python: "py",
  "python-c": "pyc",
  powershell: "ps1",
  r: "r",
  bash: "sh",
  swift: "swift",
  ruby: "rb",
  tex: "tex",
  plaintextgrammar: "text",
  rust: "rs",
  json: "json",
  yaml: "yml",
  toml: "toml",
  xml: "xml",
  groovy: "groovy",
  kotlin: "kt",
  clojure: "clj",
  lisp: "el",
  elixir: "ex"
};

// src/models/IconEnum.ts
var getIcon = (language) => {
  switch (language) {
    case "bat":
      language = theme === "dark" ? "batD" : "batL";
      break;
    case "coffee":
      language = theme === "dark" ? "coffeeD" : "coffeeL";
      break;
    case "md":
      language = theme === "dark" ? "mdD" : "mdL";
      break;
    case "sh":
      language = theme === "dark" ? "shD" : "shL";
      break;
    case "yml":
    case "yaml":
      language = theme === "dark" ? "yamlD" : "yamlL";
      break;
    case "tml":
    case "toml":
      language = theme === "dark" ? "tomlD" : "tomlL";
      break;
    default:
      break;
  }
  return IconsEnum[language];
};
var IconsEnum = {
  batD: batchfile_white_default,
  batL: batchfile_black_default,
  coffeeD: coffeescript_white_default,
  coffeeL: coffeescript_black_default,
  erl: erlang_default,
  hs: haskell_default,
  lua: lua_default,
  mdD: markdown_white_default,
  mdL: markdown_black_default,
  matlab: matlab_default,
  m: objective_c_default,
  c: c_default,
  cpp: cpp_default,
  cc: cpp_default,
  h: cpp_default,
  hh: cpp_default,
  cs: c_sharp_default,
  css: css_default,
  go: go_default,
  html: html_default,
  htm: html_default,
  java: java_default,
  js: javascript_default,
  ts: typescript_default,
  dart: dart_default,
  scala: scala_default,
  sql: sql_default,
  pl: perl_default,
  php: php_default,
  py: python_default,
  pyc: python_default,
  ps1: powershell_default,
  r: r_default,
  shD: bash_white_default,
  shL: bash_black_default,
  swift: swift_default,
  rb: ruby_default,
  tex: tex_default,
  text: text_default,
  txt: text_default,
  rs: rust_default,
  json: json_default,
  yamlD: yaml_white_default,
  yamlL: yaml_black_default,
  tomlD: toml_white_default,
  tomlL: toml_black_default,
  xml: xml_default,
  groovy: groovy_default,
  kt: kotlin_default,
  clj: clojure_default,
  el: emacslisp_default,
  ex: elixir_default,
  sol: solidity_default,
  sv: system_verilog_default,
  asp: asp_default,
  cfm: coldfusion_default
};
var LangSpecificEnum = {
  sh: "bash",
  bat: "batch",
  coffee: "coffee",
  erl: "erlang",
  hs: "haskell",
  lua: "lua",
  md: "markdown",
  matlab: "matlab",
  m: "objective-c",
  c: "c",
  cpp: "cpp",
  cc: "cpp",
  h: "cpp",
  hh: "cpp",
  cs: "csharp",
  css: "css",
  go: "go",
  html: "html",
  htm: "html",
  java: "java",
  js: "js",
  ts: "ts",
  dart: "dart",
  scala: "scala",
  sql: "sql",
  pl: "perl",
  php: "php",
  py: "python",
  pyc: "python",
  ps1: "powershell",
  r: "r",
  swift: "swift",
  rb: "ruby",
  tex: "tex",
  text: "plainTextGrammar",
  txt: "plainTextGrammar",
  rs: "rust",
  json: "json",
  yml: "yaml",
  yaml: "yaml",
  tml: "toml",
  toml: "toml",
  xml: "xml",
  groovy: "groovy",
  kt: "kotlin",
  clj: "clojure",
  el: "lisp",
  ex: "elixir",
  sol: "solidity",
  sv: "systemVerilog",
  asp: "Asp",
  cfm: "ColdFusion"
};
var searchLangSpecificEnum = {
  asp: "Asp",
  bat: "Batch",
  c: "C",
  cs: "C#",
  cpp: "C++",
  css: "CSS",
  clj: "Clojure",
  coffee: "Coffee",
  cfm: "ColdFusion",
  dart: "Dart",
  erl: "Erlang",
  ex: "Elixir",
  el: "Lisp",
  go: "Go",
  groovy: "Groovy",
  hs: "Haskell",
  html: "HTML",
  java: "Java",
  js: "JavaScript",
  json: "JSON",
  kt: "Kotlin",
  lua: "Lua",
  md: "Markdown",
  matlab: "MATLAB",
  m: "Objective-C",
  pl: "Perl",
  php: "PHP",
  text: "PlainTextGrammar",
  ps1: "PowerShell",
  py: "Python",
  rb: "Ruby",
  r: "R",
  rs: "Rust",
  scala: "Scala",
  sh: "Shell",
  sol: "Solidity",
  sql: "SQL",
  swift: "Swift",
  sv: "SystemVerilog",
  tex: "TeX",
  toml: "TOML",
  ts: "TypeScript",
  txt: "PlainTextGrammar",
  xml: "XML",
  yaml: "YAML"
};
var SearchLangToClassificationEnum = {
  Batch: ClassificationSpecificEnum.Bat,
  Coffee: ClassificationSpecificEnum.Coffee,
  Erlang: ClassificationSpecificEnum.Erl,
  Haskell: ClassificationSpecificEnum.Hs,
  Lua: ClassificationSpecificEnum.Lua,
  Markdown: ClassificationSpecificEnum.Md,
  MATLAB: ClassificationSpecificEnum.Matlab,
  "Objective-C": ClassificationSpecificEnum.M,
  C: ClassificationSpecificEnum.C,
  "C++": ClassificationSpecificEnum.Cpp,
  "C#": ClassificationSpecificEnum.Cs,
  CSS: ClassificationSpecificEnum.Css,
  Go: ClassificationSpecificEnum.Go,
  HTML: ClassificationSpecificEnum.Html,
  Java: ClassificationSpecificEnum.Java,
  JavaScript: ClassificationSpecificEnum.Js,
  TypeScript: ClassificationSpecificEnum.Ts,
  Dart: ClassificationSpecificEnum.Dart,
  Scala: ClassificationSpecificEnum.Scala,
  SQL: ClassificationSpecificEnum.Sql,
  Perl: ClassificationSpecificEnum.Pl,
  PHP: ClassificationSpecificEnum.Php,
  Python: ClassificationSpecificEnum.Py,
  PowerShell: ClassificationSpecificEnum.Ps1,
  R: ClassificationSpecificEnum.R,
  Shell: ClassificationSpecificEnum.Sh,
  Swift: ClassificationSpecificEnum.Swift,
  Ruby: ClassificationSpecificEnum.Rb,
  TeX: ClassificationSpecificEnum.Tex,
  PlainTextGrammar: ClassificationSpecificEnum.Text,
  Rust: ClassificationSpecificEnum.Rs,
  JSON: ClassificationSpecificEnum.Json,
  YAML: ClassificationSpecificEnum.Yaml,
  TOML: ClassificationSpecificEnum.Toml,
  XML: ClassificationSpecificEnum.Xml,
  Groovy: ClassificationSpecificEnum.Groovy,
  Kotlin: ClassificationSpecificEnum.Kt,
  Clojure: ClassificationSpecificEnum.Clj,
  Lisp: ClassificationSpecificEnum.El,
  Elixir: ClassificationSpecificEnum.Ex,
  solidity: ClassificationSpecificEnum.Sol,
  systemVerilog: ClassificationSpecificEnum.Sv,
  Asp: ClassificationSpecificEnum.Asp,
  ColdFusion: ClassificationSpecificEnum.Cfm
};
var invertedSearchLangSpecificEnum = (() => {
  const invertedEnum = {};
  const enumKeys = Object.keys(searchLangSpecificEnum);
  for (const key of enumKeys) {
    const value = searchLangSpecificEnum[key].toLowerCase();
    invertedEnum[value] = key;
  }
  return invertedEnum;
})();

// src/ui/views/PiecesView.ts
var import_obsidian2 = require("obsidian");
var PiecesView = class extends import_obsidian2.ItemView {
  constructor({
    leaf,
    workspace,
    title,
    type
  }) {
    super(leaf);
    this.workspace = workspace;
    this.title = title;
    this.type = type;
    this.icon = "pieces_logo";
  }
  getViewType() {
    return this.type;
  }
  getIcon() {
    return this.icon;
  }
  getDisplayText() {
    return this.title;
  }
  async onOpen() {
  }
  async onClose() {
  }
};
var displayPiecesView = async ({
  leaf,
  type,
  markdown,
  inlineTitle,
  active
}) => {
  await leaf.setViewState({
    type,
    active
  });
  const view = new import_obsidian2.MarkdownView(leaf);
  view.setViewData(markdown, true);
  await leaf.open(view);
  leaf.view.inlineTitleEl.innerHTML = inlineTitle;
  leaf.view.inlineTitleEl.contentEditable = "false";
  leaf.view.inlineTitleEl.style.userSelect = "text";
  const editor = view.editor.cm;
  editor.contentDOM.contentEditable = "false";
  editor.contentDOM.style.userSelect = "text";
  let inView = true;
  while (inView) {
    if (view.file) {
      inView = false;
      leaf.view.inlineTitleEl.contentEditable = "true";
      editor.contentDOM.contentEditable = "true";
    }
    await sleep(1e3);
  }
};

// src/ui/render/showFetchFailedState.ts
var import_obsidian3 = require("obsidian");

// assets/pfdSettings_white.png
var pfdSettings_white_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAEt8AAAPRCAMAAAC8X/D5AAAACXBIWXMAAAsTAAALEwEAmpwYAAAARVBMVEVHcEz///////////////////////////////////////////////////////////////////////////////////////9X1DS3AAAAFnRSTlMAgO8QIECf379goHAwz5BQr3+PsG9flyZTSAAAxh5JREFUGBnswYdiqzrDbdEFErZJbGTnZ9/3f74vPklw3BFwT6+7pCBMmWNEwkhYLS5WOmuzl2IpuepnZa5/2Cb6WSRpcdTyWXf17KhGXgAAAAAAAMMUCYNlooW5xsfk7tzI6ZOKWam61GJ2bJpKAAAAAAAAQxEJA2OiyMbzfdyUuUIpokX8vPDzUyUAAAAAAIB+i4SBsIsqntfVIVeHtvfl3XN2bLwAAAAAAAD6KRL6zt77eX0qc93Sqby72GovAAAAAACAnomE3rL3fl6fnHqkiO4u1/leAAAAAAAAfREJPWTvfTk/5Oqrkymyai8AAAAAAIDbi4ReMfGsnB9yDcHJlNe6EgAAAAAAwC1FQl/YJK1PTgOznd1V1V4AAAAAAAA3Egk9YJP0eM01WNvZXVXtBQAAAAAA0L1IuC2zNMdrrhHYzu6qgxcAAAAAAECnIuFmTDwrI6dR2Wblta4EAAAAAADQlUi4CbM0x2uucdrdVQcvAAAAAACALkRC52ySHpxGrmiM2QsAAAAAACC0SOiUTarIaSKK9GL2AgAAAAAACCkSOmNm6cFpYor0UnoBAAAAAACEEgmdMPGqTDVRRZPuKwEAAAAAAIQQCeEly1OmidvdvZYCAAAAAABoXSSEZWaVz4WfbbNL6QUAAAAAANCqSAgoWZ4y4W9OyWspAAAAAACA9kRCICZeveTCfxRNuq8EAAAAAADQjkgIwSyqay58yy4qvQAAAAAAAFoQCa2z8yoTfuBUR3sBAAAAAAB8lhXatUxOmfBjqVTev5YCAAAAAAD4lEhoUbI8OuEdiqYpBQAAAAAA8HGR0JZkeXTCuxVNUwoAAAAAAOCDIqEVdnXKhA8q7q97AQAAAAAAfEQkfJ5ZVJnwKYW9eAEAAAAAALxbJHySWVSZ0IJdVHoBAAAAAAC8TyR8SnK/y4W2XC8nAQAAAAAAvEckfFyyLHKhVUXTlAIAAAAA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WSAfsmoQERERERERuWQx/zFDTqla0qPN+unL02HFuCxNjnzMPSIiIiIiIiIXLeE/6ivkhIrSOPpkbcXWRWbBWORPBfJBO0REREREREQuWsJ/HJCTyg+P9G0DbOOZudlz/op4jnzUAREREREREZGLlvAfrsyRU5rdPHMCztWMwacY+bgaERERERERkYsW818GOa2bFPnBXCXIx60RERERERERuWwx/xUhJ+YS5E9JkiEeZoiIiIiIiIhctpj/2iMnVhiDfJM3OeIjQkREREREROSyxfyXXSEnlt8icD8vEC8bRERERERERC5bzE8y5NRmn7h45i5F/FQOERERERERkcsW85MaObnkngu3TGaIpwgRERERERGRCxfzkwg5vfQzF63Y5oivCBEREREREZELF/OTzQo5vf8tuVzmU1wg3p4RERERERERuXAxP8uQ0yu2CZcqSRLEX2URERERERERuXAxP6uRARQm4TIVTY4E2CMiIiIiIiJy6WJ+FiFDyE3CBTKzuEBCLBARERERERG5dDE/26yQIeQm4eKkyR0SZoOIiIiIiIjIpUt4IUMGkZdYLksRI4Eqh4iIiIiIiMili3mhRoaRm4RLklzFSKgIERERERERkYsX88IeGUhuEi5H0WRIsAoRERERERGRixfzgi2RgeQm4UIkV3GBhGsQERERERERuXgxL82RoeQm4SIUTYZ0YO0QERERERERuXgxL9XIYHKTMH3JVVwgXTCIiIiIiIiISMxLB2Q4ebNk6oomQ7oRISIiIiIiIiKGl1o3Z4K2+IpuOKHr9HrLlC3jq2ukG2WFiIiIiIiIiMS8skeGFN0zXeb+OkO6skREREREREREiHklQQaV3jNVaZIi3dkiIiIiIiIiIiS8Uq8KZEjplbVMULKcIV2qERERERERERFiXrtChpWZhMkx980M6VJlERERERERERFiXmuRgeVNzsSkSVognYoQEREREREREUh47YAMreD+KxOSJBnStQoRERERERERAcNrrZszOVt8RTcMwaS2YSLM/c0c6Vp5QEREREREREQg5g17ZHgzs2QSzH2bIN1rEREREREREZFvEt6QIGcgJ/3K+C2atEB6sDggIiIiIiIiIhDzhnqFnIP0KmHk0tvbHOnFBhERERERERH5JuYtS+QsZGbBmKVX9wukH2uHiIiIiIiIiHyT8JbqCjkL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";

// assets/pfdSettings_black.png
var pfdSettings_black_default = "data:image/png;base64,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1YXL3z1fdunCXFwtAvk1j+0+lIW4TVzepPsQEVs9cHzckozus1+86B4GdIKnJ85Ohf1t2PdU3dsyTg6Pu6oXIiIi4kLxqaVvOHd61NZjlWvy9iXwUZOKmcwaD/ktp6x/OLJk1Z1vICLya+oegfrv87O2GfCHLDwkAvl1o+7pugpxkyYzXxiFiIiIiIiIiMi/RCC/pf2J60YgbjFoY8IsRERERERERET+TQTy22JOTW+HuEFMvUObEBERERERERH5DxHI76pw/bfvIKEVl1d7HSIiIiIiIiIi/y0CuQAP7Sz5FhI6nb5LHIWIiIiIiIiIyP8KIBdgypZSJ4cgIdLz5OnloxARERERERER+QURyIWqEF9sCeK01A8TMgsQEREREREREfllAeRCHVxTtlZtxFED61z11boCRERERERERER+RQQSjPhyeypmIc6IKx59IB8RERERERERkd8QQIKRs+6rFrUmIw4YVK3bjs35iIiIiIiIiIj8lggkaHUXH34gC7FT8h9bTt2EiIiIiIiIiMjviUCM6JbXuitil8Frr5+KiIiIiIiIiMgFiEAMqlDjx7cQ65VP/iazABERERERERGRCxKBGJYc+KDibsRKcckfX7UIEREREREREZELVQgxLO9QweDyT6ciVhlSqMik/D2IiIiIiIiIiFywCMSk7jvqjkXMG/jJuZWIiIiIiIiIiAQnAjEtvlKgUjpiRlSrt4vmIyIiIiIiIiISrAjECjHXXLz6BGJM0w3VA5mIiIiIiIiIiBgQiVghP5973jy8dAkSrLYtOpY/tRkREREREREREUMiEOtEF2lYbA5y4dqubhGVgYiIiIiIiIiIYRGIpZJzGi4rQC5E1MX1zy9CRERERERERMSMCMRqMdcF4kcjvy2hyttVMxERERERERERMakQYrWTe3P3F+v/SQrya3p2Tnhl648HERERERERERExKwKxyahFH/94FvlvyXF7Ki9ERERERERERMQaEYh9mmXWrjIe+f9GTKpfaAEiIiIiIiIiIpYphNhn74+fHltz5afNeiCQ+FPfq5/5bPcuRERERERERESsE4HYruu+I0fyCW+1S588mouIiIiIiIiIiNUiEEfUKHSwzB7CU4nKsTcNQURERERERETEDhGIU2IKr6hw3xLCS9tHzux9Ih8REREREREREZtEIE5KOnxpzpkCwkPKN0Wif8hCRERERERERMRGEYjTYtq8f7DGW/hbm88jYr7LRERERERERETEZoUQp53Mzv8+6kTrhOeb4089vq90765d+XsPIiIiIiIiIiJitwgkZLq9XOXDn07jJykxx44kTUBERERERERExCkRSEjFtDn6w9YSufhA7Qpnzn+XiYiIiIiIiIiIkyKQ0Gv/5oK1r5XNwquSh2SmHNiwABERERERERERx0UgLlG3+tEfSuWvxVtSr8k/c/78G4iIiIiIiIiIiEBMvzIZW9MTzntAQvqM98uMiUFEREREREREJJQiEPepW33njxU3fX0Wd0o+v/uqIuXOv4GIiIiIiIiISMhFIG5V70+x8dXvXnoc9yjZev7aYuM/y0RERERERERExCUiEJerd7x08R+PRH6/mxCK/sO5qyIONZmOiIiIiIiIiIiIEcnzbtuwq9LeHg3PO6hhj71Hdm24bV4yIiIiIiIiIiLuFIF4TFzSirxdlR+6+bPdq7BHk8QrNnYtVTW2z8JcRERERERERETcLQLxrHZ7V379U+E/nKpxZa99O9ZiRkqVqhP2N3n+2zOFLm1eeREiIiIiIiIiIl4RgfhD3ZYJMxtlnHlmUOGTy7p9sPLBxLWFLwM+5Gd/zAXiPudn1wKHz6Tsnta8+tRWxc+MHlz4ntVd9izfhIiIiIiIiIiIiIiIiIiIiIiIOOv/AZOGjHj2EiF9AAAAAElFTkSuQmCC";

// assets/failedFetch.png
var failedFetch_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABSAAAATECAMAAABMaVsDAAACE1BMVEUAAAAAAAD////9/f3Z2dkAAAAAAAADAwP////////////Y2Nj////////////c3Nz///////////8BAQHe3t6SkpL////b29v////////////////7+/v///////////////8BAQHm5ub+/v7////Nzc2goKD+/v6BgYGDg4Pd3d3///+bm5v///98fHz////////19fX///+np6e/v7/////r6+v///////8CAgL6+vr///////+Ghob////9/f3p6enl5eXw8PDs7Oz29vaKiorf39/X19d9fX3+/v7y8vLi4uLy8vJycnLi4uLm5uaysrKkpKQKCgqRkZGzs7OPj4+Ojo7j4+Pt7e3U1NSjo6NpaWmZmZna2trIyMjx8fGWlpaampqnp6e0tLTLy8vg4OCxsbEwMDBbW1ve3t6AgIAAAADg4OD///8uLi7i4uLk5OQpKSlZWVl8fHwlJSX39/eCgoLb29vV1dXFxcVRUVHY2Ng8PDweHh4ZGRlVVVXy8vLOzs7IyMh4eHghISG1tbVxcXG7u7ugoKCIiIhgYGCRkZFDQ0NkZGRubm7S0tKvr683Nzerq6u/v7/CwsKXl5dpaWkREREWFhaxsbGnp6fKysrr6+tMTEybm5ujo6OLi4u3t7d2dnaEhIRJSUkNDQ2NjY1OTk51dXXR0dGUlJQICAjo6Oiampq+vr6urq75+fmOXS4FAAAAZ3RSTlMAC4284wYUHDPJT9o6Kg7rWqqAEPbg2O+fpV+ctyJVhgcm9sNIhL5s+vD6ZshD43F72pe0QD7zr7QzFnYc4pIv4e7X6LXRz/fz0Mzq6T752KVTQc6ErsBqwvGiUnxMmLCeLoRfY4K35AXZwwABSPJJREFUeNrs3d1LFFEYx/Gzvbj2RiuFvUhKbBBshBVESRFtQVEJUVd17dXpHDwDiaOuJo7olrtqmGjYhQVFF6J/Y845o8nSi856deb7WZidZXfn8sdz5nn2rAAAAAAAAAAAAL5p6bl53rna0yIAAFbu5b1i+8NyySk/bD9yru+UAICMy524dqyitZR68xDTyYtDXa1UkgAy7NT526dtMDpa7jjXleKdvACAbLp8veTiUdtHw6nWYW9HTgBA5uQKJ43WO8tGHZMJ7Y7hgQsC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";

// src/ui/render/showFetchFailedState.ts
var showFetchFailedState = ({
  containerVar
}) => {
  const piecesDiv = containerVar.createEl("div");
  piecesDiv.addClass(
    "loading-div",
    "flex",
    "flex-col",
    "items-center",
    "justify-center",
    "h-full",
    "w-full",
    "text-center"
  );
  const piecesImg = piecesDiv.createEl("img");
  if (theme === "dark") {
    piecesImg.setAttr("src", pfdSettings_white_default);
  } else {
    piecesImg.setAttr("src", pfdSettings_black_default);
  }
  piecesImg.setAttr("alt", "Loading your snippets...");
  piecesImg.addClass("loading-div", "!w-60", "!h-auto");
  const loadingDiv = piecesDiv.createEl("div");
  loadingDiv.addClass("loading-div", "w-60", "max-w-full");
  const loadImg = loadingDiv.createEl("img");
  loadImg.setAttr("src", failedFetch_default);
  loadImg.setAttr("alt", "Loading your snippets...");
  const loadingTextDiv = piecesDiv.createEl("div");
  loadingTextDiv.addClass("loading-div");
  const loadTxt = loadingTextDiv.createEl("h5", {
    text: "Oops! Something went wrong. " + (!versionValid && !DisplayController.fetchFailed ? toUpdatePlugin ? "Your plugin version is not compatible with your Pieces OS version. Please update the Pieces Obsidian plugin to the latest version." : `Please update Pieces OS to '${currentMinVersion}' or greater to continue using Pieces!` : "Please make sure Pieces OS is installed, updated, and running.")
  });
  loadTxt.addClass("loading-div", "text-base");
  const buttonRow = piecesDiv.createDiv();
  buttonRow.addClass("loading-div-row");
  const buttonCol = buttonRow.createDiv();
  buttonCol.addClass("loading-div-col");
  new import_obsidian3.ButtonComponent(buttonCol).setButtonText("Install Pieces OS").onClick(async () => {
    window.open(
      "https://docs.pieces.app/installation-getting-started/what-am-i-installing#pieces-desktop-app--pieces-os",
      "_blank"
    );
  }).setTooltip("Navigate to the Pieces OS install page").setClass("loading-div-button").setClass("button").setClass("w-full");
  if (versionValid || DisplayController.fetchFailed) {
    const inBetweenButtonDiv = buttonCol.createDiv();
    inBetweenButtonDiv.addClass("loading-div-button");
    inBetweenButtonDiv.createEl("p", { text: "or" });
    new import_obsidian3.ButtonComponent(buttonCol).setButtonText("Launch Pieces OS").onClick(async () => {
      window.open("pieces://launch", "_blank");
    }).setTooltip("Launch Pieces OS if you already have it installed").setClass("loading-div-button").setClass("button");
  }
};

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options2, buf, offset) {
  if (native_default.randomUUID && !buf && !options2) {
    return native_default.randomUUID();
  }
  options2 = options2 || {};
  const rnds = options2.random || (options2.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i2 = 0; i2 < 16; ++i2) {
      buf[offset + i2] = rnds[i2];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// src/ui/render/showNoSnippetState.ts
var showNoSnippetState = ({
  containerVar
}) => {
  const loadingDiv = containerVar.createEl("div");
  loadingDiv.addClass(
    "new-div",
    "justify-center",
    "items-center",
    "flex",
    "w-full",
    "pt-32",
    "text-center",
    "gap-5",
    "flex-col"
  );
  const loadImg = loadingDiv.createEl("img");
  if (theme === "dark") {
    loadImg.setAttr("src", pfdSettings_white_default);
  } else {
    loadImg.setAttr("src", pfdSettings_black_default);
  }
  loadImg.setAttr("alt", "No snippets yet!");
  loadImg.addClass("new-div", "h-12", "w-auto");
  const snippetRaw = [
    "class HelloWorld:",
    "    def __init__(self):",
    '        self.message = "Hello, World!"',
    "",
    "    def say_hello(self):",
    "        print(self.message)",
    "",
    "# Create an instance of the class",
    "hello = HelloWorld()",
    "",
    "# Call the say_hello method",
    "hello.say_hello()"
  ];
  const snippetTotal = snippetRaw.join("\n");
  const snippet = {
    title: "Hello World Snippet",
    id: "",
    type: "",
    raw: snippetTotal,
    language: ClassificationSpecificEnum.Py,
    time: "",
    created: new Date(),
    annotations: [
      {
        text: 'A simple "Hello World" Snippet that shows you how to use Pieces!',
        id: v4_default(),
        mechanism: MechanismEnum.Manual,
        type: AnnotationTypeEnum.Description,
        created: {
          value: new Date()
        },
        updated: {
          value: new Date()
        }
      }
    ],
    updated: new Date(),
    share: void 0
  };
  DisplayController.createListView({
    containerVar,
    snippets: [snippet],
    newSnippet: true
  });
  const loadingTextDiv = containerVar.createEl("div");
  loadingTextDiv.addClass("new-div");
  const loadTxt = loadingTextDiv.createEl("h4", {
    text: "You're so close to getting started! Try saving this code snippet!"
  });
  loadTxt.addClass("new-div", "text-center", "pt-6", "text-base");
};

// assets/loadingCat.png
var loadingCat_default = "data:image/png;base64,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";

// src/ui/render/showLoadingState.ts
var showLoadingState = ({
  containerVar,
  discovery
}) => {
  const loadingContainer = containerVar.createDiv();
  loadingContainer.classList.add(
    "flex",
    "flex-col",
    "items-center",
    "justify-center",
    "w-full",
    "h-[80vh]",
    "overflow-hidden"
  );
  const piecesDiv = loadingContainer.createEl("div");
  piecesDiv.addClass("loading-div", "px-12");
  const piecesImg = piecesDiv.createEl("img");
  if (theme === "dark") {
    piecesImg.setAttr("src", pfdSettings_white_default);
  } else {
    piecesImg.setAttr("src", pfdSettings_black_default);
  }
  piecesImg.setAttr("alt", "Loading your snippets...");
  piecesImg.addClass("loading-div");
  const loadingDiv = loadingContainer.createEl("div");
  loadingDiv.addClass("loading-div", "px-16");
  const loadImg = loadingDiv.createEl("img");
  loadImg.setAttr("src", loadingCat_default);
  loadImg.setAttr("alt", "Loading your snippets...");
  const loadingTextDiv = loadingContainer.createEl("div");
  loadingTextDiv.addClass("loading-div");
  const loadTxt = loadingTextDiv.createEl("h4", {
    text: discovery ? `You've saved all your discovered snippets!` : "We haven\u2019t found any snippets yet!"
  });
  loadTxt.addClass("loading-div", "!text-lg");
};

// src/ui/render/renderSnippet.ts
var import_obsidian8 = require("obsidian");

// src/utils/loadPrism.ts
var highlightSnippet = ({
  snippetContent,
  snippetLanguage
}) => {
  snippetLanguage = snippetLanguage.toLowerCase();
  switch (snippetLanguage) {
    case "bat":
      return Prism.highlight(snippetContent, Prism.languages.batch, "batch");
      break;
    case "coffee":
      return Prism.highlight(
        snippetContent,
        Prism.languages.coffeescript,
        "coffeescript"
      );
      break;
    case "erl":
      return Prism.highlight(snippetContent, Prism.languages.erlang, "erlang");
      break;
    case "hs":
      return Prism.highlight(
        snippetContent,
        Prism.languages.haskell,
        "haskell"
      );
      break;
    case "lua":
      return Prism.highlight(snippetContent, Prism.languages.lua, "lua");
      break;
    case "md":
      return Prism.highlight(
        snippetContent,
        Prism.languages.markdown,
        "markdown"
      );
      break;
    case "matlab":
      return Prism.highlight(snippetContent, Prism.languages.matlab, "matlab");
      break;
    case "m":
      return Prism.highlight(snippetContent, Prism.languages.cpp, "cpp");
      break;
    case "c":
      return Prism.highlight(snippetContent, Prism.languages.c, "c");
      break;
    case "cc":
    case "h":
    case "hh":
    case "cpp":
      return Prism.highlight(snippetContent, Prism.languages.cpp, "cpp");
      break;
    case "cs":
      return Prism.highlight(snippetContent, Prism.languages.csharp, "csharp");
      break;
    case "css":
      return Prism.highlight(snippetContent, Prism.languages.css, "css");
      break;
    case "go":
      return Prism.highlight(snippetContent, Prism.languages.go, "go");
      break;
    case "htm":
    case "html":
      return Prism.highlight(snippetContent, Prism.languages.html, "html");
      break;
    case "java":
      return Prism.highlight(snippetContent, Prism.languages.java, "java");
      break;
    case "js":
      return Prism.highlight(
        snippetContent,
        Prism.languages.javascript,
        "javascript"
      );
      break;
    case "ts":
      return Prism.highlight(
        snippetContent,
        Prism.languages.typescript,
        "typescript"
      );
      break;
    case "dart":
      return Prism.highlight(snippetContent, Prism.languages.dart, "dart");
      break;
    case "scala":
      return Prism.highlight(snippetContent, Prism.languages.scala, "scala");
      break;
    case "sql":
      return Prism.highlight(snippetContent, Prism.languages.sql, "sql");
      break;
    case "pl":
      return Prism.highlight(snippetContent, Prism.languages.perl, "perl");
      break;
    case "pyc":
    case "py":
      return Prism.highlight(snippetContent, Prism.languages.python, "python");
      break;
    case "ps1":
      return Prism.highlight(
        snippetContent,
        Prism.languages.powershell,
        "powershell"
      );
      break;
    case "r":
      return Prism.highlight(snippetContent, Prism.languages.r, "r");
      break;
    case "sh":
      return Prism.highlight(snippetContent, Prism.languages.bash, "bash");
      break;
    case "swift":
      return Prism.highlight(snippetContent, Prism.languages.swift, "swift");
      break;
    case "rb":
      return Prism.highlight(snippetContent, Prism.languages.ruby, "ruby");
      break;
    case "tex":
      return Prism.highlight(snippetContent, Prism.languages.latex, "latex");
      break;
    case "text":
    case "txt":
      return snippetContent;
      break;
    case "rs":
      return Prism.highlight(snippetContent, Prism.languages.rust, "rust");
      break;
    case "json":
      return Prism.highlight(snippetContent, Prism.languages.json, "json");
      break;
    case "yaml":
    case "yml":
      return Prism.highlight(snippetContent, Prism.languages.yaml, "yaml");
      break;
    case "tml":
    case "toml":
      return Prism.highlight(snippetContent, Prism.languages.toml, "toml");
      break;
    case "xml":
      return Prism.highlight(snippetContent, Prism.languages.xml, "xml");
      break;
    case "groovy":
      return Prism.highlight(snippetContent, Prism.languages.groovy, "groovy");
      break;
    case "kt":
      return Prism.highlight(snippetContent, Prism.languages.kotlin, "kotlin");
      break;
    case "clj":
      return Prism.highlight(
        snippetContent,
        Prism.languages.clojure,
        "clojure"
      );
      break;
    case "el":
      return Prism.highlight(snippetContent, Prism.languages.lisp, "lisp");
      break;
    case "ex":
      return Prism.highlight(snippetContent, Prism.languages.elixir, "elixir");
      break;
    default:
      return snippetContent;
      break;
  }
};

// src/ui/modals/delete-modal.ts
var import_obsidian4 = require("obsidian");

// src/actions/delete.ts
var DeletePiece = class {
  static async delete({
    id,
    retry: retry2 = false
  }) {
    const config5 = ConnectorSingleton.getInstance();
    const notifications = Notifications.getInstance();
    const cache2 = PiecesCacheSingleton.getInstance();
    try {
      const piece = cache2.mappedAssets[id];
      if (!piece) {
        notifications.information({
          message: Constants.SNIPPET_IS_DELETED
        });
        return;
      }
      await config5.assetsApi.assetsDeleteAsset({ asset: id });
      notifications.information({
        message: Constants.SNIPPET_DELETE_SUCCESS
      });
    } catch (error) {
      if (error.status === 401 || error.status === 400) {
        if (retry2) {
          notifications.error({
            message: Constants.SNIPPET_DELETE_FAILURE,
            actions: [
              {
                title: "Contact Support",
                type: "OPEN_LINK" /* OPEN_LINK */,
                params: { url: "https://docs.pieces.app/support" }
              }
            ]
          });
        } else {
          try {
            config5.context = await config5.api.connect({
              seededConnectorConnection: config5.seeded
            });
            return await this.delete({ id, retry: true });
          } catch (e3) {
            console.log(`Error from deleting snippet ${e3}`);
          }
        }
      } else {
        if (!retry2) {
          if (error.code === "ECONNREFUSED") {
            await launchRuntime(true);
            config5.context = await config5.api.connect({
              seededConnectorConnection: config5.seeded
            });
          }
          return await this.delete({ id, retry: true });
        }
        notifications.error({
          message: Constants.SNIPPET_DELETE_FAILURE,
          actions: [
            {
              title: "Contact Support",
              type: "OPEN_LINK" /* OPEN_LINK */,
              params: { url: "https://docs.pieces.app/support" }
            }
          ]
        });
      }
    }
  }
};

// src/ui/modals/delete-modal.ts
var DeleteModal = class extends import_obsidian4.Modal {
  constructor(app2, snippetTitle, snippetId, snippetParent) {
    super(app2);
    this.snippetTitle = snippetTitle;
    this.snippetId = snippetId;
    this.snippetParent = snippetParent;
  }
  onOpen() {
    const { contentEl } = this;
    const delTitle = contentEl.createEl("h1", {
      text: "Delete piece"
    });
    delTitle.addClass("button_delete_modal_title");
    contentEl.createEl("h3", {
      text: `Are you sure you want to delete '${this.snippetTitle}'?`
    });
    const buttonDiv = contentEl.createEl("div");
    buttonDiv.addClass("buttonDiv");
    new import_obsidian4.ButtonComponent(buttonDiv).setButtonText("Delete").onClick(async () => {
      await DeletePiece.delete({ id: this.snippetId });
      this.close();
      this.snippetParent.remove();
    }).setTooltip("Delete snippet").setClass("button_delete_modal");
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// node_modules/p-retry/index.js
var import_retry = __toESM(require_retry2(), 1);
var networkErrorMsgs = /* @__PURE__ */ new Set([
  "Failed to fetch",
  // Chrome
  "NetworkError when attempting to fetch resource.",
  // Firefox
  "The Internet connection appears to be offline.",
  // Safari
  "Network request failed",
  // `cross-fetch`
  "fetch failed"
  // Undici (Node.js)
]);
var AbortError = class extends Error {
  constructor(message) {
    super();
    if (message instanceof Error) {
      this.originalError = message;
      ({ message } = message);
    } else {
      this.originalError = new Error(message);
      this.originalError.stack = this.stack;
    }
    this.name = "AbortError";
    this.message = message;
  }
};
var decorateErrorWithCounts = (error, attemptNumber, options2) => {
  const retriesLeft = options2.retries - (attemptNumber - 1);
  error.attemptNumber = attemptNumber;
  error.retriesLeft = retriesLeft;
  return error;
};
var isNetworkError = (errorMessage) => networkErrorMsgs.has(errorMessage);
var getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new Error(errorMessage) : new DOMException(errorMessage);
async function pRetry(input, options2) {
  return new Promise((resolve2, reject) => {
    options2 = {
      onFailedAttempt() {
      },
      retries: 10,
      ...options2
    };
    const operation = import_retry.default.operation(options2);
    operation.attempt(async (attemptNumber) => {
      try {
        resolve2(await input(attemptNumber));
      } catch (error) {
        if (!(error instanceof Error)) {
          reject(new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`));
          return;
        }
        if (error instanceof AbortError) {
          operation.stop();
          reject(error.originalError);
        } else if (error instanceof TypeError && !isNetworkError(error.message)) {
          operation.stop();
          reject(error);
        } else {
          decorateErrorWithCounts(error, attemptNumber, options2);
          try {
            await options2.onFailedAttempt(error);
          } catch (error2) {
            reject(error2);
            return;
          }
          if (!operation.retry(error)) {
            reject(operation.mainError());
          }
        }
      }
    });
    if (options2.signal && !options2.signal.aborted) {
      options2.signal.addEventListener("abort", () => {
        operation.stop();
        const reason = options2.signal.reason === void 0 ? getDOMException("The operation was aborted.") : options2.signal.reason;
        reject(reason instanceof Error ? reason : getDOMException(reason));
      }, {
        once: true
      });
    }
  });
}

// src/connection/cloud_singleton.ts
var CloudService = class {
  constructor() {
    this.config = ConnectorSingleton.getInstance();
    this.notifications = Notifications.getInstance();
  }
  static getInstance() {
    if (!CloudService.instance) {
      CloudService.instance = new CloudService();
    }
    return CloudService.instance;
  }
  async connect({
    user
  }) {
    if (!user) {
      const profile = await this.config.userApi.userSnapshot();
      if (!profile.user) {
        this.notifications.error({
          message: Constants.LOGIN_TO_POS_CLOUD
        });
        return;
      }
      user = profile.user;
    }
    let connected;
    const connectCloud = async () => {
      connected = await this.config.allocationsApi.allocationsConnectNewCloud({
        userProfile: user
      });
      if (connected.status.cloud !== AllocationStatusEnum.Running) {
        throw new Error("Unable to Connect");
      }
    };
    await pRetry(connectCloud, { retries: 5 });
    if (connected?.status.cloud !== AllocationStatusEnum.Running) {
      this.notifications.error({ message: Constants.CLOUD_CONNECT_FAIL });
      return;
    }
    this.notifications.information({
      message: Constants.CLOUD_CONNECT_SUCCESS
    });
    return connected;
  }
  async disconnect({ user }) {
    try {
      const { config: config5 } = this;
      user = user ? user : (await config5.userApi.userSnapshot()).user;
      if (!user || !user?.allocation) {
        this.notifications.information({
          message: Constants.CLOUD_DISCONNECT_ALR
        });
        return true;
      }
      await config5.allocationsApi.allocationsDisconnectCloud({
        allocationCloud: user.allocation
      });
      this.notifications.information({
        message: Constants.CLOUD_DISCONNECT_SUCCESS
      });
      return true;
    } catch (error) {
      this.notifications.error({
        message: Constants.CLOUD_DISCONNECT_FAIL
      });
      return false;
    }
  }
};

// src/connection/shareable_link.ts
var ShareableLinksService = class {
  constructor() {
    this.config = ConnectorSingleton.getInstance();
    this.cloud = CloudService.getInstance();
    this.notifications = Notifications.getInstance();
  }
  static getInstance() {
    if (!ShareableLinksService.instance) {
      ShareableLinksService.instance = new ShareableLinksService();
    }
    return ShareableLinksService.instance;
  }
  async generate({
    id,
    retry: retry2 = false
  }) {
    try {
      const { config: config5, cloud, notifications } = this;
      const profile = await config5.userApi.userSnapshot();
      if (!profile?.user) {
        notifications.error({ message: Constants.LOGIN_TO_POS });
        return;
      } else if (!profile?.user?.allocation) {
        const allocation = await cloud.connect({
          user: profile?.user
        });
        if (!allocation) {
          notifications.error({
            message: Constants.CLOUD_CONNECT_FAIL
          });
          return;
        }
        profile.user.allocation = allocation;
      } else if (profile?.user?.allocation?.status.cloud != AllocationStatusEnum.Running) {
        notifications.error({
          message: Constants.CLOUD_CONNECT_INPROG
        });
        return;
      }
      const asset = await config5.assetApi.assetSnapshot({ asset: id }).catch((error) => {
        if (error.status === 410) {
          throw new Error("Snippet no longer exists");
        } else {
          throw new Error("Please check that Pieces OS is installed");
        }
      });
      notifications.information({ message: `Generating a link...` });
      const link = await config5.linkifyApi.linkify({
        linkify: {
          asset,
          access: AccessEnum.Public
        }
      }).catch((error) => {
        if (error.status === 413) {
          throw new Error(
            `Failed to generate shareable link. The asset is too large. Please try a smaller asset.`
          );
        } else if (error.status === 500) {
          throw new Error(
            `Failed to generate shareable link. Please update your Pieces OS.`
          );
        } else if (error.status === 511) {
          throw new Error(
            `Failed to generate shareable link. Please make sure you are signed in and connected to cloud.`
          );
        } else {
          throw new Error(
            `Failed to generate shareable link. Please check that Pieces OS is installed and running.`
          );
        }
      });
      notifications.information({
        message: Constants.LINK_GEN_SUCCESS
      });
      return link.iterable[0].link;
    } catch (error) {
      const { config: config5, notifications } = this;
      if (error.status === 401 || error.status === 400) {
        if (retry2) {
          notifications.error({
            message: Constants.LINK_GEN_FAIL,
            actions: [
              {
                title: "Contact Support",
                type: "OPEN_LINK" /* OPEN_LINK */,
                params: { url: "https://docs.pieces.app/support" }
              }
            ]
          });
        } else {
          try {
            config5.context = await config5.api.connect({
              seededConnectorConnection: config5.seeded
            });
            return await this.generate({ id, retry: true });
          } catch (e3) {
            console.log(`Error from generating link ${e3}`);
          }
        }
      } else {
        if (!retry2) {
          if (error.code === "ECONNREFUSED") {
            await launchRuntime(true);
          }
          return await this.generate({ id, retry: true });
        }
        notifications.error({
          message: Constants.LINK_GEN_FAIL,
          actions: [
            {
              title: "Contact Support",
              type: "OPEN_LINK" /* OPEN_LINK */,
              params: { url: "https://docs.pieces.app/support" }
            }
          ]
        });
      }
    }
  }
};

// src/actions/create_asset.ts
var createAsset = async ({
  selection,
  retry: retry2 = false,
  name: name314,
  annotations,
  lang,
  anchors
}) => {
  const config5 = ConnectorSingleton.getInstance();
  const notifications = Notifications.getInstance();
  const activeFile = app.workspace.getActiveFile();
  let context = config5.context;
  if (!context) {
    try {
      config5.context = await config5.api.connect({
        seededConnectorConnection: config5.seeded
      });
      context = config5.context;
    } catch (error) {
      notifications.error({ message: Constants.CONNECTION_FAIL });
      return Promise.reject(new Error("Failed to Connect"));
    }
  }
  const application = context.application;
  const seededAsset = {
    type: SeedTypeEnum.Asset,
    asset: {
      application,
      format: {
        fragment: {
          string: {
            raw: selection || ""
          }
        }
      }
    }
  };
  if (lang && lang.length) {
    seededAsset.asset.format.fragment.metadata = {
      ext: invertedSearchLangSpecificEnum[lang.toLowerCase()]
    };
  }
  seededAsset.asset.metadata = {};
  if (name314 && name314.length) {
    seededAsset.asset.metadata = {
      ...seededAsset.asset.metadata,
      name: name314
    };
  }
  if (activeFile && activeFile.name && !pluginSettings.use_note_title) {
    seededAsset.asset.metadata.name = activeFile.name.split(".")[0];
    const basePath = app.vault.adapter.basePath;
    const filePath = basePath + "/" + activeFile.path;
    seededAsset.asset.metadata.anchors = [
      {
        fullpath: filePath,
        type: AnchorTypeEnum.File
      }
    ];
  }
  if (anchors?.length) {
    if (!seededAsset.asset?.metadata.anchors)
      seededAsset.asset.metadata.anchors = [];
    for (const anchor of anchors) {
      seededAsset.asset?.metadata.anchors.push({
        fullpath: anchor,
        type: AnchorTypeEnum.File
      });
    }
  }
  if (annotations && annotations.length) {
    seededAsset.asset.metadata = {
      ...seededAsset.asset.metadata,
      annotations: annotations.map((annotation) => {
        return {
          type: annotation.type,
          text: annotation.text,
          mechanism: annotation.mechanism,
          asset: annotation.asset?.id
        };
      })
    };
  }
  let enrichmentCount = 9;
  switch (pluginSettings.enrichmentLevels) {
    case "HIGH":
      enrichmentCount = 9;
      break;
    case "MEDIUM":
      enrichmentCount = 6;
      break;
    case "LOW":
      enrichmentCount = 3;
      break;
    case "NONE":
      enrichmentCount = 0;
      break;
  }
  seededAsset.asset.enrichment = {
    tags: enrichmentCount,
    websites: enrichmentCount,
    hints: enrichmentCount
  };
  try {
    const asset = await config5.assetsApi.assetsCreateNewAsset({
      seed: seededAsset
    });
    notifications.information({ message: Constants.SAVE_SUCCESS });
    return asset.id;
  } catch (error) {
    if (retry2) {
      notifications.error({ message: Constants.SAVE_FAIL });
      return Promise.reject(new Error(`Error saving piece ${error.message}`));
    }
    if (error.status === 401 || error.status === 400) {
      return Promise.reject(
        new Error(`User error reported from Pieces OS ${error.status}`)
      );
    }
    if (error.code === "ECONNREFUSED") {
      if (retry2) {
        return Promise.reject(new Error(`Error saving piece ${error.message}`));
      }
      await launchRuntime(true);
      config5.context = await config5.api.connect({
        seededConnectorConnection: config5.seeded
      });
    }
    return createAsset({ selection, retry: true });
  }
};

// assets/fullscreen.png
var fullscreen_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAANdJREFUSEvtVUESAiEMS16mvkx9mbsvq7MMMF2gW2DkJkdoE1qSQixeXIyPTCAiLwDPBuGb5HFWrZ4cTSBGNTMEIBmwLYKN5GOkfSLyAXBPOVcEWwzsJlHgKdeu4GDWCV4lZayIhFabFaSDHpJWzBVBUIpWjAKoHtq6QFRWxnF9EIH2UqolkCUIl2BESa3YP4HbQbdF1mPG/Zvnk3LYWTKtXK0G3enMlGlpkBVGyxbvAU/NHx4VANYOu3iz7knaqCRsef+Blt/PPpy1X6brmMkA12iTuDntC9+FyxnxM78WAAAAAElFTkSuQmCC";

// src/utils/copyToClipboard.ts
var copyToClipboard = async (text) => {
  try {
    await navigator.clipboard.writeText(text);
  } catch (error) {
    console.error("Failed to copy text to clipboard:", error);
  }
};

// src/ui/modals/edit-asset-modal.ts
var import_obsidian5 = require("obsidian");

// src/actions/update_asset.ts
var reclassify = async ({
  asset,
  ext
}) => {
  const config5 = ConnectorSingleton.getInstance();
  try {
    const isImage = asset.original.reference?.classification.generic === ClassificationGenericEnum.Image;
    let ret = asset;
    if (isImage) {
      const ocrId = asset.original.reference?.analysis?.image?.ocr?.raw.id;
      if (!ocrId) {
        console.log("No OCRId Available");
        return asset;
      }
      const format5 = asset.formats.iterable?.find(
        (format6) => format6.id === ocrId
      );
      if (!format5) {
        console.log("Failed to find the format on an asset");
        return asset;
      }
      format5.file = void 0;
      format5.fragment = void 0;
      await config5.formatApi.formatReclassify({
        formatReclassification: {
          ext,
          format: format5
        }
      });
      ret = await config5.assetApi.assetSnapshot({
        asset: asset.id,
        transferables: true
      });
    } else {
      const reclassification = {
        asset,
        ext
      };
      const params = {
        assetReclassification: reclassification,
        transferables: false
      };
      ret = await config5.assetApi.assetReclassify(params);
    }
    return ret;
  } catch (error) {
    console.error(error);
    return;
  }
};
var update = async ({
  asset
}) => {
  const config5 = ConnectorSingleton.getInstance();
  const notifications = Notifications.getInstance();
  try {
    const ret = await config5.assetApi.assetUpdate({ asset });
    notifications.information({ message: Constants.UPDATE_SUCCESS });
    return ret;
  } catch (error) {
    console.error(error);
    notifications.error({
      message: Constants.UPDATE_FAILURE,
      actions: [
        {
          title: "Contact Support",
          type: "OPEN_LINK" /* OPEN_LINK */,
          params: { url: "https://docs.pieces.app/support" }
        }
      ]
    });
    return;
  }
};
var updateFormat = async ({ format: format5 }) => {
  const config5 = ConnectorSingleton.getInstance();
  try {
    const ret = await config5.formatApi.formatUpdateValue({ format: format5 });
    return ret;
  } catch (error) {
    console.error(error);
    return;
  }
};

// src/utils/langExtToClassificationSpecific.ts
function langExtToClassificationSpecificEnum(ext) {
  ext = ext.toLowerCase();
  switch (ext) {
    case "batchfile":
    case "bat":
      return ClassificationSpecificEnum.Bat;
    case "c#":
    case "c-sharp":
    case "cs":
      return ClassificationSpecificEnum.Cs;
    case "coffeescript":
    case "coffee":
      return ClassificationSpecificEnum.Coffee;
    case "clojure":
    case "clj":
      return ClassificationSpecificEnum.Clj;
    case "erlang":
    case "erl":
      return ClassificationSpecificEnum.Erl;
    case "el":
      return ClassificationSpecificEnum.El;
    case "ex":
      return ClassificationSpecificEnum.Ex;
    case "groovy":
      return ClassificationSpecificEnum.Groovy;
    case "haskell":
    case "hs":
      return ClassificationSpecificEnum.Hs;
    case "kt":
      return ClassificationSpecificEnum.Kt;
    case "lua":
      return ClassificationSpecificEnum.Lua;
    case "markdown":
    case "md":
      return ClassificationSpecificEnum.Md;
    case "matlab":
      return ClassificationSpecificEnum.Matlab;
    case "objective-c":
    case "objective":
    case "m":
      return ClassificationSpecificEnum.M;
    case "c":
      return ClassificationSpecificEnum.C;
    case "cpp":
    case "c++":
    case "cc":
    case "hh":
    case "h":
      return ClassificationSpecificEnum.Cpp;
    case "css":
      return ClassificationSpecificEnum.Css;
    case "go":
      return ClassificationSpecificEnum.Go;
    case "html":
      return ClassificationSpecificEnum.Html;
    case "htm":
      return ClassificationSpecificEnum.Htm;
    case "java":
      return ClassificationSpecificEnum.Java;
    case "javascript":
    case "js":
      return ClassificationSpecificEnum.Js;
    case "json":
      return ClassificationSpecificEnum.Json;
    case "typescript":
    case "ts":
      return ClassificationSpecificEnum.Ts;
    case "dart":
      return ClassificationSpecificEnum.Dart;
    case "scala":
      return ClassificationSpecificEnum.Scala;
    case "sql":
      return ClassificationSpecificEnum.Sql;
    case "perl":
    case "pl":
      return ClassificationSpecificEnum.Pl;
    case "php":
      return ClassificationSpecificEnum.Php;
    case "python":
    case "py":
      return ClassificationSpecificEnum.Py;
    case "powershell":
    case "ps1":
      return ClassificationSpecificEnum.Ps;
    case "plaintext":
    case "txt":
    case "text":
      return ClassificationSpecificEnum.Text;
    case "r":
      return ClassificationSpecificEnum.R;
    case "ruby":
    case "rb":
      return ClassificationSpecificEnum.Rb;
    case "shell":
    case "sh":
      return ClassificationSpecificEnum.Sh;
    case "swift":
      return ClassificationSpecificEnum.Swift;
    case "tex":
      return ClassificationSpecificEnum.Tex;
    case "rust":
    case "rs":
      return ClassificationSpecificEnum.Rs;
    case "toml":
      return ClassificationSpecificEnum.Toml;
    case "xml":
      return ClassificationSpecificEnum.Xml;
    case "yaml":
    case "yml":
      return ClassificationSpecificEnum.Yaml;
    default:
      return ClassificationSpecificEnum.Js;
  }
}

// src/utils/annotationHandler.ts
var AnnotationHandler = class {
  constructor() {
  }
  static getInstance() {
    return AnnotationHandler.instance ?? (AnnotationHandler.instance = new AnnotationHandler());
  }
  sortAnnotationsByCreated({
    annotations,
    ascending = true
  }) {
    return annotations.sort((a, b) => {
      const timeA = new Date(a.created.value).getTime();
      const timeB = new Date(b.created.value).getTime();
      return ascending ? timeA - timeB : timeB - timeA;
    });
  }
  sortAnnotationsByUpdated({
    annotations,
    ascending = true
  }) {
    return annotations.sort((a, b) => {
      const timeA = new Date(a.updated.value).getTime();
      const timeB = new Date(b.updated.value).getTime();
      return ascending ? timeA - timeB : timeB - timeA;
    });
  }
  getFavorited(annotations) {
    return annotations.filter((a) => a.favorited);
  }
  annotationsAreEqual(arr1, arr2) {
    if (arr1.length !== arr2.length) {
      return false;
    }
    const arr1Map = new Map(
      arr1.map((item) => [
        item.id,
        { text: item.text, favorited: item.favorited }
      ])
    );
    const arr2Map = new Map(
      arr2.map((item) => [
        item.id,
        { text: item.text, favorited: item.favorited }
      ])
    );
    for (const [id, annotation] of arr1Map) {
      const cur = arr2Map.get(id);
      if (!cur)
        return false;
      if (cur.text !== annotation.text)
        return false;
      if (cur.favorited !== annotation.favorited)
        return false;
    }
    return true;
  }
};

// src/ui/modals/edit-asset-modal.ts
var EditModal = class extends import_obsidian5.Modal {
  constructor(app2, snippetObject) {
    super(app2);
    this.snippetTitle = snippetObject.title;
    this.snippetId = snippetObject.id;
    this.snippetContent = snippetObject.raw;
    this.snippetLanguage = snippetObject.language;
    this.seperatedRaw = (snippetObject.raw || "").split("\n");
    this.snippetAnnotations = snippetObject.annotations || [];
  }
  onOpen() {
    const { contentEl } = this;
    const editForm = contentEl.createEl("div");
    editForm.addClass("edit-form");
    const modalTitleRow = editForm.createDiv();
    modalTitleRow.addClasses(["edit-form-row", "verticalAlign"]);
    const modalTitle = modalTitleRow.createEl("h1");
    modalTitle.addClasses(["edit-form-col", "edit-text-title"]);
    modalTitle.setText("Edit Snippet: ");
    const titleRow = editForm.createDiv();
    titleRow.addClasses(["edit-form-row", "verticalAlign"]);
    const languageDiv = titleRow.createDiv();
    languageDiv.addClasses(["edit-form-col", "col-small"]);
    const languageLabel = languageDiv.createEl("span", {
      text: "Language:"
    });
    languageLabel.addClasses(["edit-form-row", "edit-text", "justify-left"]);
    const classificationDropdown = new import_obsidian5.DropdownComponent(languageDiv);
    classificationDropdown.selectEl.addClasses([
      "edit-dropdown",
      "edit-form-row"
    ]);
    for (const classification of Object.keys(searchLangSpecificEnum)) {
      if (classification === "txt" || classification === "yml" || classification === "tml")
        continue;
      const value = searchLangSpecificEnum[classification];
      classificationDropdown.addOption(value, value);
    }
    classificationDropdown.selectEl.value = searchLangSpecificEnum[this.snippetLanguage] ?? ClassificationSpecificEnum.Dart;
    const titleDiv = titleRow.createDiv();
    titleDiv.addClasses(["edit-form-col"]);
    const titleLabel = titleDiv.createEl("span", { text: "Title:" });
    titleLabel.addClasses(["edit-form-row", "edit-text", "justify-left"]);
    this.titleInput = titleDiv.createEl("input");
    this.titleInput.setAttribute("type", "text");
    this.titleInput.setAttribute("value", this.snippetTitle);
    this.titleInput.setAttribute("id", "titleInput");
    this.titleInput.setAttribute("placeholder", "Snippet Title");
    this.titleInput.onchange = (e3) => {
      this.snippetTitle = this.titleInput.value;
    };
    this.titleInput.addClass("edit-title-input");
    const snippet = contentEl.createEl("div");
    snippet.addClasses(["snippet-form-row", "snippet"]);
    const snippetDiv = snippet.createEl("div");
    snippetDiv.addClass("pieces-parent", "!max-h-[400px]");
    snippetDiv.setAttribute("id", "editParent");
    const lineNumDiv = snippetDiv.createEl("div");
    lineNumDiv.addClass("lineNums");
    const rawCodeDiv = snippetDiv.createEl("div");
    rawCodeDiv.addClass("rawCode");
    const preElement = rawCodeDiv.createEl("pre");
    preElement.addClasses(["snippet_pre", "line-numbers"]);
    preElement.contentEditable = "true";
    for (let i2 = 0; i2 < this.seperatedRaw.length; i2++) {
      const lineNum = contentEl.createEl("code", {
        text: (i2 + 1).toString()
      });
      lineNum.addClasses(["snippet_line_number"]);
      lineNumDiv.appendChild(lineNum);
      lineNumDiv.createEl("br");
    }
    preElement.innerHTML = highlightSnippet({
      snippetContent: this.snippetContent || "",
      snippetLanguage: this.snippetLanguage
    });
    preElement.addEventListener("focusout", () => {
      this.snippetContent = preElement.innerText;
      const highlighted = highlightSnippet({
        snippetContent: this.snippetContent || "",
        snippetLanguage: langExtToClassificationSpecificEnum(
          this.snippetLanguage
        )
      });
      preElement.innerHTML = highlighted;
    });
    classificationDropdown.onChange(() => {
      this.snippetLanguage = classificationDropdown.getValue();
      const highlighted = highlightSnippet({
        snippetContent: this.snippetContent || "",
        snippetLanguage: langExtToClassificationSpecificEnum(
          this.snippetLanguage
        )
      });
      preElement.innerHTML = highlighted;
    });
    const saveRow = contentEl.createDiv();
    saveRow.addClass("edit-form-row");
    new import_obsidian5.ButtonComponent(saveRow).setButtonText("Save Changes").onClick(async () => {
      await this.updateHandler();
    }).setTooltip("Save changes").setClass("button");
  }
  async updateHandler() {
    try {
      const config5 = ConnectorSingleton.getInstance();
      let asset = await config5.assetApi.assetSnapshot({
        asset: this.snippetId,
        transferables: false
      });
      const isImage = asset.original.reference?.classification.generic === ClassificationGenericEnum.Image;
      let originalClassification;
      if (isImage) {
        const ocrId = asset.original.reference?.analysis?.image?.ocr?.raw.id;
        const format5 = asset.formats.iterable?.find(
          (frmt) => frmt.id === ocrId
        );
        originalClassification = format5?.classification.specific;
      } else {
        originalClassification = asset.original?.reference?.classification.specific ?? ClassificationSpecificEnum.Dart;
      }
      if (this.snippetLanguage !== originalClassification) {
        const newClassification = SearchLangToClassificationEnum[this.snippetLanguage];
        asset = await reclassify({
          asset,
          ext: newClassification
        }) || asset;
      }
      if (asset.name !== this.snippetTitle || // if the title or description changed
      AnnotationHandler.getInstance().annotationsAreEqual(
        asset.annotations?.iterable ?? [],
        this.snippetAnnotations
      )) {
        asset.name = this.snippetTitle;
        asset.annotations = {
          iterable: this.snippetAnnotations
        };
        asset = await update({ asset }) || asset;
      }
      const processed = processAsset({ asset });
      if (processed.raw !== this.snippetContent) {
        const id = isImage ? asset.original.reference?.analysis?.image?.ocr?.raw.id : asset.preview.base.id;
        const encoder = new TextEncoder();
        const format5 = asset.formats.iterable?.find(
          (element) => element.id === id
        );
        if (isImage) {
          format5.file = {
            bytes: {
              raw: Array.from(encoder.encode(this.snippetContent))
            }
          };
        } else {
          format5.fragment = {
            string: {
              raw: this.snippetContent
            }
          };
        }
        updateFormat({ format: format5 });
      }
      this.close();
    } catch (error) {
      console.log(error);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.titleInput.removeEventListener("change", (e3) => {
      this.snippetTitle = this.titleInput.value;
    });
  }
};

// src/ui/modals/edit-annotations-modal.ts
var import_obsidian6 = require("obsidian");
var import_obsidian7 = require("obsidian");
var AnnotationsModal = class extends import_obsidian6.Modal {
  constructor(app2, snippetObject) {
    super(app2);
    this.addAnnotationWidget = (AnnotationCol) => {
      const AddAnnotationWidget = AnnotationCol.createDiv();
      AddAnnotationWidget.classList.add(
        "row",
        "width-full",
        "width-max",
        "annotation-add-body"
      );
      const AnnotationText = AddAnnotationWidget.createEl("span");
      AnnotationText.classList.add(
        "width-full",
        "width-max",
        "annotation-add-text-body"
      );
      AnnotationText.innerText = "Add Annotation +";
      AddAnnotationWidget.addEventListener("click", async () => {
        const seperator = this.annotationWidgetSeperator();
        AnnotationCol.prepend(
          this.annotationWidget(
            {
              type: AnnotationTypeEnum.Description,
              text: "",
              id: v4_default(),
              created: {
                value: new Date()
              },
              updated: {
                value: new Date()
              }
            },
            true,
            seperator
          )
        );
        AnnotationCol.prepend(seperator);
        AnnotationCol.prepend(AddAnnotationWidget);
      });
    };
    this.annotationWidget = (annotation, isNew = false, seperator) => {
      annotation.created.value = new Date(annotation.created.value);
      annotation.updated.value = new Date(annotation.updated.value);
      const AnnotationWidget = document.createElement("div");
      AnnotationWidget.classList.add(
        "row",
        "width-full",
        "width-max",
        "annotation-body"
      );
      const AnnotationWidgetBody = AnnotationWidget.createDiv();
      AnnotationWidgetBody.classList.add("col", "width-full", "width-max");
      const AnnotationText = AnnotationWidgetBody.createEl("span");
      AnnotationText.contentEditable = "true";
      AnnotationText.classList.add(
        "width-full",
        "width-max",
        "annotation-text-height-max",
        "annotation-text-height-min",
        "annotation-text-body"
      );
      AnnotationText.innerText = annotation.text;
      const AnnotationMetaRow = AnnotationWidgetBody.createDiv();
      AnnotationMetaRow.classList.add(
        "row",
        "width-full",
        "width-max",
        "annotation-metadata"
      );
      const AnnotationMetaRowLeft = AnnotationMetaRow.createDiv();
      AnnotationMetaRowLeft.addClasses(["annotation-metadata-left"]);
      AnnotationMetaRowLeft.innerHTML = Constants.ENRICH_ICON;
      const annotationDate = AnnotationMetaRowLeft.createEl("span");
      annotationDate.textContent = `Added ${annotation.created.readable ?? "just now"}`;
      const AnnotationActionDiv = AnnotationMetaRowLeft.createDiv();
      AnnotationActionDiv.addClasses(["annotation-action-row"]);
      const favoriteBtn = AnnotationActionDiv.createDiv();
      favoriteBtn.addClasses(["annotation-metadata-left-btn"]);
      favoriteBtn.title = "Favorite annotation";
      favoriteBtn.onclick = () => {
        annotation.favorited = annotation.favorited ? false : true;
        favoriteBtn.style.color = annotation.favorited ? "yellow" : theme === "dark" ? "white" : "black";
        this.handleCrupdate(annotation, AnnotationText, isNew, true).then(
          (newAnnotation) => {
            if (annotation.id !== newAnnotation.id)
              isNew = false;
            annotation = newAnnotation;
          }
        );
      };
      favoriteBtn.innerHTML = (0, import_obsidian7.getIcon)("star").outerHTML;
      favoriteBtn.style.color = annotation.favorited ? "yellow" : theme === "dark" ? "white" : "black";
      const saveBtn = AnnotationActionDiv.createDiv();
      saveBtn.addClasses(["annotation-metadata-left-btn"]);
      saveBtn.innerHTML = Constants.SAVE_ALL_ICON;
      saveBtn.title = "Save annotation";
      saveBtn.style.color = theme === "dark" ? "white" : "black";
      saveBtn.onclick = async () => {
        this.handleCrupdate(annotation, AnnotationText, isNew).then(
          (newAnnotation) => {
            if (annotation.id !== newAnnotation.id)
              isNew = false;
            annotation = newAnnotation;
          }
        );
      };
      const deleteBtn = AnnotationActionDiv.createDiv();
      deleteBtn.addClass("annotation-metadata-left-btn", "annotation-delete");
      deleteBtn.onclick = async () => {
        seperator.remove();
        this.handleDelete(annotation, AnnotationWidget, isNew);
      };
      deleteBtn.innerHTML = (0, import_obsidian7.getIcon)("trash-2").outerHTML;
      deleteBtn.title = "Delete annotation";
      deleteBtn.style.color = "red";
      const AnnotationMetaRowRight = AnnotationMetaRow.createDiv();
      const typeDropdown = new import_obsidian6.DropdownComponent(AnnotationMetaRowRight);
      Object.values(AnnotationTypeEnum).forEach((type) => {
        typeDropdown.addOption(type, type.replace("_", " "));
      });
      typeDropdown.setValue(annotation.type);
      typeDropdown.onChange((value) => {
        annotation.type = value;
        this.handleCrupdate(annotation, AnnotationText, isNew, false, true).then(
          (newAnnotation) => {
            if (annotation.id !== newAnnotation.id)
              isNew = false;
            annotation = newAnnotation;
          }
        );
      });
      AnnotationActionDiv.addClasses(["actions-hidden"]);
      AnnotationWidget.onmouseenter = () => {
        AnnotationActionDiv.classList.remove("hidden-out");
        AnnotationActionDiv.classList.add("hidden-in");
      };
      AnnotationWidget.onmouseleave = () => {
        if (AnnotationText.innerText === annotation.text) {
          AnnotationActionDiv.classList.remove("hidden-in");
          AnnotationActionDiv.classList.add("hidden-out");
        }
      };
      return AnnotationWidget;
    };
    this.handleDelete = (annotation, AnnotationWidget, isNew) => {
      AnnotationWidget.remove();
      const config5 = ConnectorSingleton.getInstance();
      if (!isNew) {
        config5.annotationsApi.annotationsDeleteSpecificAnnotation({
          annotation: annotation.id
        }).then(() => {
          Notifications.getInstance().information({
            message: "Annotation deletion success!"
          });
        }).catch((e3) => {
          Notifications.getInstance().error({
            message: "Error deleting that annotation! If the issue persists, please contact support. Make sure that Pieces OS is installed, up to date, and running.",
            actions: [
              {
                title: "Contact Support",
                type: "OPEN_LINK" /* OPEN_LINK */,
                params: { url: "https://docs.pieces.app/support" }
              }
            ]
          });
        });
      }
    };
    this.handleCrupdate = async (annotation, AnnotationText, isNew, favorite, typeChange) => {
      if (AnnotationText.innerText === annotation.text && !favorite && !typeChange) {
        Notifications.getInstance().error({
          message: "Please modify your annotation to save changes!"
        });
        return annotation;
      } else if (!AnnotationText.innerText) {
        Notifications.getInstance().error({
          message: "Please add some text to your annotation to save changes!"
        });
        return annotation;
      }
      annotation.text = AnnotationText.innerText ?? "";
      if (isNew) {
        isNew = false;
        const config5 = ConnectorSingleton.getInstance();
        return config5.annotationsApi.annotationsCreateNewAnnotation({
          seededAnnotation: {
            asset: this.snippetId,
            type: annotation.type,
            text: annotation.text
          }
        }).then((newAnnotation) => {
          Notifications.getInstance().information({
            message: "Annotation creation was a success!"
          });
          return newAnnotation;
        }).catch(() => {
          Notifications.getInstance().error({
            message: "Something went wrong creating that annotation! If the issue persists, please contact support. Make sure that Pieces OS is installed, up to date, and running!",
            actions: [
              {
                title: "Contact Support",
                type: "OPEN_LINK" /* OPEN_LINK */,
                params: { url: "https://docs.pieces.app/support" }
              }
            ]
          });
          return annotation;
        });
      } else {
        return this.updateHandler(annotation);
      }
    };
    this.annotationWidgetSeperator = () => {
      const AnnotationWidgetSeperator = document.createElement("div");
      AnnotationWidgetSeperator.classList.add(
        "row",
        "width-full",
        "width-max",
        "annotation-seperator"
      );
      const AnnotationWidgetSeperatorBody = AnnotationWidgetSeperator.createDiv();
      AnnotationWidgetSeperatorBody.classList.add(
        "col",
        "width-full",
        "width-max"
      );
      return AnnotationWidgetSeperator;
    };
    this.snippetTitle = snippetObject.title;
    this.snippetId = snippetObject.id;
    this.snippetContent = snippetObject.raw;
    this.snippetLanguage = snippetObject.language;
    this.seperatedRaw = (snippetObject.raw || "").split("\n");
    this.snippetAnnotations = snippetObject.annotations || [];
  }
  onOpen() {
    const { contentEl, titleEl } = this;
    const modalTitle = titleEl.createEl("h1");
    modalTitle.setText("Annotations ");
    const annotationForm = contentEl.createEl("div");
    annotationForm.addClass("annotation-form");
    const AnnotationRow = annotationForm.createDiv();
    AnnotationRow.addClasses(["row", "v-align-center", "h-align-center"]);
    const AnnotationCol = AnnotationRow.createDiv();
    AnnotationCol.addClasses([
      "col",
      "v-align-center",
      "h-align-center",
      "width-full"
    ]);
    this.addAnnotationWidget(AnnotationCol);
    for (let i2 = 0; i2 < this.snippetAnnotations.length; i2++) {
      const seperator = this.annotationWidgetSeperator();
      AnnotationCol.appendChild(seperator);
      AnnotationCol.appendChild(
        this.annotationWidget(this.snippetAnnotations[i2], false, seperator)
      );
    }
    const descRow = contentEl.createDiv();
    descRow.addClass("edit-form-row", "edit-form-desc");
    const saveRow = contentEl.createDiv();
    saveRow.addClass("edit-form-row");
  }
  async updateHandler(annotation) {
    const config5 = ConnectorSingleton.getInstance();
    return config5.annotationApi.annotationUpdate({ annotation }).then((newAnnotation) => {
      Notifications.getInstance().information({
        message: "Annotation updating was a success!"
      });
      return newAnnotation;
    }).catch((e3) => {
      console.error(e3);
      Notifications.getInstance().error({
        message: "Something went wrong updating that annotation! If the issue persists, please contact support. Make sure that Pieces OS is installed, up to date, and running!",
        actions: [
          {
            title: "Contact Support",
            type: "OPEN_LINK" /* OPEN_LINK */,
            params: { url: "https://docs.pieces.app/support" }
          }
        ]
      });
      return annotation;
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/actions/activities.ts
var ActivitySingleton = class {
  constructor() {
  }
  static getInstance() {
    return this.instance ?? (this.instance = new ActivitySingleton());
  }
  async referenced(id, query, copied = false) {
    const config5 = ConnectorSingleton.getInstance();
    const seededActivity = {
      application: config5.context.application,
      mechanism: MechanismEnum.Automatic,
      asset: {
        id
      },
      event: {
        asset: {
          asset: {
            id
          },
          identifierDescriptionPair: {
            assetReferenced: TrackedAssetEventIdentifierDescriptionPairsAssetReferencedEnum.AnAssetWasReferencedByTheUser
          }
        }
      }
    };
    if (copied) {
      seededActivity.event.asset.identifierDescriptionPair = {
        assetFormatCopied: TrackedAssetEventIdentifierDescriptionPairsAssetFormatCopiedEnum.AnAssetPreviewFormatWasCopied
      };
    }
    if (query) {
      seededActivity.event.asset.metadata = {
        search: {
          query
        }
      };
      seededActivity.event.asset.identifierDescriptionPair = {
        searchedAssetReferenced: TrackedAssetEventIdentifierDescriptionPairsSearchedAssetReferencedEnum.ASearchedAssetWasReferencedByTheUser
      };
    }
    return config5.activitiesApi.activitiesCreateNewActivity({
      transferables: false,
      seededActivity
    }).catch();
  }
  async installed() {
    const config5 = ConnectorSingleton.getInstance();
    const seededActivity = {
      application: config5.context.application,
      mechanism: MechanismEnum.Automatic,
      event: {
        adoption: {
          identifierDescriptionPair: {
            adoptionInstall: AnalyticsTrackedAdoptionEventIdentifierDescriptionPairsAdoptionInstallEnum.TheUserHasInstalledAPiecesApplication
          }
        }
      }
    };
    return config5.activitiesApi.activitiesCreateNewActivity({
      transferables: false,
      seededActivity
    }).catch();
  }
};

// src/ui/render/renderSnippet.ts
function renderSnippet({
  contentEl,
  snippetObject,
  seperatedRaw,
  newSnippet = false,
  discovery = false
}) {
  const snippet = contentEl.createEl("div");
  snippet.addClass("snippet");
  const snippetFormatted = "```" + LangSpecificEnum[snippetObject.language] + `:${snippetObject.id}
` + snippetObject.raw + "\n```";
  const snippetDiv = snippet.createEl("div");
  snippetDiv.addClass("pieces-parent");
  if (snippetObject.id !== "" && "discovery" /* DISCOVERY */ !== DisplayController.defaultView) {
    const imgWrapper = snippetDiv.createDiv();
    imgWrapper.addClass("expand-wrapper");
    const expandIconImg = imgWrapper.createEl("img");
    expandIconImg.setAttr("src", fullscreen_default);
    expandIconImg.setAttr("alt", "Expand icon");
    expandIconImg.addClass("expand-icon");
    expandIconImg.title = "Expand snippet view";
    expandIconImg.onclick = async () => {
      DisplayController.createExpandedView({
        snippetId: snippetObject.id,
        snippetTitle: snippetObject.title
      });
      ActivitySingleton.getInstance().referenced(snippetObject.id);
    };
  }
  const lineNumDiv = snippetDiv.createEl("div");
  lineNumDiv.addClass("lineNums");
  const rawCodeDiv = snippetDiv.createEl("div");
  rawCodeDiv.addClass("rawCode");
  const preElement = rawCodeDiv.createEl("pre");
  preElement.addClasses(["snippet_pre", "line-numbers"]);
  for (let i2 = 0; i2 < seperatedRaw.length; i2++) {
    const lineNum = contentEl.createEl("code", {
      text: (i2 + 1).toString()
    });
    lineNum.addClasses(["snippet_line_number"]);
    lineNumDiv.appendChild(lineNum);
    lineNumDiv.createEl("br");
  }
  preElement.innerHTML = highlightSnippet({
    snippetContent: snippetObject.raw || "",
    snippetLanguage: snippetObject.language
  });
  snippet.createEl("div").addClass("horizontalBreak");
  const footerDiv = snippet.createEl("div");
  footerDiv.addClass("footerDiv");
  const buttonDiv = footerDiv.createEl("div");
  buttonDiv.addClass("buttonDiv");
  if (newSnippet || discovery) {
    const saveButton = new import_obsidian8.ButtonComponent(buttonDiv).setButtonText("Save snippet").onClick(async () => {
      const cache2 = PiecesCacheSingleton.getInstance();
      const loading = buttonDiv.createEl("div");
      loading.addClass("bouncing-loader");
      loading.createEl("div");
      loading.createEl("div");
      loading.createEl("div");
      buttonDiv.replaceChild(loading, saveButton.buttonEl);
      await createAsset({
        selection: snippetObject.raw,
        name: snippetObject.title,
        annotations: snippetObject.annotations,
        lang: snippetObject.language
      });
      if (DisplayController.defaultView === "discovery" /* DISCOVERY */) {
        const discoverIndx = cache2.discoveredSnippets.findIndex((value) => {
          return value.id === snippetObject.id;
        });
        cache2.discoveredSnippets.splice(discoverIndx, 1);
      }
      DisplayController.triggerUIRedraw({ searching: false, fetch: false });
      buttonDiv.replaceChild(saveButton.buttonEl, loading);
    }).setIcon("save").setTooltip("Save snippet to Pieces").setClass("button_copy");
    buttonDiv.createEl("div").addClass("vertBreak");
  }
  new import_obsidian8.ButtonComponent(buttonDiv).setButtonText("Copy Snippet").onClick(async () => {
    await copyToClipboard(snippetFormatted);
    new import_obsidian8.Notice("Snippet copied to clipboard!");
    ActivitySingleton.getInstance().referenced(
      snippetObject.id,
      void 0,
      true
    );
  }).setIcon("copy").setTooltip("Copy snippet to clipboard").setClass("button_copy");
  buttonDiv.createEl("div").addClass("vertBreak");
  if (!newSnippet && !discovery) {
    new import_obsidian8.ButtonComponent(buttonDiv).setIcon("pencil").setTooltip("Edit snippet").onClick(async () => {
      new EditModal(this.app, snippetObject).open();
    }).setClass("button");
    buttonDiv.createEl("div").addClass("vertBreak");
    new import_obsidian8.ButtonComponent(buttonDiv).setIcon("sticky-note").setTooltip("Edit annotations").onClick(async () => {
      new AnnotationsModal(
        this.app,
        PiecesCacheSingleton.getInstance().mappedAssets[snippetObject.id]
      ).open();
    }).setClass("button");
    buttonDiv.createEl("div").addClass("vertBreak");
  }
  const shareButton = new import_obsidian8.ButtonComponent(buttonDiv).setButtonText("Share snippet").onClick(async () => {
    const notifications = Notifications.getInstance();
    const loading = buttonDiv.createEl("div");
    loading.addClass("bouncing-loader");
    loading.createEl("div");
    loading.createEl("div");
    loading.createEl("div");
    buttonDiv.replaceChild(loading, shareButton.buttonEl);
    if (newSnippet || discovery) {
      const id = await createAsset({
        selection: snippetObject.raw,
        name: snippetObject.title,
        annotations: snippetObject.annotations,
        lang: snippetObject.language
      });
      if (typeof id === "string") {
        const link = await this.shareableLinks.generate({ id });
        copyToClipboard(link ?? "");
      }
      DisplayController.triggerUIRedraw({ searching: false, fetch: false });
    } else {
      const shareableLink = snippetObject.share ?? await ShareableLinksService.getInstance().generate({
        id: snippetObject.id
      });
      await copyToClipboard(shareableLink || "");
      if (snippetObject.share) {
        notifications.information({
          message: Constants.LINK_GEN_COPY
        });
      }
    }
    buttonDiv.replaceChild(shareButton.buttonEl, loading);
  }).setIcon("share-2").setTooltip("Copy a shareable link to clipboard").setClass("button");
  buttonDiv.appendChild(shareButton.buttonEl);
  buttonDiv.createEl("div").addClass("vertBreak");
  if (!newSnippet && !discovery) {
    new import_obsidian8.ButtonComponent(footerDiv).setIcon("trash-2").onClick(() => {
      new DeleteModal(
        this.app,
        snippetObject.title,
        snippetObject.id,
        contentEl
      ).open();
    }).setTooltip("Delete snippet").setClass("button_delete");
  }
  return snippet;
}

// src/ui/render/renderSearchBox.ts
var import_obsidian10 = require("obsidian");

// src/actions/draft_asset.ts
var draft_asset = ({ text }) => {
  const config5 = ConnectorSingleton.getInstance();
  const params = {
    seed: {
      asset: {
        application: config5.context.application,
        format: {
          fragment: {
            string: {
              raw: text
            }
          },
          classification: {
            specific: ClassificationSpecificEnum.Py
          }
        }
      },
      type: SeedTypeEnum.Asset
    }
  };
  return config5.assetsApi.assetsDraft(params);
};

// src/utils/shuffle.ts
var shuffle = (array) => {
  for (let i2 = array.length - 1; i2 > 0; i2--) {
    const j = Math.floor(Math.random() * (i2 + 1));
    [array[i2], array[j]] = [array[j], array[i2]];
  }
  return array;
};

// src/actions/discover_snippets.ts
var import_obsidian9 = require("obsidian");
var Discovery = class {
  constructor() {
  }
  static async discoverSnippets() {
    const cache2 = PiecesCacheSingleton.getInstance();
    this.discovery_loaded = false;
    if (DisplayController.discoveryProgressBar) {
      DisplayController.discoveryProgressBar.reset();
      DisplayController.discoveryProgressBar.show();
    }
    const allFiles = shuffle(app.vault.getMarkdownFiles());
    cache2.discoveredSnippets = [];
    for (let i2 = 0; i2 < allFiles.length; i2++) {
      if (pluginSettings.autoDiscoverMaximum <= cache2.discoveredSnippets.length)
        break;
      const fileData = await app.vault.read(allFiles[i2]);
      await this.findCodeBlocks(fileData);
      if (i2 === 0 && DisplayController.defaultView === "discovery" /* DISCOVERY */) {
        DisplayController.triggerUIRedraw({ searching: false, fetch: false });
      }
    }
    if (DisplayController.discoveryProgressBar) {
      DisplayController.discoveryProgressBar.setFinished(
        pluginSettings.autoDiscoverMaximum
      );
      DisplayController.discoveryProgressBar.hide();
    }
    this.discovery_loaded = true;
    if (cache2.discoveredSnippets.length === 0) {
      new import_obsidian9.Notice("Couldn't find any snippets in your vault!", 1e3);
      if (DisplayController.defaultView === "discovery" /* DISCOVERY */) {
        DisplayController.triggerUIRedraw({ searching: false, fetch: false });
      }
      return;
    } else {
      new import_obsidian9.Notice("Finished discovering snippets!", 1e3);
    }
  }
  /*
  	Finds all the markdown code fences in a string via ```{language} ```
  	returns array of CodeBlocks (the code within the fence, and the language)
  */
  static async findCodeBlocks(data) {
    const cache2 = PiecesCacheSingleton.getInstance();
    const codeFenceRegex = /```([\w-]+)(?::[\s\S]*?)?\n([\s\S]*?)```/g;
    let match;
    while ((match = codeFenceRegex.exec(data)) !== null) {
      if (pluginSettings.autoDiscoverMaximum <= cache2.discoveredSnippets.length)
        break;
      const [, lang, code] = match;
      code.trim();
      await this.populateDiscoveredSnippet({ lang, code });
    }
  }
  /*
  	This is the general pipeline a code block will go through once it is spotted in the markdown
  	1. call discovery endpoint
  	2. call draft endpoint
  	3. render generated results to the discovery view
  */
  static async populateDiscoveredSnippet(codeBlock) {
    const cache2 = PiecesCacheSingleton.getInstance();
    const notifications = Notifications.getInstance();
    const config5 = ConnectorSingleton.getInstance();
    const discoverable = {};
    const seed = {
      string: {
        raw: codeBlock.code
      },
      metadata: {
        ext: langExtToClassificationSpecificEnum(codeBlock.lang)
      }
    };
    if (codeBlock.code.split("\n").length > 50) {
      discoverable.file = seed;
    } else {
      discoverable.fragment = seed;
    }
    if (!discoverable) {
      notifications.error({
        message: "Something went wrong, we weren't able to discover a snippet"
      });
      return;
    }
    const params = {
      automatic: false,
      seededDiscoverableAssets: {
        application: config5.context.application.id,
        iterable: [discoverable]
      }
    };
    const discovery_result = await config5.DiscoveryApi.discoveryDiscoverAssets(
      params
    );
    let _text;
    if (discovery_result.iterable[0] === void 0 || !discovery_result.iterable[0].fragment?.string?.raw) {
      return;
    } else {
      _text = discovery_result.iterable[0].fragment?.string?.raw;
    }
    const draft_res = await draft_asset({
      text: _text
    });
    const snippetObject = {
      id: v4_default(),
      title: draft_res.asset?.metadata?.name ?? "Unknown Title",
      raw: discoverable.fragment?.string?.raw ?? discoverable.file?.string?.raw ?? "unable to unpack snippet",
      created: new Date(),
      updated: new Date(),
      language: discoverable.file?.metadata?.ext ?? discoverable.fragment?.metadata?.ext ?? ClassificationSpecificEnum.Ts,
      annotations: draft_res.asset?.metadata?.annotations?.map((el) => {
        const ret = {
          type: el.type,
          text: el.text,
          id: v4_default(),
          updated: {
            value: new Date()
          },
          created: {
            value: new Date()
          }
        };
        if (el.asset) {
          ret.asset = {
            id: el.asset
          };
        }
        return ret;
      }) ?? [],
      type: draft_res.asset?.format.classification?.specific ?? "Unknown type",
      time: new Date().toISOString(),
      share: void 0
    };
    cache2.discoveredSnippets.push(snippetObject);
    if (DisplayController.defaultView === "discovery" /* DISCOVERY */) {
      const snippetCacheLength = cache2.discoveredSnippets.length;
      if (snippetCacheLength === 1) {
        const loadingDivs = document.querySelectorAll(".loading-div");
        loadingDivs.forEach((loadingDiv) => {
          loadingDiv.remove();
        });
        DisplayController.createListView({
          containerVar: DisplayController.defaultContainer,
          snippets: cache2.discoveredSnippets,
          discovery: true
        });
      } else if (snippetCacheLength > 1) {
        const parentDiv = document.getElementById(
          "pieces-snippet-container"
        );
        parentDiv.firstChild.classList.remove(
          "only-snippet"
        );
        renderListView({
          contentEl: parentDiv,
          snippetObject,
          discovery: true
        });
      }
      if (DisplayController.discoveryProgressBar)
        DisplayController.discoveryProgressBar.update({
          value: snippetCacheLength
        });
    }
    if (pluginSettings.autoDiscoverMaximum > cache2.discoveredSnippets.length) {
      if (cache2.discoveredSnippets.length < 5) {
        await sleep(1e3);
      } else {
        await sleep(8e3);
      }
    }
  }
};
Discovery.discovery_loaded = false;

// src/ui/render/renderSearchBox.ts
var defaultSearchQuery = "";
var searchResultsView = false;
var renderSearchBox = ({
  containerVar
}) => {
  const SearchBoxDiv = containerVar.createEl("div");
  SearchBoxDiv.addClass("search-box-div");
  const searchInput = SearchBoxDiv.createEl("input", {
    type: "text",
    placeholder: "\u{1F50D}  Search for Snippets..."
  });
  searchInput.addClass("input-search");
  searchInput.id = "input-search";
  searchInput.value = defaultSearchQuery;
  searchInput.readOnly = !versionValid || DisplayController.fetchFailed ? true : false;
  const searchButton = new import_obsidian10.ButtonComponent(SearchBoxDiv);
  if (searchResultsView) {
    searchButton.setIcon("x").onClick(async () => {
      searchResultsView = false;
      defaultSearchQuery = "";
      await DisplayController.triggerUIRedraw({
        searching: false,
        container: document.getElementById("snippets-tab"),
        fetch: false
      });
    }).setTooltip("Clear search").setClass("button_refresh");
  } else {
    searchButton.setIcon("refresh-cw").onClick(async () => {
      if ("discovery" /* DISCOVERY */ === DisplayController.defaultView) {
        new import_obsidian10.Notice(
          Discovery.discovery_loaded ? "Discovering Pieces..." : "We still haven't finished discovering your snippets, please wait.",
          1e3
        );
      } else {
        new import_obsidian10.Notice("Refreshing Pieces...", 1e3);
      }
      searchResultsView = false;
      defaultSearchQuery = "";
      const loading = SearchBoxDiv.createEl("div");
      loading.addClass("refresh-bouncing-loader");
      loading.createEl("div");
      loading.createEl("div");
      loading.createEl("div");
      SearchBoxDiv.replaceChild(loading, searchButton.buttonEl);
      if ("discovery" /* DISCOVERY */ === DisplayController.defaultView) {
        if (Discovery.discovery_loaded) {
          try {
            DisplayController.clearDiscovery();
            await Discovery.discoverSnippets();
          } catch (e3) {
          }
        }
      } else {
        try {
          await loadPieces();
          await DisplayController.triggerUIRedraw({
            searching: false,
            container: document.getElementById("snippets-tab"),
            fetch: false
          });
        } catch (e3) {
        }
      }
      SearchBoxDiv.replaceChild(searchButton.buttonEl, loading);
    }).setClass("button_refresh");
    if (DisplayController.defaultView === "discovery" /* DISCOVERY */) {
      searchButton.setTooltip("Discover Pieces");
    } else {
      searchButton.setTooltip("Refresh Pieces");
    }
  }
  searchInput.onkeyup = async (event) => {
    if (event.key === "Enter" && searchInput.value != "") {
      const loading = SearchBoxDiv.createEl("div");
      loading.addClass("refresh-bouncing-loader");
      loading.createEl("div");
      loading.createEl("div");
      loading.createEl("div");
      SearchBoxDiv.replaceChild(loading, searchButton.buttonEl);
      searchResultsView = true;
      defaultSearchQuery = searchInput.value;
      await DisplayController.triggerUIRedraw({
        searching: true,
        container: document.getElementById("snippets-tab"),
        searchQuery: searchInput.value
      });
      SearchBoxDiv.replaceChild(searchButton.buttonEl, loading);
    }
  };
};
var renderNavBar = ({
  containerVar
}) => {
  const wrapperDiv = containerVar.createDiv();
  wrapperDiv.addClass("wrapper");
  const tabsDiv = wrapperDiv.createDiv();
  tabsDiv.addClass("pieces-tabs");
  tabsDiv.id = "piecesTabs";
  const tabInput1 = tabsDiv.createEl("input");
  tabInput1.setAttr("type", "radio");
  tabInput1.setAttr("id", "radio-1");
  tabInput1.setAttr("name", "tabs-1");
  tabInput1.checked = true;
  const tabLabel1 = tabsDiv.createEl("label");
  tabLabel1.setAttr("for", "radio-1");
  tabLabel1.addClass("pieces-tab", "svg-box");
  tabLabel1.innerHTML = Constants.CODE_ICON;
  const tabInput2 = tabsDiv.createEl("input");
  tabInput2.setAttr("type", "radio");
  tabInput2.setAttr("id", "radio-2");
  tabInput2.setAttr("name", "tabs-2");
  const tabLabel2 = tabsDiv.createEl("label");
  tabLabel2.setAttr("for", "radio-2");
  tabLabel2.addClass("pieces-tab", "svg-box");
  tabLabel2.innerHTML = Constants.AI_ICON;
  const slider = tabsDiv.createEl("span");
  slider.addClass("glider");
  if (!(theme === "dark")) {
    slider.addClass("glider-light");
  }
  return wrapperDiv;
};

// src/ui/render/renderListView.ts
var renderListView = ({
  contentEl,
  snippetObject,
  opened = false,
  newAsset = false,
  discovery = false
}) => {
  const _annotationHandler = AnnotationHandler.getInstance();
  const ListView = contentEl.createEl("div");
  ListView.addClass("list-view");
  ListView.id = `list-view-${snippetObject.id}`;
  if (DisplayController.defaultView === "discovery" /* DISCOVERY */) {
    const discoveryDiv = ListView.createEl("div");
    discoveryDiv.addClass("discovery-div-parent");
    const selectAllCheckbox = discoveryDiv.createEl("input", {
      type: "checkbox"
    });
    selectAllCheckbox.addClasses(["discovery-checkbox"]);
    DisplayController.appendDiscovery({
      snippetCheckBox: selectAllCheckbox,
      snippetObject
    });
  }
  const snippetContentDiv = ListView.createEl("div");
  snippetContentDiv.addClass("snippet-content-parent");
  const titleDiv = snippetContentDiv.createEl("div");
  titleDiv.addClass("list-title-div");
  const titleWrapper = titleDiv.createDiv();
  titleWrapper.addClass("list-title-wrapper");
  if (DisplayController.defaultView === "discovery" /* DISCOVERY */) {
    const seperator = titleWrapper.createEl("span");
    seperator.addClass("discovery-seperator");
    seperator.innerText = " ";
  }
  const imageLang = titleWrapper.createEl("img");
  imageLang.setAttr("src", getIcon(snippetObject.language));
  imageLang.setAttr("alt", "Pieces language logo");
  imageLang.addClass("list-title-div");
  imageLang.setAttr("width", "20px");
  imageLang.setAttr("height", "20px");
  const title = titleWrapper.createEl("h4");
  title.addClass("list-title-div");
  title.innerText = snippetObject.title;
  const body = snippetContentDiv.createEl("div");
  body.addClass("list-body");
  let annotationText = _annotationHandler.getFavorited(snippetObject.annotations ?? []).map((el) => el.text).join("\n");
  if (annotationText.length === 0)
    annotationText = _annotationHandler.sortAnnotationsByUpdated({
      annotations: snippetObject.annotations ?? []
    })[0]?.text.replace(/\n/g, " ") ?? "";
  body.innerText = annotationText;
  const buttonContainer = snippetContentDiv.createEl("div");
  buttonContainer.addClass("list-button-container");
  let newSnippet;
  if (newAsset) {
    const seperatedRaw = snippetObject.raw?.split("\n");
    newSnippet = renderSnippet({
      contentEl: ListView,
      snippetObject,
      seperatedRaw: seperatedRaw || [],
      newSnippet: newAsset,
      discovery
    });
    ListView.appendChild(newSnippet);
    return ListView;
  }
  const buttonInput = snippetContentDiv.createEl("input", {
    attr: { type: "checkbox" }
  });
  buttonInput.addClass("list-button-input");
  buttonInput.disabled = true;
  const buttonContentOpen = buttonContainer.createEl("span");
  buttonContentOpen.innerText = "View Code \u25BC";
  buttonContentOpen.addClass("list-button-content");
  const buttonContentClosed = buttonContainer.createEl("span");
  buttonContentClosed.innerText = "View Code \u25B6";
  buttonContentClosed.addClass("list-button-content");
  if (buttonInput.checked) {
    buttonContainer.removeChild(buttonContentClosed);
  } else {
    buttonContainer.removeChild(buttonContentOpen);
  }
  if (opened) {
    buttonInput.checked = true;
    const seperatedRaw = snippetObject.raw?.split("\n");
    newSnippet = renderSnippet({
      contentEl: ListView,
      snippetObject,
      seperatedRaw: seperatedRaw || [],
      discovery
    });
    buttonContainer.replaceChild(buttonContentOpen, buttonContentClosed);
    ListView.appendChild(newSnippet);
  }
  let clickTimer = null;
  snippetContentDiv.onclick = async () => {
    if (clickTimer === null) {
      clickTimer = setTimeout(() => {
        buttonInput.checked = !buttonInput.checked;
        if (buttonInput.checked) {
          const seperatedRaw = snippetObject.raw?.split("\n");
          newSnippet = renderSnippet({
            contentEl: ListView,
            snippetObject,
            seperatedRaw: seperatedRaw || [],
            discovery
          });
          buttonContainer.replaceChild(buttonContentOpen, buttonContentClosed);
          ListView.appendChild(newSnippet);
        } else {
          buttonContainer.replaceChild(buttonContentClosed, buttonContentOpen);
          newSnippet.empty();
          ListView.removeChild(newSnippet);
        }
        clickTimer = null;
        if (defaultSearchQuery !== "" && buttonInput.checked) {
          ActivitySingleton.getInstance().referenced(
            snippetObject.id,
            defaultSearchQuery
          );
        }
      }, 140);
    } else {
      clearTimeout(clickTimer);
      clickTimer = null;
      if (DisplayController.defaultView !== "discovery" /* DISCOVERY */) {
        DisplayController.createExpandedView({
          snippetId: snippetObject.id,
          snippetTitle: snippetObject.title
        });
        ActivitySingleton.getInstance().referenced(snippetObject.id);
      }
    }
  };
  return ListView;
};

// src/ui/render/renderLanguageView.ts
var renderLanguageView = ({
  containerVar
}) => {
  const cache2 = PiecesCacheSingleton.getInstance();
  const snippetContainer = containerVar.createEl("div");
  snippetContainer.addClass("snippet-container");
  snippetContainer.id = "language-snippet-container";
  const sortedArray = Array.from(cache2.snippetMap.entries());
  sortedArray.sort((a, b) => a[0].localeCompare(b[0]));
  cache2.snippetMap = new Map(sortedArray);
  for (const [key, value] of cache2.snippetMap) {
    let snippetsInRange = value;
    const CodeView = snippetContainer.createEl("div");
    CodeView.addClass("code-view");
    CodeView.id = "code-view-" + searchLangSpecificEnum[key];
    const titleDiv = CodeView.createEl("div");
    titleDiv.addClass("code-title-div");
    const imageLang = titleDiv.createEl("img");
    const iconImage = getIcon(key);
    imageLang.setAttr("src", iconImage);
    imageLang.setAttr("alt", "Code language logo");
    imageLang.addClass("code-title-div");
    const title = titleDiv.createEl("h1");
    title.innerText = searchLangSpecificEnum[key];
    title.addClass("code-title-div");
    const buttonContentOpen = titleDiv.createEl("span");
    buttonContentOpen.innerText = "\u2304";
    buttonContentOpen.addClass("code-title-div");
    const buttonContentClosed = titleDiv.createEl("span");
    buttonContentClosed.innerText = "\u203A";
    buttonContentClosed.addClass("code-title-div");
    const buttonInput = titleDiv.createEl("input", {
      attr: { type: "checkbox" }
    });
    buttonInput.addClass("code-button-input");
    buttonInput.id = "input-" + searchLangSpecificEnum[key];
    if (buttonInput.checked) {
      titleDiv.removeChild(buttonContentClosed);
    } else {
      titleDiv.removeChild(buttonContentOpen);
    }
    let newCodeView;
    buttonInput.onclick = () => {
      if (buttonInput.checked) {
        snippetsInRange = cache2.snippetMap.get(key) ?? [];
        for (let i2 = 0; i2 < snippetsInRange.length; i2++) {
          if (!cache2.mappedAssets[snippetsInRange[i2]]) {
            snippetsInRange.splice(i2, 1);
          }
        }
        const assetsInRange = snippetsInRange.map((snippetId) => {
          return cache2.mappedAssets[snippetId];
        });
        newCodeView = DisplayController.createListView({
          containerVar,
          snippets: assetsInRange.sort(
            (a, b) => b.created.getTime() - a.created.getTime()
          )
        });
        newCodeView.classList.add("!mt-0");
        CodeView.appendChild(newCodeView);
        titleDiv.removeChild(buttonContentClosed);
        titleDiv.appendChild(buttonContentOpen);
      } else {
        newCodeView.empty();
        CodeView.removeChild(newCodeView);
        titleDiv.removeChild(buttonContentOpen);
        titleDiv.appendChild(buttonContentClosed);
      }
    };
  }
};

// src/actions/search.ts
var import_obsidian11 = require("obsidian");

// src/utils/PromiseResolution.ts
var PromiseResolution = () => {
  let resolver;
  let rejector;
  const promise = new Promise(
    (resolve2) => {
      resolver = (args) => resolve2(args);
      rejector = (args) => resolve2(args);
    }
  );
  return {
    promise,
    resolver,
    rejector
  };
};

// src/utils/shuffleAndReinsert.ts
var shuffleAndReinsert = (array) => {
  const elementsToTake = Math.min(5, array.length);
  const takenElements = shuffle(array.splice(0, elementsToTake));
  takenElements.concat(array);
  return takenElements;
};

// src/actions/search.ts
var _Search = class {
};
var Search = _Search;
Search.search = async ({
  query
}) => {
  const config5 = ConnectorSingleton.getInstance();
  const cache2 = PiecesCacheSingleton.getInstance();
  try {
    if (_Search.searching) {
      _Search.searching.resolution.rejector({
        iterable: [],
        suggested: 0,
        exact: 0
      });
    }
    _Search.searching = {
      query,
      resolution: PromiseResolution()
    };
    config5.assetsApi.searchAssets({
      query,
      transferables: false
    }).then((response) => {
      if (!_Search.searching) {
        return response;
      }
      _Search.searching.resolution.resolver(response);
    }).catch((e3) => {
      if (!_Search.searching) {
        return { iterable: [], suggested: 0, exact: 0 };
      }
      _Search.searching.resolution.rejector({
        iterable: [],
        suggested: 0,
        exact: 0
      });
    });
    const results = await _Search.searching.resolution.promise;
    _Search.searching = void 0;
    const returnedResults = [];
    let found_asset;
    for (const asset of results.iterable) {
      found_asset = void 0;
      found_asset = cache2.assets.find((e3) => e3.id === asset.identifier);
      if (found_asset) {
        returnedResults.push(found_asset);
      }
    }
    if (returnedResults.length < 5 && returnedResults.length != 0) {
      _Search.searching = {
        query,
        resolution: PromiseResolution()
      };
      config5.searchApi.neuralCodeSearch({
        query
      }).then((response) => {
        if (!_Search.searching) {
          return response;
        }
        _Search.searching.resolution.resolver(response);
      }).catch((e3) => {
        if (!_Search.searching) {
          return { iterable: [], suggested: 0, exact: 0 };
        }
        _Search.searching.resolution.rejector({
          iterable: [],
          suggested: 0,
          exact: 0
        });
      });
      const results2 = await _Search.searching.resolution.promise;
      _Search.searching = void 0;
      for (const asset of results2.iterable) {
        found_asset = void 0;
        found_asset = cache2.assets.find((e3) => e3.id === asset.identifier);
        if (found_asset && !returnedResults.includes(found_asset)) {
          returnedResults.push(found_asset);
        }
      }
    }
    const snippets = returnedResults;
    if (snippets.length == 0) {
      new import_obsidian11.Notice(`No results found for '${query}'!`);
    } else {
      new import_obsidian11.Notice(
        `Search for '${query}' found ` + snippets.length + " result(s)."
      );
    }
    return shuffleAndReinsert(snippets);
  } catch (error) {
    _Search.searching = void 0;
    const snippets = cache2.assets;
    Notifications.getInstance().error({
      message: Constants.SEARCH_FAILURE,
      actions: [
        {
          title: "Contact Support",
          type: "OPEN_LINK" /* OPEN_LINK */,
          params: { url: "https://docs.pieces.app/support" }
        }
      ]
    });
    return snippets;
  }
};

// src/actions/fetchSnippets.ts
var fetchSnippets = (isSearch, sQuery) => {
  if (isSearch) {
    return Search.search({ query: sQuery ?? "" });
  } else {
    return loadPieces();
  }
};

// node_modules/js-search/dist/esm/js-search.js
var PrefixIndexStrategy = /* @__PURE__ */ function() {
  function PrefixIndexStrategy2() {
  }
  var _proto = PrefixIndexStrategy2.prototype;
  _proto.expandToken = function expandToken(token) {
    var expandedTokens = [];
    var string2 = "";
    for (var i2 = 0, length = token.length; i2 < length; ++i2) {
      string2 += token.charAt(i2);
      expandedTokens.push(string2);
    }
    return expandedTokens;
  };
  return PrefixIndexStrategy2;
}();
var LowerCaseSanitizer = /* @__PURE__ */ function() {
  function LowerCaseSanitizer2() {
  }
  var _proto = LowerCaseSanitizer2.prototype;
  _proto.sanitize = function sanitize(text) {
    return text ? text.toLocaleLowerCase().trim() : "";
  };
  return LowerCaseSanitizer2;
}();
function getNestedFieldValue(object, path) {
  path = path || [];
  object = object || {};
  var value = object;
  for (var i2 = 0; i2 < path.length; i2++) {
    value = value[path[i2]];
    if (value == null) {
      return null;
    }
  }
  return value;
}
var TfIdfSearchIndex = /* @__PURE__ */ function() {
  function TfIdfSearchIndex2(uidFieldName) {
    this._uidFieldName = uidFieldName;
    this._tokenToIdfCache = {};
    this._tokenMap = {};
  }
  var _proto = TfIdfSearchIndex2.prototype;
  _proto.indexDocument = function indexDocument(token, uid, doc) {
    this._tokenToIdfCache = {};
    var tokenMap = this._tokenMap;
    var tokenDatum;
    if (typeof tokenMap[token] !== "object") {
      tokenMap[token] = tokenDatum = {
        $numDocumentOccurrences: 0,
        $totalNumOccurrences: 1,
        $uidMap: {}
      };
    } else {
      tokenDatum = tokenMap[token];
      tokenDatum.$totalNumOccurrences++;
    }
    var uidMap = tokenDatum.$uidMap;
    if (typeof uidMap[uid] !== "object") {
      tokenDatum.$numDocumentOccurrences++;
      uidMap[uid] = {
        $document: doc,
        $numTokenOccurrences: 1
      };
    } else {
      uidMap[uid].$numTokenOccurrences++;
    }
  };
  _proto.search = function search(tokens, corpus) {
    var uidToDocumentMap = {};
    for (var i2 = 0, numTokens = tokens.length; i2 < numTokens; i2++) {
      var token = tokens[i2];
      var tokenMetadata = this._tokenMap[token];
      if (!tokenMetadata) {
        return [];
      }
      if (i2 === 0) {
        var keys = Object.keys(tokenMetadata.$uidMap);
        for (var j = 0, numKeys = keys.length; j < numKeys; j++) {
          var uid = keys[j];
          uidToDocumentMap[uid] = tokenMetadata.$uidMap[uid].$document;
        }
      } else {
        var keys = Object.keys(uidToDocumentMap);
        for (var j = 0, numKeys = keys.length; j < numKeys; j++) {
          var uid = keys[j];
          if (typeof tokenMetadata.$uidMap[uid] !== "object") {
            delete uidToDocumentMap[uid];
          }
        }
      }
    }
    var documents = [];
    for (var uid in uidToDocumentMap) {
      documents.push(uidToDocumentMap[uid]);
    }
    var calculateTfIdf = this._createCalculateTfIdf();
    return documents.sort(function(documentA, documentB) {
      return calculateTfIdf(tokens, documentB, corpus) - calculateTfIdf(tokens, documentA, corpus);
    });
  };
  _proto._createCalculateIdf = function _createCalculateIdf() {
    var tokenMap = this._tokenMap;
    var tokenToIdfCache = this._tokenToIdfCache;
    return function calculateIdf(token, documents) {
      if (!tokenToIdfCache[token]) {
        var numDocumentsWithToken = typeof tokenMap[token] !== "undefined" ? tokenMap[token].$numDocumentOccurrences : 0;
        tokenToIdfCache[token] = 1 + Math.log(documents.length / (1 + numDocumentsWithToken));
      }
      return tokenToIdfCache[token];
    };
  };
  _proto._createCalculateTfIdf = function _createCalculateTfIdf() {
    var tokenMap = this._tokenMap;
    var uidFieldName = this._uidFieldName;
    var calculateIdf = this._createCalculateIdf();
    return function calculateTfIdf(tokens, document2, documents) {
      var score = 0;
      for (var i2 = 0, numTokens = tokens.length; i2 < numTokens; ++i2) {
        var token = tokens[i2];
        var inverseDocumentFrequency = calculateIdf(token, documents);
        if (inverseDocumentFrequency === Infinity) {
          inverseDocumentFrequency = 0;
        }
        var uid;
        if (uidFieldName instanceof Array) {
          uid = document2 && getNestedFieldValue(document2, uidFieldName);
        } else {
          uid = document2 && document2[uidFieldName];
        }
        var termFrequency = typeof tokenMap[token] !== "undefined" && typeof tokenMap[token].$uidMap[uid] !== "undefined" ? tokenMap[token].$uidMap[uid].$numTokenOccurrences : 0;
        score += termFrequency * inverseDocumentFrequency;
      }
      return score;
    };
  };
  return TfIdfSearchIndex2;
}();
var REGEX = /[^a-zа-яё0-9\-']+/i;
var SimpleTokenizer = /* @__PURE__ */ function() {
  function SimpleTokenizer2() {
  }
  var _proto = SimpleTokenizer2.prototype;
  _proto.tokenize = function tokenize(text) {
    return text.split(REGEX).filter(
      function(text2) {
        return text2;
      }
      // Filter empty tokens
    );
  };
  return SimpleTokenizer2;
}();
var StopWordsMap = {
  a: true,
  able: true,
  about: true,
  across: true,
  after: true,
  all: true,
  almost: true,
  also: true,
  am: true,
  among: true,
  an: true,
  and: true,
  any: true,
  are: true,
  as: true,
  at: true,
  be: true,
  because: true,
  been: true,
  but: true,
  by: true,
  can: true,
  cannot: true,
  could: true,
  dear: true,
  did: true,
  "do": true,
  does: true,
  either: true,
  "else": true,
  ever: true,
  every: true,
  "for": true,
  from: true,
  "get": true,
  got: true,
  had: true,
  has: true,
  have: true,
  he: true,
  her: true,
  hers: true,
  him: true,
  his: true,
  how: true,
  however: true,
  i: true,
  "if": true,
  "in": true,
  into: true,
  is: true,
  it: true,
  its: true,
  just: true,
  least: true,
  "let": true,
  like: true,
  likely: true,
  may: true,
  me: true,
  might: true,
  most: true,
  must: true,
  my: true,
  neither: true,
  no: true,
  nor: true,
  not: true,
  of: true,
  off: true,
  often: true,
  on: true,
  only: true,
  or: true,
  other: true,
  our: true,
  own: true,
  rather: true,
  said: true,
  say: true,
  says: true,
  she: true,
  should: true,
  since: true,
  so: true,
  some: true,
  than: true,
  that: true,
  the: true,
  their: true,
  them: true,
  then: true,
  there: true,
  these: true,
  they: true,
  "this": true,
  tis: true,
  to: true,
  too: true,
  twas: true,
  us: true,
  wants: true,
  was: true,
  we: true,
  were: true,
  what: true,
  when: true,
  where: true,
  which: true,
  "while": true,
  who: true,
  whom: true,
  why: true,
  will: true,
  "with": true,
  would: true,
  yet: true,
  you: true,
  your: true
};
StopWordsMap.constructor = false;
StopWordsMap.hasOwnProperty = false;
StopWordsMap.isPrototypeOf = false;
StopWordsMap.propertyIsEnumerable = false;
StopWordsMap.toLocaleString = false;
StopWordsMap.toString = false;
StopWordsMap.valueOf = false;
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
var Search2 = /* @__PURE__ */ function() {
  function Search3(uidFieldName) {
    if (!uidFieldName) {
      throw Error("js-search requires a uid field name constructor parameter");
    }
    this._uidFieldName = uidFieldName;
    this._indexStrategy = new PrefixIndexStrategy();
    this._searchIndex = new TfIdfSearchIndex(uidFieldName);
    this._sanitizer = new LowerCaseSanitizer();
    this._tokenizer = new SimpleTokenizer();
    this._documents = [];
    this._searchableFields = [];
  }
  var _proto = Search3.prototype;
  _proto.addDocument = function addDocument(document2) {
    this.addDocuments([document2]);
  };
  _proto.addDocuments = function addDocuments(documents) {
    this._documents = this._documents.concat(documents);
    this.indexDocuments_(documents, this._searchableFields);
  };
  _proto.addIndex = function addIndex(field) {
    this._searchableFields.push(field);
    this.indexDocuments_(this._documents, [field]);
  };
  _proto.search = function search(query) {
    var tokens = this._tokenizer.tokenize(this._sanitizer.sanitize(query));
    return this._searchIndex.search(tokens, this._documents);
  };
  _proto.indexDocuments_ = function indexDocuments_(documents, _searchableFields) {
    this._initialized = true;
    var indexStrategy = this._indexStrategy;
    var sanitizer = this._sanitizer;
    var searchIndex = this._searchIndex;
    var tokenizer = this._tokenizer;
    var uidFieldName = this._uidFieldName;
    for (var di = 0, numDocuments = documents.length; di < numDocuments; di++) {
      var doc = documents[di];
      var uid;
      if (uidFieldName instanceof Array) {
        uid = getNestedFieldValue(doc, uidFieldName);
      } else {
        uid = doc[uidFieldName];
      }
      for (var sfi = 0, numSearchableFields = _searchableFields.length; sfi < numSearchableFields; sfi++) {
        var fieldValue;
        var searchableField = _searchableFields[sfi];
        if (searchableField instanceof Array) {
          fieldValue = getNestedFieldValue(doc, searchableField);
        } else {
          fieldValue = doc[searchableField];
        }
        if (fieldValue != null && typeof fieldValue !== "string" && fieldValue.toString) {
          fieldValue = fieldValue.toString();
        }
        if (typeof fieldValue === "string") {
          var fieldTokens = tokenizer.tokenize(sanitizer.sanitize(fieldValue));
          for (var fti = 0, numFieldValues = fieldTokens.length; fti < numFieldValues; fti++) {
            var fieldToken = fieldTokens[fti];
            var expandedTokens = indexStrategy.expandToken(fieldToken);
            for (var eti = 0, nummExpandedTokens = expandedTokens.length; eti < nummExpandedTokens; eti++) {
              var expandedToken = expandedTokens[eti];
              searchIndex.indexDocument(expandedToken, uid, doc);
            }
          }
        }
      }
    }
  };
  _createClass(Search3, [{
    key: "indexStrategy",
    set: function set(value) {
      if (this._initialized) {
        throw Error("IIndexStrategy cannot be set after initialization");
      }
      this._indexStrategy = value;
    },
    get: function get() {
      return this._indexStrategy;
    }
    /**
     * Override the default text sanitizing strategy.
     * @param value Custom text sanitizing strategy
     * @throws Error if documents have already been indexed by this search instance
     */
  }, {
    key: "sanitizer",
    set: function set(value) {
      if (this._initialized) {
        throw Error("ISanitizer cannot be set after initialization");
      }
      this._sanitizer = value;
    },
    get: function get() {
      return this._sanitizer;
    }
    /**
     * Override the default search index strategy.
     * @param value Custom search index strategy
     * @throws Error if documents have already been indexed
     */
  }, {
    key: "searchIndex",
    set: function set(value) {
      if (this._initialized) {
        throw Error("ISearchIndex cannot be set after initialization");
      }
      this._searchIndex = value;
    },
    get: function get() {
      return this._searchIndex;
    }
    /**
     * Override the default text tokenizing strategy.
     * @param value Custom text tokenizing strategy
     * @throws Error if documents have already been indexed by this search instance
     */
  }, {
    key: "tokenizer",
    set: function set(value) {
      if (this._initialized) {
        throw Error("ITokenizer cannot be set after initialization");
      }
      this._tokenizer = value;
    },
    get: function get() {
      return this._tokenizer;
    }
  }]);
  return Search3;
}();

// src/utils/discoverySearch.ts
var doSearch = ({
  query,
  snippets
}) => {
  const search = new Search2("id");
  search.addIndex("language");
  search.addIndex("raw");
  search.addIndex("title");
  search.addIndex("description");
  search.addDocuments(snippets);
  return search.search(query);
};
var discoverySearch_default = doSearch;

// src/ui/render/ProgressBar.ts
var ProgressBar = class {
  constructor({
    current,
    end,
    contentEl,
    source
  }) {
    this.bounceDirection = 1;
    this.isBouncing = true;
    if (current > end) {
      throw new Error(
        "Current must be less than or equal to end for the progress bar."
      );
    }
    this.source = source;
    this.current = current;
    this.end = end;
    this.contentEl = contentEl;
    this.bounceDirection = 1;
    this.barEl = this.contentEl.createDiv();
    this.barEl.classList.add("loading-bar");
    this.barEl.style.width = `${current / end * 100}%`;
    if (source === "discovery" /* Discovery */) {
      this.barEl.style.position = "absolute";
    }
    if (source === "qgpt" /* QGPT */) {
      this.barEl.style.alignSelf = "center";
      this.barEl.style.maxWidth = "95%";
    }
  }
  hide() {
    this.barEl.style.display = "none";
  }
  show() {
    this.barEl.style.display = "flex";
  }
  resetEnd(end) {
    if (this.current >= end) {
      this.current = end;
    }
    this.end = end;
    this.barEl.style.width = `${this.current / this.end * 100}%`;
  }
  update({ value }) {
    this.current = value;
    if (this.current > this.end) {
      this.current = this.end;
    }
    this.barEl.style.width = `${this.current / this.end * 100}%`;
    this.barEl.title = `Loaded ${this.current} of ${this.end} ${this.source === "qgpt" /* QGPT */ ? "files" : "snippets"}.`;
  }
  getCurrent() {
    return this.current;
  }
  getEnd() {
    return this.end;
  }
  detach() {
    this.contentEl.remove();
  }
  reset() {
    this.current = 0;
    this.barEl.style.width = `${this.current / this.end * 100}%`;
  }
  setFinished(current) {
    this.current = current;
    this.barEl.style.width = `${this.current / this.end * 100}%`;
  }
  bounce() {
    this.animateBounce();
    this.barEl.style.width = `10%`;
  }
  animateBounce() {
    const animate = () => {
      this.current += this.bounceDirection;
      if (this.current >= this.end) {
        this.bounceDirection = -1;
      } else if (this.current <= 0) {
        this.bounceDirection = 1;
      }
      this.barEl.style.transform = `translate(${this.current / this.end * 900}%)`;
      requestAnimationFrame(animate);
    };
    animate();
  }
};

// src/ui/modals/search-filters-modal.ts
var import_obsidian12 = require("obsidian");
var FilterTypeEnum = /* @__PURE__ */ ((FilterTypeEnum2) => {
  FilterTypeEnum2["Language"] = "Language";
  FilterTypeEnum2["Tags"] = "Tags";
  FilterTypeEnum2["Phrase"] = "Phrase";
  return FilterTypeEnum2;
})(FilterTypeEnum || {});
var SearchFiltersModal = class extends import_obsidian12.Modal {
  constructor(app2) {
    super(app2);
    this.filtersRan = false;
    this.addedFilters = [];
    this.filters = { Tags: [], casing: false };
    this.titleEl.setText("Filter Snippets");
    const container = this.contentEl.createDiv();
    container.classList.add("flex", "flex-col", "w-full", "h-full");
    const description = container.createDiv();
    description.classList.add(
      "text-sm",
      "flex",
      "flex-row",
      "w-full",
      "mt-[-8px]",
      "mb-1",
      "text-[var(--text-faint)]"
    );
    description.setText(
      "Use filters to narrow your search scope & refine results"
    );
    const filtersRow = container.createDiv();
    filtersRow.classList.add("flex", "flex-row", "w-full", "h-full");
    const filtersCol = filtersRow.createDiv();
    filtersCol.classList.add("flex", "flex-col", "w-full", "h-full");
    const actionRow = container.createDiv();
    actionRow.classList.add("flex", "flex-row", "w-full", "mt-2");
    const addCol = actionRow.createDiv();
    addCol.classList.add("flex", "flex-col", "min-h-[32px]");
    const addButton = new import_obsidian12.ButtonComponent(addCol);
    addButton.setButtonText("Add Filter").onClick(() => {
      this.addFilter(addCol, filtersCol, addButton);
      addButton.buttonEl.classList.add("hidden");
    }).buttonEl.classList.add("w-fit", "mr-2");
    this.addButton = addButton.buttonEl;
    const caseCol = actionRow.createDiv();
    caseCol.classList.add("flex", "flex-col", "hidden", "w-full");
    const caseRow = caseCol.createDiv();
    caseRow.classList.add(
      "flex",
      "flex-row",
      "w-full",
      "items-center",
      "h-full"
    );
    const caseCheckBox = caseRow.createEl("input", { type: "checkbox" });
    caseCheckBox.onchange = () => {
      this.filters.casing = caseCheckBox.checked;
    };
    const caseLabel = caseRow.createDiv();
    caseLabel.classList.add("w-full");
    caseLabel.setText("Case Sensitive");
    this.caseDiv = caseCol;
    const actionCol = actionRow.createDiv();
    actionCol.classList.add("flex", "flex-col", "w-full", "hidden");
    this.actionCol = actionCol;
    const actionBtnRow = actionCol.createDiv();
    actionBtnRow.classList.add("flex", "flex-row", "justify-end", "w-full");
    const clearBtn = new import_obsidian12.ButtonComponent(actionBtnRow);
    clearBtn.onClick(() => {
      document.getElementById("pieces-filters-options")?.remove();
      filtersCol.empty();
      this.addedFilters = [];
      this.filters = { Tags: [], casing: false };
      actionCol.classList.add("hidden");
      this.addButton.classList.remove("hidden");
      this.caseDiv.classList.add("hidden");
      this.handleClear();
    });
    clearBtn.setButtonText("Clear Filters");
    clearBtn.buttonEl.classList.add("mr-2");
    const runBtn = new import_obsidian12.ButtonComponent(actionBtnRow);
    runBtn.onClick(() => {
      this.runFilters();
    });
    runBtn.setButtonText("Run");
  }
  handleClear() {
    if (this.filtersRan) {
      this.filtersRan = false;
      DisplayController.triggerUIRedraw({ searching: false, fetch: false });
      DisplayController.filterModalBtn.buttonEl.classList.remove(
        "text-[var(--text-accent)]"
      );
    }
  }
  /*
     Creates a delete button
     - @param parent is the element that should be removed when the delete button is clicked
     - @param container is the element the delete button should be appended to
   */
  buildDeleteBtn(parent, container, filter3) {
    const delDiv = container.createDiv();
    delDiv.innerHTML = (0, import_obsidian12.getIcon)("trash-2").outerHTML;
    delDiv.classList.add(
      "hover:text-red-600",
      "cursor-pointer",
      "ml-2",
      "mr-2"
    );
    delDiv.onclick = () => {
      parent.remove();
      document.getElementById("pieces-filters-options")?.remove();
      this.addedFilters.remove(filter3);
      this.addButton.classList.remove("hidden");
      if (this.addedFilters.length === 0) {
        this.actionCol.classList.add("hidden");
        this.handleClear();
      }
      delete this.filters[filter3];
      if (!this.addedFilters.contains("Tags") && !this.addedFilters.contains("Phrase")) {
        this.caseDiv.classList.add("hidden");
        this.filters.casing = false;
      }
    };
    return delDiv;
  }
  /*
     Runs the filter request, and renders the results.
   */
  async runFilters() {
    const config5 = ConnectorSingleton.getInstance();
    const params = {
      transferables: false,
      pseudo: false,
      assetsSearchWithFiltersInput: {
        filters: {
          iterable: []
        },
        casing: this.filters.casing
      }
    };
    if (this.filters.Language?.length) {
      params.assetsSearchWithFiltersInput?.filters?.iterable.push({
        classification: this.filters.Language
      });
    }
    if (this.filters.Tags.filter((el) => el.length).length) {
      params.assetsSearchWithFiltersInput?.filters?.iterable.push({
        tags: this.filters.Tags
      });
    }
    if (this.filters.Phrase?.string.length) {
      const operations = {
        iterable: [],
        type: FilterOperationTypeEnum.Or
      };
      const value = this.filters.Phrase.string;
      if (this.filters.Phrase.annotations) {
        operations.iterable.push({
          phrase: { value, annotation: true }
        });
      }
      if (this.filters.Phrase.content) {
        operations.iterable.push({
          phrase: { value, content: true }
        });
      }
      if (this.filters.Phrase.titles) {
        operations.iterable.push({
          phrase: { value, title: true }
        });
      }
      if (operations.iterable.length) {
        params.assetsSearchWithFiltersInput?.filters?.iterable.push({
          operations
        });
      }
    }
    if (!params.assetsSearchWithFiltersInput?.filters?.iterable.length) {
      Notifications.getInstance().error({
        message: "Filters were empty, skipping."
      });
      return;
    }
    const assets = await config5.assetsApi.assetsSearchWithFilters(params).catch(() => {
      Notifications.getInstance().error({
        message: "Something went wrong with filtering your snippets. Please make sure that Pieces OS is installed, updated, and running. If the issue persists please contact support.",
        actions: [
          {
            title: "Contact Support",
            type: "OPEN_LINK" /* OPEN_LINK */,
            params: { url: "https://docs.pieces.app/support" }
          }
        ]
      });
    });
    if (!assets)
      return;
    if (!assets.results.iterable.length) {
      Notifications.getInstance().error({
        message: "No results found! Try again with a different set of filters."
      });
      return;
    } else {
      Notifications.getInstance().information({
        message: `${assets.results.iterable.length} results found!`
      });
    }
    this.filtersRan = true;
    const cache2 = PiecesCacheSingleton.getInstance();
    const snippets = cache2.assets.filter(
      (el) => assets.results.iterable.some((asset) => asset.identifier === el.id)
    );
    DisplayController.defaultView = "newest" /* RECENT */;
    DisplayController.createSnippetListView({
      containerVar: DisplayController.defaultContainer,
      snippets
    });
    DisplayController.filterModalBtn.buttonEl.classList.add(
      "text-[var(--text-accent)]"
    );
    this.close();
  }
  /*
     Builder for classification filter element
   */
  buildClassificationEl(container) {
    const clsRow = container.createDiv();
    clsRow.classList.add("flex", "flex-row", "my-2");
    const clsCol = clsRow.createDiv();
    clsCol.classList.add("flex", "flex-col");
    const labelRow = clsCol.createDiv();
    labelRow.classList.add(
      "flex",
      "flex-row",
      "text-sm",
      "text-[var(--text-faint)]"
    );
    labelRow.setText("LANGUAGE");
    const filterRow = clsCol.createDiv();
    filterRow.classList.add("flex", "flex-row", "items-center");
    const classificationDropdown = new import_obsidian12.DropdownComponent(filterRow);
    classificationDropdown.selectEl.classList.add("w-fit", "text-center");
    classificationDropdown.addOptions(searchLangSpecificEnum);
    classificationDropdown.onChange((value) => {
      this.filters["Language" /* Language */] = langExtToClassificationSpecificEnum(value);
    });
    this.filters["Language" /* Language */] = langExtToClassificationSpecificEnum(
      classificationDropdown.getValue()
    );
    this.buildDeleteBtn(clsRow, filterRow, "Language" /* Language */);
  }
  /*
     Builder for phrase filter element
   */
  buildPhraseEl(container) {
    this.filters["Phrase" /* Phrase */] = {
      string: "",
      annotations: true,
      titles: true,
      content: true
    };
    const phraseRow = container.createDiv();
    phraseRow.classList.add("flex", "flex-row", "my-2", "w-full");
    const phraseCol = phraseRow.createDiv();
    phraseCol.classList.add("flex", "flex-col", "w-full");
    const phraseLabel = phraseCol.createDiv();
    phraseLabel.classList.add(
      "flex-row",
      "flex",
      "text-sm",
      "text-[var(--text-faint)]"
    );
    phraseLabel.setText("PHRASE");
    const inputRow = phraseCol.createDiv();
    inputRow.classList.add(
      "flex",
      "flex-row",
      "my-1",
      "w-full",
      "items-center"
    );
    const inputEl = new import_obsidian12.TextComponent(inputRow);
    inputEl.setPlaceholder("Filter for an exact text match");
    inputEl.inputEl.classList.add("w-1/2");
    inputEl.onChange((value) => {
      this.filters["Phrase" /* Phrase */].string = value;
    });
    const optionRow = phraseCol.createDiv();
    optionRow.classList.add(
      "flex",
      "flex-row",
      "w-full",
      "items-center",
      "my-1"
    );
    const annotationCheckBox = optionRow.createEl("input", {
      type: "checkbox"
    });
    annotationCheckBox.checked = true;
    annotationCheckBox.onchange = () => {
      this.filters["Phrase" /* Phrase */].annotations = annotationCheckBox.checked;
    };
    const annotationLabel = optionRow.createDiv();
    annotationLabel.setText("Match Annotations");
    annotationLabel.classList.add("mx-1");
    const seperatorEl = optionRow.createDiv();
    seperatorEl.classList.add(
      "ml-2",
      "mr-3",
      "text-xs",
      "text-[var(--text-faint)]"
    );
    seperatorEl.setText("OR");
    const titleCheckbox = optionRow.createEl("input", { type: "checkbox" });
    titleCheckbox.checked = true;
    titleCheckbox.onchange = () => {
      this.filters["Phrase" /* Phrase */].titles = titleCheckbox.checked;
    };
    const titleLabel = optionRow.createDiv();
    titleLabel.setText("Match Titles");
    titleLabel.classList.add("mx-1");
    optionRow.appendChild(seperatorEl.cloneNode(true));
    const contentCheckbox = optionRow.createEl("input", { type: "checkbox" });
    contentCheckbox.checked = true;
    contentCheckbox.onchange = () => {
      this.filters.Phrase.content = contentCheckbox.checked;
    };
    const contentLabel = optionRow.createDiv();
    contentLabel.setText("Match Content");
    contentLabel.classList.add("mx-1");
    this.buildDeleteBtn(phraseRow, inputRow, "Phrase" /* Phrase */);
  }
  buildTagEl(container) {
    const tagRow = container.createDiv();
    tagRow.classList.add("flex", "flex-row", "my-2");
    const tagCol = tagRow.createDiv();
    tagCol.classList.add("flex", "flex-col");
    const tagLabel = tagCol.createDiv();
    tagLabel.classList.add(
      "flex",
      "flex-row",
      "my-1",
      "text-sm",
      "text-[var(--text-faint)]"
    );
    tagLabel.setText("TAGS");
    const filtersRow = tagCol.createDiv();
    filtersRow.classList.add(
      "flex",
      "flex-row",
      "my-1",
      "items-center",
      "flex-wrap"
    );
    let tagInputCount = 0;
    const buildTagInput = () => {
      const tagIndx = tagInputCount.valueOf();
      tagInputCount++;
      this.filters["Tags" /* Tags */].push("");
      filtersRow.empty();
      for (const tag2 of this.filters["Tags" /* Tags */]) {
        const tagFilterCol = filtersRow.createDiv();
        tagFilterCol.classList.add("flex", "flex-col");
        const tagFilterRow = tagFilterCol.createDiv();
        tagFilterRow.classList.add("flex", "flex-row", "items-center", "my-1");
        const tagFilterEl = new import_obsidian12.TextComponent(tagFilterRow);
        tagFilterEl.setValue(tag2);
        tagFilterEl.onChange((value) => {
          this.filters["Tags" /* Tags */][tagIndx] = value;
        });
        tagFilterEl.setPlaceholder("Add tag...");
        tagFilterEl.inputEl.classList.add("mr-1");
        const deleteBtn = this.buildDeleteBtn(
          tagFilterCol,
          tagFilterRow,
          "Tags" /* Tags */
        );
        deleteBtn.onclick = () => {
          document.getElementById("pieces-filters-options")?.remove();
          tagInputCount--;
          this.filters["Tags" /* Tags */]?.remove(tagFilterEl.getValue());
          tagFilterCol.remove();
          if (tagInputCount <= 0) {
            tagRow.remove();
            this.addButton.classList.remove("hidden");
            this.addedFilters.remove("Tags" /* Tags */);
            if (this.addedFilters.length === 0) {
              this.actionCol.classList.add("hidden");
              this.handleClear();
            }
            if (!this.addedFilters.contains("Tags") && !this.addedFilters.contains("Phrase")) {
              this.caseDiv.classList.add("hidden");
              this.filters.casing = false;
            }
          }
        };
      }
      const plusEl = filtersRow.createDiv();
      plusEl.classList.add(
        "mx-1",
        "cursor-pointer",
        "hover:text-[var(--text-accent-hover)]"
      );
      plusEl.innerHTML = (0, import_obsidian12.getIcon)("plus").outerHTML;
      plusEl.onclick = () => {
        buildTagInput();
      };
    };
    buildTagInput();
  }
  buildFilterEl(type, container) {
    if (type === "Language" /* Language */) {
      return this.buildClassificationEl(container);
    } else if (type === "Phrase" /* Phrase */) {
      return this.buildPhraseEl(container);
    } else if (type === "Tags" /* Tags */) {
      return this.buildTagEl(container);
    }
    throw new Error("Invalid filter type");
  }
  /*
     Shows the available filter options to the user, 
     and when an option is clicked it will build a filter element
   */
  addFilter(container, filterCol, addButton) {
    const options2 = Object.keys(FilterTypeEnum).filter(
      (el) => !this.addedFilters.includes(el)
    );
    const optionDiv = document.createElement("div");
    optionDiv.id = "pieces-filters-options";
    optionDiv.classList.add(
      "flex",
      "flex-row",
      "items-center",
      "filter-grow-animation",
      "h-full",
      "mr-1"
    );
    for (let i2 = 0; i2 < options2.length; i2++) {
      const option = options2[i2];
      if (i2 !== 0) {
        const split = optionDiv.createDiv();
        split.classList.add("mx-1", "text-[var(--text-faint)]");
        split.setText("|");
      }
      const curOption = optionDiv.createDiv();
      curOption.classList.add(
        "underline",
        "cursor-pointer",
        "mx-1",
        "hover:text-[var(--text-accent-hover)]",
        "text-[var(--text-faint)]"
      );
      curOption.setText(option);
      curOption.onclick = () => {
        this.addedFilters.push(option);
        this.buildFilterEl(
          FilterTypeEnum[option],
          filterCol
        );
        optionDiv.remove();
        this.actionCol.classList.remove("hidden");
        if (this.addedFilters.length !== Object.keys(FilterTypeEnum).length) {
          addButton.buttonEl.classList.remove("hidden");
        }
        if (option === "Tags" || option === "Phrase") {
          this.caseDiv.classList.remove("hidden");
        }
      };
    }
    container.appendChild(optionDiv);
  }
};

// src/ui/views/DisplayController.ts
var _DisplayController = class {
  constructor() {
  }
};
var DisplayController = _DisplayController;
DisplayController.searchFiltersModal = new SearchFiltersModal(app);
DisplayController.defaultView = "newest" /* RECENT */;
DisplayController.discoveryCheckboxArray = [];
DisplayController.snippetsFetched = false;
DisplayController.fetchFailed = false;
DisplayController.appendDiscovery = (value) => {
  _DisplayController.discoveryCheckboxArray.push(value);
};
DisplayController.clearDiscovery = () => {
  _DisplayController.discoveryCheckboxArray.length = 0;
};
/*
   TODO this should not be callable if the pieces view is not open
re-renders the entire snippet list UI
*/
DisplayController.triggerUIRedraw = async ({
  searching,
  container = _DisplayController.defaultContainer,
  searchQuery,
  fetch: fetch2 = true
}) => {
  console.log("Pieces for Developers: Redrawing");
  const cache2 = PiecesCacheSingleton.getInstance();
  let snippets = [];
  if (!_DisplayController.fetchFailed && versionValid) {
    if ("discovery" /* DISCOVERY */ === _DisplayController.defaultView && searching) {
      snippets = discoverySearch_default({
        query: searchQuery ?? "",
        snippets: cache2.discoveredSnippets
      });
    } else if (searching) {
      snippets = await fetchSnippets(true, searchQuery);
    } else if (fetch2) {
      snippets = await fetchSnippets(false);
    } else {
      snippets = cache2.assets;
    }
  }
  if (searchQuery && snippets.length !== 0) {
    _DisplayController.createSnippetListView({
      containerVar: container,
      snippets,
      searched: searching
    });
  } else {
    _DisplayController.createSnippetListView({
      containerVar: container,
      snippets
    });
  }
};
/*
builder for the snippet list view,
creates search box,
dropdown,
checks if we are in a UI edge case,
creates the list of snippets according to what sort order we are using
*/
DisplayController.createSnippetListView = async ({
  containerVar,
  snippets,
  viewType = _DisplayController.defaultView,
  searched = false
}) => {
  const cache2 = PiecesCacheSingleton.getInstance();
  const notifications = Notifications.getInstance();
  containerVar.empty();
  _DisplayController.defaultView = viewType;
  _DisplayController.defaultContainer = containerVar;
  const searchDiv = containerVar.createDiv();
  searchDiv.addClass("search-div");
  renderSearchBox({ containerVar: searchDiv });
  const titleDiv = searchDiv.createDiv();
  titleDiv.addClass("title_div");
  new import_obsidian13.DropdownComponent(titleDiv).addOption("newest" /* RECENT */, "\u{1F553} RECENT").addOption("language" /* LANGUAGE */, "\u{1F310} LANGUAGE").addOption("discovery" /* DISCOVERY */, "\u{1F50D} DISCOVER").onChange(async (value) => {
    _DisplayController.defaultView = value;
    _DisplayController.createSnippetListView({
      containerVar,
      snippets: cache2.assets,
      viewType: value
    });
  }).setValue(viewType).selectEl.addClass("sort-dropdown");
  if (_DisplayController.defaultView !== "discovery" /* DISCOVERY */) {
    const disableFilters = versionCheck({ minVersion: "6.1.0" });
    _DisplayController.filterModalBtn = new import_obsidian13.ButtonComponent(titleDiv);
    _DisplayController.filterModalBtn.setIcon("filter").onClick(() => {
      disableFilters.then((val) => {
        if (val) {
          _DisplayController.searchFiltersModal.open();
        } else {
          Notifications.getInstance().error({
            message: "Please update to Pieces OS 6.1.0 or higher to use the snippet filtering feature."
          });
        }
      }).catch(_DisplayController.searchFiltersModal.open);
    }).setTooltip("Filter your snippets").buttonEl.addClass("cursor-pointer");
  }
  if (_DisplayController.defaultView === "discovery" /* DISCOVERY */) {
    const saveAllDiv = titleDiv.createDiv();
    saveAllDiv.addClasses(["discovery-div"]);
    const selectAllDiv = saveAllDiv.createDiv();
    selectAllDiv.addClasses(["discovery-div-inner"]);
    const selectAllCheckbox = selectAllDiv.createEl("input", {
      type: "checkbox"
    });
    selectAllCheckbox.id = "select-all-checkbox";
    selectAllCheckbox.onClickEvent(() => {
      if (selectAllCheckbox.checked) {
        for (let i2 = 0; i2 < _DisplayController.discoveryCheckboxArray.length; i2++) {
          _DisplayController.discoveryCheckboxArray[i2].snippetCheckBox.checked = true;
        }
      } else {
        for (let i2 = 0; i2 < _DisplayController.discoveryCheckboxArray.length; i2++) {
          _DisplayController.discoveryCheckboxArray[i2].snippetCheckBox.checked = false;
        }
      }
    });
    const selectAllLabel = selectAllDiv.createEl("label");
    selectAllLabel.htmlFor = "select-all-checkbox";
    selectAllLabel.innerText = "Select all";
    selectAllLabel.addClasses(["discovery-title"]);
    saveAllDiv.createEl("div").addClass("discovery-break");
    const saveallButton = new import_obsidian13.ButtonComponent(saveAllDiv).setButtonText("Save all selected snippets").onClick(async () => {
      _DisplayController.defaultView = "discovery" /* DISCOVERY */;
      const loading = saveAllDiv.createEl("div");
      loading.addClass("bouncing-loader");
      loading.createEl("div");
      loading.createEl("div");
      loading.createEl("div");
      saveAllDiv.replaceChild(loading, saveallButton.buttonEl);
      let i2 = _DisplayController.discoveryCheckboxArray.length;
      const originalI = i2;
      while (i2--) {
        const element = _DisplayController.discoveryCheckboxArray[i2];
        if (element.snippetCheckBox.checked) {
          await createAsset({
            selection: element.snippetObject.raw,
            name: element.snippetObject.title,
            annotations: element.snippetObject.annotations,
            lang: element.snippetObject.language
          });
          const discoverIndx = cache2.discoveredSnippets.findIndex(
            (value) => {
              return value.id === element.snippetObject.id;
            }
          );
          cache2.discoveredSnippets.splice(discoverIndx, 1);
          const removalEl = document.getElementById(
            "list-view-" + element.snippetObject.id
          );
          removalEl?.remove();
          _DisplayController.discoveryCheckboxArray.splice(i2, 1);
        }
      }
      if (i2 === originalI) {
        notifications.information({
          message: Constants.NO_SELECTION_SAVE
        });
      }
      saveAllDiv.replaceChild(saveallButton.buttonEl, loading);
      _DisplayController.triggerUIRedraw({
        searching: false,
        fetch: false
      });
    }).setIcon("save-all").setTooltip(
      cache2.discoveredSnippets.length < 1 ? "There aren't any discovered snippets to save" : "Save all selected snippets to Pieces"
    ).setClass("button_copy");
    _DisplayController.discoveryProgressBar = new ProgressBar({
      current: cache2.discoveredSnippets.length,
      end: pluginSettings.autoDiscoverMaximum,
      contentEl: searchDiv,
      source: "discovery" /* Discovery */
    });
    if (Discovery.discovery_loaded)
      _DisplayController.discoveryProgressBar.hide();
  }
  const searchBackground = searchDiv.createEl("div");
  searchBackground.addClass("search-background");
  if (_DisplayController.fetchFailed || !versionValid) {
    showFetchFailedState({ containerVar });
  } else if (!snippets.length && !_DisplayController.snippetsFetched) {
    showLoadingState({ containerVar });
  } else if (!snippets.length && _DisplayController.snippetsFetched) {
    showNoSnippetState({ containerVar });
  } else {
    if (viewType === "newest" /* RECENT */) {
      _DisplayController.createListView({
        containerVar,
        snippets: searched ? snippets : snippets.sort(
          (a, b) => new Date(b.created).getTime() - new Date(a.created).getTime()
          // eslint-disable-next-line no-mixed-spaces-and-tabs
        )
      });
    } else if (viewType === "language" /* LANGUAGE */) {
      renderLanguageView({
        containerVar
      });
    } else if (viewType === "discovery" /* DISCOVERY */) {
      if (!cache2.discoveredSnippets.length) {
        showLoadingState({
          containerVar,
          discovery: true
        });
      } else {
        _DisplayController.createListView({
          containerVar,
          snippets: searched ? snippets : cache2.discoveredSnippets,
          discovery: true
        });
      }
    }
  }
};
/*
    Creates the list of snippet elements
*/
DisplayController.createListView = ({
  containerVar,
  snippets,
  newSnippet = false,
  discovery = false
}) => {
  const snippetContainer = containerVar.createEl("div");
  snippetContainer.addClass("snippet-container");
  snippetContainer.id = "pieces-snippet-container";
  _DisplayController.clearDiscovery();
  for (let i2 = 0; i2 < snippets.length; i2++) {
    if (!(typeof snippets[i2].raw === "string")) {
      snippets[i2].raw = "Loading code...";
    }
    const listView = renderListView({
      contentEl: snippetContainer,
      snippetObject: snippets[i2],
      opened: newSnippet,
      newAsset: newSnippet,
      discovery
    });
    if (snippets.length == 1) {
      listView.addClass("only-snippet");
    } else if (i2 == snippets.length - 1) {
      listView.addClass("last-snippet");
    } else if (i2 == 0) {
      listView.addClass("first-snippet");
    }
    snippetContainer.appendChild(listView);
  }
  return snippetContainer;
};
/*
Uses the result of /asset/export to create a markdown view of the expanded snippet
*/
DisplayController.createExpandedView = async ({
  snippetId,
  snippetTitle
}) => {
  const config5 = ConnectorSingleton.getInstance();
  const leaf = app.workspace.getLeaf(true);
  const exportParams = {
    asset: snippetId,
    exportType: AssetSpecificAssetExportExportTypeEnum.Md
  };
  let expandedSnippetMD = (await config5.assetApi.assetSpecificAssetExport(exportParams)).raw.string?.raw ?? "";
  expandedSnippetMD = expandedSnippetMD.replace(
    "Preview:",
    "Pieces Preview:"
  );
  const firstIndex = expandedSnippetMD.indexOf("```");
  const secondIndex = expandedSnippetMD.indexOf("```", firstIndex + 1);
  expandedSnippetMD = expandedSnippetMD.substring(0, secondIndex + 3) + "\n" + expandedSnippetMD.substring(secondIndex + 3);
  let lines = expandedSnippetMD.split("\n");
  lines = lines.slice(1);
  for (let i2 = 0; i2 < lines.length; i2++) {
    if (lines[i2].includes("```")) {
      const lang = lines[i2].slice(3);
      const newLang = LangSpecificEnum[lang];
      lines[i2] = "```" + newLang;
      break;
    }
  }
  expandedSnippetMD = lines.join("\n");
  displayPiecesView({
    leaf,
    type: Constants.PIECES_EXPANDED_SNIPPET_VIEW_TYPE,
    markdown: expandedSnippetMD,
    inlineTitle: snippetTitle,
    active: true
  });
};

// src/actions/open_vault_note.ts
var import_obsidian14 = require("obsidian");
var openVaultNote = (myPath) => {
  const cleanedPath = myPath.substring(myPath.lastIndexOf("/") + 1);
  const vaultFiles = app.vault.getFiles();
  const targetFile = vaultFiles.find(
    (f) => f.path.contains(cleanedPath)
  );
  try {
    if (targetFile) {
      const leaf = app.workspace.getLeaf("tab");
      leaf.openFile(targetFile);
    } else {
      console.error(`Target file error: ${targetFile}`);
    }
  } catch (e3) {
    new import_obsidian14.Notice(`Error opening ${myPath}, the file may not exist.`);
  }
};

// src/cache/FileTracking.ts
var FileTracking = class {
  constructor(plugin) {
    this.recentFiles = [];
    const basePath = plugin.app.vault.adapter.basePath;
    plugin.registerEvent(
      plugin.app.workspace.on("file-open", (file) => {
        if (!file)
          return;
        this.recentFiles.push(basePath + "/" + file.path);
        while (this.recentFiles.length > 10) {
          this.recentFiles.shift();
        }
      })
    );
  }
  get recent() {
    return this.recentFiles;
  }
  static getInstance(plugin) {
    if (this.instance)
      return this.instance;
    if (!plugin)
      throw new Error(
        "first instance of file tracking must get a plugin as well"
      );
    return this.instance = new FileTracking(plugin);
  }
};

// src/ui/views/CopilotParams.ts
var import_obsidian16 = require("obsidian");

// src/ui/modals/add-snippet-context-modal.ts
var import_obsidian15 = require("obsidian");
var AddSnippetToContextModal = class extends import_obsidian15.Modal {
  constructor(conversation) {
    super(app);
    this.snippetsToAdd = {};
    this.contentEl.onclick = (e3) => {
      e3.stopPropagation();
    };
    this.conversation = conversation;
    this.titleEl.innerText = "Add snippet to context";
    for (const snippet of PiecesCacheSingleton.getInstance().assets) {
      const snippetRow = this.contentEl.createDiv();
      snippetRow.classList.add("flex", "flex-row", "items-center");
      const checkBox = snippetRow.createEl("input");
      checkBox.type = "checkbox";
      checkBox.onchange = () => {
        this.snippetsToAdd[snippet.id] = checkBox.checked;
      };
      renderListView({
        contentEl: snippetRow,
        discovery: false,
        snippetObject: snippet
      });
    }
    const actionRow = this.contentEl.createDiv();
    actionRow.classList.add("flex", "flex-row", "justify-center", "p-3");
    const saveBtn = actionRow.createDiv();
    saveBtn.classList.add(
      "p-2",
      "bg-[var(--background-secondary)]",
      "cursor-pointer",
      "rounded"
    );
    saveBtn.innerText = "save";
    saveBtn.onclick = () => {
      this.close();
    };
  }
  handleAddToContext() {
    this.modalEl.remove();
    const snippetIds = Object.keys(this.snippetsToAdd).filter(
      (id) => this.snippetsToAdd[id]
    );
    for (const id of snippetIds) {
      ConnectorSingleton.getInstance().conversationApi.conversationAssociateAsset(
        {
          conversation: this.conversation,
          asset: id
        }
      );
    }
  }
  onClose() {
    this.handleAddToContext();
  }
};

// src/ui/views/CopilotParams.ts
var lastSelection;
var lastRange;
var lastActiveFile;
var copilotState = "";
document.onselectionchange = () => {
  const editor = app.workspace.activeEditor?.editor;
  lastActiveFile = app.workspace.getActiveFile();
  if (!editor)
    return;
  lastSelection = document.getSelection();
  if (!lastSelection)
    return;
  lastRange = lastSelection.getRangeAt(0);
};
var getApplication = async () => {
  if (!ConnectorSingleton.getInstance().context)
    await loadConnect();
  return ConnectorSingleton.getInstance().context.application;
};
var copilotParams = {
  async corsProxyFetch(url, options2) {
    const content = await (0, import_obsidian16.request)({
      url,
      method: options2?.method,
      headers: options2?.headers,
      body: options2?.body,
      throw: true
    });
    return { content };
  },
  async updateApplication(application) {
    const capabilities = application.capabilities === CapabilitiesEnum.Blended ? "blended" : "local";
    PiecesPlugin.getInstance().settings.cloudCapabilities = capabilities;
    PiecesPlugin.getInstance().saveSettings();
  },
  async getRecentFiles() {
    return { paths: FileTracking.getInstance().recent ?? [] };
  },
  async getWorkspacePaths() {
    return { paths: [app.vault.adapter.basePath ?? ""] };
  },
  migration: 0,
  openFile: openVaultNote,
  generateShareableLink: async (params) => {
    let link;
    if ("id" in params) {
      link = await ShareableLinksService.getInstance().generate({
        id: params.id
      });
      if (link)
        copyToClipboard(link);
      return { id: params.id };
    } else {
      const application = await getApplication();
      if (!application)
        return;
      const asset = await ConnectorSingleton.getInstance().assetsApi.assetsCreateNewAsset({
        seed: {
          type: SeedTypeEnum.Asset,
          asset: {
            application,
            format: {
              fragment: {
                string: {
                  raw: params.raw
                },
                metadata: {
                  ext: langExtToClassificationSpecificEnum(params.ext)
                }
              }
            }
          }
        }
      });
      if (asset) {
        link = await ShareableLinksService.getInstance().generate({
          id: asset.id
        });
        if (link)
          copyToClipboard(link);
        return { id: asset.id };
      }
    }
  },
  getApplication,
  requestContextPicker: async (type, conversationId) => {
    let paths = null;
    if (type === "files") {
      paths = await ConnectorSingleton.getInstance().osApi.osFilesystemPickFiles({
        filePickerInput: {}
      });
    }
    if (type === "folders") {
      paths = await ConnectorSingleton.getInstance().osApi.osFilesystemPickFolders();
    }
    if (paths) {
      const anchors = await Promise.all(
        paths.map(
          (path) => ConnectorSingleton.getInstance().anchorsApi.anchorsCreateNewAnchor({
            transferables: false,
            seededAnchor: {
              type: type === "folders" ? AnchorTypeEnum.Directory : AnchorTypeEnum.File,
              fullpath: path
            }
          })
        )
      );
      for (const anchor of anchors) {
        ConnectorSingleton.getInstance().conversationApi.conversationAssociateAnchor(
          {
            conversation: conversationId,
            anchor: anchor.id
          }
        );
      }
      return;
    }
    new AddSnippetToContextModal(conversationId).open();
  },
  saveState: (newState) => {
    copilotState = newState;
    PiecesDatabase.writeData();
  },
  getState: () => {
    return { pieces: copilotState };
  },
  sendNotification: (params) => {
    if (params.type === "info") {
      Notifications.getInstance().information({
        message: params.message,
        actions: params.actions
      });
    } else {
      Notifications.getInstance().error({
        message: params.message,
        actions: params.actions
      });
    }
  },
  // LEAVE THIS UNIMPLEMENTED TRACKING IS STRICTLY FORBIDDEN IN OBSIDIAN
  track: (event) => {
  },
  openLink: (url) => window.open(url),
  insertAtCursor(text) {
    if (!lastRange || !lastSelection || lastActiveFile !== app.workspace.getActiveFile()) {
      Notifications.getInstance().error({
        message: "Cannot insert at cursor because the editor is not detected."
      });
      return;
    }
    const selectedText = lastRange.toString();
    lastRange.deleteContents();
    const newText = selectedText + "\n```\n" + text + "\n```\n";
    const textNode = document.createTextNode(newText);
    lastRange.insertNode(textNode);
    lastRange.setStartAfter(textNode);
    lastRange.collapse(true);
    lastSelection.removeAllRanges();
    lastSelection.addRange(lastRange);
  }
};

// src/database/pieces_database.ts
var PiecesDatabase = class {
  constructor() {
  }
  static async getData() {
    const { vault } = app;
    const dataFile = await this.loadFile();
    const rawData = await vault.read(dataFile);
    const data = JSON.parse(rawData);
    data.assets?.forEach(
      (e3) => e3.created = new Date(e3.created)
    );
    return data;
  }
  static async writeData() {
    clearTimeout(this.writeTimeout);
    this.writeTimeout = setTimeout(async () => {
      if (true) {
        console.log("Pieces for Developers DEV: Writing to piecesdb.json");
      }
      const cache2 = PiecesCacheSingleton.getInstance();
      const { vault } = app;
      const dataFile = await this.loadFile();
      const newDb = {
        assets: cache2.assets,
        gptContexts: cache2.gptContextPaths,
        gptFolderNames: cache2.gptFolderNames,
        enrichedCode: cache2.getAllIsEnriched(),
        migration,
        remoteCopilotState: copilotState
      };
      vault.modify(dataFile, JSON.stringify(newDb));
    }, 5e3);
  }
  static async loadFile(retries = 0) {
    const { vault } = app;
    const dbPath = "piecesdb.json";
    const dataFile = vault.getAbstractFileByPath(dbPath);
    if (dataFile === null) {
      if (retries < 5) {
        await sleep(100);
        return this.loadFile(retries + 1);
      }
      return vault.create(dbPath, '{"assets":[]}');
    }
    if (dataFile instanceof import_obsidian17.TFolder) {
      await vault.delete(dataFile);
      return vault.create(dbPath, '{"assets":[]}');
    }
    return dataFile;
  }
  static async clearStaleIds() {
    const config5 = ConnectorSingleton.getInstance();
    const cache2 = PiecesCacheSingleton.getInstance();
    const idSnapshot = await config5.assetsApi.assetsIdentifiersSnapshot({
      pseudo: false
    });
    const idMap = /* @__PURE__ */ new Map();
    idSnapshot.iterable?.forEach((identifier) => {
      idMap.set(identifier.id, true);
    });
    const staleIds = Object.keys(cache2.mappedAssets).filter((id) => {
      return !idMap.has(id);
    });
    staleIds.forEach((id) => {
      const snippetEl = document.getElementById(`list-view-${id}`);
      snippetEl?.remove();
      delete cache2.mappedAssets[id];
    });
    cache2.assets = Object.values(cache2.mappedAssets);
    if (staleIds.length) {
      this.writeData();
    }
    if (!cache2.assets.length) {
      DisplayController.triggerUIRedraw({ searching: false, fetch: false });
    }
  }
};

// src/cache/pieces_cache.ts
var PiecesCacheSingleton = class {
  constructor() {
    this.enrichedCode = {};
    this.assets = [];
    this.suggestedAssets = [];
    this.explainedMappedAssets = /* @__PURE__ */ new Map();
    this.mappedAssets = {};
    this.fetchedFormats = {};
    this.snippetMap = /* @__PURE__ */ new Map();
    this.discoveredSnippets = [];
    this.gptContextPaths = [];
    this.gptFolderNames = [];
    this.assetAnnotations = /* @__PURE__ */ new Map();
    // this is a map of key: format uuid and value here is a transferable
    this.formatTransferables = {};
  }
  getIsEnriched(code) {
    code = code.trim();
    const hash = import_crypto.default.createHash("sha256").update(code).digest("hex");
    return this.enrichedCode[hash];
  }
  setIsEnriched(code, val) {
    code = code.trim();
    const hash = import_crypto.default.createHash("sha256").update(code).digest("hex");
    this.enrichedCode[hash] = val !== void 0 ? val : true;
    PiecesDatabase.writeData();
  }
  setAllIsEnriched(enrichedCode) {
    this.enrichedCode = enrichedCode;
  }
  getAllIsEnriched() {
    return this.enrichedCode;
  }
  /**
   * Stores the loaded pieces in one singleton variable so they are accessible everywhere.
   */
  store({
    assets: incomingAssets,
    transferables
  }) {
    if (incomingAssets) {
      this.assets = incomingAssets;
      this.convertToMap(incomingAssets);
      for (let i2 = 0; i2 < incomingAssets.length; i2++) {
        const currentLanguage = incomingAssets[i2].language;
        if (!currentLanguage) {
          continue;
        }
        const curList = this.snippetMap.get(currentLanguage);
        if (curList) {
          curList.push(incomingAssets[i2].id);
        } else {
          this.snippetMap.set(currentLanguage, [incomingAssets[i2].id]);
        }
      }
    }
    if (transferables) {
      this.formatTransferables = transferables;
    }
  }
  /*
     This will add an asset to the beginning of the assets list
     @DEV make sure to provide transferables with the asset!!
   */
  prependAsset({ asset }) {
    if (this.mappedAssets[asset.id]) {
      return this.updateAsset({ asset });
    }
    const processed = processAsset({ asset });
    this.assets.unshift(processed);
    this.mappedAssets[asset.id] = processed;
    if (asset.original.reference?.file || asset.original.reference?.fragment) {
      this.formatTransferables[asset.original.reference?.id] = {
        file: asset.original.reference?.file,
        fragment: asset.original.reference?.fragment
      };
    }
  }
  updateAsset({ asset }) {
    const processed = processAsset({ asset });
    for (let i2 = 0; i2 < this.assets.length; i2++) {
      if (this.assets[i2].id === asset.id) {
        this.assets[i2] = processed;
      }
    }
    this.mappedAssets[asset.id] = processed;
  }
  /**
   * Maps the iterable of Pieces so they are accessible by the id.
   */
  convertToMap(iterable) {
    for (const iter of iterable) {
      this.mappedAssets[iter.id] = iter;
    }
  }
  /**
   *
   * Loads the scheme and providers for each piece required for the snippet display to work.
   */
  static getInstance() {
    if (!PiecesCacheSingleton._instance) {
      PiecesCacheSingleton._instance = new PiecesCacheSingleton();
    }
    return PiecesCacheSingleton._instance;
  }
  /*
  	Overwrites the asset annotations cache to the inputted annotations
  */
  storeAnnotations(annotations, asset) {
    if (asset && !annotations.length)
      this.assetAnnotations.set(asset, /* @__PURE__ */ new Map());
    for (let i2 = 0; i2 < annotations.length; i2++) {
      this.assetAnnotations.delete(annotations[i2].asset?.id ?? "");
    }
    for (let i2 = 0; i2 < annotations.length; i2++) {
      const curMap = this.assetAnnotations.get(annotations[i2].asset?.id ?? "") ?? /* @__PURE__ */ new Map();
      curMap.set(annotations[i2].id, annotations[i2]);
      this.assetAnnotations.set(annotations[i2].asset?.id ?? "", curMap);
    }
  }
  getAllAnnotations(asset) {
    return Array.from(this.assetAnnotations.get(asset)?.values() ?? []);
  }
};

// src/utils/transferables.ts
var mergeAssetsWithTransferables = ({
  assets,
  references
}) => {
  const iterable = assets.iterable;
  for (let i2 = 0; i2 < iterable.length; i2++) {
    const asset = assets.iterable[i2];
    assets.iterable[i2] = mergeAssetWithTransferables({
      asset,
      references
    });
  }
  return assets;
};
var mergeAssetWithTransferables = ({
  asset,
  references
}) => {
  const iterable = asset.formats.iterable || [];
  for (let i2 = 0; i2 < iterable.length; i2++) {
    const format5 = iterable[i2];
    iterable[i2].fragment = references[format5.id]?.fragment;
    iterable[i2].file = references[format5.id]?.file;
  }
  if (asset.original.reference) {
    asset.original.reference.fragment = references[asset.original.id]?.fragment;
    asset.original.reference.file = references[asset.original.id]?.file;
  }
  if (asset.preview.base.reference) {
    asset.preview.base.reference.fragment = references[asset.preview.base.id]?.fragment;
    asset.preview.base.reference.file = references[asset.preview.base.id]?.file;
  }
  if (asset.preview.overlay?.reference) {
    asset.preview.overlay.reference.fragment = references[asset.preview.overlay?.id]?.fragment;
    asset.preview.overlay.reference.file = references[asset.preview.overlay?.id]?.file;
  }
  return asset;
};

// src/connection/api_wrapper.ts
var loadConnect = async () => {
  const config5 = ConnectorSingleton.getInstance();
  try {
    config5.context = await config5.api.connect({
      seededConnectorConnection: config5.seeded
    });
    return true;
  } catch (err) {
    return false;
  }
};
var loadPieces = async () => {
  const config5 = ConnectorSingleton.getInstance();
  const notifications = Notifications.getInstance();
  if (!config5.context) {
    try {
      config5.context = await config5.api.connect({
        seededConnectorConnection: config5.seeded
      });
    } catch (err) {
    }
    if (!config5.context) {
      notifications.error({
        message: "Failed to connect to Pieces OS. Please check that Pieces OS is installed and up to date."
      });
      DisplayController.fetchFailed = true;
      return Promise.reject(new Error("Context Undefined"));
    }
  }
  const snapshot = await fetchSnapshot({ config: config5 });
  if (snapshot instanceof Error) {
    DisplayController.fetchFailed = true;
    return Promise.reject(snapshot);
  }
  await fetchAllFormats({ assets: snapshot.iterable });
  const cache2 = PiecesCacheSingleton.getInstance();
  const assets = mergeAssetsWithTransferables({
    assets: snapshot,
    references: cache2.formatTransferables
  });
  cache2.store({
    assets: processAssets({ assets: assets.iterable }).snippets
  });
  PiecesDatabase.writeData();
  const snippets = cache2.assets;
  DisplayController.fetchFailed = false;
  return snippets;
};
var fetchSnapshot = async ({
  config: config5,
  retry: retry2 = false
}) => {
  const notifications = Notifications.getInstance();
  let snapshot;
  try {
    snapshot = await config5.assetsApi.assetsSnapshot({
      suggested: false,
      transferables: false,
      pseudo: false
    });
    return snapshot;
  } catch (error) {
    if (!retry2) {
      return await fetchSnapshot({
        suggested: false,
        config: config5,
        retry: true
      });
    } else {
      notifications.error({
        message: "Failed to load snippets. Please restart Pieces OS, ensure that it is up-to-date, and try again. If the problem persists please reach out to support.",
        actions: [
          {
            title: "Contact Support",
            type: "OPEN_LINK" /* OPEN_LINK */,
            params: { url: "https://docs.pieces.app/support" }
          }
        ]
      });
      return Promise.reject("Failed to fetch snapshot");
    }
  }
};
var fetchAllFormats = async ({ assets }) => {
  const cache2 = PiecesCacheSingleton.getInstance();
  const formatFetching = [];
  for (const asset of assets) {
    for (const format5 of asset.formats.iterable || []) {
      if (!(format5.id in cache2.fetchedFormats) || cache2.fetchedFormats[format5.id] < format5.updated.value) {
        formatFetching.push(fetchFormatTransferable({ format: format5, asset }));
      }
    }
  }
  await Promise.all(formatFetching);
};
var processAssets = ({ assets }) => {
  const snippets = [];
  for (const asset of assets) {
    snippets.push(processAsset({ asset }));
  }
  return {
    snippets
  };
};
var processAsset = ({ asset }) => {
  const cache2 = PiecesCacheSingleton.getInstance();
  let rawText = void 0;
  let rawFormat = void 0;
  const type = asset.original.reference?.classification.generic;
  if (type === "IMAGE") {
    const decoder = new TextDecoder("utf-8");
    const ocrid = asset.original.reference?.analysis?.image?.ocr?.raw.id;
    if (!ocrid) {
    }
    const format5 = asset.formats.iterable?.find((e3) => e3.id === ocrid);
    const bytes = new Uint8Array(format5?.file?.bytes?.raw ?? []);
    rawText = decoder.decode(bytes);
    rawFormat = format5?.classification.specific;
  }
  let link = void 0;
  for (let i2 = 0; i2 < (asset.shares?.iterable.length ?? 0); i2++) {
    if (asset.shares?.iterable[i2].access === AccessEnum.Public) {
      link = asset.shares?.iterable[i2].link;
      break;
    }
  }
  return {
    title: asset.name || "Unnamed Asset",
    id: asset.id,
    type: asset.original.reference?.classification.generic || "Unknown Type",
    raw: rawText ?? asset.original.reference?.fragment?.string?.raw ?? asset.preview.base.reference?.fragment?.string?.raw ?? asset.original.reference?.file?.string?.raw ?? asset.preview.base.reference?.file?.string?.raw,
    //@ts-ignore
    language: rawFormat ?? (asset.original.reference?.classification.specific || ClassificationSpecificEnum.Ts),
    time: asset.created.readable || "Unknown Time",
    created: new Date(asset.created.value),
    annotations: cache2.getAllAnnotations(asset.id),
    updated: new Date(asset.updated.value),
    share: link ?? void 0
  };
};
var fetchFormatTransferable = async ({
  format: format5,
  asset,
  retryCount = 0
}) => {
  const connector = ConnectorSingleton.getInstance();
  const cache2 = PiecesCacheSingleton.getInstance();
  return connector.formatApi.formatSnapshot({
    format: format5.id,
    transferable: true
  }).then((fetched) => {
    cache2.formatTransferables[format5.id] = {
      file: fetched.file,
      fragment: fetched.fragment
    };
    cache2.fetchedFormats[format5.id] = new Date();
  }).catch((error) => {
    if ((error.message ?? "").includes("connect ECONNRESET") && retryCount++ <= 5) {
      console.log(`Making request ${format5.id} Retry: ${retryCount}`);
      sleep(200).then((_) => {
        fetchFormatTransferable({
          format: format5,
          asset,
          retryCount
        });
      });
    } else if ((error.message ?? "").includes("connect ECONNRESET") && retryCount++ > 5) {
      console.log(
        `Max threshold hit for this format ${format5.id} Error: ${error}`
      );
    }
  });
};

// src/settings/index.ts
var import_obsidian18 = require("obsidian");

// src/actions/login.ts
var login = async () => {
  const notifications = Notifications.getInstance();
  const config5 = ConnectorSingleton.getInstance();
  try {
    const user = (await config5.userApi.userSnapshot()).user;
    if (!user) {
      await config5.osApi.signIntoOS();
    }
    notifications.information({ message: Constants.SIGNIN_SUCCESS });
    return true;
  } catch (error) {
    notifications.error({ message: Constants.SIGNIN_FAIL });
    return false;
  }
};
var logout = async () => {
  const notifications = Notifications.getInstance();
  const config5 = ConnectorSingleton.getInstance();
  try {
    const user = (await config5.userApi.userSnapshot()).user;
    if (user) {
      await config5.osApi.signOutOfOS();
      notifications.information({ message: Constants.SIGNOUT_SUCCESS });
      return true;
    } else {
      notifications.error({ message: Constants.SIGNOUT_FAIL });
      return false;
    }
  } catch (error) {
    return false;
  }
};

// assets/socials/discord.png
var discord_default = "data:image/png;base64,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";

// assets/socials/facebook.png
var facebook_default = "data:image/png;base64,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51XCycv7whe+PRR+Wm56q18AIACATnfk4mq48sGBsCkuEK/6BQACAOhw6VvoToqv+h//yXAYtPgFAAIA6PCT/BZWWveNX/LAQHhxr/f6BQACwEGALJx2U394YONwqA9Z/gIABAB0vHTf/r++c/SafiMAQABABo69pBqW/cNg2FHxql8AgACAjpe+pve919bCV54aDoO+sEcAgACAPO7od8qNfa1v6zMCAAQAZHJjnz9f2R82/tTn/QIABABks/zPvKM/PLvL8hcAIAAgj+W/qBL+4vb+sGlnIzSc7ycAQABA55uzuBouuH+gdaa/e/kLABAAkMkr/7O+XA/lus0vAPz3gACAbD7zP2Nlf9hZtfwFgABAAIAT/owAAAEAnSld5//9bSNO+DMCAAEAOZi1sBJOvL4vfGeL5W8EAAIAspG+znf1xmFbzwgABADk4ojzK+Hz3xqy8YwAQABATj51Tz0Mub2/EQAIAMjHhz7X13qiN0YAIAAgEwuuqoXHNznpzwgABABk45iLq+HGxwfDgPP+jABAAEA+N/tJX+37/Mve+jcCAAEA2fgPf1ML/7jJWX9GACAAIBu/sbASln1j0Fn/RgAgACAnH/xsf6j73N8IAAQA5OPYS6rhiU22vxEACADIxmGLKuHirw6E6oBr/owAQABANtIT+fqtI6Fp/xsBgACAPPzm+dVw9cODoe52/0YAIAAgHycv7wv//ILT/o0AQABANuYsroZr46t/YwQAAgAy8p+u6wvP+rIfIwAQAJDXTX+ue9SrfyMAEACQlbdfWg0v1Zz2bwQAAgCyMStasnrAFjMCAAEAOfmdy6rhme0++zcCAAEAWTnv3oFQqXv73wgABABkI93zf/XG4dCw/40AQABAPk67qb/15G2MAEAAQCaOOL8Slj82GEbsfyMAEACQ041/amH9c277awQAAgCyuvHPJ27vD1Un/xkBgACAfMy9qBpu+KY7/xkBgACArPzelbXw9Ive/jcCAAEAWd3573/c2u/kPyMAEACQk8MWVcLt64dsLSMAEACQk6MWV8POipP/jABAAEBWTl7eZ2MZAYAAgNxc+aBv/jMCAAEA2V3//+RWZ/8bAYAAgKy899q+8OJen/8bAYAAgKycfWc97O0XANN10smbO8b8ZGcjPLVtpC088PRwWHCVAEAAQNu66YnBMOgTgLaf3bVm2PD8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hZ5PEAAIAGOymXK9GU683iWACAAEgDFZzTPbG+G919Y8nyAAEADG5DSrNw6Hdy1xBQACAAFgTFbzpXVDYd6nBQACAAFgTFZz+eoBlwAiABAAxuQ2pb+vh1meSxAACABj8pkX9jbDR2/t91yCAEAAGJPT/OCnjfCBG1wCiABAABiT1TyxaSS8xyWACAAEgDF5zVeeGg5vv9QVAAgABIAxWc2ta4d8BwACAAFgTE5TH2qGK9cMeB5BACAAjMlpdlWb4X/fVfc8ggBAABiT02zZ3QinrnAFAAIAAWBMVrPxxUZ433UCAAGAADAmq/n2syPh6ItcAYAAQAAYk800o4d/NOw5BAGAADAmpxkYDmHpo4OeQxAACABjcpq+wWZYdK8rABAACABjsppyvRk+fLMTABEACABjspqXas1w3DW+AwABgAAwJqt5YW8jzFro+QMBgAAwJqv5zpYRzx8IAASAMbnNbd8e8vyBAEAAGJPbXPJVXwKEAEAAGJPdnP4FlwAiABAAxmQ3777cFQAIAASAMVlNZaDpOwAQAAgAY3KbdAXAUYsFAAKAaW5ufCWzaWcja5t3NWy1A5x0DHN5vNz4+GA44nzPHQgAprnDFlZadzTL2fuuq9ngBzjpGObyeHnHpVU3AUIAQCeYHV/NmQOb2V4RgwAAASAAAAEAAkAAAAIABIAAAAQACAABAAgAEAACABAAIAAEAAgABwEEgAAAAQAIAAEAAgAQAAIABAAgAAQACABAAAgAEACAABAAIABAABgBAAIABIARACAAQAAYAQACAASAEQAgAEAAGAEAAgAEgAAABAAIAAEACAAQAAIAEAAgAAQAIABAAAgAQACAABAAgAAAASAAQAAAAkAAgAAABIAAAAEACAABAAIAEAACAAQAIAAEAAgAEAACQACAAAABYAQACAAQAEYAgAAAAWAEAAgAEABGAIAAAAEgAAABAAJAAAACAASAAAAEAAgAAQAIABAAAgAQACAABAAgAEAACAAQAIAAEAAgAAABIABAAAACQACAAAAEgAAAAQAIAAEAAgAQAAIABAAIACMAQACAADACAAQACAAjAEAAgAAwAgAEAAgAAQAIABAAAgAQACAABAAgAEAACABAAIAAEACAAAABIAAAAQACQACAAAAEgAAAAQAIAAEAAgAQAAIABAAgAAQACABAAAgAEACAABAAIABA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";

// assets/socials/linkedin.png
var linkedin_default = "data:image/png;base64,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";

// assets/socials/youtube.png
var youtube_default = "data:image/png;base64,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";

// assets/socials/twitter.png
var twitter_default = "data:image/png;base64,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";

// src/settings/index.ts
var PiecesSettingTab = class extends import_obsidian18.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.cloud = CloudService.getInstance();
    this.plugin = plugin;
  }
  async display() {
    const { containerEl } = this;
    const config5 = ConnectorSingleton.getInstance();
    containerEl.empty();
    containerEl.createEl("h1", { text: "Pieces Settings" });
    new import_obsidian18.Setting(containerEl).setName(Constants.SHOW_TUTORIAL).setDesc(Constants.TUTORIAL_DESCRIPTION).addButton(
      (comp) => comp.setButtonText("Show").onClick(() => {
        this.plugin.showOnboarding();
      }).setClass("button")
    );
    new import_obsidian18.Setting(containerEl).setName("Snippet Enrichment Levels").setDesc(
      "Choose how much metadata should be automatically added to snippets when you save them. ([NONE: 0], [LOW: 1-3], [MEDIUM: 3-6], [HIGH: 6+])"
    ).addDropdown((dropdown) => {
      dropdown.addOptions({
        NONE: "NONE",
        LOW: "LOW",
        MEDIUM: "MEDIUM",
        HIGH: "HIGH"
      }).setValue(pluginSettings.enrichmentLevels).onChange((value) => {
        pluginSettings.enrichmentLevels = value;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian18.Setting(containerEl).setName(Constants.TOGGLE_AUTOOPEN).setDesc(Constants.TOGGLE_AUTOOPEN_DESC).addToggle(
      (comp) => comp.setValue(this.plugin.settings.autoOpen).onChange((value) => {
        this.plugin.settings.autoOpen = value;
        this.plugin.saveSettings();
      })
    );
    new import_obsidian18.Setting(containerEl).setName(Constants.ENRICH_PERSISTENCE).setDesc(Constants.ENRICH_PERSISTENCE_DESC).addToggle((comp) => {
      comp.setValue(this.plugin.settings.enrich_confirmation).onChange((value) => {
        this.plugin.settings.enrich_confirmation = value;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian18.Setting(containerEl).setName(Constants.TOGGLE_AUTODISCOVER).setDesc(Constants.TOGGLE_AUTODISCOVER_DESC).addToggle(
      (comp) => comp.setValue(this.plugin.settings.autoDiscover).onChange(async (value) => {
        this.plugin.settings.autoDiscover = value;
        this.plugin.saveSettings();
      })
    );
    new import_obsidian18.Setting(containerEl).setName(Constants.TOGGLE_USE_NOTE_TITLE).setDesc(Constants.TOGGLE_USE_NOTE_TITLE_DESC).addToggle((comp) => {
      comp.setValue(this.plugin.settings.use_note_title).onChange(async (value) => {
        this.plugin.settings.use_note_title = value;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian18.Setting(containerEl).setName(Constants.TOGGLE_AUTODISCOVER_MAX).setDesc(Constants.TOGGLE_AUTODISCOVER_DESC_MAX).addSlider(
      (comp) => comp.setLimits(1, 200, 1).setDynamicTooltip().setValue(this.plugin.settings.autoDiscoverMaximum).onChange(async (value) => {
        this.plugin.settings.autoDiscoverMaximum = value;
        if (DisplayController.discoveryProgressBar)
          DisplayController.discoveryProgressBar.resetEnd(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian18.Setting(containerEl).setName(Constants.CLOUD_SELECT).setDesc(Constants.CLOUD_SELECT_DESC).addDropdown(
      (comp) => comp.addOptions({
        blended: "Blended",
        local: "Local",
        cloud: "Cloud"
      }).setValue(this.plugin.settings.cloudCapabilities).onChange(
        async (value) => {
          this.plugin.settings.cloudCapabilities = value;
          await updateConnectionType(this.plugin.settings);
          await this.plugin.saveSettings();
        }
      )
    );
    new import_obsidian18.Setting(containerEl).setName(Constants.PORT_PROMPT).addText((comp) => comp.setValue(Constants.PORT_VALUE).setDisabled(true)).setDesc(Constants.PORT_DESCRIPTION);
    let user = (await config5.userApi.userSnapshot()).user;
    if (user) {
      new import_obsidian18.Setting(containerEl).setName(Constants.LOGOUT_TITLE).setDesc(Constants.LOGOUT_DESC).addButton(
        (comp) => comp.setButtonText("Logout").onClick(async () => {
          const success = await logout();
          if (success) {
            await this.refreshSettingsView();
          }
        }).setClass("button")
      );
    } else {
      new import_obsidian18.Setting(containerEl).setName(Constants.LOGIN_TITLE).setDesc(Constants.LOGIN_DESC).addButton(
        (comp) => comp.setButtonText("Login").onClick(async () => {
          const success = await login();
          user = (await config5.userApi.userSnapshot()).user;
          if (success) {
            await this.refreshSettingsView();
          }
        }).setClass("button")
      );
    }
    containerEl.createEl("hr", {
      cls: "settings_divider"
    });
    createExternalLinksSection(containerEl);
    containerEl.createEl("hr");
    createSocialLinksSection(containerEl);
    containerEl.createEl("br");
    containerEl.createEl("br");
    containerEl.createEl("br");
    containerEl.createEl("br");
    const imageDiv = containerEl.createEl("div");
    imageDiv.addClass("settings-div");
    const imageTest = imageDiv.createEl("img");
    if (theme === "dark") {
      imageTest.setAttr("src", pfdSettings_white_default);
    } else {
      imageTest.setAttr("src", pfdSettings_black_default);
    }
    imageTest.setAttr("alt", "Pieces settings logo");
  }
  async refreshSettingsView() {
    await this.display();
  }
};
var createExternalLinksSection = (containerEl) => {
  const externalLinks = [
    {
      href: "https://docs.pieces.app/extensions-plugins/obsidian",
      text: "Docs",
      class: ["settings_external_links", "button"]
    },
    {
      href: "https://getpieces.typeform.com/obsidian-plugin?typeform-source=pfo-settings",
      text: "Leave feedback",
      class: ["settings_external_links", "button"]
    }
  ];
  const externalLinksSection = containerEl.createEl("div", {
    cls: "settings_external_links_section"
  });
  for (const link of externalLinks) {
    const btn = containerEl.createEl("button");
    const p = btn.createEl("p");
    btn.onClickEvent((event) => {
      window.open(link.href);
    });
    p.textContent = link.text;
    p.addClasses(link.class);
    externalLinksSection.appendChild(btn);
  }
};
var createSocialLinksSection = (containerEl) => {
  const socialLinks = [
    {
      href: "https://discord.gg/GkmyfqWf3W",
      text: "Discord",
      icon: discord_default,
      class: ["settings_external_links", "button"],
      width: 40,
      height: 30
    },
    {
      href: "https://www.youtube.com/@getpieces",
      text: "YouTube",
      icon: youtube_default,
      class: ["settings_external_links", "button"],
      width: 55,
      height: 30
    },
    {
      href: "https://twitter.com/@getpieces",
      text: "Twitter",
      icon: twitter_default,
      class: ["settings_external_links", "button"],
      width: 35,
      height: 30
    },
    {
      href: "https://www.linkedin.com/company/getpieces",
      text: "LinkedIn",
      icon: linkedin_default,
      class: ["settings_external_links", "button"],
      width: 30,
      height: 30
    },
    {
      href: "https://www.facebook.com/getpieces",
      text: "Facebook",
      icon: facebook_default,
      class: ["settings_external_links", "button"],
      width: 30,
      height: 30
    }
  ];
  const socialLinksSection = containerEl.createEl("div", {
    cls: "settings_external_links_section"
  });
  for (const link of socialLinks) {
    const img = containerEl.createEl("img");
    img.onClickEvent((event) => {
      window.open(link.href);
    });
    img.src = link.icon;
    img.width = link.width;
    img.height = link.height;
    img.addClasses(link.class);
    socialLinksSection.appendChild(img);
  }
};
var updateConnectionType = async (settings) => {
  const configuration = ConnectorSingleton.getInstance();
  try {
    const cloudCapabilities = settings.cloudCapabilities === "cloud" ? CapabilitiesEnum.Cloud : settings.cloudCapabilities === "blended" ? CapabilitiesEnum.Blended : CapabilitiesEnum.Local;
    const updatedApplication = await configuration.applicationApi.applicationUpdate({
      application: {
        ...configuration.context.application,
        capabilities: cloudCapabilities
      }
    });
    if (updatedApplication) {
      configuration.context.application = updatedApplication;
    }
  } catch (error) {
  }
};

// src/settings/defaults.ts
var DEFAULT_SETTINGS = {
  cloudCapabilities: "blended",
  hasLoaded: false,
  autoOpen: true,
  autoDiscover: true,
  enrich_confirmation: true,
  autoDiscoverMaximum: 50,
  use_note_title: false,
  enrichmentLevels: "HIGH"
};

// src/ui/views/pieces-snippet-list-view.ts
var import_obsidian19 = require("obsidian");

// src/ui/views/copilot/index.ts
var semver = __toESM(require_semver2());

// node_modules/color-parse/node_modules/color-name/index.js
var color_name_default = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};

// node_modules/color-parse/index.js
var color_parse_default = parse;
var baseHues = {
  red: 0,
  orange: 60,
  yellow: 120,
  green: 180,
  blue: 240,
  purple: 300
};
function parse(cstr) {
  var m, parts = [], alpha = 1, space;
  if (typeof cstr === "number") {
    return { space: "rgb", values: [cstr >>> 16, (cstr & 65280) >>> 8, cstr & 255], alpha: 1 };
  }
  if (typeof cstr === "number")
    return { space: "rgb", values: [cstr >>> 16, (cstr & 65280) >>> 8, cstr & 255], alpha: 1 };
  cstr = String(cstr).toLowerCase();
  if (color_name_default[cstr]) {
    parts = color_name_default[cstr].slice();
    space = "rgb";
  } else if (cstr === "transparent") {
    alpha = 0;
    space = "rgb";
    parts = [0, 0, 0];
  } else if (cstr[0] === "#") {
    var base = cstr.slice(1);
    var size2 = base.length;
    var isShort = size2 <= 4;
    alpha = 1;
    if (isShort) {
      parts = [
        parseInt(base[0] + base[0], 16),
        parseInt(base[1] + base[1], 16),
        parseInt(base[2] + base[2], 16)
      ];
      if (size2 === 4) {
        alpha = parseInt(base[3] + base[3], 16) / 255;
      }
    } else {
      parts = [
        parseInt(base[0] + base[1], 16),
        parseInt(base[2] + base[3], 16),
        parseInt(base[4] + base[5], 16)
      ];
      if (size2 === 8) {
        alpha = parseInt(base[6] + base[7], 16) / 255;
      }
    }
    if (!parts[0])
      parts[0] = 0;
    if (!parts[1])
      parts[1] = 0;
    if (!parts[2])
      parts[2] = 0;
    space = "rgb";
  } else if (m = /^((?:rgba?|hs[lvb]a?|hwba?|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms|oklch|oklab|color))\s*\(([^\)]*)\)/.exec(cstr)) {
    var name314 = m[1];
    space = name314.replace(/a$/, "");
    var dims = space === "cmyk" ? 4 : space === "gray" ? 1 : 3;
    parts = m[2].trim().split(/\s*[,\/]\s*|\s+/);
    if (space === "color")
      space = parts.shift();
    parts = parts.map(function(x, i2) {
      if (x[x.length - 1] === "%") {
        x = parseFloat(x) / 100;
        if (i2 === 3)
          return x;
        if (space === "rgb")
          return x * 255;
        if (space[0] === "h")
          return x * 100;
        if (space[0] === "l" && !i2)
          return x * 100;
        if (space === "lab")
          return x * 125;
        if (space === "lch")
          return i2 < 2 ? x * 150 : x * 360;
        if (space[0] === "o" && !i2)
          return x;
        if (space === "oklab")
          return x * 0.4;
        if (space === "oklch")
          return i2 < 2 ? x * 0.4 : x * 360;
        return x;
      }
      if (space[i2] === "h" || i2 === 2 && space[space.length - 1] === "h") {
        if (baseHues[x] !== void 0)
          return baseHues[x];
        if (x.endsWith("deg"))
          return parseFloat(x);
        if (x.endsWith("turn"))
          return parseFloat(x) * 360;
        if (x.endsWith("grad"))
          return parseFloat(x) * 360 / 400;
        if (x.endsWith("rad"))
          return parseFloat(x) * 180 / Math.PI;
      }
      if (x === "none")
        return 0;
      return parseFloat(x);
    });
    alpha = parts.length > dims ? parts.pop() : 1;
  } else if (/[0-9](?:\s|\/|,)/.test(cstr)) {
    parts = cstr.match(/([0-9]+)/g).map(function(value) {
      return parseFloat(value);
    });
    space = cstr.match(/([a-z])/ig)?.join("")?.toLowerCase() || "rgb";
  }
  return {
    space,
    values: parts,
    alpha
  };
}

// node_modules/color-space/rgb.js
var rgb_default = {
  name: "rgb",
  min: [0, 0, 0],
  max: [255, 255, 255],
  channel: ["red", "green", "blue"],
  alias: ["RGB"]
};

// node_modules/color-space/hsl.js
var hsl_default = {
  name: "hsl",
  min: [0, 0, 0],
  max: [360, 100, 100],
  channel: ["hue", "saturation", "lightness"],
  alias: ["HSL"],
  rgb: function(hsl) {
    var h = hsl[0] / 360, s = hsl[1] / 100, l = hsl[2] / 100, t1, t2, t3, rgb, val, i2 = 0;
    if (s === 0)
      return val = l * 255, [val, val, val];
    t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
    t1 = 2 * l - t2;
    rgb = [0, 0, 0];
    for (; i2 < 3; ) {
      t3 = h + 1 / 3 * -(i2 - 1);
      t3 < 0 ? t3++ : t3 > 1 && t3--;
      val = 6 * t3 < 1 ? t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? t2 : 3 * t3 < 2 ? t1 + (t2 - t1) * (2 / 3 - t3) * 6 : t1;
      rgb[i2++] = val * 255;
    }
    return rgb;
  }
};
rgb_default.hsl = function(rgb) {
  var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, min3 = Math.min(r, g, b), max3 = Math.max(r, g, b), delta = max3 - min3, h, s, l;
  if (max3 === min3) {
    h = 0;
  } else if (r === max3) {
    h = (g - b) / delta;
  } else if (g === max3) {
    h = 2 + (b - r) / delta;
  } else if (b === max3) {
    h = 4 + (r - g) / delta;
  }
  h = Math.min(h * 60, 360);
  if (h < 0) {
    h += 360;
  }
  l = (min3 + max3) / 2;
  if (max3 === min3) {
    s = 0;
  } else if (l <= 0.5) {
    s = delta / (max3 + min3);
  } else {
    s = delta / (2 - max3 - min3);
  }
  return [h, s * 100, l * 100];
};

// node_modules/color-rgba/index.js
function rgba(color) {
  if (Array.isArray(color) && color.raw)
    color = String.raw(...arguments);
  if (color instanceof Number)
    color = +color;
  var values, i2, l;
  var parsed = color_parse_default(color);
  if (!parsed.space)
    return [];
  const min3 = parsed.space[0] === "h" ? hsl_default.min : rgb_default.min;
  const max3 = parsed.space[0] === "h" ? hsl_default.max : rgb_default.max;
  values = Array(3);
  values[0] = Math.min(Math.max(parsed.values[0], min3[0]), max3[0]);
  values[1] = Math.min(Math.max(parsed.values[1], min3[1]), max3[1]);
  values[2] = Math.min(Math.max(parsed.values[2], min3[2]), max3[2]);
  if (parsed.space[0] === "h") {
    values = hsl_default.rgb(values);
  }
  values.push(Math.min(Math.max(parsed.alpha, 0), 1));
  return values;
}

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t = arguments[e3];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}

// node_modules/mathjs/lib/esm/core/config.js
var DEFAULT_CONFIG = {
  // minimum relative difference between two compared values,
  // used by all comparison functions
  relTol: 1e-12,
  // minimum absolute difference between two compared values,
  // used by all comparison functions
  absTol: 1e-15,
  // type of default matrix output. Choose 'matrix' (default) or 'array'
  matrix: "Matrix",
  // type of default number output. Choose 'number' (default) 'BigNumber', 'bigint', or 'Fraction'
  number: "number",
  // type of fallback used for config { number: 'bigint' } when a value cannot be represented
  // in the configured numeric type. Choose 'number' (default) or 'BigNumber'.
  numberFallback: "number",
  // number of significant digits in BigNumbers
  precision: 64,
  // predictable output type of functions. When true, output type depends only
  // on the input types. When false (default), output type can vary depending
  // on input values. For example `math.sqrt(-4)` returns `complex('2i')` when
  // predictable is false, and returns `NaN` when true.
  predictable: false,
  // random seed for seeded pseudo random number generation
  // null = randomly seed
  randomSeed: null
};

// node_modules/mathjs/lib/esm/utils/is.js
function isNumber(x) {
  return typeof x === "number";
}
function isBigNumber(x) {
  if (!x || typeof x !== "object" || typeof x.constructor !== "function") {
    return false;
  }
  if (x.isBigNumber === true && typeof x.constructor.prototype === "object" && x.constructor.prototype.isBigNumber === true) {
    return true;
  }
  if (typeof x.constructor.isDecimal === "function" && x.constructor.isDecimal(x) === true) {
    return true;
  }
  return false;
}
function isBigInt(x) {
  return typeof x === "bigint";
}
function isComplex(x) {
  return x && typeof x === "object" && Object.getPrototypeOf(x).isComplex === true || false;
}
function isFraction(x) {
  return x && typeof x === "object" && Object.getPrototypeOf(x).isFraction === true || false;
}
function isUnit(x) {
  return x && x.constructor.prototype.isUnit === true || false;
}
function isString(x) {
  return typeof x === "string";
}
var isArray = Array.isArray;
function isMatrix(x) {
  return x && x.constructor.prototype.isMatrix === true || false;
}
function isCollection(x) {
  return Array.isArray(x) || isMatrix(x);
}
function isDenseMatrix(x) {
  return x && x.isDenseMatrix && x.constructor.prototype.isMatrix === true || false;
}
function isSparseMatrix(x) {
  return x && x.isSparseMatrix && x.constructor.prototype.isMatrix === true || false;
}
function isRange(x) {
  return x && x.constructor.prototype.isRange === true || false;
}
function isIndex(x) {
  return x && x.constructor.prototype.isIndex === true || false;
}
function isBoolean(x) {
  return typeof x === "boolean";
}
function isResultSet(x) {
  return x && x.constructor.prototype.isResultSet === true || false;
}
function isHelp(x) {
  return x && x.constructor.prototype.isHelp === true || false;
}
function isFunction(x) {
  return typeof x === "function";
}
function isDate(x) {
  return x instanceof Date;
}
function isRegExp(x) {
  return x instanceof RegExp;
}
function isObject(x) {
  return !!(x && typeof x === "object" && x.constructor === Object && !isComplex(x) && !isFraction(x));
}
function isNull(x) {
  return x === null;
}
function isUndefined(x) {
  return x === void 0;
}
function isAccessorNode(x) {
  return x && x.isAccessorNode === true && x.constructor.prototype.isNode === true || false;
}
function isArrayNode(x) {
  return x && x.isArrayNode === true && x.constructor.prototype.isNode === true || false;
}
function isAssignmentNode(x) {
  return x && x.isAssignmentNode === true && x.constructor.prototype.isNode === true || false;
}
function isBlockNode(x) {
  return x && x.isBlockNode === true && x.constructor.prototype.isNode === true || false;
}
function isConditionalNode(x) {
  return x && x.isConditionalNode === true && x.constructor.prototype.isNode === true || false;
}
function isConstantNode(x) {
  return x && x.isConstantNode === true && x.constructor.prototype.isNode === true || false;
}
function rule2Node(node) {
  return isConstantNode(node) || isOperatorNode(node) && node.args.length === 1 && isConstantNode(node.args[0]) && "-+~".includes(node.op);
}
function isFunctionAssignmentNode(x) {
  return x && x.isFunctionAssignmentNode === true && x.constructor.prototype.isNode === true || false;
}
function isFunctionNode(x) {
  return x && x.isFunctionNode === true && x.constructor.prototype.isNode === true || false;
}
function isIndexNode(x) {
  return x && x.isIndexNode === true && x.constructor.prototype.isNode === true || false;
}
function isNode(x) {
  return x && x.isNode === true && x.constructor.prototype.isNode === true || false;
}
function isObjectNode(x) {
  return x && x.isObjectNode === true && x.constructor.prototype.isNode === true || false;
}
function isOperatorNode(x) {
  return x && x.isOperatorNode === true && x.constructor.prototype.isNode === true || false;
}
function isParenthesisNode(x) {
  return x && x.isParenthesisNode === true && x.constructor.prototype.isNode === true || false;
}
function isRangeNode(x) {
  return x && x.isRangeNode === true && x.constructor.prototype.isNode === true || false;
}
function isRelationalNode(x) {
  return x && x.isRelationalNode === true && x.constructor.prototype.isNode === true || false;
}
function isSymbolNode(x) {
  return x && x.isSymbolNode === true && x.constructor.prototype.isNode === true || false;
}
function isChain(x) {
  return x && x.constructor.prototype.isChain === true || false;
}
function typeOf(x) {
  var t = typeof x;
  if (t === "object") {
    if (x === null)
      return "null";
    if (isBigNumber(x))
      return "BigNumber";
    if (x.constructor && x.constructor.name)
      return x.constructor.name;
    return "Object";
  }
  return t;
}

// node_modules/mathjs/lib/esm/utils/object.js
function clone(x) {
  var type = typeof x;
  if (type === "number" || type === "bigint" || type === "string" || type === "boolean" || x === null || x === void 0) {
    return x;
  }
  if (typeof x.clone === "function") {
    return x.clone();
  }
  if (Array.isArray(x)) {
    return x.map(function(value) {
      return clone(value);
    });
  }
  if (x instanceof Date)
    return new Date(x.valueOf());
  if (isBigNumber(x))
    return x;
  if (isObject(x)) {
    return mapObject(x, clone);
  }
  throw new TypeError("Cannot clone: unknown type of value (value: ".concat(x, ")"));
}
function mapObject(object, callback) {
  var clone5 = {};
  for (var key in object) {
    if (hasOwnProperty(object, key)) {
      clone5[key] = callback(object[key]);
    }
  }
  return clone5;
}
function extend(a, b) {
  for (var prop in b) {
    if (hasOwnProperty(b, prop)) {
      a[prop] = b[prop];
    }
  }
  return a;
}
function deepStrictEqual(a, b) {
  var prop, i2, len;
  if (Array.isArray(a)) {
    if (!Array.isArray(b)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    for (i2 = 0, len = a.length; i2 < len; i2++) {
      if (!deepStrictEqual(a[i2], b[i2])) {
        return false;
      }
    }
    return true;
  } else if (typeof a === "function") {
    return a === b;
  } else if (a instanceof Object) {
    if (Array.isArray(b) || !(b instanceof Object)) {
      return false;
    }
    for (prop in a) {
      if (!(prop in b) || !deepStrictEqual(a[prop], b[prop])) {
        return false;
      }
    }
    for (prop in b) {
      if (!(prop in a)) {
        return false;
      }
    }
    return true;
  } else {
    return a === b;
  }
}
function lazy(object, prop, valueResolver) {
  var _uninitialized = true;
  var _value;
  Object.defineProperty(object, prop, {
    get: function get() {
      if (_uninitialized) {
        _value = valueResolver();
        _uninitialized = false;
      }
      return _value;
    },
    set: function set(value) {
      _value = value;
      _uninitialized = false;
    },
    configurable: true,
    enumerable: true
  });
}
function hasOwnProperty(object, property) {
  return object && Object.hasOwnProperty.call(object, property);
}
function pickShallow(object, properties2) {
  var copy = {};
  for (var i2 = 0; i2 < properties2.length; i2++) {
    var key = properties2[i2];
    var value = object[key];
    if (value !== void 0) {
      copy[key] = value;
    }
  }
  return copy;
}

// node_modules/mathjs/lib/esm/core/function/config.js
var MATRIX_OPTIONS = ["Matrix", "Array"];
var NUMBER_OPTIONS = ["number", "BigNumber", "Fraction"];

// node_modules/mathjs/lib/esm/entry/configReadonly.js
var config2 = function config3(options2) {
  if (options2) {
    throw new Error("The global config is readonly. \nPlease create a mathjs instance if you want to change the default configuration. \nExample:\n\n  import { create, all } from 'mathjs';\n  const mathjs = create(all);\n  mathjs.config({ number: 'BigNumber' });\n");
  }
  return Object.freeze(DEFAULT_CONFIG);
};
_extends(config2, DEFAULT_CONFIG, {
  MATRIX_OPTIONS,
  NUMBER_OPTIONS
});

// node_modules/mathjs/lib/esm/core/function/typed.js
var import_typed_function = __toESM(require_typed_function(), 1);

// node_modules/mathjs/lib/esm/utils/number.js
function isInteger(value) {
  if (typeof value === "boolean") {
    return true;
  }
  return isFinite(value) ? value === Math.round(value) : false;
}
function isIntegerStr(str) {
  return /^-?\d+$/.test(str);
}
function safeNumberType(numberStr, config5) {
  if (config5.number === "bigint" && !isIntegerStr(numberStr)) {
    return config5.numberFallback;
  }
  return config5.number;
}
var sign = Math.sign || function(x) {
  if (x > 0) {
    return 1;
  } else if (x < 0) {
    return -1;
  } else {
    return 0;
  }
};
var log2 = Math.log2 || function log22(x) {
  return Math.log(x) / Math.LN2;
};
var log10 = Math.log10 || function log102(x) {
  return Math.log(x) / Math.LN10;
};
var log1p = Math.log1p || function(x) {
  return Math.log(x + 1);
};
var cbrt = Math.cbrt || function cbrt2(x) {
  if (x === 0) {
    return x;
  }
  var negate = x < 0;
  var result;
  if (negate) {
    x = -x;
  }
  if (isFinite(x)) {
    result = Math.exp(Math.log(x) / 3);
    result = (x / (result * result) + 2 * result) / 3;
  } else {
    result = x;
  }
  return negate ? -result : result;
};
var expm1 = Math.expm1 || function expm12(x) {
  return x >= 2e-4 || x <= -2e-4 ? Math.exp(x) - 1 : x + x * x / 2 + x * x * x / 6;
};
function formatNumberToBase(n, base, size2) {
  var prefixes = {
    2: "0b",
    8: "0o",
    16: "0x"
  };
  var prefix = prefixes[base];
  var suffix = "";
  if (size2) {
    if (size2 < 1) {
      throw new Error("size must be in greater than 0");
    }
    if (!isInteger(size2)) {
      throw new Error("size must be an integer");
    }
    if (n > 2 ** (size2 - 1) - 1 || n < -(2 ** (size2 - 1))) {
      throw new Error("Value must be in range [-2^".concat(size2 - 1, ", 2^").concat(size2 - 1, "-1]"));
    }
    if (!isInteger(n)) {
      throw new Error("Value must be an integer");
    }
    if (n < 0) {
      n = n + 2 ** size2;
    }
    suffix = "i".concat(size2);
  }
  var sign4 = "";
  if (n < 0) {
    n = -n;
    sign4 = "-";
  }
  return "".concat(sign4).concat(prefix).concat(n.toString(base)).concat(suffix);
}
function format(value, options2) {
  if (typeof options2 === "function") {
    return options2(value);
  }
  if (value === Infinity) {
    return "Infinity";
  } else if (value === -Infinity) {
    return "-Infinity";
  } else if (isNaN(value)) {
    return "NaN";
  }
  var {
    notation,
    precision,
    wordSize
  } = normalizeFormatOptions(options2);
  switch (notation) {
    case "fixed":
      return toFixed(value, precision);
    case "exponential":
      return toExponential(value, precision);
    case "engineering":
      return toEngineering(value, precision);
    case "bin":
      return formatNumberToBase(value, 2, wordSize);
    case "oct":
      return formatNumberToBase(value, 8, wordSize);
    case "hex":
      return formatNumberToBase(value, 16, wordSize);
    case "auto":
      return toPrecision(value, precision, options2).replace(/((\.\d*?)(0+))($|e)/, function() {
        var digits2 = arguments[2];
        var e3 = arguments[4];
        return digits2 !== "." ? digits2 + e3 : e3;
      });
    default:
      throw new Error('Unknown notation "' + notation + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
  }
}
function normalizeFormatOptions(options2) {
  var notation = "auto";
  var precision;
  var wordSize;
  if (options2 !== void 0) {
    if (isNumber(options2)) {
      precision = options2;
    } else if (isBigNumber(options2)) {
      precision = options2.toNumber();
    } else if (isObject(options2)) {
      if (options2.precision !== void 0) {
        precision = _toNumberOrThrow(options2.precision, () => {
          throw new Error('Option "precision" must be a number or BigNumber');
        });
      }
      if (options2.wordSize !== void 0) {
        wordSize = _toNumberOrThrow(options2.wordSize, () => {
          throw new Error('Option "wordSize" must be a number or BigNumber');
        });
      }
      if (options2.notation) {
        notation = options2.notation;
      }
    } else {
      throw new Error("Unsupported type of options, number, BigNumber, or object expected");
    }
  }
  return {
    notation,
    precision,
    wordSize
  };
}
function splitNumber(value) {
  var match = String(value).toLowerCase().match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);
  if (!match) {
    throw new SyntaxError("Invalid number " + value);
  }
  var sign4 = match[1];
  var digits2 = match[2];
  var exponent = parseFloat(match[4] || "0");
  var dot2 = digits2.indexOf(".");
  exponent += dot2 !== -1 ? dot2 - 1 : digits2.length - 1;
  var coefficients = digits2.replace(".", "").replace(/^0*/, function(zeros3) {
    exponent -= zeros3.length;
    return "";
  }).replace(/0*$/, "").split("").map(function(d) {
    return parseInt(d);
  });
  if (coefficients.length === 0) {
    coefficients.push(0);
    exponent++;
  }
  return {
    sign: sign4,
    coefficients,
    exponent
  };
}
function toEngineering(value, precision) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var split = splitNumber(value);
  var rounded = roundDigits(split, precision);
  var e3 = rounded.exponent;
  var c = rounded.coefficients;
  var newExp = e3 % 3 === 0 ? e3 : e3 < 0 ? e3 - 3 - e3 % 3 : e3 - e3 % 3;
  if (isNumber(precision)) {
    while (precision > c.length || e3 - newExp + 1 > c.length) {
      c.push(0);
    }
  } else {
    var missingZeros = Math.abs(e3 - newExp) - (c.length - 1);
    for (var i2 = 0; i2 < missingZeros; i2++) {
      c.push(0);
    }
  }
  var expDiff = Math.abs(e3 - newExp);
  var decimalIdx = 1;
  while (expDiff > 0) {
    decimalIdx++;
    expDiff--;
  }
  var decimals = c.slice(decimalIdx).join("");
  var decimalVal = isNumber(precision) && decimals.length || decimals.match(/[1-9]/) ? "." + decimals : "";
  var str = c.slice(0, decimalIdx).join("") + decimalVal + "e" + (e3 >= 0 ? "+" : "") + newExp.toString();
  return rounded.sign + str;
}
function toFixed(value, precision) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var splitValue = splitNumber(value);
  var rounded = typeof precision === "number" ? roundDigits(splitValue, splitValue.exponent + 1 + precision) : splitValue;
  var c = rounded.coefficients;
  var p = rounded.exponent + 1;
  var pp = p + (precision || 0);
  if (c.length < pp) {
    c = c.concat(zeros(pp - c.length));
  }
  if (p < 0) {
    c = zeros(-p + 1).concat(c);
    p = 1;
  }
  if (p < c.length) {
    c.splice(p, 0, p === 0 ? "0." : ".");
  }
  return rounded.sign + c.join("");
}
function toExponential(value, precision) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var split = splitNumber(value);
  var rounded = precision ? roundDigits(split, precision) : split;
  var c = rounded.coefficients;
  var e3 = rounded.exponent;
  if (c.length < precision) {
    c = c.concat(zeros(precision - c.length));
  }
  var first = c.shift();
  return rounded.sign + first + (c.length > 0 ? "." + c.join("") : "") + "e" + (e3 >= 0 ? "+" : "") + e3;
}
function toPrecision(value, precision, options2) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var lowerExp = _toNumberOrDefault(options2 === null || options2 === void 0 ? void 0 : options2.lowerExp, -3);
  var upperExp = _toNumberOrDefault(options2 === null || options2 === void 0 ? void 0 : options2.upperExp, 5);
  var split = splitNumber(value);
  var rounded = precision ? roundDigits(split, precision) : split;
  if (rounded.exponent < lowerExp || rounded.exponent >= upperExp) {
    return toExponential(value, precision);
  } else {
    var c = rounded.coefficients;
    var e3 = rounded.exponent;
    if (c.length < precision) {
      c = c.concat(zeros(precision - c.length));
    }
    c = c.concat(zeros(e3 - c.length + 1 + (c.length < precision ? precision - c.length : 0)));
    c = zeros(-e3).concat(c);
    var dot2 = e3 > 0 ? e3 : 0;
    if (dot2 < c.length - 1) {
      c.splice(dot2 + 1, 0, ".");
    }
    return rounded.sign + c.join("");
  }
}
function roundDigits(split, precision) {
  var rounded = {
    sign: split.sign,
    coefficients: split.coefficients,
    exponent: split.exponent
  };
  var c = rounded.coefficients;
  while (precision <= 0) {
    c.unshift(0);
    rounded.exponent++;
    precision++;
  }
  if (c.length > precision) {
    var removed = c.splice(precision, c.length - precision);
    if (removed[0] >= 5) {
      var i2 = precision - 1;
      c[i2]++;
      while (c[i2] === 10) {
        c.pop();
        if (i2 === 0) {
          c.unshift(0);
          rounded.exponent++;
          i2++;
        }
        i2--;
        c[i2]++;
      }
    }
  }
  return rounded;
}
function zeros(length) {
  var arr = [];
  for (var i2 = 0; i2 < length; i2++) {
    arr.push(0);
  }
  return arr;
}
function digits(value) {
  return value.toExponential().replace(/e.*$/, "").replace(/^0\.?0*|\./, "").length;
}
var DBL_EPSILON = Number.EPSILON || 2220446049250313e-31;
function nearlyEqual(a, b) {
  var relTol = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1e-8;
  var absTol = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
  if (relTol <= 0) {
    throw new Error("Relative tolerance must be greater than 0");
  }
  if (absTol < 0) {
    throw new Error("Absolute tolerance must be at least 0");
  }
  if (isNaN(a) || isNaN(b)) {
    return false;
  }
  if (!isFinite(a) || !isFinite(b)) {
    return a === b;
  }
  if (a === b) {
    return true;
  }
  return Math.abs(a - b) <= Math.max(relTol * Math.max(Math.abs(a), Math.abs(b)), absTol);
}
var acosh = Math.acosh || function(x) {
  return Math.log(Math.sqrt(x * x - 1) + x);
};
var asinh = Math.asinh || function(x) {
  return Math.log(Math.sqrt(x * x + 1) + x);
};
var atanh = Math.atanh || function(x) {
  return Math.log((1 + x) / (1 - x)) / 2;
};
var cosh = Math.cosh || function(x) {
  return (Math.exp(x) + Math.exp(-x)) / 2;
};
var sinh = Math.sinh || function(x) {
  return (Math.exp(x) - Math.exp(-x)) / 2;
};
var tanh = Math.tanh || function(x) {
  var e3 = Math.exp(2 * x);
  return (e3 - 1) / (e3 + 1);
};
function copysign(x, y) {
  var signx = x > 0 ? true : x < 0 ? false : 1 / x === Infinity;
  var signy = y > 0 ? true : y < 0 ? false : 1 / y === Infinity;
  return signx ^ signy ? -x : x;
}
function _toNumberOrThrow(value, onError) {
  if (isNumber(value)) {
    return value;
  } else if (isBigNumber(value)) {
    return value.toNumber();
  } else {
    onError();
  }
}
function _toNumberOrDefault(value, defaultValue) {
  if (isNumber(value)) {
    return value;
  } else if (isBigNumber(value)) {
    return value.toNumber();
  } else {
    return defaultValue;
  }
}

// node_modules/mathjs/lib/esm/utils/factory.js
function factory(name314, dependencies315, create, meta) {
  function assertAndCreate(scope) {
    var deps = pickShallow(scope, dependencies315.map(stripOptionalNotation));
    assertDependencies(name314, dependencies315, scope);
    return create(deps);
  }
  assertAndCreate.isFactory = true;
  assertAndCreate.fn = name314;
  assertAndCreate.dependencies = dependencies315.slice().sort();
  if (meta) {
    assertAndCreate.meta = meta;
  }
  return assertAndCreate;
}
function assertDependencies(name314, dependencies315, scope) {
  var allDefined = dependencies315.filter((dependency) => !isOptionalDependency(dependency)).every((dependency) => scope[dependency] !== void 0);
  if (!allDefined) {
    var missingDependencies = dependencies315.filter((dependency) => scope[dependency] === void 0);
    throw new Error('Cannot create function "'.concat(name314, '", ') + "some dependencies are missing: ".concat(missingDependencies.map((d) => '"'.concat(d, '"')).join(", "), "."));
  }
}
function isOptionalDependency(dependency) {
  return dependency && dependency[0] === "?";
}
function stripOptionalNotation(dependency) {
  return dependency && dependency[0] === "?" ? dependency.slice(1) : dependency;
}

// node_modules/mathjs/lib/esm/utils/customs.js
function getSafeProperty(object, prop) {
  if (isPlainObject(object) && isSafeProperty(object, prop)) {
    return object[prop];
  }
  if (typeof object[prop] === "function" && isSafeMethod(object, prop)) {
    throw new Error('Cannot access method "' + prop + '" as a property');
  }
  throw new Error('No access to property "' + prop + '"');
}
function setSafeProperty(object, prop, value) {
  if (isPlainObject(object) && isSafeProperty(object, prop)) {
    object[prop] = value;
    return value;
  }
  throw new Error('No access to property "' + prop + '"');
}
function hasSafeProperty(object, prop) {
  return prop in object;
}
function isSafeProperty(object, prop) {
  if (!object || typeof object !== "object") {
    return false;
  }
  if (hasOwnProperty(safeNativeProperties, prop)) {
    return true;
  }
  if (prop in Object.prototype) {
    return false;
  }
  if (prop in Function.prototype) {
    return false;
  }
  return true;
}
function getSafeMethod(object, method) {
  if (!isSafeMethod(object, method)) {
    throw new Error('No access to method "' + method + '"');
  }
  return object[method];
}
function isSafeMethod(object, method) {
  if (object === null || object === void 0 || typeof object[method] !== "function") {
    return false;
  }
  if (hasOwnProperty(object, method) && Object.getPrototypeOf && method in Object.getPrototypeOf(object)) {
    return false;
  }
  if (hasOwnProperty(safeNativeMethods, method)) {
    return true;
  }
  if (method in Object.prototype) {
    return false;
  }
  if (method in Function.prototype) {
    return false;
  }
  return true;
}
function isPlainObject(object) {
  return typeof object === "object" && object && object.constructor === Object;
}
var safeNativeProperties = {
  length: true,
  name: true
};
var safeNativeMethods = {
  toString: true,
  valueOf: true,
  toLocaleString: true
};

// node_modules/mathjs/lib/esm/utils/map.js
var ObjectWrappingMap = class {
  constructor(object) {
    this.wrappedObject = object;
    this[Symbol.iterator] = this.entries;
  }
  keys() {
    return Object.keys(this.wrappedObject).values();
  }
  get(key) {
    return getSafeProperty(this.wrappedObject, key);
  }
  set(key, value) {
    setSafeProperty(this.wrappedObject, key, value);
    return this;
  }
  has(key) {
    return hasSafeProperty(this.wrappedObject, key);
  }
  entries() {
    return mapIterator(this.keys(), (key) => [key, this.get(key)]);
  }
  forEach(callback) {
    for (var key of this.keys()) {
      callback(this.get(key), key, this);
    }
  }
  delete(key) {
    delete this.wrappedObject[key];
  }
  clear() {
    for (var key of this.keys()) {
      this.delete(key);
    }
  }
  get size() {
    return Object.keys(this.wrappedObject).length;
  }
};
var PartitionedMap = class {
  /**
   * @param {Map} a
   * @param {Map} b
   * @param {Set} bKeys
   */
  constructor(a, b, bKeys) {
    this.a = a;
    this.b = b;
    this.bKeys = bKeys;
    this[Symbol.iterator] = this.entries;
  }
  get(key) {
    return this.bKeys.has(key) ? this.b.get(key) : this.a.get(key);
  }
  set(key, value) {
    if (this.bKeys.has(key)) {
      this.b.set(key, value);
    } else {
      this.a.set(key, value);
    }
    return this;
  }
  has(key) {
    return this.b.has(key) || this.a.has(key);
  }
  keys() {
    return (/* @__PURE__ */ new Set([...this.a.keys(), ...this.b.keys()]))[Symbol.iterator]();
  }
  entries() {
    return mapIterator(this.keys(), (key) => [key, this.get(key)]);
  }
  forEach(callback) {
    for (var key of this.keys()) {
      callback(this.get(key), key, this);
    }
  }
  delete(key) {
    return this.bKeys.has(key) ? this.b.delete(key) : this.a.delete(key);
  }
  clear() {
    this.a.clear();
    this.b.clear();
  }
  get size() {
    return [...this.keys()].length;
  }
};
function mapIterator(it, callback) {
  return {
    next: () => {
      var n = it.next();
      return n.done ? n : {
        value: callback(n.value),
        done: false
      };
    }
  };
}
function createEmptyMap() {
  return /* @__PURE__ */ new Map();
}
function createMap(mapOrObject) {
  if (!mapOrObject) {
    return createEmptyMap();
  }
  if (isMap(mapOrObject)) {
    return mapOrObject;
  }
  if (isObject(mapOrObject)) {
    return new ObjectWrappingMap(mapOrObject);
  }
  throw new Error("createMap can create maps from objects or Maps");
}
function toObject(map3) {
  if (map3 instanceof ObjectWrappingMap) {
    return map3.wrappedObject;
  }
  var object = {};
  for (var key of map3.keys()) {
    var value = map3.get(key);
    setSafeProperty(object, key, value);
  }
  return object;
}
function isMap(object) {
  if (!object) {
    return false;
  }
  return object instanceof Map || object instanceof ObjectWrappingMap || typeof object.set === "function" && typeof object.get === "function" && typeof object.keys === "function" && typeof object.has === "function";
}

// node_modules/mathjs/lib/esm/core/function/typed.js
var _createTyped2 = function _createTyped() {
  _createTyped2 = import_typed_function.default.create;
  return import_typed_function.default;
};
var dependencies = ["?BigNumber", "?Complex", "?DenseMatrix", "?Fraction"];
var createTyped = /* @__PURE__ */ factory("typed", dependencies, function createTyped2(_ref) {
  var {
    BigNumber: BigNumber2,
    Complex: Complex3,
    DenseMatrix: DenseMatrix2,
    Fraction: Fraction3
  } = _ref;
  var typed3 = _createTyped2();
  typed3.clear();
  typed3.addTypes([
    {
      name: "number",
      test: isNumber
    },
    {
      name: "Complex",
      test: isComplex
    },
    {
      name: "BigNumber",
      test: isBigNumber
    },
    {
      name: "bigint",
      test: isBigInt
    },
    {
      name: "Fraction",
      test: isFraction
    },
    {
      name: "Unit",
      test: isUnit
    },
    // The following type matches a valid variable name, i.e., an alphanumeric
    // string starting with an alphabetic character. It is used (at least)
    // in the definition of the derivative() function, as the argument telling
    // what to differentiate over must (currently) be a variable.
    {
      name: "identifier",
      test: (s) => isString && /^(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])*$/.test(s)
    },
    {
      name: "string",
      test: isString
    },
    {
      name: "Chain",
      test: isChain
    },
    {
      name: "Array",
      test: isArray
    },
    {
      name: "Matrix",
      test: isMatrix
    },
    {
      name: "DenseMatrix",
      test: isDenseMatrix
    },
    {
      name: "SparseMatrix",
      test: isSparseMatrix
    },
    {
      name: "Range",
      test: isRange
    },
    {
      name: "Index",
      test: isIndex
    },
    {
      name: "boolean",
      test: isBoolean
    },
    {
      name: "ResultSet",
      test: isResultSet
    },
    {
      name: "Help",
      test: isHelp
    },
    {
      name: "function",
      test: isFunction
    },
    {
      name: "Date",
      test: isDate
    },
    {
      name: "RegExp",
      test: isRegExp
    },
    {
      name: "null",
      test: isNull
    },
    {
      name: "undefined",
      test: isUndefined
    },
    {
      name: "AccessorNode",
      test: isAccessorNode
    },
    {
      name: "ArrayNode",
      test: isArrayNode
    },
    {
      name: "AssignmentNode",
      test: isAssignmentNode
    },
    {
      name: "BlockNode",
      test: isBlockNode
    },
    {
      name: "ConditionalNode",
      test: isConditionalNode
    },
    {
      name: "ConstantNode",
      test: isConstantNode
    },
    {
      name: "FunctionNode",
      test: isFunctionNode
    },
    {
      name: "FunctionAssignmentNode",
      test: isFunctionAssignmentNode
    },
    {
      name: "IndexNode",
      test: isIndexNode
    },
    {
      name: "Node",
      test: isNode
    },
    {
      name: "ObjectNode",
      test: isObjectNode
    },
    {
      name: "OperatorNode",
      test: isOperatorNode
    },
    {
      name: "ParenthesisNode",
      test: isParenthesisNode
    },
    {
      name: "RangeNode",
      test: isRangeNode
    },
    {
      name: "RelationalNode",
      test: isRelationalNode
    },
    {
      name: "SymbolNode",
      test: isSymbolNode
    },
    {
      name: "Map",
      test: isMap
    },
    {
      name: "Object",
      test: isObject
    }
    // order 'Object' last, it matches on other classes too
  ]);
  typed3.addConversions([{
    from: "number",
    to: "BigNumber",
    convert: function convert(x) {
      if (!BigNumber2) {
        throwNoBignumber(x);
      }
      if (digits(x) > 15) {
        throw new TypeError("Cannot implicitly convert a number with >15 significant digits to BigNumber (value: " + x + "). Use function bignumber(x) to convert to BigNumber.");
      }
      return new BigNumber2(x);
    }
  }, {
    from: "number",
    to: "Complex",
    convert: function convert(x) {
      if (!Complex3) {
        throwNoComplex(x);
      }
      return new Complex3(x, 0);
    }
  }, {
    from: "BigNumber",
    to: "Complex",
    convert: function convert(x) {
      if (!Complex3) {
        throwNoComplex(x);
      }
      return new Complex3(x.toNumber(), 0);
    }
  }, {
    from: "bigint",
    to: "number",
    convert: function convert(x) {
      if (x > Number.MAX_SAFE_INTEGER) {
        throw new TypeError("Cannot implicitly convert bigint to number: value exceeds the max safe integer value (value: " + x + ")");
      }
      return Number(x);
    }
  }, {
    from: "bigint",
    to: "BigNumber",
    convert: function convert(x) {
      if (!BigNumber2) {
        throwNoBignumber(x);
      }
      return new BigNumber2(x.toString());
    }
  }, {
    from: "bigint",
    to: "Fraction",
    convert: function convert(x) {
      if (!Fraction3) {
        throwNoFraction(x);
      }
      return new Fraction3(x.toString());
    }
  }, {
    from: "Fraction",
    to: "BigNumber",
    convert: function convert(x) {
      throw new TypeError("Cannot implicitly convert a Fraction to BigNumber or vice versa. Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.");
    }
  }, {
    from: "Fraction",
    to: "Complex",
    convert: function convert(x) {
      if (!Complex3) {
        throwNoComplex(x);
      }
      return new Complex3(x.valueOf(), 0);
    }
  }, {
    from: "number",
    to: "Fraction",
    convert: function convert(x) {
      if (!Fraction3) {
        throwNoFraction(x);
      }
      var f = new Fraction3(x);
      if (f.valueOf() !== x) {
        throw new TypeError("Cannot implicitly convert a number to a Fraction when there will be a loss of precision (value: " + x + "). Use function fraction(x) to convert to Fraction.");
      }
      return f;
    }
  }, {
    // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`
    //  from: 'Fraction',
    //  to: 'number',
    //  convert: function (x) {
    //    return x.valueOf()
    //  }
    // }, {
    from: "string",
    to: "number",
    convert: function convert(x) {
      var n = Number(x);
      if (isNaN(n)) {
        throw new Error('Cannot convert "' + x + '" to a number');
      }
      return n;
    }
  }, {
    from: "string",
    to: "BigNumber",
    convert: function convert(x) {
      if (!BigNumber2) {
        throwNoBignumber(x);
      }
      try {
        return new BigNumber2(x);
      } catch (err) {
        throw new Error('Cannot convert "' + x + '" to BigNumber');
      }
    }
  }, {
    from: "string",
    to: "bigint",
    convert: function convert(x) {
      try {
        return BigInt(x);
      } catch (err) {
        throw new Error('Cannot convert "' + x + '" to BigInt');
      }
    }
  }, {
    from: "string",
    to: "Fraction",
    convert: function convert(x) {
      if (!Fraction3) {
        throwNoFraction(x);
      }
      try {
        return new Fraction3(x);
      } catch (err) {
        throw new Error('Cannot convert "' + x + '" to Fraction');
      }
    }
  }, {
    from: "string",
    to: "Complex",
    convert: function convert(x) {
      if (!Complex3) {
        throwNoComplex(x);
      }
      try {
        return new Complex3(x);
      } catch (err) {
        throw new Error('Cannot convert "' + x + '" to Complex');
      }
    }
  }, {
    from: "boolean",
    to: "number",
    convert: function convert(x) {
      return +x;
    }
  }, {
    from: "boolean",
    to: "BigNumber",
    convert: function convert(x) {
      if (!BigNumber2) {
        throwNoBignumber(x);
      }
      return new BigNumber2(+x);
    }
  }, {
    from: "boolean",
    to: "bigint",
    convert: function convert(x) {
      return BigInt(+x);
    }
  }, {
    from: "boolean",
    to: "Fraction",
    convert: function convert(x) {
      if (!Fraction3) {
        throwNoFraction(x);
      }
      return new Fraction3(+x);
    }
  }, {
    from: "boolean",
    to: "string",
    convert: function convert(x) {
      return String(x);
    }
  }, {
    from: "Array",
    to: "Matrix",
    convert: function convert(array) {
      if (!DenseMatrix2) {
        throwNoMatrix();
      }
      return new DenseMatrix2(array);
    }
  }, {
    from: "Matrix",
    to: "Array",
    convert: function convert(matrix2) {
      return matrix2.valueOf();
    }
  }]);
  typed3.onMismatch = (name314, args, signatures) => {
    var usualError = typed3.createError(name314, args, signatures);
    if (["wrongType", "mismatch"].includes(usualError.data.category) && args.length === 1 && isCollection(args[0]) && // check if the function can be unary:
    signatures.some((sig) => !sig.params.includes(","))) {
      var err = new TypeError("Function '".concat(name314, "' doesn't apply to matrices. To call it ") + "elementwise on a matrix 'M', try 'map(M, ".concat(name314, ")'."));
      err.data = usualError.data;
      throw err;
    }
    throw usualError;
  };
  typed3.onMismatch = (name314, args, signatures) => {
    var usualError = typed3.createError(name314, args, signatures);
    if (["wrongType", "mismatch"].includes(usualError.data.category) && args.length === 1 && isCollection(args[0]) && // check if the function can be unary:
    signatures.some((sig) => !sig.params.includes(","))) {
      var err = new TypeError("Function '".concat(name314, "' doesn't apply to matrices. To call it ") + "elementwise on a matrix 'M', try 'map(M, ".concat(name314, ")'."));
      err.data = usualError.data;
      throw err;
    }
    throw usualError;
  };
  return typed3;
});
function throwNoBignumber(x) {
  throw new Error("Cannot convert value ".concat(x, " into a BigNumber: no class 'BigNumber' provided"));
}
function throwNoComplex(x) {
  throw new Error("Cannot convert value ".concat(x, " into a Complex number: no class 'Complex' provided"));
}
function throwNoMatrix() {
  throw new Error("Cannot convert array into a Matrix: no class 'DenseMatrix' provided");
}
function throwNoFraction(x) {
  throw new Error("Cannot convert value ".concat(x, " into a Fraction, no class 'Fraction' provided."));
}

// node_modules/mathjs/lib/esm/type/resultset/ResultSet.js
var name = "ResultSet";
var dependencies2 = [];
var createResultSet = /* @__PURE__ */ factory(name, dependencies2, () => {
  function ResultSet2(entries) {
    if (!(this instanceof ResultSet2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this.entries = entries || [];
  }
  ResultSet2.prototype.type = "ResultSet";
  ResultSet2.prototype.isResultSet = true;
  ResultSet2.prototype.valueOf = function() {
    return this.entries;
  };
  ResultSet2.prototype.toString = function() {
    return "[" + this.entries.join(", ") + "]";
  };
  ResultSet2.prototype.toJSON = function() {
    return {
      mathjs: "ResultSet",
      entries: this.entries
    };
  };
  ResultSet2.fromJSON = function(json) {
    return new ResultSet2(json.entries);
  };
  return ResultSet2;
}, {
  isClass: true
});

// node_modules/decimal.js/decimal.mjs
var EXP_LIMIT = 9e15;
var MAX_DIGITS = 1e9;
var NUMERALS = "0123456789abcdef";
var LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
var PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
var DEFAULTS = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -EXP_LIMIT,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: EXP_LIMIT,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: false
  // true/false
};
var inexact;
var quadrant;
var external = true;
var decimalError = "[DecimalError] ";
var invalidArgument = decimalError + "Invalid argument: ";
var precisionLimitExceeded = decimalError + "Precision limit exceeded";
var cryptoUnavailable = decimalError + "crypto unavailable";
var tag = "[object Decimal]";
var mathfloor = Math.floor;
var mathpow = Math.pow;
var isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
var isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
var isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
var isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
var BASE = 1e7;
var LOG_BASE = 7;
var MAX_SAFE_INTEGER = 9007199254740991;
var LN10_PRECISION = LN10.length - 1;
var PI_PRECISION = PI.length - 1;
var P = { toStringTag: tag };
P.absoluteValue = P.abs = function() {
  var x = new this.constructor(this);
  if (x.s < 0)
    x.s = 1;
  return finalise(x);
};
P.ceil = function() {
  return finalise(new this.constructor(this), this.e + 1, 2);
};
P.clampedTo = P.clamp = function(min3, max3) {
  var k, x = this, Ctor = x.constructor;
  min3 = new Ctor(min3);
  max3 = new Ctor(max3);
  if (!min3.s || !max3.s)
    return new Ctor(NaN);
  if (min3.gt(max3))
    throw Error(invalidArgument + max3);
  k = x.cmp(min3);
  return k < 0 ? min3 : x.cmp(max3) > 0 ? max3 : new Ctor(x);
};
P.comparedTo = P.cmp = function(y) {
  var i2, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
  if (!xd || !yd) {
    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
  }
  if (!xd[0] || !yd[0])
    return xd[0] ? xs : yd[0] ? -ys : 0;
  if (xs !== ys)
    return xs;
  if (x.e !== y.e)
    return x.e > y.e ^ xs < 0 ? 1 : -1;
  xdL = xd.length;
  ydL = yd.length;
  for (i2 = 0, j = xdL < ydL ? xdL : ydL; i2 < j; ++i2) {
    if (xd[i2] !== yd[i2])
      return xd[i2] > yd[i2] ^ xs < 0 ? 1 : -1;
  }
  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
};
P.cosine = P.cos = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.d)
    return new Ctor(NaN);
  if (!x.d[0])
    return new Ctor(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
};
P.cubeRoot = P.cbrt = function() {
  var e3, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  external = false;
  s = x.s * mathpow(x.s * x, 1 / 3);
  if (!s || Math.abs(s) == 1 / 0) {
    n = digitsToString(x.d);
    e3 = x.e;
    if (s = (e3 - n.length + 1) % 3)
      n += s == 1 || s == -2 ? "0" : "00";
    s = mathpow(n, 1 / 3);
    e3 = mathfloor((e3 + 1) / 3) - (e3 % 3 == (e3 < 0 ? -1 : 2));
    if (s == 1 / 0) {
      n = "5e" + e3;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e3;
    }
    r = new Ctor(n);
    r.s = x.s;
  } else {
    r = new Ctor(s.toString());
  }
  sd = (e3 = Ctor.precision) + 3;
  for (; ; ) {
    t = r;
    t3 = t.times(t).times(t);
    t3plusx = t3.plus(x);
    r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e3 + 1, 0);
          if (t.times(t).times(t).eq(x)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e3 + 1, 1);
          m = !r.times(r).times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e3, Ctor.rounding, m);
};
P.decimalPlaces = P.dp = function() {
  var w, d = this.d, n = NaN;
  if (d) {
    w = d.length - 1;
    n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
    w = d[w];
    if (w)
      for (; w % 10 == 0; w /= 10)
        n--;
    if (n < 0)
      n = 0;
  }
  return n;
};
P.dividedBy = P.div = function(y) {
  return divide(this, new this.constructor(y));
};
P.dividedToIntegerBy = P.divToInt = function(y) {
  var x = this, Ctor = x.constructor;
  return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
};
P.equals = P.eq = function(y) {
  return this.cmp(y) === 0;
};
P.floor = function() {
  return finalise(new this.constructor(this), this.e + 1, 3);
};
P.greaterThan = P.gt = function(y) {
  return this.cmp(y) > 0;
};
P.greaterThanOrEqualTo = P.gte = function(y) {
  var k = this.cmp(y);
  return k == 1 || k === 0;
};
P.hyperbolicCosine = P.cosh = function() {
  var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
  if (!x.isFinite())
    return new Ctor(x.s ? 1 / 0 : NaN);
  if (x.isZero())
    return one;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    n = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    n = "2.3283064365386962890625e-10";
  }
  x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
  var cosh2_x, i2 = k, d8 = new Ctor(8);
  for (; i2--; ) {
    cosh2_x = x.times(x);
    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
  }
  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P.hyperbolicSine = P.sinh = function() {
  var k, pr, rm, len, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 3) {
    x = taylorSeries(Ctor, 2, x, x, true);
  } else {
    k = 1.4 * Math.sqrt(len);
    k = k > 16 ? 16 : k | 0;
    x = x.times(1 / tinyPow(5, k));
    x = taylorSeries(Ctor, 2, x, x, true);
    var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
    for (; k--; ) {
      sinh2_x = x.times(x);
      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
    }
  }
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(x, pr, rm, true);
};
P.hyperbolicTangent = P.tanh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(x.s);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;
  return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
};
P.inverseCosine = P.acos = function() {
  var halfPi, x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
  if (k !== -1) {
    return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
  }
  if (x.isZero())
    return getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = x.asin();
  halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return halfPi.minus(x);
};
P.inverseHyperbolicCosine = P.acosh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (x.lte(1))
    return new Ctor(x.eq(1) ? 0 : NaN);
  if (!x.isFinite())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).minus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P.inverseHyperbolicSine = P.asinh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).plus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P.inverseHyperbolicTangent = P.atanh = function() {
  var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.e >= 0)
    return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  xsd = x.sd();
  if (Math.max(xsd, pr) < 2 * -x.e - 1)
    return finalise(new Ctor(x), pr, rm, true);
  Ctor.precision = wpr = xsd - x.e;
  x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
  Ctor.precision = pr + 4;
  Ctor.rounding = 1;
  x = x.ln();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(0.5);
};
P.inverseSine = P.asin = function() {
  var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
  if (x.isZero())
    return new Ctor(x);
  k = x.abs().cmp(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (k !== -1) {
    if (k === 0) {
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
      halfPi.s = x.s;
      return halfPi;
    }
    return new Ctor(NaN);
  }
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(2);
};
P.inverseTangent = P.atan = function() {
  var i2, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
  if (!x.isFinite()) {
    if (!x.s)
      return new Ctor(NaN);
    if (pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.5);
      r.s = x.s;
      return r;
    }
  } else if (x.isZero()) {
    return new Ctor(x);
  } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
    r = getPi(Ctor, pr + 4, rm).times(0.25);
    r.s = x.s;
    return r;
  }
  Ctor.precision = wpr = pr + 10;
  Ctor.rounding = 1;
  k = Math.min(28, wpr / LOG_BASE + 2 | 0);
  for (i2 = k; i2; --i2)
    x = x.div(x.times(x).plus(1).sqrt().plus(1));
  external = false;
  j = Math.ceil(wpr / LOG_BASE);
  n = 1;
  x2 = x.times(x);
  r = new Ctor(x);
  px = x;
  for (; i2 !== -1; ) {
    px = px.times(x2);
    t = r.minus(px.div(n += 2));
    px = px.times(x2);
    r = t.plus(px.div(n += 2));
    if (r.d[j] !== void 0)
      for (i2 = j; r.d[i2] === t.d[i2] && i2--; )
        ;
  }
  if (k)
    r = r.times(2 << k - 1);
  external = true;
  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P.isFinite = function() {
  return !!this.d;
};
P.isInteger = P.isInt = function() {
  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
};
P.isNaN = function() {
  return !this.s;
};
P.isNegative = P.isNeg = function() {
  return this.s < 0;
};
P.isPositive = P.isPos = function() {
  return this.s > 0;
};
P.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
P.lessThan = P.lt = function(y) {
  return this.cmp(y) < 0;
};
P.lessThanOrEqualTo = P.lte = function(y) {
  return this.cmp(y) < 1;
};
P.logarithm = P.log = function(base) {
  var isBase10, d, denominator, k, inf, num, sd, r, arg2 = this, Ctor = arg2.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
  if (base == null) {
    base = new Ctor(10);
    isBase10 = true;
  } else {
    base = new Ctor(base);
    d = base.d;
    if (base.s < 0 || !d || !d[0] || base.eq(1))
      return new Ctor(NaN);
    isBase10 = base.eq(10);
  }
  d = arg2.d;
  if (arg2.s < 0 || !d || !d[0] || arg2.eq(1)) {
    return new Ctor(d && !d[0] ? -1 / 0 : arg2.s != 1 ? NaN : d ? 0 : 1 / 0);
  }
  if (isBase10) {
    if (d.length > 1) {
      inf = true;
    } else {
      for (k = d[0]; k % 10 === 0; )
        k /= 10;
      inf = k !== 1;
    }
  }
  external = false;
  sd = pr + guard;
  num = naturalLogarithm(arg2, sd);
  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
  r = divide(num, denominator, sd, 1);
  if (checkRoundingDigits(r.d, k = pr, rm)) {
    do {
      sd += 10;
      num = naturalLogarithm(arg2, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
      r = divide(num, denominator, sd, 1);
      if (!inf) {
        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
          r = finalise(r, pr + 1, 0);
        }
        break;
      }
    } while (checkRoundingDigits(r.d, k += 10, rm));
  }
  external = true;
  return finalise(r, pr, rm);
};
P.minus = P.sub = function(y) {
  var d, e3, i2, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.d) {
    if (!x.s || !y.s)
      y = new Ctor(NaN);
    else if (x.d)
      y.s = -y.s;
    else
      y = new Ctor(y.d || x.s !== y.s ? x : NaN);
    return y;
  }
  if (x.s != y.s) {
    y.s = -y.s;
    return x.plus(y);
  }
  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (yd[0])
      y.s = -y.s;
    else if (xd[0])
      y = new Ctor(x);
    else
      return new Ctor(rm === 3 ? -0 : 0);
    return external ? finalise(y, pr, rm) : y;
  }
  e3 = mathfloor(y.e / LOG_BASE);
  xe = mathfloor(x.e / LOG_BASE);
  xd = xd.slice();
  k = xe - e3;
  if (k) {
    xLTy = k < 0;
    if (xLTy) {
      d = xd;
      k = -k;
      len = yd.length;
    } else {
      d = yd;
      e3 = xe;
      len = xd.length;
    }
    i2 = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
    if (k > i2) {
      k = i2;
      d.length = 1;
    }
    d.reverse();
    for (i2 = k; i2--; )
      d.push(0);
    d.reverse();
  } else {
    i2 = xd.length;
    len = yd.length;
    xLTy = i2 < len;
    if (xLTy)
      len = i2;
    for (i2 = 0; i2 < len; i2++) {
      if (xd[i2] != yd[i2]) {
        xLTy = xd[i2] < yd[i2];
        break;
      }
    }
    k = 0;
  }
  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y.s = -y.s;
  }
  len = xd.length;
  for (i2 = yd.length - len; i2 > 0; --i2)
    xd[len++] = 0;
  for (i2 = yd.length; i2 > k; ) {
    if (xd[--i2] < yd[i2]) {
      for (j = i2; j && xd[--j] === 0; )
        xd[j] = BASE - 1;
      --xd[j];
      xd[i2] += BASE;
    }
    xd[i2] -= yd[i2];
  }
  for (; xd[--len] === 0; )
    xd.pop();
  for (; xd[0] === 0; xd.shift())
    --e3;
  if (!xd[0])
    return new Ctor(rm === 3 ? -0 : 0);
  y.d = xd;
  y.e = getBase10Exponent(xd, e3);
  return external ? finalise(y, pr, rm) : y;
};
P.modulo = P.mod = function(y) {
  var q, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.s || y.d && !y.d[0])
    return new Ctor(NaN);
  if (!y.d || x.d && !x.d[0]) {
    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
  }
  external = false;
  if (Ctor.modulo == 9) {
    q = divide(x, y.abs(), 0, 3, 1);
    q.s *= y.s;
  } else {
    q = divide(x, y, 0, Ctor.modulo, 1);
  }
  q = q.times(y);
  external = true;
  return x.minus(q);
};
P.naturalExponential = P.exp = function() {
  return naturalExponential(this);
};
P.naturalLogarithm = P.ln = function() {
  return naturalLogarithm(this);
};
P.negated = P.neg = function() {
  var x = new this.constructor(this);
  x.s = -x.s;
  return finalise(x);
};
P.plus = P.add = function(y) {
  var carry, d, e3, i2, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.d) {
    if (!x.s || !y.s)
      y = new Ctor(NaN);
    else if (!x.d)
      y = new Ctor(y.d || x.s === y.s ? x : NaN);
    return y;
  }
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }
  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (!yd[0])
      y = new Ctor(x);
    return external ? finalise(y, pr, rm) : y;
  }
  k = mathfloor(x.e / LOG_BASE);
  e3 = mathfloor(y.e / LOG_BASE);
  xd = xd.slice();
  i2 = k - e3;
  if (i2) {
    if (i2 < 0) {
      d = xd;
      i2 = -i2;
      len = yd.length;
    } else {
      d = yd;
      e3 = k;
      len = xd.length;
    }
    k = Math.ceil(pr / LOG_BASE);
    len = k > len ? k + 1 : len + 1;
    if (i2 > len) {
      i2 = len;
      d.length = 1;
    }
    d.reverse();
    for (; i2--; )
      d.push(0);
    d.reverse();
  }
  len = xd.length;
  i2 = yd.length;
  if (len - i2 < 0) {
    i2 = len;
    d = yd;
    yd = xd;
    xd = d;
  }
  for (carry = 0; i2; ) {
    carry = (xd[--i2] = xd[i2] + yd[i2] + carry) / BASE | 0;
    xd[i2] %= BASE;
  }
  if (carry) {
    xd.unshift(carry);
    ++e3;
  }
  for (len = xd.length; xd[--len] == 0; )
    xd.pop();
  y.d = xd;
  y.e = getBase10Exponent(xd, e3);
  return external ? finalise(y, pr, rm) : y;
};
P.precision = P.sd = function(z) {
  var k, x = this;
  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0)
    throw Error(invalidArgument + z);
  if (x.d) {
    k = getPrecision(x.d);
    if (z && x.e + 1 > k)
      k = x.e + 1;
  } else {
    k = NaN;
  }
  return k;
};
P.round = function() {
  var x = this, Ctor = x.constructor;
  return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
};
P.sine = P.sin = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x = sine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
};
P.squareRoot = P.sqrt = function() {
  var m, n, sd, r, rep, t, x = this, d = x.d, e3 = x.e, s = x.s, Ctor = x.constructor;
  if (s !== 1 || !d || !d[0]) {
    return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
  }
  external = false;
  s = Math.sqrt(+x);
  if (s == 0 || s == 1 / 0) {
    n = digitsToString(d);
    if ((n.length + e3) % 2 == 0)
      n += "0";
    s = Math.sqrt(n);
    e3 = mathfloor((e3 + 1) / 2) - (e3 < 0 || e3 % 2);
    if (s == 1 / 0) {
      n = "5e" + e3;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e3;
    }
    r = new Ctor(n);
  } else {
    r = new Ctor(s.toString());
  }
  sd = (e3 = Ctor.precision) + 3;
  for (; ; ) {
    t = r;
    r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e3 + 1, 0);
          if (t.times(t).eq(x)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e3 + 1, 1);
          m = !r.times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e3, Ctor.rounding, m);
};
P.tangent = P.tan = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 10;
  Ctor.rounding = 1;
  x = x.sin();
  x.s = 1;
  x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
};
P.times = P.mul = function(y) {
  var carry, e3, i2, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
  y.s *= x.s;
  if (!xd || !xd[0] || !yd || !yd[0]) {
    return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
  }
  e3 = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
  xdL = xd.length;
  ydL = yd.length;
  if (xdL < ydL) {
    r = xd;
    xd = yd;
    yd = r;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }
  r = [];
  rL = xdL + ydL;
  for (i2 = rL; i2--; )
    r.push(0);
  for (i2 = ydL; --i2 >= 0; ) {
    carry = 0;
    for (k = xdL + i2; k > i2; ) {
      t = r[k] + yd[i2] * xd[k - i2 - 1] + carry;
      r[k--] = t % BASE | 0;
      carry = t / BASE | 0;
    }
    r[k] = (r[k] + carry) % BASE | 0;
  }
  for (; !r[--rL]; )
    r.pop();
  if (carry)
    ++e3;
  else
    r.shift();
  y.d = r;
  y.e = getBase10Exponent(r, e3);
  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
};
P.toBinary = function(sd, rm) {
  return toStringBinary(this, 2, sd, rm);
};
P.toDecimalPlaces = P.toDP = function(dp, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (dp === void 0)
    return x;
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0)
    rm = Ctor.rounding;
  else
    checkInt32(rm, 0, 8);
  return finalise(x, dp + x.e + 1, rm);
};
P.toExponential = function(dp, rm) {
  var str, x = this, Ctor = x.constructor;
  if (dp === void 0) {
    str = finiteToString(x, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), dp + 1, rm);
    str = finiteToString(x, true, dp + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toFixed = function(dp, rm) {
  var str, y, x = this, Ctor = x.constructor;
  if (dp === void 0) {
    str = finiteToString(x);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    y = finalise(new Ctor(x), dp + x.e + 1, rm);
    str = finiteToString(y, false, dp + y.e + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toFraction = function(maxD) {
  var d, d0, d1, d2, e3, k, n, n0, n16, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
  if (!xd)
    return new Ctor(x);
  n16 = d0 = new Ctor(1);
  d1 = n0 = new Ctor(0);
  d = new Ctor(d1);
  e3 = d.e = getPrecision(xd) - x.e - 1;
  k = e3 % LOG_BASE;
  d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
  if (maxD == null) {
    maxD = e3 > 0 ? d : n16;
  } else {
    n = new Ctor(maxD);
    if (!n.isInt() || n.lt(n16))
      throw Error(invalidArgument + n);
    maxD = n.gt(d) ? e3 > 0 ? d : n16 : n;
  }
  external = false;
  n = new Ctor(digitsToString(xd));
  pr = Ctor.precision;
  Ctor.precision = e3 = xd.length * LOG_BASE * 2;
  for (; ; ) {
    q = divide(n, d, 0, 1, 1);
    d2 = d0.plus(q.times(d1));
    if (d2.cmp(maxD) == 1)
      break;
    d0 = d1;
    d1 = d2;
    d2 = n16;
    n16 = n0.plus(q.times(d2));
    n0 = d2;
    d2 = d;
    d = n.minus(q.times(d2));
    n = d2;
  }
  d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
  n0 = n0.plus(d2.times(n16));
  d0 = d0.plus(d2.times(d1));
  n0.s = n16.s = x.s;
  r = divide(n16, d1, e3, 1).minus(x).abs().cmp(divide(n0, d0, e3, 1).minus(x).abs()) < 1 ? [n16, d1] : [n0, d0];
  Ctor.precision = pr;
  external = true;
  return r;
};
P.toHexadecimal = P.toHex = function(sd, rm) {
  return toStringBinary(this, 16, sd, rm);
};
P.toNearest = function(y, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (y == null) {
    if (!x.d)
      return x;
    y = new Ctor(1);
    rm = Ctor.rounding;
  } else {
    y = new Ctor(y);
    if (rm === void 0) {
      rm = Ctor.rounding;
    } else {
      checkInt32(rm, 0, 8);
    }
    if (!x.d)
      return y.s ? x : y;
    if (!y.d) {
      if (y.s)
        y.s = x.s;
      return y;
    }
  }
  if (y.d[0]) {
    external = false;
    x = divide(x, y, 0, rm, 1).times(y);
    external = true;
    finalise(x);
  } else {
    y.s = x.s;
    x = y;
  }
  return x;
};
P.toNumber = function() {
  return +this;
};
P.toOctal = function(sd, rm) {
  return toStringBinary(this, 8, sd, rm);
};
P.toPower = P.pow = function(y) {
  var e3, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
  if (!x.d || !y.d || !x.d[0] || !y.d[0])
    return new Ctor(mathpow(+x, yn));
  x = new Ctor(x);
  if (x.eq(1))
    return x;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (y.eq(1))
    return finalise(x, pr, rm);
  e3 = mathfloor(y.e / LOG_BASE);
  if (e3 >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
    r = intPow(Ctor, x, k, pr);
    return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
  }
  s = x.s;
  if (s < 0) {
    if (e3 < y.d.length - 1)
      return new Ctor(NaN);
    if ((y.d[e3] & 1) == 0)
      s = 1;
    if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
      x.s = s;
      return x;
    }
  }
  k = mathpow(+x, yn);
  e3 = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
  if (e3 > Ctor.maxE + 1 || e3 < Ctor.minE - 1)
    return new Ctor(e3 > 0 ? s / 0 : 0);
  external = false;
  Ctor.rounding = x.s = 1;
  k = Math.min(12, (e3 + "").length);
  r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
  if (r.d) {
    r = finalise(r, pr + 5, 1);
    if (checkRoundingDigits(r.d, pr, rm)) {
      e3 = pr + 10;
      r = finalise(naturalExponential(y.times(naturalLogarithm(x, e3 + k)), e3), e3 + 5, 1);
      if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
        r = finalise(r, pr + 1, 0);
      }
    }
  }
  r.s = s;
  external = true;
  Ctor.rounding = rm;
  return finalise(r, pr, rm);
};
P.toPrecision = function(sd, rm) {
  var str, x = this, Ctor = x.constructor;
  if (sd === void 0) {
    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), sd, rm);
    str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toSignificantDigits = P.toSD = function(sd, rm) {
  var x = this, Ctor = x.constructor;
  if (sd === void 0) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  }
  return finalise(new Ctor(x), sd, rm);
};
P.toString = function() {
  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.truncated = P.trunc = function() {
  return finalise(new this.constructor(this), this.e + 1, 1);
};
P.valueOf = P.toJSON = function() {
  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() ? "-" + str : str;
};
function digitsToString(d) {
  var i2, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
  if (indexOfLastWord > 0) {
    str += w;
    for (i2 = 1; i2 < indexOfLastWord; i2++) {
      ws = d[i2] + "";
      k = LOG_BASE - ws.length;
      if (k)
        str += getZeroString(k);
      str += ws;
    }
    w = d[i2];
    ws = w + "";
    k = LOG_BASE - ws.length;
    if (k)
      str += getZeroString(k);
  } else if (w === 0) {
    return "0";
  }
  for (; w % 10 === 0; )
    w /= 10;
  return str + w;
}
function checkInt32(i2, min3, max3) {
  if (i2 !== ~~i2 || i2 < min3 || i2 > max3) {
    throw Error(invalidArgument + i2);
  }
}
function checkRoundingDigits(d, i2, rm, repeating) {
  var di, k, r, rd;
  for (k = d[0]; k >= 10; k /= 10)
    --i2;
  if (--i2 < 0) {
    i2 += LOG_BASE;
    di = 0;
  } else {
    di = Math.ceil((i2 + 1) / LOG_BASE);
    i2 %= LOG_BASE;
  }
  k = mathpow(10, LOG_BASE - i2);
  rd = d[di] % k | 0;
  if (repeating == null) {
    if (i2 < 3) {
      if (i2 == 0)
        rd = rd / 100 | 0;
      else if (i2 == 1)
        rd = rd / 10 | 0;
      r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
    } else {
      r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i2 - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
    }
  } else {
    if (i2 < 4) {
      if (i2 == 0)
        rd = rd / 1e3 | 0;
      else if (i2 == 1)
        rd = rd / 100 | 0;
      else if (i2 == 2)
        rd = rd / 10 | 0;
      r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
    } else {
      r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i2 - 3) - 1;
    }
  }
  return r;
}
function convertBase(str, baseIn, baseOut) {
  var j, arr = [0], arrL, i2 = 0, strL = str.length;
  for (; i2 < strL; ) {
    for (arrL = arr.length; arrL--; )
      arr[arrL] *= baseIn;
    arr[0] += NUMERALS.indexOf(str.charAt(i2++));
    for (j = 0; j < arr.length; j++) {
      if (arr[j] > baseOut - 1) {
        if (arr[j + 1] === void 0)
          arr[j + 1] = 0;
        arr[j + 1] += arr[j] / baseOut | 0;
        arr[j] %= baseOut;
      }
    }
  }
  return arr.reverse();
}
function cosine(Ctor, x) {
  var k, len, y;
  if (x.isZero())
    return x;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    y = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    y = "2.3283064365386962890625e-10";
  }
  Ctor.precision += k;
  x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
  for (var i2 = k; i2--; ) {
    var cos2x = x.times(x);
    x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
  }
  Ctor.precision -= k;
  return x;
}
var divide = function() {
  function multiplyInteger(x, k, base) {
    var temp, carry = 0, i2 = x.length;
    for (x = x.slice(); i2--; ) {
      temp = x[i2] * k + carry;
      x[i2] = temp % base | 0;
      carry = temp / base | 0;
    }
    if (carry)
      x.unshift(carry);
    return x;
  }
  function compare2(a, b, aL, bL) {
    var i2, r;
    if (aL != bL) {
      r = aL > bL ? 1 : -1;
    } else {
      for (i2 = r = 0; i2 < aL; i2++) {
        if (a[i2] != b[i2]) {
          r = a[i2] > b[i2] ? 1 : -1;
          break;
        }
      }
    }
    return r;
  }
  function subtract2(a, b, aL, base) {
    var i2 = 0;
    for (; aL--; ) {
      a[aL] -= i2;
      i2 = a[aL] < b[aL] ? 1 : 0;
      a[aL] = i2 * base + a[aL] - b[aL];
    }
    for (; !a[0] && a.length > 1; )
      a.shift();
  }
  return function(x, y, pr, rm, dp, base) {
    var cmp, e3, i2, k, logBase, more, prod2, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign4 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
    if (!xd || !xd[0] || !yd || !yd[0]) {
      return new Ctor(
        // Return NaN if either NaN, or both Infinity or 0.
        !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : (
          // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.
          xd && xd[0] == 0 || !yd ? sign4 * 0 : sign4 / 0
        )
      );
    }
    if (base) {
      logBase = 1;
      e3 = x.e - y.e;
    } else {
      base = BASE;
      logBase = LOG_BASE;
      e3 = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
    }
    yL = yd.length;
    xL = xd.length;
    q = new Ctor(sign4);
    qd = q.d = [];
    for (i2 = 0; yd[i2] == (xd[i2] || 0); i2++)
      ;
    if (yd[i2] > (xd[i2] || 0))
      e3--;
    if (pr == null) {
      sd = pr = Ctor.precision;
      rm = Ctor.rounding;
    } else if (dp) {
      sd = pr + (x.e - y.e) + 1;
    } else {
      sd = pr;
    }
    if (sd < 0) {
      qd.push(1);
      more = true;
    } else {
      sd = sd / logBase + 2 | 0;
      i2 = 0;
      if (yL == 1) {
        k = 0;
        yd = yd[0];
        sd++;
        for (; (i2 < xL || k) && sd--; i2++) {
          t = k * base + (xd[i2] || 0);
          qd[i2] = t / yd | 0;
          k = t % yd | 0;
        }
        more = k || i2 < xL;
      } else {
        k = base / (yd[0] + 1) | 0;
        if (k > 1) {
          yd = multiplyInteger(yd, k, base);
          xd = multiplyInteger(xd, k, base);
          yL = yd.length;
          xL = xd.length;
        }
        xi = yL;
        rem = xd.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; )
          rem[remL++] = 0;
        yz = yd.slice();
        yz.unshift(0);
        yd0 = yd[0];
        if (yd[1] >= base / 2)
          ++yd0;
        do {
          k = 0;
          cmp = compare2(yd, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base + (rem[1] || 0);
            k = rem0 / yd0 | 0;
            if (k > 1) {
              if (k >= base)
                k = base - 1;
              prod2 = multiplyInteger(yd, k, base);
              prodL = prod2.length;
              remL = rem.length;
              cmp = compare2(prod2, rem, prodL, remL);
              if (cmp == 1) {
                k--;
                subtract2(prod2, yL < prodL ? yz : yd, prodL, base);
              }
            } else {
              if (k == 0)
                cmp = k = 1;
              prod2 = yd.slice();
            }
            prodL = prod2.length;
            if (prodL < remL)
              prod2.unshift(0);
            subtract2(rem, prod2, remL, base);
            if (cmp == -1) {
              remL = rem.length;
              cmp = compare2(yd, rem, yL, remL);
              if (cmp < 1) {
                k++;
                subtract2(rem, yL < remL ? yz : yd, remL, base);
              }
            }
            remL = rem.length;
          } else if (cmp === 0) {
            k++;
            rem = [0];
          }
          qd[i2++] = k;
          if (cmp && rem[0]) {
            rem[remL++] = xd[xi] || 0;
          } else {
            rem = [xd[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] !== void 0) && sd--);
        more = rem[0] !== void 0;
      }
      if (!qd[0])
        qd.shift();
    }
    if (logBase == 1) {
      q.e = e3;
      inexact = more;
    } else {
      for (i2 = 1, k = qd[0]; k >= 10; k /= 10)
        i2++;
      q.e = i2 + e3 * logBase - 1;
      finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
    }
    return q;
  };
}();
function finalise(x, sd, rm, isTruncated) {
  var digits2, i2, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
  out:
    if (sd != null) {
      xd = x.d;
      if (!xd)
        return x;
      for (digits2 = 1, k = xd[0]; k >= 10; k /= 10)
        digits2++;
      i2 = sd - digits2;
      if (i2 < 0) {
        i2 += LOG_BASE;
        j = sd;
        w = xd[xdi = 0];
        rd = w / mathpow(10, digits2 - j - 1) % 10 | 0;
      } else {
        xdi = Math.ceil((i2 + 1) / LOG_BASE);
        k = xd.length;
        if (xdi >= k) {
          if (isTruncated) {
            for (; k++ <= xdi; )
              xd.push(0);
            w = rd = 0;
            digits2 = 1;
            i2 %= LOG_BASE;
            j = i2 - LOG_BASE + 1;
          } else {
            break out;
          }
        } else {
          w = k = xd[xdi];
          for (digits2 = 1; k >= 10; k /= 10)
            digits2++;
          i2 %= LOG_BASE;
          j = i2 - LOG_BASE + digits2;
          rd = j < 0 ? 0 : w / mathpow(10, digits2 - j - 1) % 10 | 0;
        }
      }
      isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits2 - j - 1));
      roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
      (i2 > 0 ? j > 0 ? w / mathpow(10, digits2 - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
      if (sd < 1 || !xd[0]) {
        xd.length = 0;
        if (roundUp) {
          sd -= x.e + 1;
          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
          x.e = -sd || 0;
        } else {
          xd[0] = x.e = 0;
        }
        return x;
      }
      if (i2 == 0) {
        xd.length = xdi;
        k = 1;
        xdi--;
      } else {
        xd.length = xdi + 1;
        k = mathpow(10, LOG_BASE - i2);
        xd[xdi] = j > 0 ? (w / mathpow(10, digits2 - j) % mathpow(10, j) | 0) * k : 0;
      }
      if (roundUp) {
        for (; ; ) {
          if (xdi == 0) {
            for (i2 = 1, j = xd[0]; j >= 10; j /= 10)
              i2++;
            j = xd[0] += k;
            for (k = 1; j >= 10; j /= 10)
              k++;
            if (i2 != k) {
              x.e++;
              if (xd[0] == BASE)
                xd[0] = 1;
            }
            break;
          } else {
            xd[xdi] += k;
            if (xd[xdi] != BASE)
              break;
            xd[xdi--] = 0;
            k = 1;
          }
        }
      }
      for (i2 = xd.length; xd[--i2] === 0; )
        xd.pop();
    }
  if (external) {
    if (x.e > Ctor.maxE) {
      x.d = null;
      x.e = NaN;
    } else if (x.e < Ctor.minE) {
      x.e = 0;
      x.d = [0];
    }
  }
  return x;
}
function finiteToString(x, isExp, sd) {
  if (!x.isFinite())
    return nonFiniteToString(x);
  var k, e3 = x.e, str = digitsToString(x.d), len = str.length;
  if (isExp) {
    if (sd && (k = sd - len) > 0) {
      str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
    } else if (len > 1) {
      str = str.charAt(0) + "." + str.slice(1);
    }
    str = str + (x.e < 0 ? "e" : "e+") + x.e;
  } else if (e3 < 0) {
    str = "0." + getZeroString(-e3 - 1) + str;
    if (sd && (k = sd - len) > 0)
      str += getZeroString(k);
  } else if (e3 >= len) {
    str += getZeroString(e3 + 1 - len);
    if (sd && (k = sd - e3 - 1) > 0)
      str = str + "." + getZeroString(k);
  } else {
    if ((k = e3 + 1) < len)
      str = str.slice(0, k) + "." + str.slice(k);
    if (sd && (k = sd - len) > 0) {
      if (e3 + 1 === len)
        str += ".";
      str += getZeroString(k);
    }
  }
  return str;
}
function getBase10Exponent(digits2, e3) {
  var w = digits2[0];
  for (e3 *= LOG_BASE; w >= 10; w /= 10)
    e3++;
  return e3;
}
function getLn10(Ctor, sd, pr) {
  if (sd > LN10_PRECISION) {
    external = true;
    if (pr)
      Ctor.precision = pr;
    throw Error(precisionLimitExceeded);
  }
  return finalise(new Ctor(LN10), sd, 1, true);
}
function getPi(Ctor, sd, rm) {
  if (sd > PI_PRECISION)
    throw Error(precisionLimitExceeded);
  return finalise(new Ctor(PI), sd, rm, true);
}
function getPrecision(digits2) {
  var w = digits2.length - 1, len = w * LOG_BASE + 1;
  w = digits2[w];
  if (w) {
    for (; w % 10 == 0; w /= 10)
      len--;
    for (w = digits2[0]; w >= 10; w /= 10)
      len++;
  }
  return len;
}
function getZeroString(k) {
  var zs = "";
  for (; k--; )
    zs += "0";
  return zs;
}
function intPow(Ctor, x, n, pr) {
  var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
  external = false;
  for (; ; ) {
    if (n % 2) {
      r = r.times(x);
      if (truncate(r.d, k))
        isTruncated = true;
    }
    n = mathfloor(n / 2);
    if (n === 0) {
      n = r.d.length - 1;
      if (isTruncated && r.d[n] === 0)
        ++r.d[n];
      break;
    }
    x = x.times(x);
    truncate(x.d, k);
  }
  external = true;
  return r;
}
function isOdd(n) {
  return n.d[n.d.length - 1] & 1;
}
function maxOrMin(Ctor, args, ltgt) {
  var y, x = new Ctor(args[0]), i2 = 0;
  for (; ++i2 < args.length; ) {
    y = new Ctor(args[i2]);
    if (!y.s) {
      x = y;
      break;
    } else if (x[ltgt](y)) {
      x = y;
    }
  }
  return x;
}
function naturalExponential(x, sd) {
  var denominator, guard, j, pow3, sum3, t, wpr, rep = 0, i2 = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (!x.d || !x.d[0] || x.e > 17) {
    return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  t = new Ctor(0.03125);
  while (x.e > -2) {
    x = x.times(t);
    k += 5;
  }
  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow3 = sum3 = new Ctor(1);
  Ctor.precision = wpr;
  for (; ; ) {
    pow3 = finalise(pow3.times(x), wpr, 1);
    denominator = denominator.times(++i2);
    t = sum3.plus(divide(pow3, denominator, wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum3.d).slice(0, wpr)) {
      j = k;
      while (j--)
        sum3 = finalise(sum3.times(sum3), wpr, 1);
      if (sd == null) {
        if (rep < 3 && checkRoundingDigits(sum3.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += 10;
          denominator = pow3 = t = new Ctor(1);
          i2 = 0;
          rep++;
        } else {
          return finalise(sum3, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum3;
      }
    }
    sum3 = t;
  }
}
function naturalLogarithm(y, sd) {
  var c, c0, denominator, e3, numerator, rep, sum3, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
    return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  Ctor.precision = wpr += guard;
  c = digitsToString(xd);
  c0 = c.charAt(0);
  if (Math.abs(e3 = x.e) < 15e14) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
      x = x.times(y);
      c = digitsToString(x.d);
      c0 = c.charAt(0);
      n++;
    }
    e3 = x.e;
    if (c0 > 1) {
      x = new Ctor("0." + c);
      e3++;
    } else {
      x = new Ctor(c0 + "." + c.slice(1));
    }
  } else {
    t = getLn10(Ctor, wpr + 2, pr).times(e3 + "");
    x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
    Ctor.precision = pr;
    return sd == null ? finalise(x, pr, rm, external = true) : x;
  }
  x1 = x;
  sum3 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
  x2 = finalise(x.times(x), wpr, 1);
  denominator = 3;
  for (; ; ) {
    numerator = finalise(numerator.times(x2), wpr, 1);
    t = sum3.plus(divide(numerator, new Ctor(denominator), wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum3.d).slice(0, wpr)) {
      sum3 = sum3.times(2);
      if (e3 !== 0)
        sum3 = sum3.plus(getLn10(Ctor, wpr + 2, pr).times(e3 + ""));
      sum3 = divide(sum3, new Ctor(n), wpr, 1);
      if (sd == null) {
        if (checkRoundingDigits(sum3.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += guard;
          t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
          x2 = finalise(x.times(x), wpr, 1);
          denominator = rep = 1;
        } else {
          return finalise(sum3, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum3;
      }
    }
    sum3 = t;
    denominator += 2;
  }
}
function nonFiniteToString(x) {
  return String(x.s * x.s / 0);
}
function parseDecimal(x, str) {
  var e3, i2, len;
  if ((e3 = str.indexOf(".")) > -1)
    str = str.replace(".", "");
  if ((i2 = str.search(/e/i)) > 0) {
    if (e3 < 0)
      e3 = i2;
    e3 += +str.slice(i2 + 1);
    str = str.substring(0, i2);
  } else if (e3 < 0) {
    e3 = str.length;
  }
  for (i2 = 0; str.charCodeAt(i2) === 48; i2++)
    ;
  for (len = str.length; str.charCodeAt(len - 1) === 48; --len)
    ;
  str = str.slice(i2, len);
  if (str) {
    len -= i2;
    x.e = e3 = e3 - i2 - 1;
    x.d = [];
    i2 = (e3 + 1) % LOG_BASE;
    if (e3 < 0)
      i2 += LOG_BASE;
    if (i2 < len) {
      if (i2)
        x.d.push(+str.slice(0, i2));
      for (len -= LOG_BASE; i2 < len; )
        x.d.push(+str.slice(i2, i2 += LOG_BASE));
      str = str.slice(i2);
      i2 = LOG_BASE - str.length;
    } else {
      i2 -= len;
    }
    for (; i2--; )
      str += "0";
    x.d.push(+str);
    if (external) {
      if (x.e > x.constructor.maxE) {
        x.d = null;
        x.e = NaN;
      } else if (x.e < x.constructor.minE) {
        x.e = 0;
        x.d = [0];
      }
    }
  } else {
    x.e = 0;
    x.d = [0];
  }
  return x;
}
function parseOther(x, str) {
  var base, Ctor, divisor, i2, isFloat, len, p, xd, xe;
  if (str.indexOf("_") > -1) {
    str = str.replace(/(\d)_(?=\d)/g, "$1");
    if (isDecimal.test(str))
      return parseDecimal(x, str);
  } else if (str === "Infinity" || str === "NaN") {
    if (!+str)
      x.s = NaN;
    x.e = NaN;
    x.d = null;
    return x;
  }
  if (isHex.test(str)) {
    base = 16;
    str = str.toLowerCase();
  } else if (isBinary.test(str)) {
    base = 2;
  } else if (isOctal.test(str)) {
    base = 8;
  } else {
    throw Error(invalidArgument + str);
  }
  i2 = str.search(/p/i);
  if (i2 > 0) {
    p = +str.slice(i2 + 1);
    str = str.substring(2, i2);
  } else {
    str = str.slice(2);
  }
  i2 = str.indexOf(".");
  isFloat = i2 >= 0;
  Ctor = x.constructor;
  if (isFloat) {
    str = str.replace(".", "");
    len = str.length;
    i2 = len - i2;
    divisor = intPow(Ctor, new Ctor(base), i2, i2 * 2);
  }
  xd = convertBase(str, base, BASE);
  xe = xd.length - 1;
  for (i2 = xe; xd[i2] === 0; --i2)
    xd.pop();
  if (i2 < 0)
    return new Ctor(x.s * 0);
  x.e = getBase10Exponent(xd, xe);
  x.d = xd;
  external = false;
  if (isFloat)
    x = divide(x, divisor, len * 4);
  if (p)
    x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
  external = true;
  return x;
}
function sine(Ctor, x) {
  var k, len = x.d.length;
  if (len < 3) {
    return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
  }
  k = 1.4 * Math.sqrt(len);
  k = k > 16 ? 16 : k | 0;
  x = x.times(1 / tinyPow(5, k));
  x = taylorSeries(Ctor, 2, x, x);
  var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
  for (; k--; ) {
    sin2_x = x.times(x);
    x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
  }
  return x;
}
function taylorSeries(Ctor, n, x, y, isHyperbolic) {
  var j, t, u, x2, i2 = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
  external = false;
  x2 = x.times(x);
  u = new Ctor(y);
  for (; ; ) {
    t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
    u = isHyperbolic ? y.plus(t) : y.minus(t);
    y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
    t = u.plus(y);
    if (t.d[k] !== void 0) {
      for (j = k; t.d[j] === u.d[j] && j--; )
        ;
      if (j == -1)
        break;
    }
    j = u;
    u = y;
    y = t;
    t = j;
    i2++;
  }
  external = true;
  t.d.length = k + 1;
  return t;
}
function tinyPow(b, e3) {
  var n = b;
  while (--e3)
    n *= b;
  return n;
}
function toLessThanHalfPi(Ctor, x) {
  var t, isNeg = x.s < 0, pi3 = getPi(Ctor, Ctor.precision, 1), halfPi = pi3.times(0.5);
  x = x.abs();
  if (x.lte(halfPi)) {
    quadrant = isNeg ? 4 : 1;
    return x;
  }
  t = x.divToInt(pi3);
  if (t.isZero()) {
    quadrant = isNeg ? 3 : 2;
  } else {
    x = x.minus(t.times(pi3));
    if (x.lte(halfPi)) {
      quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
      return x;
    }
    quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
  }
  return x.minus(pi3).abs();
}
function toStringBinary(x, baseOut, sd, rm) {
  var base, e3, i2, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;
  if (isExp) {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  } else {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  }
  if (!x.isFinite()) {
    str = nonFiniteToString(x);
  } else {
    str = finiteToString(x);
    i2 = str.indexOf(".");
    if (isExp) {
      base = 2;
      if (baseOut == 16) {
        sd = sd * 4 - 3;
      } else if (baseOut == 8) {
        sd = sd * 3 - 2;
      }
    } else {
      base = baseOut;
    }
    if (i2 >= 0) {
      str = str.replace(".", "");
      y = new Ctor(1);
      y.e = str.length - i2;
      y.d = convertBase(finiteToString(y), 10, base);
      y.e = y.d.length;
    }
    xd = convertBase(str, 10, base);
    e3 = len = xd.length;
    for (; xd[--len] == 0; )
      xd.pop();
    if (!xd[0]) {
      str = isExp ? "0p+0" : "0";
    } else {
      if (i2 < 0) {
        e3--;
      } else {
        x = new Ctor(x);
        x.d = xd;
        x.e = e3;
        x = divide(x, y, sd, rm, 0, base);
        xd = x.d;
        e3 = x.e;
        roundUp = inexact;
      }
      i2 = xd[sd];
      k = base / 2;
      roundUp = roundUp || xd[sd + 1] !== void 0;
      roundUp = rm < 4 ? (i2 !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i2 > k || i2 === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
      xd.length = sd;
      if (roundUp) {
        for (; ++xd[--sd] > base - 1; ) {
          xd[sd] = 0;
          if (!sd) {
            ++e3;
            xd.unshift(1);
          }
        }
      }
      for (len = xd.length; !xd[len - 1]; --len)
        ;
      for (i2 = 0, str = ""; i2 < len; i2++)
        str += NUMERALS.charAt(xd[i2]);
      if (isExp) {
        if (len > 1) {
          if (baseOut == 16 || baseOut == 8) {
            i2 = baseOut == 16 ? 4 : 3;
            for (--len; len % i2; len++)
              str += "0";
            xd = convertBase(str, base, baseOut);
            for (len = xd.length; !xd[len - 1]; --len)
              ;
            for (i2 = 1, str = "1."; i2 < len; i2++)
              str += NUMERALS.charAt(xd[i2]);
          } else {
            str = str.charAt(0) + "." + str.slice(1);
          }
        }
        str = str + (e3 < 0 ? "p" : "p+") + e3;
      } else if (e3 < 0) {
        for (; ++e3; )
          str = "0" + str;
        str = "0." + str;
      } else {
        if (++e3 > len)
          for (e3 -= len; e3--; )
            str += "0";
        else if (e3 < len)
          str = str.slice(0, e3) + "." + str.slice(e3);
      }
    }
    str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
  }
  return x.s < 0 ? "-" + str : str;
}
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}
function abs(x) {
  return new this(x).abs();
}
function acos(x) {
  return new this(x).acos();
}
function acosh2(x) {
  return new this(x).acosh();
}
function add(x, y) {
  return new this(x).plus(y);
}
function asin(x) {
  return new this(x).asin();
}
function asinh2(x) {
  return new this(x).asinh();
}
function atan(x) {
  return new this(x).atan();
}
function atanh2(x) {
  return new this(x).atanh();
}
function atan2(y, x) {
  y = new this(y);
  x = new this(x);
  var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
  if (!y.s || !x.s) {
    r = new this(NaN);
  } else if (!y.d && !x.d) {
    r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
    r.s = y.s;
  } else if (!x.d || y.isZero()) {
    r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
    r.s = y.s;
  } else if (!y.d || x.isZero()) {
    r = getPi(this, wpr, 1).times(0.5);
    r.s = y.s;
  } else if (x.s < 0) {
    this.precision = wpr;
    this.rounding = 1;
    r = this.atan(divide(y, x, wpr, 1));
    x = getPi(this, wpr, 1);
    this.precision = pr;
    this.rounding = rm;
    r = y.s < 0 ? r.minus(x) : r.plus(x);
  } else {
    r = this.atan(divide(y, x, wpr, 1));
  }
  return r;
}
function cbrt3(x) {
  return new this(x).cbrt();
}
function ceil(x) {
  return finalise(x = new this(x), x.e + 1, 2);
}
function clamp(x, min3, max3) {
  return new this(x).clamp(min3, max3);
}
function config4(obj) {
  if (!obj || typeof obj !== "object")
    throw Error(decimalError + "Object expected");
  var i2, p, v, useDefaults = obj.defaults === true, ps = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -EXP_LIMIT,
    0,
    "toExpPos",
    0,
    EXP_LIMIT,
    "maxE",
    0,
    EXP_LIMIT,
    "minE",
    -EXP_LIMIT,
    0,
    "modulo",
    0,
    9
  ];
  for (i2 = 0; i2 < ps.length; i2 += 3) {
    if (p = ps[i2], useDefaults)
      this[p] = DEFAULTS[p];
    if ((v = obj[p]) !== void 0) {
      if (mathfloor(v) === v && v >= ps[i2 + 1] && v <= ps[i2 + 2])
        this[p] = v;
      else
        throw Error(invalidArgument + p + ": " + v);
    }
  }
  if (p = "crypto", useDefaults)
    this[p] = DEFAULTS[p];
  if ((v = obj[p]) !== void 0) {
    if (v === true || v === false || v === 0 || v === 1) {
      if (v) {
        if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
          this[p] = true;
        } else {
          throw Error(cryptoUnavailable);
        }
      } else {
        this[p] = false;
      }
    } else {
      throw Error(invalidArgument + p + ": " + v);
    }
  }
  return this;
}
function cos(x) {
  return new this(x).cos();
}
function cosh2(x) {
  return new this(x).cosh();
}
function clone2(obj) {
  var i2, p, ps;
  function Decimal2(v) {
    var e3, i3, t, x = this;
    if (!(x instanceof Decimal2))
      return new Decimal2(v);
    x.constructor = Decimal2;
    if (isDecimalInstance(v)) {
      x.s = v.s;
      if (external) {
        if (!v.d || v.e > Decimal2.maxE) {
          x.e = NaN;
          x.d = null;
        } else if (v.e < Decimal2.minE) {
          x.e = 0;
          x.d = [0];
        } else {
          x.e = v.e;
          x.d = v.d.slice();
        }
      } else {
        x.e = v.e;
        x.d = v.d ? v.d.slice() : v.d;
      }
      return;
    }
    t = typeof v;
    if (t === "number") {
      if (v === 0) {
        x.s = 1 / v < 0 ? -1 : 1;
        x.e = 0;
        x.d = [0];
        return;
      }
      if (v < 0) {
        v = -v;
        x.s = -1;
      } else {
        x.s = 1;
      }
      if (v === ~~v && v < 1e7) {
        for (e3 = 0, i3 = v; i3 >= 10; i3 /= 10)
          e3++;
        if (external) {
          if (e3 > Decimal2.maxE) {
            x.e = NaN;
            x.d = null;
          } else if (e3 < Decimal2.minE) {
            x.e = 0;
            x.d = [0];
          } else {
            x.e = e3;
            x.d = [v];
          }
        } else {
          x.e = e3;
          x.d = [v];
        }
        return;
      } else if (v * 0 !== 0) {
        if (!v)
          x.s = NaN;
        x.e = NaN;
        x.d = null;
        return;
      }
      return parseDecimal(x, v.toString());
    } else if (t !== "string") {
      throw Error(invalidArgument + v);
    }
    if ((i3 = v.charCodeAt(0)) === 45) {
      v = v.slice(1);
      x.s = -1;
    } else {
      if (i3 === 43)
        v = v.slice(1);
      x.s = 1;
    }
    return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
  }
  Decimal2.prototype = P;
  Decimal2.ROUND_UP = 0;
  Decimal2.ROUND_DOWN = 1;
  Decimal2.ROUND_CEIL = 2;
  Decimal2.ROUND_FLOOR = 3;
  Decimal2.ROUND_HALF_UP = 4;
  Decimal2.ROUND_HALF_DOWN = 5;
  Decimal2.ROUND_HALF_EVEN = 6;
  Decimal2.ROUND_HALF_CEIL = 7;
  Decimal2.ROUND_HALF_FLOOR = 8;
  Decimal2.EUCLID = 9;
  Decimal2.config = Decimal2.set = config4;
  Decimal2.clone = clone2;
  Decimal2.isDecimal = isDecimalInstance;
  Decimal2.abs = abs;
  Decimal2.acos = acos;
  Decimal2.acosh = acosh2;
  Decimal2.add = add;
  Decimal2.asin = asin;
  Decimal2.asinh = asinh2;
  Decimal2.atan = atan;
  Decimal2.atanh = atanh2;
  Decimal2.atan2 = atan2;
  Decimal2.cbrt = cbrt3;
  Decimal2.ceil = ceil;
  Decimal2.clamp = clamp;
  Decimal2.cos = cos;
  Decimal2.cosh = cosh2;
  Decimal2.div = div;
  Decimal2.exp = exp;
  Decimal2.floor = floor;
  Decimal2.hypot = hypot;
  Decimal2.ln = ln;
  Decimal2.log = log;
  Decimal2.log10 = log103;
  Decimal2.log2 = log23;
  Decimal2.max = max;
  Decimal2.min = min;
  Decimal2.mod = mod;
  Decimal2.mul = mul;
  Decimal2.pow = pow;
  Decimal2.random = random;
  Decimal2.round = round;
  Decimal2.sign = sign2;
  Decimal2.sin = sin;
  Decimal2.sinh = sinh2;
  Decimal2.sqrt = sqrt;
  Decimal2.sub = sub;
  Decimal2.sum = sum;
  Decimal2.tan = tan;
  Decimal2.tanh = tanh2;
  Decimal2.trunc = trunc;
  if (obj === void 0)
    obj = {};
  if (obj) {
    if (obj.defaults !== true) {
      ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
      for (i2 = 0; i2 < ps.length; )
        if (!obj.hasOwnProperty(p = ps[i2++]))
          obj[p] = this[p];
    }
  }
  Decimal2.config(obj);
  return Decimal2;
}
function div(x, y) {
  return new this(x).div(y);
}
function exp(x) {
  return new this(x).exp();
}
function floor(x) {
  return finalise(x = new this(x), x.e + 1, 3);
}
function hypot() {
  var i2, n, t = new this(0);
  external = false;
  for (i2 = 0; i2 < arguments.length; ) {
    n = new this(arguments[i2++]);
    if (!n.d) {
      if (n.s) {
        external = true;
        return new this(1 / 0);
      }
      t = n;
    } else if (t.d) {
      t = t.plus(n.times(n));
    }
  }
  external = true;
  return t.sqrt();
}
function isDecimalInstance(obj) {
  return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
}
function ln(x) {
  return new this(x).ln();
}
function log(x, y) {
  return new this(x).log(y);
}
function log23(x) {
  return new this(x).log(2);
}
function log103(x) {
  return new this(x).log(10);
}
function max() {
  return maxOrMin(this, arguments, "lt");
}
function min() {
  return maxOrMin(this, arguments, "gt");
}
function mod(x, y) {
  return new this(x).mod(y);
}
function mul(x, y) {
  return new this(x).mul(y);
}
function pow(x, y) {
  return new this(x).pow(y);
}
function random(sd) {
  var d, e3, k, n, i2 = 0, r = new this(1), rd = [];
  if (sd === void 0)
    sd = this.precision;
  else
    checkInt32(sd, 1, MAX_DIGITS);
  k = Math.ceil(sd / LOG_BASE);
  if (!this.crypto) {
    for (; i2 < k; )
      rd[i2++] = Math.random() * 1e7 | 0;
  } else if (crypto.getRandomValues) {
    d = crypto.getRandomValues(new Uint32Array(k));
    for (; i2 < k; ) {
      n = d[i2];
      if (n >= 429e7) {
        d[i2] = crypto.getRandomValues(new Uint32Array(1))[0];
      } else {
        rd[i2++] = n % 1e7;
      }
    }
  } else if (crypto.randomBytes) {
    d = crypto.randomBytes(k *= 4);
    for (; i2 < k; ) {
      n = d[i2] + (d[i2 + 1] << 8) + (d[i2 + 2] << 16) + ((d[i2 + 3] & 127) << 24);
      if (n >= 214e7) {
        crypto.randomBytes(4).copy(d, i2);
      } else {
        rd.push(n % 1e7);
        i2 += 4;
      }
    }
    i2 = k / 4;
  } else {
    throw Error(cryptoUnavailable);
  }
  k = rd[--i2];
  sd %= LOG_BASE;
  if (k && sd) {
    n = mathpow(10, LOG_BASE - sd);
    rd[i2] = (k / n | 0) * n;
  }
  for (; rd[i2] === 0; i2--)
    rd.pop();
  if (i2 < 0) {
    e3 = 0;
    rd = [0];
  } else {
    e3 = -1;
    for (; rd[0] === 0; e3 -= LOG_BASE)
      rd.shift();
    for (k = 1, n = rd[0]; n >= 10; n /= 10)
      k++;
    if (k < LOG_BASE)
      e3 -= LOG_BASE - k;
  }
  r.e = e3;
  r.d = rd;
  return r;
}
function round(x) {
  return finalise(x = new this(x), x.e + 1, this.rounding);
}
function sign2(x) {
  x = new this(x);
  return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
}
function sin(x) {
  return new this(x).sin();
}
function sinh2(x) {
  return new this(x).sinh();
}
function sqrt(x) {
  return new this(x).sqrt();
}
function sub(x, y) {
  return new this(x).sub(y);
}
function sum() {
  var i2 = 0, args = arguments, x = new this(args[i2]);
  external = false;
  for (; x.s && ++i2 < args.length; )
    x = x.plus(args[i2]);
  external = true;
  return finalise(x, this.precision, this.rounding);
}
function tan(x) {
  return new this(x).tan();
}
function tanh2(x) {
  return new this(x).tanh();
}
function trunc(x) {
  return finalise(x = new this(x), x.e + 1, 1);
}
P[Symbol.for("nodejs.util.inspect.custom")] = P.toString;
P[Symbol.toStringTag] = "Decimal";
var Decimal = P.constructor = clone2(DEFAULTS);
LN10 = new Decimal(LN10);
PI = new Decimal(PI);
var decimal_default = Decimal;

// node_modules/mathjs/lib/esm/type/bignumber/BigNumber.js
var name2 = "BigNumber";
var dependencies3 = ["?on", "config"];
var createBigNumberClass = /* @__PURE__ */ factory(name2, dependencies3, (_ref) => {
  var {
    on,
    config: config5
  } = _ref;
  var BigNumber2 = decimal_default.clone({
    precision: config5.precision,
    modulo: decimal_default.EUCLID
  });
  BigNumber2.prototype = Object.create(BigNumber2.prototype);
  BigNumber2.prototype.type = "BigNumber";
  BigNumber2.prototype.isBigNumber = true;
  BigNumber2.prototype.toJSON = function() {
    return {
      mathjs: "BigNumber",
      value: this.toString()
    };
  };
  BigNumber2.fromJSON = function(json) {
    return new BigNumber2(json.value);
  };
  if (on) {
    on("config", function(curr, prev) {
      if (curr.precision !== prev.precision) {
        BigNumber2.config({
          precision: curr.precision
        });
      }
    });
  }
  return BigNumber2;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/complex/Complex.js
var import_complex = __toESM(require_complex(), 1);
var name3 = "Complex";
var dependencies4 = [];
var createComplexClass = /* @__PURE__ */ factory(name3, dependencies4, () => {
  Object.defineProperty(import_complex.default, "name", {
    value: "Complex"
  });
  import_complex.default.prototype.constructor = import_complex.default;
  import_complex.default.prototype.type = "Complex";
  import_complex.default.prototype.isComplex = true;
  import_complex.default.prototype.toJSON = function() {
    return {
      mathjs: "Complex",
      re: this.re,
      im: this.im
    };
  };
  import_complex.default.prototype.toPolar = function() {
    return {
      r: this.abs(),
      phi: this.arg()
    };
  };
  import_complex.default.prototype.format = function(options2) {
    var str = "";
    var im2 = this.im;
    var re2 = this.re;
    var strRe = format(this.re, options2);
    var strIm = format(this.im, options2);
    var precision = isNumber(options2) ? options2 : options2 ? options2.precision : null;
    if (precision !== null) {
      var epsilon = Math.pow(10, -precision);
      if (Math.abs(re2 / im2) < epsilon) {
        re2 = 0;
      }
      if (Math.abs(im2 / re2) < epsilon) {
        im2 = 0;
      }
    }
    if (im2 === 0) {
      str = strRe;
    } else if (re2 === 0) {
      if (im2 === 1) {
        str = "i";
      } else if (im2 === -1) {
        str = "-i";
      } else {
        str = strIm + "i";
      }
    } else {
      if (im2 < 0) {
        if (im2 === -1) {
          str = strRe + " - i";
        } else {
          str = strRe + " - " + strIm.substring(1) + "i";
        }
      } else {
        if (im2 === 1) {
          str = strRe + " + i";
        } else {
          str = strRe + " + " + strIm + "i";
        }
      }
    }
    return str;
  };
  import_complex.default.fromPolar = function(args) {
    switch (arguments.length) {
      case 1: {
        var arg2 = arguments[0];
        if (typeof arg2 === "object") {
          return (0, import_complex.default)(arg2);
        } else {
          throw new TypeError("Input has to be an object with r and phi keys.");
        }
      }
      case 2: {
        var r = arguments[0];
        var phi3 = arguments[1];
        if (isNumber(r)) {
          if (isUnit(phi3) && phi3.hasBase("ANGLE")) {
            phi3 = phi3.toNumber("rad");
          }
          if (isNumber(phi3)) {
            return new import_complex.default({
              r,
              phi: phi3
            });
          }
          throw new TypeError("Phi is not a number nor an angle unit.");
        } else {
          throw new TypeError("Radius r is not a number.");
        }
      }
      default:
        throw new SyntaxError("Wrong number of arguments in function fromPolar");
    }
  };
  import_complex.default.prototype.valueOf = import_complex.default.prototype.toString;
  import_complex.default.fromJSON = function(json) {
    return new import_complex.default(json);
  };
  import_complex.default.compare = function(a, b) {
    if (a.re > b.re) {
      return 1;
    }
    if (a.re < b.re) {
      return -1;
    }
    if (a.im > b.im) {
      return 1;
    }
    if (a.im < b.im) {
      return -1;
    }
    return 0;
  };
  return import_complex.default;
}, {
  isClass: true
});

// node_modules/fraction.js/fraction.js
var MAX_CYCLE_LEN = 2e3;
var P2 = {
  "s": 1,
  "n": 0,
  "d": 1
};
function assign(n, s) {
  if (isNaN(n = parseInt(n, 10))) {
    throw InvalidParameter();
  }
  return n * s;
}
function newFraction(n, d) {
  if (d === 0) {
    throw DivisionByZero();
  }
  var f = Object.create(Fraction.prototype);
  f["s"] = n < 0 ? -1 : 1;
  n = n < 0 ? -n : n;
  var a = gcd(n, d);
  f["n"] = n / a;
  f["d"] = d / a;
  return f;
}
function factorize(num) {
  var factors = {};
  var n = num;
  var i2 = 2;
  var s = 4;
  while (s <= n) {
    while (n % i2 === 0) {
      n /= i2;
      factors[i2] = (factors[i2] || 0) + 1;
    }
    s += 1 + 2 * i2++;
  }
  if (n !== num) {
    if (n > 1)
      factors[n] = (factors[n] || 0) + 1;
  } else {
    factors[num] = (factors[num] || 0) + 1;
  }
  return factors;
}
var parse2 = function(p1, p2) {
  var n = 0, d = 1, s = 1;
  var v = 0, w = 0, x = 0, y = 1, z = 1;
  var A = 0, B = 1;
  var C = 1, D = 1;
  var N = 1e7;
  var M;
  if (p1 === void 0 || p1 === null) {
  } else if (p2 !== void 0) {
    n = p1;
    d = p2;
    s = n * d;
    if (n % 1 !== 0 || d % 1 !== 0) {
      throw NonIntegerParameter();
    }
  } else
    switch (typeof p1) {
      case "object": {
        if ("d" in p1 && "n" in p1) {
          n = p1["n"];
          d = p1["d"];
          if ("s" in p1)
            n *= p1["s"];
        } else if (0 in p1) {
          n = p1[0];
          if (1 in p1)
            d = p1[1];
        } else {
          throw InvalidParameter();
        }
        s = n * d;
        break;
      }
      case "number": {
        if (p1 < 0) {
          s = p1;
          p1 = -p1;
        }
        if (p1 % 1 === 0) {
          n = p1;
        } else if (p1 > 0) {
          if (p1 >= 1) {
            z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
            p1 /= z;
          }
          while (B <= N && D <= N) {
            M = (A + C) / (B + D);
            if (p1 === M) {
              if (B + D <= N) {
                n = A + C;
                d = B + D;
              } else if (D > B) {
                n = C;
                d = D;
              } else {
                n = A;
                d = B;
              }
              break;
            } else {
              if (p1 > M) {
                A += C;
                B += D;
              } else {
                C += A;
                D += B;
              }
              if (B > N) {
                n = C;
                d = D;
              } else {
                n = A;
                d = B;
              }
            }
          }
          n *= z;
        } else if (isNaN(p1) || isNaN(p2)) {
          d = n = NaN;
        }
        break;
      }
      case "string": {
        B = p1.match(/\d+|./g);
        if (B === null)
          throw InvalidParameter();
        if (B[A] === "-") {
          s = -1;
          A++;
        } else if (B[A] === "+") {
          A++;
        }
        if (B.length === A + 1) {
          w = assign(B[A++], s);
        } else if (B[A + 1] === "." || B[A] === ".") {
          if (B[A] !== ".") {
            v = assign(B[A++], s);
          }
          A++;
          if (A + 1 === B.length || B[A + 1] === "(" && B[A + 3] === ")" || B[A + 1] === "'" && B[A + 3] === "'") {
            w = assign(B[A], s);
            y = Math.pow(10, B[A].length);
            A++;
          }
          if (B[A] === "(" && B[A + 2] === ")" || B[A] === "'" && B[A + 2] === "'") {
            x = assign(B[A + 1], s);
            z = Math.pow(10, B[A + 1].length) - 1;
            A += 3;
          }
        } else if (B[A + 1] === "/" || B[A + 1] === ":") {
          w = assign(B[A], s);
          y = assign(B[A + 2], 1);
          A += 3;
        } else if (B[A + 3] === "/" && B[A + 1] === " ") {
          v = assign(B[A], s);
          w = assign(B[A + 2], s);
          y = assign(B[A + 4], 1);
          A += 5;
        }
        if (B.length <= A) {
          d = y * z;
          s = /* void */
          n = x + d * v + z * w;
          break;
        }
      }
      default:
        throw InvalidParameter();
    }
  if (d === 0) {
    throw DivisionByZero();
  }
  P2["s"] = s < 0 ? -1 : 1;
  P2["n"] = Math.abs(n);
  P2["d"] = Math.abs(d);
};
function modpow(b, e3, m) {
  var r = 1;
  for (; e3 > 0; b = b * b % m, e3 >>= 1) {
    if (e3 & 1) {
      r = r * b % m;
    }
  }
  return r;
}
function cycleLen(n, d) {
  for (; d % 2 === 0; d /= 2) {
  }
  for (; d % 5 === 0; d /= 5) {
  }
  if (d === 1)
    return 0;
  var rem = 10 % d;
  var t = 1;
  for (; rem !== 1; t++) {
    rem = rem * 10 % d;
    if (t > MAX_CYCLE_LEN)
      return 0;
  }
  return t;
}
function cycleStart(n, d, len) {
  var rem1 = 1;
  var rem2 = modpow(10, len, d);
  for (var t = 0; t < 300; t++) {
    if (rem1 === rem2)
      return t;
    rem1 = rem1 * 10 % d;
    rem2 = rem2 * 10 % d;
  }
  return 0;
}
function gcd(a, b) {
  if (!a)
    return b;
  if (!b)
    return a;
  while (1) {
    a %= b;
    if (!a)
      return b;
    b %= a;
    if (!b)
      return a;
  }
}
function Fraction(a, b) {
  parse2(a, b);
  if (this instanceof Fraction) {
    a = gcd(P2["d"], P2["n"]);
    this["s"] = P2["s"];
    this["n"] = P2["n"] / a;
    this["d"] = P2["d"] / a;
  } else {
    return newFraction(P2["s"] * P2["n"], P2["d"]);
  }
}
var DivisionByZero = function() {
  return new Error("Division by Zero");
};
var InvalidParameter = function() {
  return new Error("Invalid argument");
};
var NonIntegerParameter = function() {
  return new Error("Parameters must be integer");
};
Fraction.prototype = {
  "s": 1,
  "n": 0,
  "d": 1,
  /**
   * Calculates the absolute value
   *
   * Ex: new Fraction(-4).abs() => 4
   **/
  "abs": function() {
    return newFraction(this["n"], this["d"]);
  },
  /**
   * Inverts the sign of the current fraction
   *
   * Ex: new Fraction(-4).neg() => 4
   **/
  "neg": function() {
    return newFraction(-this["s"] * this["n"], this["d"]);
  },
  /**
   * Adds two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
   **/
  "add": function(a, b) {
    parse2(a, b);
    return newFraction(
      this["s"] * this["n"] * P2["d"] + P2["s"] * this["d"] * P2["n"],
      this["d"] * P2["d"]
    );
  },
  /**
   * Subtracts two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
   **/
  "sub": function(a, b) {
    parse2(a, b);
    return newFraction(
      this["s"] * this["n"] * P2["d"] - P2["s"] * this["d"] * P2["n"],
      this["d"] * P2["d"]
    );
  },
  /**
   * Multiplies two rational numbers
   *
   * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
   **/
  "mul": function(a, b) {
    parse2(a, b);
    return newFraction(
      this["s"] * P2["s"] * this["n"] * P2["n"],
      this["d"] * P2["d"]
    );
  },
  /**
   * Divides two rational numbers
   *
   * Ex: new Fraction("-17.(345)").inverse().div(3)
   **/
  "div": function(a, b) {
    parse2(a, b);
    return newFraction(
      this["s"] * P2["s"] * this["n"] * P2["d"],
      this["d"] * P2["n"]
    );
  },
  /**
   * Clones the actual object
   *
   * Ex: new Fraction("-17.(345)").clone()
   **/
  "clone": function() {
    return newFraction(this["s"] * this["n"], this["d"]);
  },
  /**
   * Calculates the modulo of two rational numbers - a more precise fmod
   *
   * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
   **/
  "mod": function(a, b) {
    if (isNaN(this["n"]) || isNaN(this["d"])) {
      return new Fraction(NaN);
    }
    if (a === void 0) {
      return newFraction(this["s"] * this["n"] % this["d"], 1);
    }
    parse2(a, b);
    if (0 === P2["n"] && 0 === this["d"]) {
      throw DivisionByZero();
    }
    return newFraction(
      this["s"] * (P2["d"] * this["n"]) % (P2["n"] * this["d"]),
      P2["d"] * this["d"]
    );
  },
  /**
   * Calculates the fractional gcd of two rational numbers
   *
   * Ex: new Fraction(5,8).gcd(3,7) => 1/56
   */
  "gcd": function(a, b) {
    parse2(a, b);
    return newFraction(gcd(P2["n"], this["n"]) * gcd(P2["d"], this["d"]), P2["d"] * this["d"]);
  },
  /**
   * Calculates the fractional lcm of two rational numbers
   *
   * Ex: new Fraction(5,8).lcm(3,7) => 15
   */
  "lcm": function(a, b) {
    parse2(a, b);
    if (P2["n"] === 0 && this["n"] === 0) {
      return newFraction(0, 1);
    }
    return newFraction(P2["n"] * this["n"], gcd(P2["n"], this["n"]) * gcd(P2["d"], this["d"]));
  },
  /**
   * Calculates the ceil of a rational number
   *
   * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
   **/
  "ceil": function(places) {
    places = Math.pow(10, places || 0);
    if (isNaN(this["n"]) || isNaN(this["d"])) {
      return new Fraction(NaN);
    }
    return newFraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
  },
  /**
   * Calculates the floor of a rational number
   *
   * Ex: new Fraction('4.(3)').floor() => (4 / 1)
   **/
  "floor": function(places) {
    places = Math.pow(10, places || 0);
    if (isNaN(this["n"]) || isNaN(this["d"])) {
      return new Fraction(NaN);
    }
    return newFraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
  },
  /**
   * Rounds a rational number
   *
   * Ex: new Fraction('4.(3)').round() => (4 / 1)
   **/
  "round": function(places) {
    places = Math.pow(10, places || 0);
    if (isNaN(this["n"]) || isNaN(this["d"])) {
      return new Fraction(NaN);
    }
    return newFraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
  },
  /**
   * Rounds a rational number to a multiple of another rational number
   *
   * Ex: new Fraction('0.9').roundTo("1/8") => 7 / 8
   **/
  "roundTo": function(a, b) {
    parse2(a, b);
    return newFraction(this["s"] * Math.round(this["n"] * P2["d"] / (this["d"] * P2["n"])) * P2["n"], P2["d"]);
  },
  /**
   * Gets the inverse of the fraction, means numerator and denominator are exchanged
   *
   * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
   **/
  "inverse": function() {
    return newFraction(this["s"] * this["d"], this["n"]);
  },
  /**
   * Calculates the fraction to some rational exponent, if possible
   *
   * Ex: new Fraction(-1,2).pow(-3) => -8
   */
  "pow": function(a, b) {
    parse2(a, b);
    if (P2["d"] === 1) {
      if (P2["s"] < 0) {
        return newFraction(Math.pow(this["s"] * this["d"], P2["n"]), Math.pow(this["n"], P2["n"]));
      } else {
        return newFraction(Math.pow(this["s"] * this["n"], P2["n"]), Math.pow(this["d"], P2["n"]));
      }
    }
    if (this["s"] < 0)
      return null;
    var N = factorize(this["n"]);
    var D = factorize(this["d"]);
    var n = 1;
    var d = 1;
    for (var k in N) {
      if (k === "1")
        continue;
      if (k === "0") {
        n = 0;
        break;
      }
      N[k] *= P2["n"];
      if (N[k] % P2["d"] === 0) {
        N[k] /= P2["d"];
      } else
        return null;
      n *= Math.pow(k, N[k]);
    }
    for (var k in D) {
      if (k === "1")
        continue;
      D[k] *= P2["n"];
      if (D[k] % P2["d"] === 0) {
        D[k] /= P2["d"];
      } else
        return null;
      d *= Math.pow(k, D[k]);
    }
    if (P2["s"] < 0) {
      return newFraction(d, n);
    }
    return newFraction(n, d);
  },
  /**
   * Check if two rational numbers are the same
   *
   * Ex: new Fraction(19.6).equals([98, 5]);
   **/
  "equals": function(a, b) {
    parse2(a, b);
    return this["s"] * this["n"] * P2["d"] === P2["s"] * P2["n"] * this["d"];
  },
  /**
   * Check if two rational numbers are the same
   *
   * Ex: new Fraction(19.6).equals([98, 5]);
   **/
  "compare": function(a, b) {
    parse2(a, b);
    var t = this["s"] * this["n"] * P2["d"] - P2["s"] * P2["n"] * this["d"];
    return (0 < t) - (t < 0);
  },
  "simplify": function(eps) {
    if (isNaN(this["n"]) || isNaN(this["d"])) {
      return this;
    }
    eps = eps || 1e-3;
    var thisABS = this["abs"]();
    var cont = thisABS["toContinued"]();
    for (var i2 = 1; i2 < cont.length; i2++) {
      var s = newFraction(cont[i2 - 1], 1);
      for (var k = i2 - 2; k >= 0; k--) {
        s = s["inverse"]()["add"](cont[k]);
      }
      if (Math.abs(s["sub"](thisABS).valueOf()) < eps) {
        return s["mul"](this["s"]);
      }
    }
    return this;
  },
  /**
   * Check if two rational numbers are divisible
   *
   * Ex: new Fraction(19.6).divisible(1.5);
   */
  "divisible": function(a, b) {
    parse2(a, b);
    return !(!(P2["n"] * this["d"]) || this["n"] * P2["d"] % (P2["n"] * this["d"]));
  },
  /**
   * Returns a decimal representation of the fraction
   *
   * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
   **/
  "valueOf": function() {
    return this["s"] * this["n"] / this["d"];
  },
  /**
   * Returns a string-fraction representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
   **/
  "toFraction": function(excludeWhole) {
    var whole, str = "";
    var n = this["n"];
    var d = this["d"];
    if (this["s"] < 0) {
      str += "-";
    }
    if (d === 1) {
      str += n;
    } else {
      if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
        str += whole;
        str += " ";
        n %= d;
      }
      str += n;
      str += "/";
      str += d;
    }
    return str;
  },
  /**
   * Returns a latex representation of a Fraction object
   *
   * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
   **/
  "toLatex": function(excludeWhole) {
    var whole, str = "";
    var n = this["n"];
    var d = this["d"];
    if (this["s"] < 0) {
      str += "-";
    }
    if (d === 1) {
      str += n;
    } else {
      if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
        str += whole;
        n %= d;
      }
      str += "\\frac{";
      str += n;
      str += "}{";
      str += d;
      str += "}";
    }
    return str;
  },
  /**
   * Returns an array of continued fraction elements
   *
   * Ex: new Fraction("7/8").toContinued() => [0,1,7]
   */
  "toContinued": function() {
    var t;
    var a = this["n"];
    var b = this["d"];
    var res = [];
    if (isNaN(a) || isNaN(b)) {
      return res;
    }
    do {
      res.push(Math.floor(a / b));
      t = a % b;
      a = b;
      b = t;
    } while (a !== 1);
    return res;
  },
  /**
   * Creates a string representation of a fraction with all digits
   *
   * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
   **/
  "toString": function(dec) {
    var N = this["n"];
    var D = this["d"];
    if (isNaN(N) || isNaN(D)) {
      return "NaN";
    }
    dec = dec || 15;
    var cycLen = cycleLen(N, D);
    var cycOff = cycleStart(N, D, cycLen);
    var str = this["s"] < 0 ? "-" : "";
    str += N / D | 0;
    N %= D;
    N *= 10;
    if (N)
      str += ".";
    if (cycLen) {
      for (var i2 = cycOff; i2--; ) {
        str += N / D | 0;
        N %= D;
        N *= 10;
      }
      str += "(";
      for (var i2 = cycLen; i2--; ) {
        str += N / D | 0;
        N %= D;
        N *= 10;
      }
      str += ")";
    } else {
      for (var i2 = dec; N && i2--; ) {
        str += N / D | 0;
        N %= D;
        N *= 10;
      }
    }
    return str;
  }
};

// node_modules/mathjs/lib/esm/type/fraction/Fraction.js
var name4 = "Fraction";
var dependencies5 = [];
var createFractionClass = /* @__PURE__ */ factory(name4, dependencies5, () => {
  Object.defineProperty(Fraction, "name", {
    value: "Fraction"
  });
  Fraction.prototype.constructor = Fraction;
  Fraction.prototype.type = "Fraction";
  Fraction.prototype.isFraction = true;
  Fraction.prototype.toJSON = function() {
    return {
      mathjs: "Fraction",
      n: this.s * this.n,
      d: this.d
    };
  };
  Fraction.fromJSON = function(json) {
    return new Fraction(json);
  };
  return Fraction;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/matrix/Range.js
var name5 = "Range";
var dependencies6 = [];
var createRangeClass = /* @__PURE__ */ factory(name5, dependencies6, () => {
  function Range2(start, end, step) {
    if (!(this instanceof Range2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    var hasStart = start !== null && start !== void 0;
    var hasEnd = end !== null && end !== void 0;
    var hasStep = step !== null && step !== void 0;
    if (hasStart) {
      if (isBigNumber(start)) {
        start = start.toNumber();
      } else if (typeof start !== "number") {
        throw new TypeError("Parameter start must be a number");
      }
    }
    if (hasEnd) {
      if (isBigNumber(end)) {
        end = end.toNumber();
      } else if (typeof end !== "number") {
        throw new TypeError("Parameter end must be a number");
      }
    }
    if (hasStep) {
      if (isBigNumber(step)) {
        step = step.toNumber();
      } else if (typeof step !== "number") {
        throw new TypeError("Parameter step must be a number");
      }
    }
    this.start = hasStart ? parseFloat(start) : 0;
    this.end = hasEnd ? parseFloat(end) : 0;
    this.step = hasStep ? parseFloat(step) : 1;
  }
  Range2.prototype.type = "Range";
  Range2.prototype.isRange = true;
  Range2.parse = function(str) {
    if (typeof str !== "string") {
      return null;
    }
    var args = str.split(":");
    var nums = args.map(function(arg2) {
      return parseFloat(arg2);
    });
    var invalid = nums.some(function(num) {
      return isNaN(num);
    });
    if (invalid) {
      return null;
    }
    switch (nums.length) {
      case 2:
        return new Range2(nums[0], nums[1]);
      case 3:
        return new Range2(nums[0], nums[2], nums[1]);
      default:
        return null;
    }
  };
  Range2.prototype.clone = function() {
    return new Range2(this.start, this.end, this.step);
  };
  Range2.prototype.size = function() {
    var len = 0;
    var start = this.start;
    var step = this.step;
    var end = this.end;
    var diff2 = end - start;
    if (sign(step) === sign(diff2)) {
      len = Math.ceil(diff2 / step);
    } else if (diff2 === 0) {
      len = 0;
    }
    if (isNaN(len)) {
      len = 0;
    }
    return [len];
  };
  Range2.prototype.min = function() {
    var size2 = this.size()[0];
    if (size2 > 0) {
      if (this.step > 0) {
        return this.start;
      } else {
        return this.start + (size2 - 1) * this.step;
      }
    } else {
      return void 0;
    }
  };
  Range2.prototype.max = function() {
    var size2 = this.size()[0];
    if (size2 > 0) {
      if (this.step > 0) {
        return this.start + (size2 - 1) * this.step;
      } else {
        return this.start;
      }
    } else {
      return void 0;
    }
  };
  Range2.prototype.forEach = function(callback) {
    var x = this.start;
    var step = this.step;
    var end = this.end;
    var i2 = 0;
    if (step > 0) {
      while (x < end) {
        callback(x, [i2], this);
        x += step;
        i2++;
      }
    } else if (step < 0) {
      while (x > end) {
        callback(x, [i2], this);
        x += step;
        i2++;
      }
    }
  };
  Range2.prototype.map = function(callback) {
    var array = [];
    this.forEach(function(value, index2, obj) {
      array[index2[0]] = callback(value, index2, obj);
    });
    return array;
  };
  Range2.prototype.toArray = function() {
    var array = [];
    this.forEach(function(value, index2) {
      array[index2[0]] = value;
    });
    return array;
  };
  Range2.prototype.valueOf = function() {
    return this.toArray();
  };
  Range2.prototype.format = function(options2) {
    var str = format(this.start, options2);
    if (this.step !== 1) {
      str += ":" + format(this.step, options2);
    }
    str += ":" + format(this.end, options2);
    return str;
  };
  Range2.prototype.toString = function() {
    return this.format();
  };
  Range2.prototype.toJSON = function() {
    return {
      mathjs: "Range",
      start: this.start,
      end: this.end,
      step: this.step
    };
  };
  Range2.fromJSON = function(json) {
    return new Range2(json.start, json.end, json.step);
  };
  return Range2;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/matrix/Matrix.js
var name6 = "Matrix";
var dependencies7 = [];
var createMatrixClass = /* @__PURE__ */ factory(name6, dependencies7, () => {
  function Matrix2() {
    if (!(this instanceof Matrix2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
  }
  Matrix2.prototype.type = "Matrix";
  Matrix2.prototype.isMatrix = true;
  Matrix2.prototype.storage = function() {
    throw new Error("Cannot invoke storage on a Matrix interface");
  };
  Matrix2.prototype.datatype = function() {
    throw new Error("Cannot invoke datatype on a Matrix interface");
  };
  Matrix2.prototype.create = function(data, datatype) {
    throw new Error("Cannot invoke create on a Matrix interface");
  };
  Matrix2.prototype.subset = function(index2, replacement, defaultValue) {
    throw new Error("Cannot invoke subset on a Matrix interface");
  };
  Matrix2.prototype.get = function(index2) {
    throw new Error("Cannot invoke get on a Matrix interface");
  };
  Matrix2.prototype.set = function(index2, value, defaultValue) {
    throw new Error("Cannot invoke set on a Matrix interface");
  };
  Matrix2.prototype.resize = function(size2, defaultValue) {
    throw new Error("Cannot invoke resize on a Matrix interface");
  };
  Matrix2.prototype.reshape = function(size2, defaultValue) {
    throw new Error("Cannot invoke reshape on a Matrix interface");
  };
  Matrix2.prototype.clone = function() {
    throw new Error("Cannot invoke clone on a Matrix interface");
  };
  Matrix2.prototype.size = function() {
    throw new Error("Cannot invoke size on a Matrix interface");
  };
  Matrix2.prototype.map = function(callback, skipZeros) {
    throw new Error("Cannot invoke map on a Matrix interface");
  };
  Matrix2.prototype.forEach = function(callback) {
    throw new Error("Cannot invoke forEach on a Matrix interface");
  };
  Matrix2.prototype[Symbol.iterator] = function() {
    throw new Error("Cannot iterate a Matrix interface");
  };
  Matrix2.prototype.toArray = function() {
    throw new Error("Cannot invoke toArray on a Matrix interface");
  };
  Matrix2.prototype.valueOf = function() {
    throw new Error("Cannot invoke valueOf on a Matrix interface");
  };
  Matrix2.prototype.format = function(options2) {
    throw new Error("Cannot invoke format on a Matrix interface");
  };
  Matrix2.prototype.toString = function() {
    throw new Error("Cannot invoke toString on a Matrix interface");
  };
  return Matrix2;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/utils/bignumber/formatter.js
function formatBigNumberToBase(n, base, size2) {
  var BigNumberCtor = n.constructor;
  var big2 = new BigNumberCtor(2);
  var suffix = "";
  if (size2) {
    if (size2 < 1) {
      throw new Error("size must be in greater than 0");
    }
    if (!isInteger(size2)) {
      throw new Error("size must be an integer");
    }
    if (n.greaterThan(big2.pow(size2 - 1).sub(1)) || n.lessThan(big2.pow(size2 - 1).mul(-1))) {
      throw new Error("Value must be in range [-2^".concat(size2 - 1, ", 2^").concat(size2 - 1, "-1]"));
    }
    if (!n.isInteger()) {
      throw new Error("Value must be an integer");
    }
    if (n.lessThan(0)) {
      n = n.add(big2.pow(size2));
    }
    suffix = "i".concat(size2);
  }
  switch (base) {
    case 2:
      return "".concat(n.toBinary()).concat(suffix);
    case 8:
      return "".concat(n.toOctal()).concat(suffix);
    case 16:
      return "".concat(n.toHexadecimal()).concat(suffix);
    default:
      throw new Error("Base ".concat(base, " not supported "));
  }
}
function format2(value, options2) {
  if (typeof options2 === "function") {
    return options2(value);
  }
  if (!value.isFinite()) {
    return value.isNaN() ? "NaN" : value.gt(0) ? "Infinity" : "-Infinity";
  }
  var {
    notation,
    precision,
    wordSize
  } = normalizeFormatOptions(options2);
  switch (notation) {
    case "fixed":
      return toFixed2(value, precision);
    case "exponential":
      return toExponential2(value, precision);
    case "engineering":
      return toEngineering2(value, precision);
    case "bin":
      return formatBigNumberToBase(value, 2, wordSize);
    case "oct":
      return formatBigNumberToBase(value, 8, wordSize);
    case "hex":
      return formatBigNumberToBase(value, 16, wordSize);
    case "auto": {
      var lowerExp = _toNumberOrDefault2(options2 === null || options2 === void 0 ? void 0 : options2.lowerExp, -3);
      var upperExp = _toNumberOrDefault2(options2 === null || options2 === void 0 ? void 0 : options2.upperExp, 5);
      if (value.isZero())
        return "0";
      var str;
      var rounded = value.toSignificantDigits(precision);
      var exp3 = rounded.e;
      if (exp3 >= lowerExp && exp3 < upperExp) {
        str = rounded.toFixed();
      } else {
        str = toExponential2(value, precision);
      }
      return str.replace(/((\.\d*?)(0+))($|e)/, function() {
        var digits2 = arguments[2];
        var e3 = arguments[4];
        return digits2 !== "." ? digits2 + e3 : e3;
      });
    }
    default:
      throw new Error('Unknown notation "' + notation + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
  }
}
function toEngineering2(value, precision) {
  var e3 = value.e;
  var newExp = e3 % 3 === 0 ? e3 : e3 < 0 ? e3 - 3 - e3 % 3 : e3 - e3 % 3;
  var valueWithoutExp = value.mul(Math.pow(10, -newExp));
  var valueStr = valueWithoutExp.toPrecision(precision);
  if (valueStr.includes("e")) {
    var BigNumber2 = value.constructor;
    valueStr = new BigNumber2(valueStr).toFixed();
  }
  return valueStr + "e" + (e3 >= 0 ? "+" : "") + newExp.toString();
}
function toExponential2(value, precision) {
  if (precision !== void 0) {
    return value.toExponential(precision - 1);
  } else {
    return value.toExponential();
  }
}
function toFixed2(value, precision) {
  return value.toFixed(precision);
}
function _toNumberOrDefault2(value, defaultValue) {
  if (isNumber(value)) {
    return value;
  } else if (isBigNumber(value)) {
    return value.toNumber();
  } else {
    return defaultValue;
  }
}

// node_modules/mathjs/lib/esm/utils/string.js
function endsWith(text, search) {
  var start = text.length - search.length;
  var end = text.length;
  return text.substring(start, end) === search;
}
function format3(value, options2) {
  var result = _format(value, options2);
  if (options2 && typeof options2 === "object" && "truncate" in options2 && result.length > options2.truncate) {
    return result.substring(0, options2.truncate - 3) + "...";
  }
  return result;
}
function _format(value, options2) {
  if (typeof value === "number") {
    return format(value, options2);
  }
  if (isBigNumber(value)) {
    return format2(value, options2);
  }
  if (looksLikeFraction(value)) {
    if (!options2 || options2.fraction !== "decimal") {
      return value.s * value.n + "/" + value.d;
    } else {
      return value.toString();
    }
  }
  if (Array.isArray(value)) {
    return formatArray(value, options2);
  }
  if (isString(value)) {
    return stringify(value);
  }
  if (typeof value === "function") {
    return value.syntax ? String(value.syntax) : "function";
  }
  if (value && typeof value === "object") {
    if (typeof value.format === "function") {
      return value.format(options2);
    } else if (value && value.toString(options2) !== {}.toString()) {
      return value.toString(options2);
    } else {
      var entries = Object.keys(value).map((key) => {
        return stringify(key) + ": " + format3(value[key], options2);
      });
      return "{" + entries.join(", ") + "}";
    }
  }
  return String(value);
}
function stringify(value) {
  var text = String(value);
  var escaped = "";
  var i2 = 0;
  while (i2 < text.length) {
    var c = text.charAt(i2);
    escaped += c in controlCharacters ? controlCharacters[c] : c;
    i2++;
  }
  return '"' + escaped + '"';
}
var controlCharacters = {
  '"': '\\"',
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t"
};
function escape(value) {
  var text = String(value);
  text = text.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  return text;
}
function formatArray(array, options2) {
  if (Array.isArray(array)) {
    var str = "[";
    var len = array.length;
    for (var i2 = 0; i2 < len; i2++) {
      if (i2 !== 0) {
        str += ", ";
      }
      str += formatArray(array[i2], options2);
    }
    str += "]";
    return str;
  } else {
    return format3(array, options2);
  }
}
function looksLikeFraction(value) {
  return value && typeof value === "object" && typeof value.s === "number" && typeof value.n === "number" && typeof value.d === "number" || false;
}
function compareText(x, y) {
  if (!isString(x)) {
    throw new TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: " + typeOf(x) + ", index: 0)");
  }
  if (!isString(y)) {
    throw new TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: " + typeOf(y) + ", index: 1)");
  }
  return x === y ? 0 : x > y ? 1 : -1;
}

// node_modules/mathjs/lib/esm/error/DimensionError.js
function DimensionError(actual, expected, relation) {
  if (!(this instanceof DimensionError)) {
    throw new SyntaxError("Constructor must be called with the new operator");
  }
  this.actual = actual;
  this.expected = expected;
  this.relation = relation;
  this.message = "Dimension mismatch (" + (Array.isArray(actual) ? "[" + actual.join(", ") + "]" : actual) + " " + (this.relation || "!=") + " " + (Array.isArray(expected) ? "[" + expected.join(", ") + "]" : expected) + ")";
  this.stack = new Error().stack;
}
DimensionError.prototype = new RangeError();
DimensionError.prototype.constructor = RangeError;
DimensionError.prototype.name = "DimensionError";
DimensionError.prototype.isDimensionError = true;

// node_modules/mathjs/lib/esm/error/IndexError.js
function IndexError(index2, min3, max3) {
  if (!(this instanceof IndexError)) {
    throw new SyntaxError("Constructor must be called with the new operator");
  }
  this.index = index2;
  if (arguments.length < 3) {
    this.min = 0;
    this.max = min3;
  } else {
    this.min = min3;
    this.max = max3;
  }
  if (this.min !== void 0 && this.index < this.min) {
    this.message = "Index out of range (" + this.index + " < " + this.min + ")";
  } else if (this.max !== void 0 && this.index >= this.max) {
    this.message = "Index out of range (" + this.index + " > " + (this.max - 1) + ")";
  } else {
    this.message = "Index out of range (" + this.index + ")";
  }
  this.stack = new Error().stack;
}
IndexError.prototype = new RangeError();
IndexError.prototype.constructor = RangeError;
IndexError.prototype.name = "IndexError";
IndexError.prototype.isIndexError = true;

// node_modules/mathjs/lib/esm/utils/array.js
function arraySize(x) {
  var s = [];
  while (Array.isArray(x)) {
    s.push(x.length);
    x = x[0];
  }
  return s;
}
function _validate(array, size2, dim) {
  var i2;
  var len = array.length;
  if (len !== size2[dim]) {
    throw new DimensionError(len, size2[dim]);
  }
  if (dim < size2.length - 1) {
    var dimNext = dim + 1;
    for (i2 = 0; i2 < len; i2++) {
      var child = array[i2];
      if (!Array.isArray(child)) {
        throw new DimensionError(size2.length - 1, size2.length, "<");
      }
      _validate(array[i2], size2, dimNext);
    }
  } else {
    for (i2 = 0; i2 < len; i2++) {
      if (Array.isArray(array[i2])) {
        throw new DimensionError(size2.length + 1, size2.length, ">");
      }
    }
  }
}
function validate(array, size2) {
  var isScalar = size2.length === 0;
  if (isScalar) {
    if (Array.isArray(array)) {
      throw new DimensionError(array.length, 0);
    }
  } else {
    _validate(array, size2, 0);
  }
}
function validateIndexSourceSize(value, index2) {
  var valueSize = value.isMatrix ? value._size : arraySize(value);
  var sourceSize = index2._sourceSize;
  sourceSize.forEach((sourceDim, i2) => {
    if (sourceDim !== null && sourceDim !== valueSize[i2]) {
      throw new DimensionError(sourceDim, valueSize[i2]);
    }
  });
}
function validateIndex(index2, length) {
  if (index2 !== void 0) {
    if (!isNumber(index2) || !isInteger(index2)) {
      throw new TypeError("Index must be an integer (value: " + index2 + ")");
    }
    if (index2 < 0 || typeof length === "number" && index2 >= length) {
      throw new IndexError(index2, length);
    }
  }
}
function isEmptyIndex(index2) {
  for (var i2 = 0; i2 < index2._dimensions.length; ++i2) {
    var dimension = index2._dimensions[i2];
    if (dimension._data && isArray(dimension._data)) {
      if (dimension._size[0] === 0) {
        return true;
      }
    } else if (dimension.isRange) {
      if (dimension.start === dimension.end) {
        return true;
      }
    } else if (isString(dimension)) {
      if (dimension.length === 0) {
        return true;
      }
    }
  }
  return false;
}
function resize(array, size2, defaultValue) {
  if (!Array.isArray(size2)) {
    throw new TypeError("Array expected");
  }
  if (size2.length === 0) {
    throw new Error("Resizing to scalar is not supported");
  }
  size2.forEach(function(value) {
    if (!isNumber(value) || !isInteger(value) || value < 0) {
      throw new TypeError("Invalid size, must contain positive integers (size: " + format3(size2) + ")");
    }
  });
  if (isNumber(array) || isBigNumber(array)) {
    array = [array];
  }
  var _defaultValue = defaultValue !== void 0 ? defaultValue : 0;
  _resize(array, size2, 0, _defaultValue);
  return array;
}
function _resize(array, size2, dim, defaultValue) {
  var i2;
  var elem;
  var oldLen = array.length;
  var newLen = size2[dim];
  var minLen = Math.min(oldLen, newLen);
  array.length = newLen;
  if (dim < size2.length - 1) {
    var dimNext = dim + 1;
    for (i2 = 0; i2 < minLen; i2++) {
      elem = array[i2];
      if (!Array.isArray(elem)) {
        elem = [elem];
        array[i2] = elem;
      }
      _resize(elem, size2, dimNext, defaultValue);
    }
    for (i2 = minLen; i2 < newLen; i2++) {
      elem = [];
      array[i2] = elem;
      _resize(elem, size2, dimNext, defaultValue);
    }
  } else {
    for (i2 = 0; i2 < minLen; i2++) {
      while (Array.isArray(array[i2])) {
        array[i2] = array[i2][0];
      }
    }
    for (i2 = minLen; i2 < newLen; i2++) {
      array[i2] = defaultValue;
    }
  }
}
function reshape(array, sizes) {
  var flatArray = flatten(array);
  var currentLength = flatArray.length;
  if (!Array.isArray(array) || !Array.isArray(sizes)) {
    throw new TypeError("Array expected");
  }
  if (sizes.length === 0) {
    throw new DimensionError(0, currentLength, "!=");
  }
  sizes = processSizesWildcard(sizes, currentLength);
  var newLength = product(sizes);
  if (currentLength !== newLength) {
    throw new DimensionError(newLength, currentLength, "!=");
  }
  try {
    return _reshape(flatArray, sizes);
  } catch (e3) {
    if (e3 instanceof DimensionError) {
      throw new DimensionError(newLength, currentLength, "!=");
    }
    throw e3;
  }
}
function processSizesWildcard(sizes, currentLength) {
  var newLength = product(sizes);
  var processedSizes = sizes.slice();
  var WILDCARD = -1;
  var wildCardIndex = sizes.indexOf(WILDCARD);
  var isMoreThanOneWildcard = sizes.indexOf(WILDCARD, wildCardIndex + 1) >= 0;
  if (isMoreThanOneWildcard) {
    throw new Error("More than one wildcard in sizes");
  }
  var hasWildcard = wildCardIndex >= 0;
  var canReplaceWildcard = currentLength % newLength === 0;
  if (hasWildcard) {
    if (canReplaceWildcard) {
      processedSizes[wildCardIndex] = -currentLength / newLength;
    } else {
      throw new Error("Could not replace wildcard, since " + currentLength + " is no multiple of " + -newLength);
    }
  }
  return processedSizes;
}
function product(array) {
  return array.reduce((prev, curr) => prev * curr, 1);
}
function _reshape(array, sizes) {
  var tmpArray = array;
  var tmpArray2;
  for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {
    var size2 = sizes[sizeIndex];
    tmpArray2 = [];
    var length = tmpArray.length / size2;
    for (var i2 = 0; i2 < length; i2++) {
      tmpArray2.push(tmpArray.slice(i2 * size2, (i2 + 1) * size2));
    }
    tmpArray = tmpArray2;
  }
  return tmpArray;
}
function squeeze(array, size2) {
  var s = size2 || arraySize(array);
  while (Array.isArray(array) && array.length === 1) {
    array = array[0];
    s.shift();
  }
  var dims = s.length;
  while (s[dims - 1] === 1) {
    dims--;
  }
  if (dims < s.length) {
    array = _squeeze(array, dims, 0);
    s.length = dims;
  }
  return array;
}
function _squeeze(array, dims, dim) {
  var i2, ii;
  if (dim < dims) {
    var next = dim + 1;
    for (i2 = 0, ii = array.length; i2 < ii; i2++) {
      array[i2] = _squeeze(array[i2], dims, next);
    }
  } else {
    while (Array.isArray(array)) {
      array = array[0];
    }
  }
  return array;
}
function unsqueeze(array, dims, outer, size2) {
  var s = size2 || arraySize(array);
  if (outer) {
    for (var i2 = 0; i2 < outer; i2++) {
      array = [array];
      s.unshift(1);
    }
  }
  array = _unsqueeze(array, dims, 0);
  while (s.length < dims) {
    s.push(1);
  }
  return array;
}
function _unsqueeze(array, dims, dim) {
  var i2, ii;
  if (Array.isArray(array)) {
    var next = dim + 1;
    for (i2 = 0, ii = array.length; i2 < ii; i2++) {
      array[i2] = _unsqueeze(array[i2], dims, next);
    }
  } else {
    for (var d = dim; d < dims; d++) {
      array = [array];
    }
  }
  return array;
}
function flatten(array) {
  if (!Array.isArray(array)) {
    return array;
  }
  var flat = [];
  array.forEach(function callback(value) {
    if (Array.isArray(value)) {
      value.forEach(callback);
    } else {
      flat.push(value);
    }
  });
  return flat;
}
function map(array, callback) {
  return Array.prototype.map.call(array, callback);
}
function forEach(array, callback) {
  Array.prototype.forEach.call(array, callback);
}
function filter(array, callback) {
  if (arraySize(array).length !== 1) {
    throw new Error("Only one dimensional matrices supported");
  }
  return Array.prototype.filter.call(array, callback);
}
function filterRegExp(array, regexp) {
  if (arraySize(array).length !== 1) {
    throw new Error("Only one dimensional matrices supported");
  }
  return Array.prototype.filter.call(array, (entry) => regexp.test(entry));
}
function join(array, separator) {
  return Array.prototype.join.call(array, separator);
}
function identify(a) {
  if (!Array.isArray(a)) {
    throw new TypeError("Array input expected");
  }
  if (a.length === 0) {
    return a;
  }
  var b = [];
  var count2 = 0;
  b[0] = {
    value: a[0],
    identifier: 0
  };
  for (var i2 = 1; i2 < a.length; i2++) {
    if (a[i2] === a[i2 - 1]) {
      count2++;
    } else {
      count2 = 0;
    }
    b.push({
      value: a[i2],
      identifier: count2
    });
  }
  return b;
}
function generalize(a) {
  if (!Array.isArray(a)) {
    throw new TypeError("Array input expected");
  }
  if (a.length === 0) {
    return a;
  }
  var b = [];
  for (var i2 = 0; i2 < a.length; i2++) {
    b.push(a[i2].value);
  }
  return b;
}
function getArrayDataType(array, typeOf3) {
  var type;
  var length = 0;
  for (var i2 = 0; i2 < array.length; i2++) {
    var item = array[i2];
    var _isArray = Array.isArray(item);
    if (i2 === 0 && _isArray) {
      length = item.length;
    }
    if (_isArray && item.length !== length) {
      return void 0;
    }
    var itemType = _isArray ? getArrayDataType(item, typeOf3) : typeOf3(item);
    if (type === void 0) {
      type = itemType;
    } else if (type !== itemType) {
      return "mixed";
    } else {
    }
  }
  return type;
}
function concatRecursive(a, b, concatDim, dim) {
  if (dim < concatDim) {
    if (a.length !== b.length) {
      throw new DimensionError(a.length, b.length);
    }
    var c = [];
    for (var i2 = 0; i2 < a.length; i2++) {
      c[i2] = concatRecursive(a[i2], b[i2], concatDim, dim + 1);
    }
    return c;
  } else {
    return a.concat(b);
  }
}
function concat() {
  var arrays = Array.prototype.slice.call(arguments, 0, -1);
  var concatDim = Array.prototype.slice.call(arguments, -1);
  if (arrays.length === 1) {
    return arrays[0];
  }
  if (arrays.length > 1) {
    return arrays.slice(1).reduce(function(A, B) {
      return concatRecursive(A, B, concatDim, 0);
    }, arrays[0]);
  } else {
    throw new Error("Wrong number of arguments in function concat");
  }
}
function broadcastSizes() {
  for (var _len = arguments.length, sizes = new Array(_len), _key = 0; _key < _len; _key++) {
    sizes[_key] = arguments[_key];
  }
  var dimensions = sizes.map((s) => s.length);
  var N = Math.max(...dimensions);
  var sizeMax = new Array(N).fill(null);
  for (var i2 = 0; i2 < sizes.length; i2++) {
    var size2 = sizes[i2];
    var dim = dimensions[i2];
    for (var j = 0; j < dim; j++) {
      var n = N - dim + j;
      if (size2[j] > sizeMax[n]) {
        sizeMax[n] = size2[j];
      }
    }
  }
  for (var _i = 0; _i < sizes.length; _i++) {
    checkBroadcastingRules(sizes[_i], sizeMax);
  }
  return sizeMax;
}
function checkBroadcastingRules(size2, toSize) {
  var N = toSize.length;
  var dim = size2.length;
  for (var j = 0; j < dim; j++) {
    var n = N - dim + j;
    if (size2[j] < toSize[n] && size2[j] > 1 || size2[j] > toSize[n]) {
      throw new Error("shape missmatch: missmatch is found in arg with shape (".concat(size2, ") not possible to broadcast dimension ").concat(dim, " with size ").concat(size2[j], " to size ").concat(toSize[n]));
    }
  }
}
function broadcastTo(array, toSize) {
  var Asize = arraySize(array);
  if (deepStrictEqual(Asize, toSize)) {
    return array;
  }
  checkBroadcastingRules(Asize, toSize);
  var broadcastedSize = broadcastSizes(Asize, toSize);
  var N = broadcastedSize.length;
  var paddedSize = [...Array(N - Asize.length).fill(1), ...Asize];
  var A = clone3(array);
  if (Asize.length < N) {
    A = reshape(A, paddedSize);
    Asize = arraySize(A);
  }
  for (var dim = 0; dim < N; dim++) {
    if (Asize[dim] < broadcastedSize[dim]) {
      A = stretch(A, broadcastedSize[dim], dim);
      Asize = arraySize(A);
    }
  }
  return A;
}
function stretch(arrayToStretch, sizeToStretch, dimToStretch) {
  return concat(...Array(sizeToStretch).fill(arrayToStretch), dimToStretch);
}
function clone3(array) {
  return _extends([], array);
}

// node_modules/mathjs/lib/esm/utils/lruQueue.js
function lruQueue(limit) {
  var size2 = 0;
  var base = 1;
  var queue = /* @__PURE__ */ Object.create(null);
  var map3 = /* @__PURE__ */ Object.create(null);
  var index2 = 0;
  var del = function del2(id) {
    var oldIndex = map3[id];
    if (!oldIndex)
      return;
    delete queue[oldIndex];
    delete map3[id];
    --size2;
    if (base !== oldIndex)
      return;
    if (!size2) {
      index2 = 0;
      base = 1;
      return;
    }
    while (!Object.prototype.hasOwnProperty.call(queue, ++base)) {
    }
  };
  limit = Math.abs(limit);
  return {
    hit: function hit(id) {
      var oldIndex = map3[id];
      var nuIndex = ++index2;
      queue[nuIndex] = id;
      map3[id] = nuIndex;
      if (!oldIndex) {
        ++size2;
        if (size2 <= limit)
          return void 0;
        id = queue[base];
        del(id);
        return id;
      }
      delete queue[oldIndex];
      if (base !== oldIndex)
        return void 0;
      while (!Object.prototype.hasOwnProperty.call(queue, ++base)) {
      }
      return void 0;
    },
    delete: del,
    clear: function clear() {
      size2 = index2 = 0;
      base = 1;
      queue = /* @__PURE__ */ Object.create(null);
      map3 = /* @__PURE__ */ Object.create(null);
    }
  };
}

// node_modules/mathjs/lib/esm/utils/function.js
function memoize(fn) {
  var {
    hasher: hasher2,
    limit
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  limit = limit == null ? Number.POSITIVE_INFINITY : limit;
  hasher2 = hasher2 == null ? JSON.stringify : hasher2;
  return function memoize2() {
    if (typeof memoize2.cache !== "object") {
      memoize2.cache = {
        values: /* @__PURE__ */ new Map(),
        lru: lruQueue(limit || Number.POSITIVE_INFINITY)
      };
    }
    var args = [];
    for (var i2 = 0; i2 < arguments.length; i2++) {
      args[i2] = arguments[i2];
    }
    var hash = hasher2(args);
    if (memoize2.cache.values.has(hash)) {
      memoize2.cache.lru.hit(hash);
      return memoize2.cache.values.get(hash);
    }
    var newVal = fn.apply(fn, args);
    memoize2.cache.values.set(hash, newVal);
    memoize2.cache.values.delete(memoize2.cache.lru.hit(hash));
    return newVal;
  };
}
function maxArgumentCount(fn) {
  return Object.keys(fn.signatures || {}).reduce(function(args, signature) {
    var count2 = (signature.match(/,/g) || []).length + 1;
    return Math.max(args, count2);
  }, -1);
}

// node_modules/mathjs/lib/esm/type/matrix/DenseMatrix.js
var name7 = "DenseMatrix";
var dependencies8 = ["Matrix"];
var createDenseMatrixClass = /* @__PURE__ */ factory(name7, dependencies8, (_ref) => {
  var {
    Matrix: Matrix2
  } = _ref;
  function DenseMatrix2(data, datatype) {
    if (!(this instanceof DenseMatrix2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (datatype && !isString(datatype)) {
      throw new Error("Invalid datatype: " + datatype);
    }
    if (isMatrix(data)) {
      if (data.type === "DenseMatrix") {
        this._data = clone(data._data);
        this._size = clone(data._size);
        this._datatype = datatype || data._datatype;
      } else {
        this._data = data.toArray();
        this._size = data.size();
        this._datatype = datatype || data._datatype;
      }
    } else if (data && isArray(data.data) && isArray(data.size)) {
      this._data = data.data;
      this._size = data.size;
      validate(this._data, this._size);
      this._datatype = datatype || data.datatype;
    } else if (isArray(data)) {
      this._data = preprocess(data);
      this._size = arraySize(this._data);
      validate(this._data, this._size);
      this._datatype = datatype;
    } else if (data) {
      throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
    } else {
      this._data = [];
      this._size = [0];
      this._datatype = datatype;
    }
  }
  DenseMatrix2.prototype = new Matrix2();
  DenseMatrix2.prototype.createDenseMatrix = function(data, datatype) {
    return new DenseMatrix2(data, datatype);
  };
  Object.defineProperty(DenseMatrix2, "name", {
    value: "DenseMatrix"
  });
  DenseMatrix2.prototype.constructor = DenseMatrix2;
  DenseMatrix2.prototype.type = "DenseMatrix";
  DenseMatrix2.prototype.isDenseMatrix = true;
  DenseMatrix2.prototype.getDataType = function() {
    return getArrayDataType(this._data, typeOf);
  };
  DenseMatrix2.prototype.storage = function() {
    return "dense";
  };
  DenseMatrix2.prototype.datatype = function() {
    return this._datatype;
  };
  DenseMatrix2.prototype.create = function(data, datatype) {
    return new DenseMatrix2(data, datatype);
  };
  DenseMatrix2.prototype.subset = function(index2, replacement, defaultValue) {
    switch (arguments.length) {
      case 1:
        return _get(this, index2);
      case 2:
      case 3:
        return _set(this, index2, replacement, defaultValue);
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  };
  DenseMatrix2.prototype.get = function(index2) {
    if (!isArray(index2)) {
      throw new TypeError("Array expected");
    }
    if (index2.length !== this._size.length) {
      throw new DimensionError(index2.length, this._size.length);
    }
    for (var x = 0; x < index2.length; x++) {
      validateIndex(index2[x], this._size[x]);
    }
    var data = this._data;
    for (var i2 = 0, ii = index2.length; i2 < ii; i2++) {
      var indexI = index2[i2];
      validateIndex(indexI, data.length);
      data = data[indexI];
    }
    return data;
  };
  DenseMatrix2.prototype.set = function(index2, value, defaultValue) {
    if (!isArray(index2)) {
      throw new TypeError("Array expected");
    }
    if (index2.length < this._size.length) {
      throw new DimensionError(index2.length, this._size.length, "<");
    }
    var i2, ii, indexI;
    var size2 = index2.map(function(i3) {
      return i3 + 1;
    });
    _fit(this, size2, defaultValue);
    var data = this._data;
    for (i2 = 0, ii = index2.length - 1; i2 < ii; i2++) {
      indexI = index2[i2];
      validateIndex(indexI, data.length);
      data = data[indexI];
    }
    indexI = index2[index2.length - 1];
    validateIndex(indexI, data.length);
    data[indexI] = value;
    return this;
  };
  function _get(matrix2, index2) {
    if (!isIndex(index2)) {
      throw new TypeError("Invalid index");
    }
    var isScalar = index2.isScalar();
    if (isScalar) {
      return matrix2.get(index2.min());
    } else {
      var size2 = index2.size();
      if (size2.length !== matrix2._size.length) {
        throw new DimensionError(size2.length, matrix2._size.length);
      }
      var min3 = index2.min();
      var max3 = index2.max();
      for (var i2 = 0, ii = matrix2._size.length; i2 < ii; i2++) {
        validateIndex(min3[i2], matrix2._size[i2]);
        validateIndex(max3[i2], matrix2._size[i2]);
      }
      return new DenseMatrix2(_getSubmatrix(matrix2._data, index2, size2.length, 0), matrix2._datatype);
    }
  }
  function _getSubmatrix(data, index2, dims, dim) {
    var last = dim === dims - 1;
    var range2 = index2.dimension(dim);
    if (last) {
      return range2.map(function(i2) {
        validateIndex(i2, data.length);
        return data[i2];
      }).valueOf();
    } else {
      return range2.map(function(i2) {
        validateIndex(i2, data.length);
        var child = data[i2];
        return _getSubmatrix(child, index2, dims, dim + 1);
      }).valueOf();
    }
  }
  function _set(matrix2, index2, submatrix, defaultValue) {
    if (!index2 || index2.isIndex !== true) {
      throw new TypeError("Invalid index");
    }
    var iSize = index2.size();
    var isScalar = index2.isScalar();
    var sSize;
    if (isMatrix(submatrix)) {
      sSize = submatrix.size();
      submatrix = submatrix.valueOf();
    } else {
      sSize = arraySize(submatrix);
    }
    if (isScalar) {
      if (sSize.length !== 0) {
        throw new TypeError("Scalar expected");
      }
      matrix2.set(index2.min(), submatrix, defaultValue);
    } else {
      if (!deepStrictEqual(sSize, iSize)) {
        try {
          if (sSize.length === 0) {
            submatrix = broadcastTo([submatrix], iSize);
          } else {
            submatrix = broadcastTo(submatrix, iSize);
          }
          sSize = arraySize(submatrix);
        } catch (_unused) {
        }
      }
      if (iSize.length < matrix2._size.length) {
        throw new DimensionError(iSize.length, matrix2._size.length, "<");
      }
      if (sSize.length < iSize.length) {
        var i2 = 0;
        var outer = 0;
        while (iSize[i2] === 1 && sSize[i2] === 1) {
          i2++;
        }
        while (iSize[i2] === 1) {
          outer++;
          i2++;
        }
        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
      }
      if (!deepStrictEqual(iSize, sSize)) {
        throw new DimensionError(iSize, sSize, ">");
      }
      var size2 = index2.max().map(function(i3) {
        return i3 + 1;
      });
      _fit(matrix2, size2, defaultValue);
      var dims = iSize.length;
      var dim = 0;
      _setSubmatrix(matrix2._data, index2, submatrix, dims, dim);
    }
    return matrix2;
  }
  function _setSubmatrix(data, index2, submatrix, dims, dim) {
    var last = dim === dims - 1;
    var range2 = index2.dimension(dim);
    if (last) {
      range2.forEach(function(dataIndex, subIndex) {
        validateIndex(dataIndex);
        data[dataIndex] = submatrix[subIndex[0]];
      });
    } else {
      range2.forEach(function(dataIndex, subIndex) {
        validateIndex(dataIndex);
        _setSubmatrix(data[dataIndex], index2, submatrix[subIndex[0]], dims, dim + 1);
      });
    }
  }
  DenseMatrix2.prototype.resize = function(size2, defaultValue, copy) {
    if (!isCollection(size2)) {
      throw new TypeError("Array or Matrix expected");
    }
    var sizeArray = size2.valueOf().map((value) => {
      return Array.isArray(value) && value.length === 1 ? value[0] : value;
    });
    var m = copy ? this.clone() : this;
    return _resize2(m, sizeArray, defaultValue);
  };
  function _resize2(matrix2, size2, defaultValue) {
    if (size2.length === 0) {
      var v = matrix2._data;
      while (isArray(v)) {
        v = v[0];
      }
      return v;
    }
    matrix2._size = size2.slice(0);
    matrix2._data = resize(matrix2._data, matrix2._size, defaultValue);
    return matrix2;
  }
  DenseMatrix2.prototype.reshape = function(size2, copy) {
    var m = copy ? this.clone() : this;
    m._data = reshape(m._data, size2);
    var currentLength = m._size.reduce((length, size3) => length * size3);
    m._size = processSizesWildcard(size2, currentLength);
    return m;
  };
  function _fit(matrix2, size2, defaultValue) {
    var newSize = matrix2._size.slice(0);
    var changed = false;
    while (newSize.length < size2.length) {
      newSize.push(0);
      changed = true;
    }
    for (var i2 = 0, ii = size2.length; i2 < ii; i2++) {
      if (size2[i2] > newSize[i2]) {
        newSize[i2] = size2[i2];
        changed = true;
      }
    }
    if (changed) {
      _resize2(matrix2, newSize, defaultValue);
    }
  }
  DenseMatrix2.prototype.clone = function() {
    var m = new DenseMatrix2({
      data: clone(this._data),
      size: clone(this._size),
      datatype: this._datatype
    });
    return m;
  };
  DenseMatrix2.prototype.size = function() {
    return this._size.slice(0);
  };
  DenseMatrix2.prototype.map = function(callback) {
    var me = this;
    var args = maxArgumentCount(callback);
    var recurse = function recurse2(value, index2) {
      if (isArray(value)) {
        return value.map(function(child, i2) {
          return recurse2(child, index2.concat(i2));
        });
      } else {
        if (args === 1) {
          return callback(value);
        } else if (args === 2) {
          return callback(value, index2);
        } else {
          return callback(value, index2, me);
        }
      }
    };
    var data = recurse(this._data, []);
    var datatype = this._datatype !== void 0 ? getArrayDataType(data, typeOf) : void 0;
    return new DenseMatrix2(data, datatype);
  };
  DenseMatrix2.prototype.forEach = function(callback) {
    var me = this;
    var recurse = function recurse2(value, index2) {
      if (isArray(value)) {
        value.forEach(function(child, i2) {
          recurse2(child, index2.concat(i2));
        });
      } else {
        callback(value, index2, me);
      }
    };
    recurse(this._data, []);
  };
  DenseMatrix2.prototype[Symbol.iterator] = function* () {
    var recurse = function* recurse2(value, index2) {
      if (isArray(value)) {
        for (var i2 = 0; i2 < value.length; i2++) {
          yield* recurse2(value[i2], index2.concat(i2));
        }
      } else {
        yield {
          value,
          index: index2
        };
      }
    };
    yield* recurse(this._data, []);
  };
  DenseMatrix2.prototype.rows = function() {
    var result = [];
    var s = this.size();
    if (s.length !== 2) {
      throw new TypeError("Rows can only be returned for a 2D matrix.");
    }
    var data = this._data;
    for (var row2 of data) {
      result.push(new DenseMatrix2([row2], this._datatype));
    }
    return result;
  };
  DenseMatrix2.prototype.columns = function() {
    var _this = this;
    var result = [];
    var s = this.size();
    if (s.length !== 2) {
      throw new TypeError("Rows can only be returned for a 2D matrix.");
    }
    var data = this._data;
    var _loop = function _loop2(i3) {
      var col = data.map((row2) => [row2[i3]]);
      result.push(new DenseMatrix2(col, _this._datatype));
    };
    for (var i2 = 0; i2 < s[1]; i2++) {
      _loop(i2);
    }
    return result;
  };
  DenseMatrix2.prototype.toArray = function() {
    return clone(this._data);
  };
  DenseMatrix2.prototype.valueOf = function() {
    return this._data;
  };
  DenseMatrix2.prototype.format = function(options2) {
    return format3(this._data, options2);
  };
  DenseMatrix2.prototype.toString = function() {
    return format3(this._data);
  };
  DenseMatrix2.prototype.toJSON = function() {
    return {
      mathjs: "DenseMatrix",
      data: this._data,
      size: this._size,
      datatype: this._datatype
    };
  };
  DenseMatrix2.prototype.diagonal = function(k) {
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = this._size[0];
    var columns = this._size[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var data = [];
    for (var i2 = 0; i2 < n; i2++) {
      data[i2] = this._data[i2 + kSub][i2 + kSuper];
    }
    return new DenseMatrix2({
      data,
      size: [n],
      datatype: this._datatype
    });
  };
  DenseMatrix2.diagonal = function(size2, value, k, defaultValue) {
    if (!isArray(size2)) {
      throw new TypeError("Array expected, size parameter");
    }
    if (size2.length !== 2) {
      throw new Error("Only two dimensions matrix are supported");
    }
    size2 = size2.map(function(s) {
      if (isBigNumber(s)) {
        s = s.toNumber();
      }
      if (!isNumber(s) || !isInteger(s) || s < 1) {
        throw new Error("Size values must be positive integers");
      }
      return s;
    });
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = size2[0];
    var columns = size2[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var _value;
    if (isArray(value)) {
      if (value.length !== n) {
        throw new Error("Invalid value array length");
      }
      _value = function _value2(i2) {
        return value[i2];
      };
    } else if (isMatrix(value)) {
      var ms = value.size();
      if (ms.length !== 1 || ms[0] !== n) {
        throw new Error("Invalid matrix length");
      }
      _value = function _value2(i2) {
        return value.get([i2]);
      };
    } else {
      _value = function _value2() {
        return value;
      };
    }
    if (!defaultValue) {
      defaultValue = isBigNumber(_value(0)) ? _value(0).mul(0) : 0;
    }
    var data = [];
    if (size2.length > 0) {
      data = resize(data, size2, defaultValue);
      for (var d = 0; d < n; d++) {
        data[d + kSub][d + kSuper] = _value(d);
      }
    }
    return new DenseMatrix2({
      data,
      size: [rows, columns]
    });
  };
  DenseMatrix2.fromJSON = function(json) {
    return new DenseMatrix2(json);
  };
  DenseMatrix2.prototype.swapRows = function(i2, j) {
    if (!isNumber(i2) || !isInteger(i2) || !isNumber(j) || !isInteger(j)) {
      throw new Error("Row index must be positive integers");
    }
    if (this._size.length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(i2, this._size[0]);
    validateIndex(j, this._size[0]);
    DenseMatrix2._swapRows(i2, j, this._data);
    return this;
  };
  DenseMatrix2._swapRows = function(i2, j, data) {
    var vi = data[i2];
    data[i2] = data[j];
    data[j] = vi;
  };
  function preprocess(data) {
    if (isMatrix(data)) {
      return preprocess(data.valueOf());
    }
    if (isArray(data)) {
      return data.map(preprocess);
    }
    return data;
  }
  return DenseMatrix2;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/function/utils/clone.js
var name8 = "clone";
var dependencies9 = ["typed"];
var createClone = /* @__PURE__ */ factory(name8, dependencies9, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name8, {
    any: clone
  });
});

// node_modules/mathjs/lib/esm/utils/switch.js
function _switch(mat) {
  var I = mat.length;
  var J = mat[0].length;
  var i2, j;
  var ret = [];
  for (j = 0; j < J; j++) {
    var tmp = [];
    for (i2 = 0; i2 < I; i2++) {
      tmp.push(mat[i2][j]);
    }
    ret.push(tmp);
  }
  return ret;
}

// node_modules/mathjs/lib/esm/utils/collection.js
function containsCollections(array) {
  for (var i2 = 0; i2 < array.length; i2++) {
    if (isCollection(array[i2])) {
      return true;
    }
  }
  return false;
}
function deepForEach(array, callback) {
  if (isMatrix(array)) {
    array = array.valueOf();
  }
  for (var i2 = 0, ii = array.length; i2 < ii; i2++) {
    var value = array[i2];
    if (Array.isArray(value)) {
      deepForEach(value, callback);
    } else {
      callback(value);
    }
  }
}
function deepMap(array, callback, skipZeros) {
  if (array && typeof array.map === "function") {
    return array.map(function(x) {
      return deepMap(x, callback, skipZeros);
    });
  } else {
    return callback(array);
  }
}
function reduce(mat, dim, callback) {
  var size2 = Array.isArray(mat) ? arraySize(mat) : mat.size();
  if (dim < 0 || dim >= size2.length) {
    throw new IndexError(dim, size2.length);
  }
  if (isMatrix(mat)) {
    return mat.create(_reduce(mat.valueOf(), dim, callback));
  } else {
    return _reduce(mat, dim, callback);
  }
}
function _reduce(mat, dim, callback) {
  var i2, ret, val, tran;
  if (dim <= 0) {
    if (!Array.isArray(mat[0])) {
      val = mat[0];
      for (i2 = 1; i2 < mat.length; i2++) {
        val = callback(val, mat[i2]);
      }
      return val;
    } else {
      tran = _switch(mat);
      ret = [];
      for (i2 = 0; i2 < tran.length; i2++) {
        ret[i2] = _reduce(tran[i2], dim - 1, callback);
      }
      return ret;
    }
  } else {
    ret = [];
    for (i2 = 0; i2 < mat.length; i2++) {
      ret[i2] = _reduce(mat[i2], dim - 1, callback);
    }
    return ret;
  }
}
function scatter(a, j, w, x, u, mark, cindex, f, inverse, update2, value) {
  var avalues = a._values;
  var aindex = a._index;
  var aptr = a._ptr;
  var k, k0, k1, i2;
  if (x) {
    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
      i2 = aindex[k];
      if (w[i2] !== mark) {
        w[i2] = mark;
        cindex.push(i2);
        if (update2) {
          x[i2] = inverse ? f(avalues[k], value) : f(value, avalues[k]);
          u[i2] = mark;
        } else {
          x[i2] = avalues[k];
        }
      } else {
        x[i2] = inverse ? f(avalues[k], x[i2]) : f(x[i2], avalues[k]);
        u[i2] = mark;
      }
    }
  } else {
    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
      i2 = aindex[k];
      if (w[i2] !== mark) {
        w[i2] = mark;
        cindex.push(i2);
      } else {
        u[i2] = mark;
      }
    }
  }
}

// node_modules/mathjs/lib/esm/function/utils/isInteger.js
var name9 = "isInteger";
var dependencies10 = ["typed"];
var createIsInteger = /* @__PURE__ */ factory(name9, dependencies10, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name9, {
    number: isInteger,
    // TODO: what to do with isInteger(add(0.1, 0.2))  ?
    BigNumber: function BigNumber2(x) {
      return x.isInt();
    },
    bigint: function bigint2(x) {
      return true;
    },
    Fraction: function Fraction3(x) {
      return x.d === 1 && isFinite(x.n);
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});

// node_modules/mathjs/lib/esm/plain/number/arithmetic.js
var n1 = "number";
var n2 = "number, number";
function absNumber(a) {
  return Math.abs(a);
}
absNumber.signature = n1;
function addNumber(a, b) {
  return a + b;
}
addNumber.signature = n2;
function subtractNumber(a, b) {
  return a - b;
}
subtractNumber.signature = n2;
function multiplyNumber(a, b) {
  return a * b;
}
multiplyNumber.signature = n2;
function divideNumber(a, b) {
  return a / b;
}
divideNumber.signature = n2;
function unaryMinusNumber(x) {
  return -x;
}
unaryMinusNumber.signature = n1;
function unaryPlusNumber(x) {
  return x;
}
unaryPlusNumber.signature = n1;
function cbrtNumber(x) {
  return cbrt(x);
}
cbrtNumber.signature = n1;
function cubeNumber(x) {
  return x * x * x;
}
cubeNumber.signature = n1;
function expNumber(x) {
  return Math.exp(x);
}
expNumber.signature = n1;
function expm1Number(x) {
  return expm1(x);
}
expm1Number.signature = n1;
function gcdNumber(a, b) {
  if (!isInteger(a) || !isInteger(b)) {
    throw new Error("Parameters in function gcd must be integer numbers");
  }
  var r;
  while (b !== 0) {
    r = a % b;
    a = b;
    b = r;
  }
  return a < 0 ? -a : a;
}
gcdNumber.signature = n2;
function lcmNumber(a, b) {
  if (!isInteger(a) || !isInteger(b)) {
    throw new Error("Parameters in function lcm must be integer numbers");
  }
  if (a === 0 || b === 0) {
    return 0;
  }
  var t;
  var prod2 = a * b;
  while (b !== 0) {
    t = b;
    b = a % t;
    a = t;
  }
  return Math.abs(prod2 / a);
}
lcmNumber.signature = n2;
function logNumber(x, y) {
  if (y) {
    return Math.log(x) / Math.log(y);
  }
  return Math.log(x);
}
function log10Number(x) {
  return log10(x);
}
log10Number.signature = n1;
function log2Number(x) {
  return log2(x);
}
log2Number.signature = n1;
function log1pNumber(x) {
  return log1p(x);
}
log1pNumber.signature = n1;
function modNumber(x, y) {
  return y === 0 ? x : x - y * Math.floor(x / y);
}
modNumber.signature = n2;
function nthRootNumber(a) {
  var root = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
  var inv2 = root < 0;
  if (inv2) {
    root = -root;
  }
  if (root === 0) {
    throw new Error("Root must be non-zero");
  }
  if (a < 0 && Math.abs(root) % 2 !== 1) {
    throw new Error("Root must be odd when a is negative.");
  }
  if (a === 0) {
    return inv2 ? Infinity : 0;
  }
  if (!isFinite(a)) {
    return inv2 ? 0 : a;
  }
  var x = Math.pow(Math.abs(a), 1 / root);
  x = a < 0 ? -x : x;
  return inv2 ? 1 / x : x;
}
function signNumber(x) {
  return sign(x);
}
signNumber.signature = n1;
function sqrtNumber(x) {
  return Math.sqrt(x);
}
sqrtNumber.signature = n1;
function squareNumber(x) {
  return x * x;
}
squareNumber.signature = n1;
function xgcdNumber(a, b) {
  var t;
  var q;
  var r;
  var x = 0;
  var lastx = 1;
  var y = 1;
  var lasty = 0;
  if (!isInteger(a) || !isInteger(b)) {
    throw new Error("Parameters in function xgcd must be integer numbers");
  }
  while (b) {
    q = Math.floor(a / b);
    r = a - q * b;
    t = x;
    x = lastx - q * x;
    lastx = t;
    t = y;
    y = lasty - q * y;
    lasty = t;
    a = b;
    b = r;
  }
  var res;
  if (a < 0) {
    res = [-a, -lastx, -lasty];
  } else {
    res = [a, a ? lastx : 0, lasty];
  }
  return res;
}
xgcdNumber.signature = n2;
function powNumber(x, y) {
  if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
    return 0;
  }
  return Math.pow(x, y);
}
powNumber.signature = n2;
function roundNumber(value) {
  var decimals = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  if (!isInteger(decimals) || decimals < 0 || decimals > 15) {
    throw new Error("Number of decimals in function round must be an integer from 0 to 15 inclusive");
  }
  return parseFloat(toFixed(value, decimals));
}
function normNumber(x) {
  return Math.abs(x);
}
normNumber.signature = n1;

// node_modules/mathjs/lib/esm/plain/number/bitwise.js
var n12 = "number";
var n22 = "number, number";
function bitAndNumber(x, y) {
  if (!isInteger(x) || !isInteger(y)) {
    throw new Error("Integers expected in function bitAnd");
  }
  return x & y;
}
bitAndNumber.signature = n22;
function bitNotNumber(x) {
  if (!isInteger(x)) {
    throw new Error("Integer expected in function bitNot");
  }
  return ~x;
}
bitNotNumber.signature = n12;
function bitOrNumber(x, y) {
  if (!isInteger(x) || !isInteger(y)) {
    throw new Error("Integers expected in function bitOr");
  }
  return x | y;
}
bitOrNumber.signature = n22;
function bitXorNumber(x, y) {
  if (!isInteger(x) || !isInteger(y)) {
    throw new Error("Integers expected in function bitXor");
  }
  return x ^ y;
}
bitXorNumber.signature = n22;
function leftShiftNumber(x, y) {
  if (!isInteger(x) || !isInteger(y)) {
    throw new Error("Integers expected in function leftShift");
  }
  return x << y;
}
leftShiftNumber.signature = n22;
function rightArithShiftNumber(x, y) {
  if (!isInteger(x) || !isInteger(y)) {
    throw new Error("Integers expected in function rightArithShift");
  }
  return x >> y;
}
rightArithShiftNumber.signature = n22;
function rightLogShiftNumber(x, y) {
  if (!isInteger(x) || !isInteger(y)) {
    throw new Error("Integers expected in function rightLogShift");
  }
  return x >>> y;
}
rightLogShiftNumber.signature = n22;

// node_modules/mathjs/lib/esm/utils/product.js
function product2(i2, n) {
  if (n < i2) {
    return 1;
  }
  if (n === i2) {
    return n;
  }
  var half = n + i2 >> 1;
  return product2(i2, half) * product2(half + 1, n);
}

// node_modules/mathjs/lib/esm/plain/number/combinations.js
function combinationsNumber(n, k) {
  if (!isInteger(n) || n < 0) {
    throw new TypeError("Positive integer value expected in function combinations");
  }
  if (!isInteger(k) || k < 0) {
    throw new TypeError("Positive integer value expected in function combinations");
  }
  if (k > n) {
    throw new TypeError("k must be less than or equal to n");
  }
  var nMinusk = n - k;
  var answer = 1;
  var firstnumerator = k < nMinusk ? nMinusk + 1 : k + 1;
  var nextdivisor = 2;
  var lastdivisor = k < nMinusk ? k : nMinusk;
  for (var nextnumerator = firstnumerator; nextnumerator <= n; ++nextnumerator) {
    answer *= nextnumerator;
    while (nextdivisor <= lastdivisor && answer % nextdivisor === 0) {
      answer /= nextdivisor;
      ++nextdivisor;
    }
  }
  if (nextdivisor <= lastdivisor) {
    answer /= product2(nextdivisor, lastdivisor);
  }
  return answer;
}
combinationsNumber.signature = "number, number";

// node_modules/mathjs/lib/esm/plain/number/constants.js
var pi = Math.PI;
var tau = 2 * Math.PI;
var e = Math.E;
var phi = 1.618033988749895;

// node_modules/mathjs/lib/esm/plain/number/logical.js
var n13 = "number";
var n23 = "number, number";
function notNumber(x) {
  return !x;
}
notNumber.signature = n13;
function orNumber(x, y) {
  return !!(x || y);
}
orNumber.signature = n23;
function xorNumber(x, y) {
  return !!x !== !!y;
}
xorNumber.signature = n23;
function andNumber(x, y) {
  return !!(x && y);
}
andNumber.signature = n23;

// node_modules/mathjs/lib/esm/plain/number/probability.js
function gammaNumber(n) {
  var x;
  if (isInteger(n)) {
    if (n <= 0) {
      return isFinite(n) ? Infinity : NaN;
    }
    if (n > 171) {
      return Infinity;
    }
    return product2(1, n - 1);
  }
  if (n < 0.5) {
    return Math.PI / (Math.sin(Math.PI * n) * gammaNumber(1 - n));
  }
  if (n >= 171.35) {
    return Infinity;
  }
  if (n > 85) {
    var twoN = n * n;
    var threeN = twoN * n;
    var fourN = threeN * n;
    var fiveN = fourN * n;
    return Math.sqrt(2 * Math.PI / n) * Math.pow(n / Math.E, n) * (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) - 571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) + 5246819 / (75246796800 * fiveN * n));
  }
  --n;
  x = gammaP[0];
  for (var i2 = 1; i2 < gammaP.length; ++i2) {
    x += gammaP[i2] / (n + i2);
  }
  var t = n + gammaG + 0.5;
  return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
}
gammaNumber.signature = "number";
var gammaG = 4.7421875;
var gammaP = [0.9999999999999971, 57.15623566586292, -59.59796035547549, 14.136097974741746, -0.4919138160976202, 3399464998481189e-20, 4652362892704858e-20, -9837447530487956e-20, 1580887032249125e-19, -21026444172410488e-20, 21743961811521265e-20, -1643181065367639e-19, 8441822398385275e-20, -26190838401581408e-21, 36899182659531625e-22];
var lnSqrt2PI = 0.9189385332046728;
var lgammaG = 5;
var lgammaN = 7;
var lgammaSeries = [1.000000000190015, 76.18009172947146, -86.50532032941678, 24.01409824083091, -1.231739572450155, 0.001208650973866179, -5395239384953e-18];
function lgammaNumber(n) {
  if (n < 0)
    return NaN;
  if (n === 0)
    return Infinity;
  if (!isFinite(n))
    return n;
  if (n < 0.5) {
    return Math.log(Math.PI / Math.sin(Math.PI * n)) - lgammaNumber(1 - n);
  }
  n = n - 1;
  var base = n + lgammaG + 0.5;
  var sum3 = lgammaSeries[0];
  for (var i2 = lgammaN - 1; i2 >= 1; i2--) {
    sum3 += lgammaSeries[i2] / (n + i2);
  }
  return lnSqrt2PI + (n + 0.5) * Math.log(base) - base + Math.log(sum3);
}
lgammaNumber.signature = "number";

// node_modules/mathjs/lib/esm/plain/number/trigonometry.js
var n14 = "number";
var n24 = "number, number";
function acosNumber(x) {
  return Math.acos(x);
}
acosNumber.signature = n14;
function acoshNumber(x) {
  return acosh(x);
}
acoshNumber.signature = n14;
function acotNumber(x) {
  return Math.atan(1 / x);
}
acotNumber.signature = n14;
function acothNumber(x) {
  return isFinite(x) ? (Math.log((x + 1) / x) + Math.log(x / (x - 1))) / 2 : 0;
}
acothNumber.signature = n14;
function acscNumber(x) {
  return Math.asin(1 / x);
}
acscNumber.signature = n14;
function acschNumber(x) {
  var xInv = 1 / x;
  return Math.log(xInv + Math.sqrt(xInv * xInv + 1));
}
acschNumber.signature = n14;
function asecNumber(x) {
  return Math.acos(1 / x);
}
asecNumber.signature = n14;
function asechNumber(x) {
  var xInv = 1 / x;
  var ret = Math.sqrt(xInv * xInv - 1);
  return Math.log(ret + xInv);
}
asechNumber.signature = n14;
function asinNumber(x) {
  return Math.asin(x);
}
asinNumber.signature = n14;
function asinhNumber(x) {
  return asinh(x);
}
asinhNumber.signature = n14;
function atanNumber(x) {
  return Math.atan(x);
}
atanNumber.signature = n14;
function atan2Number(y, x) {
  return Math.atan2(y, x);
}
atan2Number.signature = n24;
function atanhNumber(x) {
  return atanh(x);
}
atanhNumber.signature = n14;
function cosNumber(x) {
  return Math.cos(x);
}
cosNumber.signature = n14;
function coshNumber(x) {
  return cosh(x);
}
coshNumber.signature = n14;
function cotNumber(x) {
  return 1 / Math.tan(x);
}
cotNumber.signature = n14;
function cothNumber(x) {
  var e3 = Math.exp(2 * x);
  return (e3 + 1) / (e3 - 1);
}
cothNumber.signature = n14;
function cscNumber(x) {
  return 1 / Math.sin(x);
}
cscNumber.signature = n14;
function cschNumber(x) {
  if (x === 0) {
    return Number.POSITIVE_INFINITY;
  } else {
    return Math.abs(2 / (Math.exp(x) - Math.exp(-x))) * sign(x);
  }
}
cschNumber.signature = n14;
function secNumber(x) {
  return 1 / Math.cos(x);
}
secNumber.signature = n14;
function sechNumber(x) {
  return 2 / (Math.exp(x) + Math.exp(-x));
}
sechNumber.signature = n14;
function sinNumber(x) {
  return Math.sin(x);
}
sinNumber.signature = n14;
function sinhNumber(x) {
  return sinh(x);
}
sinhNumber.signature = n14;
function tanNumber(x) {
  return Math.tan(x);
}
tanNumber.signature = n14;
function tanhNumber(x) {
  return tanh(x);
}
tanhNumber.signature = n14;

// node_modules/mathjs/lib/esm/plain/number/utils.js
var n15 = "number";
function isIntegerNumber(x) {
  return isInteger(x);
}
isIntegerNumber.signature = n15;
function isNegativeNumber(x) {
  return x < 0;
}
isNegativeNumber.signature = n15;
function isPositiveNumber(x) {
  return x > 0;
}
isPositiveNumber.signature = n15;
function isZeroNumber(x) {
  return x === 0;
}
isZeroNumber.signature = n15;
function isNaNNumber(x) {
  return Number.isNaN(x);
}
isNaNNumber.signature = n15;

// node_modules/mathjs/lib/esm/utils/bignumber/nearlyEqual.js
function nearlyEqual2(a, b) {
  var relTol = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1e-9;
  var absTol = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
  if (relTol <= 0) {
    throw new Error("Relative tolerance must be greater than 0");
  }
  if (absTol < 0) {
    throw new Error("Absolute tolerance must be at least 0");
  }
  if (a.isNaN() || b.isNaN()) {
    return false;
  }
  if (!a.isFinite() || !b.isFinite()) {
    return a.eq(b);
  }
  if (a.eq(b)) {
    return true;
  }
  return a.minus(b).abs().lte(a.constructor.max(a.constructor.max(a.abs(), b.abs()).mul(relTol), absTol));
}

// node_modules/mathjs/lib/esm/function/utils/isNegative.js
var name10 = "isNegative";
var dependencies11 = ["typed", "config"];
var createIsNegative = /* @__PURE__ */ factory(name10, dependencies11, (_ref) => {
  var {
    typed: typed3,
    config: config5
  } = _ref;
  return typed3(name10, {
    number: (x) => nearlyEqual(x, 0, config5.relTol, config5.absTol) ? false : isNegativeNumber(x),
    BigNumber: (x) => nearlyEqual2(x, new x.constructor(0), config5.relTol, config5.absTol) ? false : x.isNeg() && !x.isZero() && !x.isNaN(),
    bigint: (x) => x < 0n,
    Fraction: (x) => x.s < 0,
    // It's enough to decide on the sign
    Unit: typed3.referToSelf((self2) => (x) => typed3.find(self2, x.valueType())(x.value)),
    "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});

// node_modules/mathjs/lib/esm/function/utils/isNumeric.js
var name11 = "isNumeric";
var dependencies12 = ["typed"];
var createIsNumeric = /* @__PURE__ */ factory(name11, dependencies12, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name11, {
    "number | BigNumber | bigint | Fraction | boolean": () => true,
    "Complex | Unit | string | null | undefined | Node": () => false,
    "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});

// node_modules/mathjs/lib/esm/function/utils/hasNumericValue.js
var name12 = "hasNumericValue";
var dependencies13 = ["typed", "isNumeric"];
var createHasNumericValue = /* @__PURE__ */ factory(name12, dependencies13, (_ref) => {
  var {
    typed: typed3,
    isNumeric: isNumeric2
  } = _ref;
  return typed3(name12, {
    boolean: () => true,
    string: function string2(x) {
      return x.trim().length > 0 && !isNaN(Number(x));
    },
    any: function any(x) {
      return isNumeric2(x);
    }
  });
});

// node_modules/mathjs/lib/esm/function/utils/isPositive.js
var name13 = "isPositive";
var dependencies14 = ["typed", "config"];
var createIsPositive = /* @__PURE__ */ factory(name13, dependencies14, (_ref) => {
  var {
    typed: typed3,
    config: config5
  } = _ref;
  return typed3(name13, {
    number: (x) => nearlyEqual(x, 0, config5.relTol, config5.absTol) ? false : isPositiveNumber(x),
    BigNumber: (x) => nearlyEqual2(x, new x.constructor(0), config5.relTol, config5.absTol) ? false : !x.isNeg() && !x.isZero() && !x.isNaN(),
    bigint: (x) => x > 0n,
    Fraction: (x) => x.s > 0 && x.n > 0,
    Unit: typed3.referToSelf((self2) => (x) => typed3.find(self2, x.valueType())(x.value)),
    "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});

// node_modules/mathjs/lib/esm/function/utils/isZero.js
var name14 = "isZero";
var dependencies15 = ["typed", "equalScalar"];
var createIsZero = /* @__PURE__ */ factory(name14, dependencies15, (_ref) => {
  var {
    typed: typed3,
    equalScalar: equalScalar2
  } = _ref;
  return typed3(name14, {
    "number | BigNumber | Complex | Fraction": (x) => equalScalar2(x, 0),
    bigint: (x) => x === 0n,
    Unit: typed3.referToSelf((self2) => (x) => typed3.find(self2, x.valueType())(x.value)),
    "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});

// node_modules/mathjs/lib/esm/function/utils/isNaN.js
var name15 = "isNaN";
var dependencies16 = ["typed"];
var createIsNaN = /* @__PURE__ */ factory(name15, dependencies16, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name15, {
    number: isNaNNumber,
    BigNumber: function BigNumber2(x) {
      return x.isNaN();
    },
    bigint: function bigint2(x) {
      return false;
    },
    Fraction: function Fraction3(x) {
      return false;
    },
    Complex: function Complex3(x) {
      return x.isNaN();
    },
    Unit: function Unit2(x) {
      return Number.isNaN(x.value);
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});

// node_modules/mathjs/lib/esm/function/utils/typeOf.js
var name16 = "typeOf";
var dependencies17 = ["typed"];
var createTypeOf = /* @__PURE__ */ factory(name16, dependencies17, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name16, {
    any: typeOf
  });
});

// node_modules/mathjs/lib/esm/utils/complex.js
function complexEquals(x, y, relTol, absTol) {
  return nearlyEqual(x.re, y.re, relTol, absTol) && nearlyEqual(x.im, y.im, relTol, absTol);
}

// node_modules/mathjs/lib/esm/function/relational/compareUnits.js
var createCompareUnits = /* @__PURE__ */ factory("compareUnits", ["typed"], (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return {
    "Unit, Unit": typed3.referToSelf((self2) => (x, y) => {
      if (!x.equalBase(y)) {
        throw new Error("Cannot compare units with different base");
      }
      return typed3.find(self2, [x.valueType(), y.valueType()])(x.value, y.value);
    })
  };
});

// node_modules/mathjs/lib/esm/function/relational/equalScalar.js
var name17 = "equalScalar";
var dependencies18 = ["typed", "config"];
var createEqualScalar = /* @__PURE__ */ factory(name17, dependencies18, (_ref) => {
  var {
    typed: typed3,
    config: config5
  } = _ref;
  var compareUnits = createCompareUnits({
    typed: typed3
  });
  return typed3(name17, {
    "boolean, boolean": function booleanBoolean(x, y) {
      return x === y;
    },
    "number, number": function numberNumber(x, y) {
      return nearlyEqual(x, y, config5.relTol, config5.absTol);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.eq(y) || nearlyEqual2(x, y, config5.relTol, config5.absTol);
    },
    "bigint, bigint": function bigintBigint(x, y) {
      return x === y;
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return x.equals(y);
    },
    "Complex, Complex": function ComplexComplex(x, y) {
      return complexEquals(x, y, config5.relTol, config5.absTol);
    }
  }, compareUnits);
});
var createEqualScalarNumber = factory(name17, ["typed", "config"], (_ref2) => {
  var {
    typed: typed3,
    config: config5
  } = _ref2;
  return typed3(name17, {
    "number, number": function numberNumber(x, y) {
      return nearlyEqual(x, y, config5.relTol, config5.absTol);
    }
  });
});

// node_modules/mathjs/lib/esm/type/matrix/SparseMatrix.js
var name18 = "SparseMatrix";
var dependencies19 = ["typed", "equalScalar", "Matrix"];
var createSparseMatrixClass = /* @__PURE__ */ factory(name18, dependencies19, (_ref) => {
  var {
    typed: typed3,
    equalScalar: equalScalar2,
    Matrix: Matrix2
  } = _ref;
  function SparseMatrix2(data, datatype) {
    if (!(this instanceof SparseMatrix2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (datatype && !isString(datatype)) {
      throw new Error("Invalid datatype: " + datatype);
    }
    if (isMatrix(data)) {
      _createFromMatrix(this, data, datatype);
    } else if (data && isArray(data.index) && isArray(data.ptr) && isArray(data.size)) {
      this._values = data.values;
      this._index = data.index;
      this._ptr = data.ptr;
      this._size = data.size;
      this._datatype = datatype || data.datatype;
    } else if (isArray(data)) {
      _createFromArray(this, data, datatype);
    } else if (data) {
      throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
    } else {
      this._values = [];
      this._index = [];
      this._ptr = [0];
      this._size = [0, 0];
      this._datatype = datatype;
    }
  }
  function _createFromMatrix(matrix2, source, datatype) {
    if (source.type === "SparseMatrix") {
      matrix2._values = source._values ? clone(source._values) : void 0;
      matrix2._index = clone(source._index);
      matrix2._ptr = clone(source._ptr);
      matrix2._size = clone(source._size);
      matrix2._datatype = datatype || source._datatype;
    } else {
      _createFromArray(matrix2, source.valueOf(), datatype || source._datatype);
    }
  }
  function _createFromArray(matrix2, data, datatype) {
    matrix2._values = [];
    matrix2._index = [];
    matrix2._ptr = [];
    matrix2._datatype = datatype;
    var rows = data.length;
    var columns = 0;
    var eq = equalScalar2;
    var zero = 0;
    if (isString(datatype)) {
      eq = typed3.find(equalScalar2, [datatype, datatype]) || equalScalar2;
      zero = typed3.convert(0, datatype);
    }
    if (rows > 0) {
      var j = 0;
      do {
        matrix2._ptr.push(matrix2._index.length);
        for (var i2 = 0; i2 < rows; i2++) {
          var row2 = data[i2];
          if (isArray(row2)) {
            if (j === 0 && columns < row2.length) {
              columns = row2.length;
            }
            if (j < row2.length) {
              var v = row2[j];
              if (!eq(v, zero)) {
                matrix2._values.push(v);
                matrix2._index.push(i2);
              }
            }
          } else {
            if (j === 0 && columns < 1) {
              columns = 1;
            }
            if (!eq(row2, zero)) {
              matrix2._values.push(row2);
              matrix2._index.push(i2);
            }
          }
        }
        j++;
      } while (j < columns);
    }
    matrix2._ptr.push(matrix2._index.length);
    matrix2._size = [rows, columns];
  }
  SparseMatrix2.prototype = new Matrix2();
  SparseMatrix2.prototype.createSparseMatrix = function(data, datatype) {
    return new SparseMatrix2(data, datatype);
  };
  Object.defineProperty(SparseMatrix2, "name", {
    value: "SparseMatrix"
  });
  SparseMatrix2.prototype.constructor = SparseMatrix2;
  SparseMatrix2.prototype.type = "SparseMatrix";
  SparseMatrix2.prototype.isSparseMatrix = true;
  SparseMatrix2.prototype.getDataType = function() {
    return getArrayDataType(this._values, typeOf);
  };
  SparseMatrix2.prototype.storage = function() {
    return "sparse";
  };
  SparseMatrix2.prototype.datatype = function() {
    return this._datatype;
  };
  SparseMatrix2.prototype.create = function(data, datatype) {
    return new SparseMatrix2(data, datatype);
  };
  SparseMatrix2.prototype.density = function() {
    var rows = this._size[0];
    var columns = this._size[1];
    return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;
  };
  SparseMatrix2.prototype.subset = function(index2, replacement, defaultValue) {
    if (!this._values) {
      throw new Error("Cannot invoke subset on a Pattern only matrix");
    }
    switch (arguments.length) {
      case 1:
        return _getsubset(this, index2);
      case 2:
      case 3:
        return _setsubset(this, index2, replacement, defaultValue);
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  };
  function _getsubset(matrix2, idx) {
    if (!isIndex(idx)) {
      throw new TypeError("Invalid index");
    }
    var isScalar = idx.isScalar();
    if (isScalar) {
      return matrix2.get(idx.min());
    }
    var size2 = idx.size();
    if (size2.length !== matrix2._size.length) {
      throw new DimensionError(size2.length, matrix2._size.length);
    }
    var i2, ii, k, kk;
    var min3 = idx.min();
    var max3 = idx.max();
    for (i2 = 0, ii = matrix2._size.length; i2 < ii; i2++) {
      validateIndex(min3[i2], matrix2._size[i2]);
      validateIndex(max3[i2], matrix2._size[i2]);
    }
    var mvalues = matrix2._values;
    var mindex = matrix2._index;
    var mptr = matrix2._ptr;
    var rows = idx.dimension(0);
    var columns = idx.dimension(1);
    var w = [];
    var pv = [];
    rows.forEach(function(i3, r) {
      pv[i3] = r[0];
      w[i3] = true;
    });
    var values = mvalues ? [] : void 0;
    var index2 = [];
    var ptr = [];
    columns.forEach(function(j) {
      ptr.push(index2.length);
      for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {
        i2 = mindex[k];
        if (w[i2] === true) {
          index2.push(pv[i2]);
          if (values) {
            values.push(mvalues[k]);
          }
        }
      }
    });
    ptr.push(index2.length);
    return new SparseMatrix2({
      values,
      index: index2,
      ptr,
      size: size2,
      datatype: matrix2._datatype
    });
  }
  function _setsubset(matrix2, index2, submatrix, defaultValue) {
    if (!index2 || index2.isIndex !== true) {
      throw new TypeError("Invalid index");
    }
    var iSize = index2.size();
    var isScalar = index2.isScalar();
    var sSize;
    if (isMatrix(submatrix)) {
      sSize = submatrix.size();
      submatrix = submatrix.toArray();
    } else {
      sSize = arraySize(submatrix);
    }
    if (isScalar) {
      if (sSize.length !== 0) {
        throw new TypeError("Scalar expected");
      }
      matrix2.set(index2.min(), submatrix, defaultValue);
    } else {
      if (iSize.length !== 1 && iSize.length !== 2) {
        throw new DimensionError(iSize.length, matrix2._size.length, "<");
      }
      if (sSize.length < iSize.length) {
        var i2 = 0;
        var outer = 0;
        while (iSize[i2] === 1 && sSize[i2] === 1) {
          i2++;
        }
        while (iSize[i2] === 1) {
          outer++;
          i2++;
        }
        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
      }
      if (!deepStrictEqual(iSize, sSize)) {
        throw new DimensionError(iSize, sSize, ">");
      }
      if (iSize.length === 1) {
        var range2 = index2.dimension(0);
        range2.forEach(function(dataIndex, subIndex) {
          validateIndex(dataIndex);
          matrix2.set([dataIndex, 0], submatrix[subIndex[0]], defaultValue);
        });
      } else {
        var firstDimensionRange = index2.dimension(0);
        var secondDimensionRange = index2.dimension(1);
        firstDimensionRange.forEach(function(firstDataIndex, firstSubIndex) {
          validateIndex(firstDataIndex);
          secondDimensionRange.forEach(function(secondDataIndex, secondSubIndex) {
            validateIndex(secondDataIndex);
            matrix2.set([firstDataIndex, secondDataIndex], submatrix[firstSubIndex[0]][secondSubIndex[0]], defaultValue);
          });
        });
      }
    }
    return matrix2;
  }
  SparseMatrix2.prototype.get = function(index2) {
    if (!isArray(index2)) {
      throw new TypeError("Array expected");
    }
    if (index2.length !== this._size.length) {
      throw new DimensionError(index2.length, this._size.length);
    }
    if (!this._values) {
      throw new Error("Cannot invoke get on a Pattern only matrix");
    }
    var i2 = index2[0];
    var j = index2[1];
    validateIndex(i2, this._size[0]);
    validateIndex(j, this._size[1]);
    var k = _getValueIndex(i2, this._ptr[j], this._ptr[j + 1], this._index);
    if (k < this._ptr[j + 1] && this._index[k] === i2) {
      return this._values[k];
    }
    return 0;
  };
  SparseMatrix2.prototype.set = function(index2, v, defaultValue) {
    if (!isArray(index2)) {
      throw new TypeError("Array expected");
    }
    if (index2.length !== this._size.length) {
      throw new DimensionError(index2.length, this._size.length);
    }
    if (!this._values) {
      throw new Error("Cannot invoke set on a Pattern only matrix");
    }
    var i2 = index2[0];
    var j = index2[1];
    var rows = this._size[0];
    var columns = this._size[1];
    var eq = equalScalar2;
    var zero = 0;
    if (isString(this._datatype)) {
      eq = typed3.find(equalScalar2, [this._datatype, this._datatype]) || equalScalar2;
      zero = typed3.convert(0, this._datatype);
    }
    if (i2 > rows - 1 || j > columns - 1) {
      _resize2(this, Math.max(i2 + 1, rows), Math.max(j + 1, columns), defaultValue);
      rows = this._size[0];
      columns = this._size[1];
    }
    validateIndex(i2, rows);
    validateIndex(j, columns);
    var k = _getValueIndex(i2, this._ptr[j], this._ptr[j + 1], this._index);
    if (k < this._ptr[j + 1] && this._index[k] === i2) {
      if (!eq(v, zero)) {
        this._values[k] = v;
      } else {
        _remove(k, j, this._values, this._index, this._ptr);
      }
    } else {
      if (!eq(v, zero)) {
        _insert(k, i2, j, v, this._values, this._index, this._ptr);
      }
    }
    return this;
  };
  function _getValueIndex(i2, top, bottom, index2) {
    if (bottom - top === 0) {
      return bottom;
    }
    for (var r = top; r < bottom; r++) {
      if (index2[r] === i2) {
        return r;
      }
    }
    return top;
  }
  function _remove(k, j, values, index2, ptr) {
    values.splice(k, 1);
    index2.splice(k, 1);
    for (var x = j + 1; x < ptr.length; x++) {
      ptr[x]--;
    }
  }
  function _insert(k, i2, j, v, values, index2, ptr) {
    values.splice(k, 0, v);
    index2.splice(k, 0, i2);
    for (var x = j + 1; x < ptr.length; x++) {
      ptr[x]++;
    }
  }
  SparseMatrix2.prototype.resize = function(size2, defaultValue, copy) {
    if (!isCollection(size2)) {
      throw new TypeError("Array or Matrix expected");
    }
    var sizeArray = size2.valueOf().map((value) => {
      return Array.isArray(value) && value.length === 1 ? value[0] : value;
    });
    if (sizeArray.length !== 2) {
      throw new Error("Only two dimensions matrix are supported");
    }
    sizeArray.forEach(function(value) {
      if (!isNumber(value) || !isInteger(value) || value < 0) {
        throw new TypeError("Invalid size, must contain positive integers (size: " + format3(sizeArray) + ")");
      }
    });
    var m = copy ? this.clone() : this;
    return _resize2(m, sizeArray[0], sizeArray[1], defaultValue);
  };
  function _resize2(matrix2, rows, columns, defaultValue) {
    var value = defaultValue || 0;
    var eq = equalScalar2;
    var zero = 0;
    if (isString(matrix2._datatype)) {
      eq = typed3.find(equalScalar2, [matrix2._datatype, matrix2._datatype]) || equalScalar2;
      zero = typed3.convert(0, matrix2._datatype);
      value = typed3.convert(value, matrix2._datatype);
    }
    var ins = !eq(value, zero);
    var r = matrix2._size[0];
    var c = matrix2._size[1];
    var i2, j, k;
    if (columns > c) {
      for (j = c; j < columns; j++) {
        matrix2._ptr[j] = matrix2._values.length;
        if (ins) {
          for (i2 = 0; i2 < r; i2++) {
            matrix2._values.push(value);
            matrix2._index.push(i2);
          }
        }
      }
      matrix2._ptr[columns] = matrix2._values.length;
    } else if (columns < c) {
      matrix2._ptr.splice(columns + 1, c - columns);
      matrix2._values.splice(matrix2._ptr[columns], matrix2._values.length);
      matrix2._index.splice(matrix2._ptr[columns], matrix2._index.length);
    }
    c = columns;
    if (rows > r) {
      if (ins) {
        var n = 0;
        for (j = 0; j < c; j++) {
          matrix2._ptr[j] = matrix2._ptr[j] + n;
          k = matrix2._ptr[j + 1] + n;
          var p = 0;
          for (i2 = r; i2 < rows; i2++, p++) {
            matrix2._values.splice(k + p, 0, value);
            matrix2._index.splice(k + p, 0, i2);
            n++;
          }
        }
        matrix2._ptr[c] = matrix2._values.length;
      }
    } else if (rows < r) {
      var d = 0;
      for (j = 0; j < c; j++) {
        matrix2._ptr[j] = matrix2._ptr[j] - d;
        var k0 = matrix2._ptr[j];
        var k1 = matrix2._ptr[j + 1] - d;
        for (k = k0; k < k1; k++) {
          i2 = matrix2._index[k];
          if (i2 > rows - 1) {
            matrix2._values.splice(k, 1);
            matrix2._index.splice(k, 1);
            d++;
          }
        }
      }
      matrix2._ptr[j] = matrix2._values.length;
    }
    matrix2._size[0] = rows;
    matrix2._size[1] = columns;
    return matrix2;
  }
  SparseMatrix2.prototype.reshape = function(sizes, copy) {
    if (!isArray(sizes)) {
      throw new TypeError("Array expected");
    }
    if (sizes.length !== 2) {
      throw new Error("Sparse matrices can only be reshaped in two dimensions");
    }
    sizes.forEach(function(value) {
      if (!isNumber(value) || !isInteger(value) || value <= -2 || value === 0) {
        throw new TypeError("Invalid size, must contain positive integers or -1 (size: " + format3(sizes) + ")");
      }
    });
    var currentLength = this._size[0] * this._size[1];
    sizes = processSizesWildcard(sizes, currentLength);
    var newLength = sizes[0] * sizes[1];
    if (currentLength !== newLength) {
      throw new Error("Reshaping sparse matrix will result in the wrong number of elements");
    }
    var m = copy ? this.clone() : this;
    if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {
      return m;
    }
    var colIndex = [];
    for (var i2 = 0; i2 < m._ptr.length; i2++) {
      for (var j = 0; j < m._ptr[i2 + 1] - m._ptr[i2]; j++) {
        colIndex.push(i2);
      }
    }
    var values = m._values.slice();
    var rowIndex = m._index.slice();
    for (var _i = 0; _i < m._index.length; _i++) {
      var r1 = rowIndex[_i];
      var c1 = colIndex[_i];
      var flat = r1 * m._size[1] + c1;
      colIndex[_i] = flat % sizes[1];
      rowIndex[_i] = Math.floor(flat / sizes[1]);
    }
    m._values.length = 0;
    m._index.length = 0;
    m._ptr.length = sizes[1] + 1;
    m._size = sizes.slice();
    for (var _i2 = 0; _i2 < m._ptr.length; _i2++) {
      m._ptr[_i2] = 0;
    }
    for (var h = 0; h < values.length; h++) {
      var _i3 = rowIndex[h];
      var _j = colIndex[h];
      var v = values[h];
      var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);
      _insert(k, _i3, _j, v, m._values, m._index, m._ptr);
    }
    return m;
  };
  SparseMatrix2.prototype.clone = function() {
    var m = new SparseMatrix2({
      values: this._values ? clone(this._values) : void 0,
      index: clone(this._index),
      ptr: clone(this._ptr),
      size: clone(this._size),
      datatype: this._datatype
    });
    return m;
  };
  SparseMatrix2.prototype.size = function() {
    return this._size.slice(0);
  };
  SparseMatrix2.prototype.map = function(callback, skipZeros) {
    if (!this._values) {
      throw new Error("Cannot invoke map on a Pattern only matrix");
    }
    var me = this;
    var rows = this._size[0];
    var columns = this._size[1];
    var args = maxArgumentCount(callback);
    var invoke = function invoke2(v, i2, j) {
      if (args === 1)
        return callback(v);
      if (args === 2)
        return callback(v, [i2, j]);
      return callback(v, [i2, j], me);
    };
    return _map3(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);
  };
  function _map3(matrix2, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {
    var values = [];
    var index2 = [];
    var ptr = [];
    var eq = equalScalar2;
    var zero = 0;
    if (isString(matrix2._datatype)) {
      eq = typed3.find(equalScalar2, [matrix2._datatype, matrix2._datatype]) || equalScalar2;
      zero = typed3.convert(0, matrix2._datatype);
    }
    var invoke = function invoke2(v, x, y) {
      v = callback(v, x, y);
      if (!eq(v, zero)) {
        values.push(v);
        index2.push(x);
      }
    };
    for (var j = minColumn; j <= maxColumn; j++) {
      ptr.push(values.length);
      var k0 = matrix2._ptr[j];
      var k1 = matrix2._ptr[j + 1];
      if (skipZeros) {
        for (var k = k0; k < k1; k++) {
          var i2 = matrix2._index[k];
          if (i2 >= minRow && i2 <= maxRow) {
            invoke(matrix2._values[k], i2 - minRow, j - minColumn);
          }
        }
      } else {
        var _values = {};
        for (var _k = k0; _k < k1; _k++) {
          var _i4 = matrix2._index[_k];
          _values[_i4] = matrix2._values[_k];
        }
        for (var _i5 = minRow; _i5 <= maxRow; _i5++) {
          var value = _i5 in _values ? _values[_i5] : 0;
          invoke(value, _i5 - minRow, j - minColumn);
        }
      }
    }
    ptr.push(values.length);
    return new SparseMatrix2({
      values,
      index: index2,
      ptr,
      size: [maxRow - minRow + 1, maxColumn - minColumn + 1]
    });
  }
  SparseMatrix2.prototype.forEach = function(callback, skipZeros) {
    if (!this._values) {
      throw new Error("Cannot invoke forEach on a Pattern only matrix");
    }
    var me = this;
    var rows = this._size[0];
    var columns = this._size[1];
    for (var j = 0; j < columns; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      if (skipZeros) {
        for (var k = k0; k < k1; k++) {
          var i2 = this._index[k];
          callback(this._values[k], [i2, j], me);
        }
      } else {
        var values = {};
        for (var _k2 = k0; _k2 < k1; _k2++) {
          var _i6 = this._index[_k2];
          values[_i6] = this._values[_k2];
        }
        for (var _i7 = 0; _i7 < rows; _i7++) {
          var value = _i7 in values ? values[_i7] : 0;
          callback(value, [_i7, j], me);
        }
      }
    }
  };
  SparseMatrix2.prototype[Symbol.iterator] = function* () {
    if (!this._values) {
      throw new Error("Cannot iterate a Pattern only matrix");
    }
    var columns = this._size[1];
    for (var j = 0; j < columns; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      for (var k = k0; k < k1; k++) {
        var i2 = this._index[k];
        yield {
          value: this._values[k],
          index: [i2, j]
        };
      }
    }
  };
  SparseMatrix2.prototype.toArray = function() {
    return _toArray(this._values, this._index, this._ptr, this._size, true);
  };
  SparseMatrix2.prototype.valueOf = function() {
    return _toArray(this._values, this._index, this._ptr, this._size, false);
  };
  function _toArray(values, index2, ptr, size2, copy) {
    var rows = size2[0];
    var columns = size2[1];
    var a = [];
    var i2, j;
    for (i2 = 0; i2 < rows; i2++) {
      a[i2] = [];
      for (j = 0; j < columns; j++) {
        a[i2][j] = 0;
      }
    }
    for (j = 0; j < columns; j++) {
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      for (var k = k0; k < k1; k++) {
        i2 = index2[k];
        a[i2][j] = values ? copy ? clone(values[k]) : values[k] : 1;
      }
    }
    return a;
  }
  SparseMatrix2.prototype.format = function(options2) {
    var rows = this._size[0];
    var columns = this._size[1];
    var density = this.density();
    var str = "Sparse Matrix [" + format3(rows, options2) + " x " + format3(columns, options2) + "] density: " + format3(density, options2) + "\n";
    for (var j = 0; j < columns; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      for (var k = k0; k < k1; k++) {
        var i2 = this._index[k];
        str += "\n    (" + format3(i2, options2) + ", " + format3(j, options2) + ") ==> " + (this._values ? format3(this._values[k], options2) : "X");
      }
    }
    return str;
  };
  SparseMatrix2.prototype.toString = function() {
    return format3(this.toArray());
  };
  SparseMatrix2.prototype.toJSON = function() {
    return {
      mathjs: "SparseMatrix",
      values: this._values,
      index: this._index,
      ptr: this._ptr,
      size: this._size,
      datatype: this._datatype
    };
  };
  SparseMatrix2.prototype.diagonal = function(k) {
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = this._size[0];
    var columns = this._size[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var values = [];
    var index2 = [];
    var ptr = [];
    ptr[0] = 0;
    for (var j = kSuper; j < columns && values.length < n; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      for (var x = k0; x < k1; x++) {
        var i2 = this._index[x];
        if (i2 === j - kSuper + kSub) {
          values.push(this._values[x]);
          index2[values.length - 1] = i2 - kSub;
          break;
        }
      }
    }
    ptr.push(values.length);
    return new SparseMatrix2({
      values,
      index: index2,
      ptr,
      size: [n, 1]
    });
  };
  SparseMatrix2.fromJSON = function(json) {
    return new SparseMatrix2(json);
  };
  SparseMatrix2.diagonal = function(size2, value, k, defaultValue, datatype) {
    if (!isArray(size2)) {
      throw new TypeError("Array expected, size parameter");
    }
    if (size2.length !== 2) {
      throw new Error("Only two dimensions matrix are supported");
    }
    size2 = size2.map(function(s) {
      if (isBigNumber(s)) {
        s = s.toNumber();
      }
      if (!isNumber(s) || !isInteger(s) || s < 1) {
        throw new Error("Size values must be positive integers");
      }
      return s;
    });
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var eq = equalScalar2;
    var zero = 0;
    if (isString(datatype)) {
      eq = typed3.find(equalScalar2, [datatype, datatype]) || equalScalar2;
      zero = typed3.convert(0, datatype);
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = size2[0];
    var columns = size2[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var _value;
    if (isArray(value)) {
      if (value.length !== n) {
        throw new Error("Invalid value array length");
      }
      _value = function _value2(i3) {
        return value[i3];
      };
    } else if (isMatrix(value)) {
      var ms = value.size();
      if (ms.length !== 1 || ms[0] !== n) {
        throw new Error("Invalid matrix length");
      }
      _value = function _value2(i3) {
        return value.get([i3]);
      };
    } else {
      _value = function _value2() {
        return value;
      };
    }
    var values = [];
    var index2 = [];
    var ptr = [];
    for (var j = 0; j < columns; j++) {
      ptr.push(values.length);
      var i2 = j - kSuper;
      if (i2 >= 0 && i2 < n) {
        var v = _value(i2);
        if (!eq(v, zero)) {
          index2.push(i2 + kSub);
          values.push(v);
        }
      }
    }
    ptr.push(values.length);
    return new SparseMatrix2({
      values,
      index: index2,
      ptr,
      size: [rows, columns]
    });
  };
  SparseMatrix2.prototype.swapRows = function(i2, j) {
    if (!isNumber(i2) || !isInteger(i2) || !isNumber(j) || !isInteger(j)) {
      throw new Error("Row index must be positive integers");
    }
    if (this._size.length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(i2, this._size[0]);
    validateIndex(j, this._size[0]);
    SparseMatrix2._swapRows(i2, j, this._size[1], this._values, this._index, this._ptr);
    return this;
  };
  SparseMatrix2._forEachRow = function(j, values, index2, ptr, callback) {
    var k0 = ptr[j];
    var k1 = ptr[j + 1];
    for (var k = k0; k < k1; k++) {
      callback(index2[k], values[k]);
    }
  };
  SparseMatrix2._swapRows = function(x, y, columns, values, index2, ptr) {
    for (var j = 0; j < columns; j++) {
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      var kx = _getValueIndex(x, k0, k1, index2);
      var ky = _getValueIndex(y, k0, k1, index2);
      if (kx < k1 && ky < k1 && index2[kx] === x && index2[ky] === y) {
        if (values) {
          var v = values[kx];
          values[kx] = values[ky];
          values[ky] = v;
        }
        continue;
      }
      if (kx < k1 && index2[kx] === x && (ky >= k1 || index2[ky] !== y)) {
        var vx = values ? values[kx] : void 0;
        index2.splice(ky, 0, y);
        if (values) {
          values.splice(ky, 0, vx);
        }
        index2.splice(ky <= kx ? kx + 1 : kx, 1);
        if (values) {
          values.splice(ky <= kx ? kx + 1 : kx, 1);
        }
        continue;
      }
      if (ky < k1 && index2[ky] === y && (kx >= k1 || index2[kx] !== x)) {
        var vy = values ? values[ky] : void 0;
        index2.splice(kx, 0, x);
        if (values) {
          values.splice(kx, 0, vy);
        }
        index2.splice(kx <= ky ? ky + 1 : ky, 1);
        if (values) {
          values.splice(kx <= ky ? ky + 1 : ky, 1);
        }
      }
    }
  };
  return SparseMatrix2;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/number.js
var name19 = "number";
var dependencies20 = ["typed"];
function getNonDecimalNumberParts(input) {
  var nonDecimalWithRadixMatch = input.match(/(0[box])([0-9a-fA-F]*)\.([0-9a-fA-F]*)/);
  if (nonDecimalWithRadixMatch) {
    var radix = {
      "0b": 2,
      "0o": 8,
      "0x": 16
    }[nonDecimalWithRadixMatch[1]];
    var integerPart = nonDecimalWithRadixMatch[2];
    var fractionalPart = nonDecimalWithRadixMatch[3];
    return {
      input,
      radix,
      integerPart,
      fractionalPart
    };
  } else {
    return null;
  }
}
function makeNumberFromNonDecimalParts(parts) {
  var n = parseInt(parts.integerPart, parts.radix);
  var f = 0;
  for (var i2 = 0; i2 < parts.fractionalPart.length; i2++) {
    var digitValue = parseInt(parts.fractionalPart[i2], parts.radix);
    f += digitValue / Math.pow(parts.radix, i2 + 1);
  }
  var result = n + f;
  if (isNaN(result)) {
    throw new SyntaxError('String "' + parts.input + '" is not a valid number');
  }
  return result;
}
var createNumber = /* @__PURE__ */ factory(name19, dependencies20, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  var number2 = typed3("number", {
    "": function _() {
      return 0;
    },
    number: function number3(x) {
      return x;
    },
    string: function string2(x) {
      if (x === "NaN")
        return NaN;
      var nonDecimalNumberParts = getNonDecimalNumberParts(x);
      if (nonDecimalNumberParts) {
        return makeNumberFromNonDecimalParts(nonDecimalNumberParts);
      }
      var size2 = 0;
      var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
      if (wordSizeSuffixMatch) {
        size2 = Number(wordSizeSuffixMatch[2]);
        x = wordSizeSuffixMatch[1];
      }
      var num = Number(x);
      if (isNaN(num)) {
        throw new SyntaxError('String "' + x + '" is not a valid number');
      }
      if (wordSizeSuffixMatch) {
        if (num > 2 ** size2 - 1) {
          throw new SyntaxError('String "'.concat(x, '" is out of range'));
        }
        if (num >= 2 ** (size2 - 1)) {
          num = num - 2 ** size2;
        }
      }
      return num;
    },
    BigNumber: function BigNumber2(x) {
      return x.toNumber();
    },
    bigint: function bigint2(x) {
      return Number(x);
    },
    Fraction: function Fraction3(x) {
      return x.valueOf();
    },
    Unit: typed3.referToSelf((self2) => (x) => {
      var clone5 = x.clone();
      clone5.value = self2(x.value);
      return clone5;
    }),
    null: function _null2(x) {
      return 0;
    },
    "Unit, string | Unit": function UnitStringUnit(unit2, valuelessUnit) {
      return unit2.toNumber(valuelessUnit);
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
  });
  number2.fromJSON = function(json) {
    return parseFloat(json.value);
  };
  return number2;
});

// node_modules/mathjs/lib/esm/type/bigint.js
var name20 = "bigint";
var dependencies21 = ["typed"];
var createBigint = /* @__PURE__ */ factory(name20, dependencies21, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  var bigint2 = typed3("bigint", {
    "": function _() {
      return 0n;
    },
    bigint: function bigint3(x) {
      return x;
    },
    number: function number2(x) {
      return BigInt(x.toFixed());
    },
    BigNumber: function BigNumber2(x) {
      return BigInt(x.round().toString());
    },
    Fraction: function Fraction3(x) {
      return BigInt(x.valueOf().toFixed());
    },
    "string | boolean": function stringBoolean(x) {
      return BigInt(x);
    },
    null: function _null2(x) {
      return 0n;
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
  });
  bigint2.fromJSON = function(json) {
    return BigInt(json.value);
  };
  return bigint2;
});

// node_modules/mathjs/lib/esm/type/string.js
var name21 = "string";
var dependencies22 = ["typed"];
var createString = /* @__PURE__ */ factory(name21, dependencies22, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name21, {
    "": function _() {
      return "";
    },
    number: format,
    null: function _null2(x) {
      return "null";
    },
    boolean: function boolean2(x) {
      return x + "";
    },
    string: function string2(x) {
      return x;
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2)),
    any: function any(x) {
      return String(x);
    }
  });
});

// node_modules/mathjs/lib/esm/type/boolean.js
var name22 = "boolean";
var dependencies23 = ["typed"];
var createBoolean = /* @__PURE__ */ factory(name22, dependencies23, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name22, {
    "": function _() {
      return false;
    },
    boolean: function boolean2(x) {
      return x;
    },
    number: function number2(x) {
      return !!x;
    },
    null: function _null2(x) {
      return false;
    },
    BigNumber: function BigNumber2(x) {
      return !x.isZero();
    },
    string: function string2(x) {
      var lcase = x.toLowerCase();
      if (lcase === "true") {
        return true;
      } else if (lcase === "false") {
        return false;
      }
      var num = Number(x);
      if (x !== "" && !isNaN(num)) {
        return !!num;
      }
      throw new Error('Cannot convert "' + x + '" to a boolean');
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});

// node_modules/mathjs/lib/esm/type/bignumber/function/bignumber.js
var name23 = "bignumber";
var dependencies24 = ["typed", "BigNumber"];
var createBignumber = /* @__PURE__ */ factory(name23, dependencies24, (_ref) => {
  var {
    typed: typed3,
    BigNumber: BigNumber2
  } = _ref;
  return typed3("bignumber", {
    "": function _() {
      return new BigNumber2(0);
    },
    number: function number2(x) {
      return new BigNumber2(x + "");
    },
    string: function string2(x) {
      var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
      if (wordSizeSuffixMatch) {
        var size2 = wordSizeSuffixMatch[2];
        var n = BigNumber2(wordSizeSuffixMatch[1]);
        var twoPowSize = new BigNumber2(2).pow(Number(size2));
        if (n.gt(twoPowSize.sub(1))) {
          throw new SyntaxError('String "'.concat(x, '" is out of range'));
        }
        var twoPowSizeSubOne = new BigNumber2(2).pow(Number(size2) - 1);
        if (n.gte(twoPowSizeSubOne)) {
          return n.sub(twoPowSize);
        } else {
          return n;
        }
      }
      return new BigNumber2(x);
    },
    BigNumber: function BigNumber3(x) {
      return x;
    },
    bigint: function bigint2(x) {
      return new BigNumber2(x.toString());
    },
    Unit: typed3.referToSelf((self2) => (x) => {
      var clone5 = x.clone();
      clone5.value = self2(x.value);
      return clone5;
    }),
    Fraction: function Fraction3(x) {
      return new BigNumber2(x.n).div(x.d).times(x.s);
    },
    null: function _null2(x) {
      return new BigNumber2(0);
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});

// node_modules/mathjs/lib/esm/type/complex/function/complex.js
var name24 = "complex";
var dependencies25 = ["typed", "Complex"];
var createComplex = /* @__PURE__ */ factory(name24, dependencies25, (_ref) => {
  var {
    typed: typed3,
    Complex: Complex3
  } = _ref;
  return typed3("complex", {
    "": function _() {
      return Complex3.ZERO;
    },
    number: function number2(x) {
      return new Complex3(x, 0);
    },
    "number, number": function numberNumber(re2, im2) {
      return new Complex3(re2, im2);
    },
    // TODO: this signature should be redundant
    "BigNumber, BigNumber": function BigNumberBigNumber(re2, im2) {
      return new Complex3(re2.toNumber(), im2.toNumber());
    },
    Fraction: function Fraction3(x) {
      return new Complex3(x.valueOf(), 0);
    },
    Complex: function Complex4(x) {
      return x.clone();
    },
    string: function string2(x) {
      return Complex3(x);
    },
    null: function _null2(x) {
      return Complex3(0);
    },
    Object: function Object2(x) {
      if ("re" in x && "im" in x) {
        return new Complex3(x.re, x.im);
      }
      if ("r" in x && "phi" in x || "abs" in x && "arg" in x) {
        return new Complex3(x);
      }
      throw new Error("Expected object with properties (re and im) or (r and phi) or (abs and arg)");
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});

// node_modules/mathjs/lib/esm/type/fraction/function/fraction.js
var name25 = "fraction";
var dependencies26 = ["typed", "Fraction"];
var createFraction = /* @__PURE__ */ factory(name25, dependencies26, (_ref) => {
  var {
    typed: typed3,
    Fraction: Fraction3
  } = _ref;
  return typed3("fraction", {
    number: function number2(x) {
      if (!isFinite(x) || isNaN(x)) {
        throw new Error(x + " cannot be represented as a fraction");
      }
      return new Fraction3(x);
    },
    string: function string2(x) {
      return new Fraction3(x);
    },
    "number, number": function numberNumber(numerator, denominator) {
      return new Fraction3(numerator, denominator);
    },
    null: function _null2(x) {
      return new Fraction3(0);
    },
    BigNumber: function BigNumber2(x) {
      return new Fraction3(x.toString());
    },
    bigint: function bigint2(x) {
      return new Fraction3(x.toString());
    },
    Fraction: function Fraction4(x) {
      return x;
    },
    Unit: typed3.referToSelf((self2) => (x) => {
      var clone5 = x.clone();
      clone5.value = self2(x.value);
      return clone5;
    }),
    Object: function Object2(x) {
      return new Fraction3(x);
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});

// node_modules/mathjs/lib/esm/type/matrix/function/matrix.js
var name26 = "matrix";
var dependencies27 = ["typed", "Matrix", "DenseMatrix", "SparseMatrix"];
var createMatrix = /* @__PURE__ */ factory(name26, dependencies27, (_ref) => {
  var {
    typed: typed3,
    Matrix: Matrix2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  return typed3(name26, {
    "": function _() {
      return _create([]);
    },
    string: function string2(format5) {
      return _create([], format5);
    },
    "string, string": function stringString(format5, datatype) {
      return _create([], format5, datatype);
    },
    Array: function Array2(data) {
      return _create(data);
    },
    Matrix: function Matrix3(data) {
      return _create(data, data.storage());
    },
    "Array | Matrix, string": _create,
    "Array | Matrix, string, string": _create
  });
  function _create(data, format5, datatype) {
    if (format5 === "dense" || format5 === "default" || format5 === void 0) {
      return new DenseMatrix2(data, datatype);
    }
    if (format5 === "sparse") {
      return new SparseMatrix2(data, datatype);
    }
    throw new TypeError("Unknown matrix type " + JSON.stringify(format5) + ".");
  }
});

// node_modules/mathjs/lib/esm/function/matrix/matrixFromFunction.js
var name27 = "matrixFromFunction";
var dependencies28 = ["typed", "matrix", "isZero"];
var createMatrixFromFunction = /* @__PURE__ */ factory(name27, dependencies28, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    isZero: isZero2
  } = _ref;
  return typed3(name27, {
    "Array | Matrix, function, string, string": function ArrayMatrixFunctionStringString(size2, fn, format5, datatype) {
      return _create(size2, fn, format5, datatype);
    },
    "Array | Matrix, function, string": function ArrayMatrixFunctionString(size2, fn, format5) {
      return _create(size2, fn, format5);
    },
    "Matrix, function": function MatrixFunction(size2, fn) {
      return _create(size2, fn, "dense");
    },
    "Array, function": function ArrayFunction(size2, fn) {
      return _create(size2, fn, "dense").toArray();
    },
    "Array | Matrix, string, function": function ArrayMatrixStringFunction(size2, format5, fn) {
      return _create(size2, fn, format5);
    },
    "Array | Matrix, string, string, function": function ArrayMatrixStringStringFunction(size2, format5, datatype, fn) {
      return _create(size2, fn, format5, datatype);
    }
  });
  function _create(size2, fn, format5, datatype) {
    var m;
    if (datatype !== void 0) {
      m = matrix2(format5, datatype);
    } else {
      m = matrix2(format5);
    }
    m.resize(size2);
    m.forEach(function(_, index2) {
      var val = fn(index2);
      if (isZero2(val))
        return;
      m.set(index2, val);
    });
    return m;
  }
});

// node_modules/mathjs/lib/esm/function/matrix/matrixFromRows.js
var name28 = "matrixFromRows";
var dependencies29 = ["typed", "matrix", "flatten", "size"];
var createMatrixFromRows = /* @__PURE__ */ factory(name28, dependencies29, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    flatten: flatten3,
    size: size2
  } = _ref;
  return typed3(name28, {
    "...Array": function Array2(arr) {
      return _createArray(arr);
    },
    "...Matrix": function Matrix2(arr) {
      return matrix2(_createArray(arr.map((m) => m.toArray())));
    }
    // TODO implement this properly for SparseMatrix
  });
  function _createArray(arr) {
    if (arr.length === 0)
      throw new TypeError("At least one row is needed to construct a matrix.");
    var N = checkVectorTypeAndReturnLength(arr[0]);
    var result = [];
    for (var row2 of arr) {
      var rowLength = checkVectorTypeAndReturnLength(row2);
      if (rowLength !== N) {
        throw new TypeError("The vectors had different length: " + (N | 0) + " \u2260 " + (rowLength | 0));
      }
      result.push(flatten3(row2));
    }
    return result;
  }
  function checkVectorTypeAndReturnLength(vec) {
    var s = size2(vec);
    if (s.length === 1) {
      return s[0];
    } else if (s.length === 2) {
      if (s[0] === 1) {
        return s[1];
      } else if (s[1] === 1) {
        return s[0];
      } else {
        throw new TypeError("At least one of the arguments is not a vector.");
      }
    } else {
      throw new TypeError("Only one- or two-dimensional vectors are supported.");
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/matrixFromColumns.js
var name29 = "matrixFromColumns";
var dependencies30 = ["typed", "matrix", "flatten", "size"];
var createMatrixFromColumns = /* @__PURE__ */ factory(name29, dependencies30, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    flatten: flatten3,
    size: size2
  } = _ref;
  return typed3(name29, {
    "...Array": function Array2(arr) {
      return _createArray(arr);
    },
    "...Matrix": function Matrix2(arr) {
      return matrix2(_createArray(arr.map((m) => m.toArray())));
    }
    // TODO implement this properly for SparseMatrix
  });
  function _createArray(arr) {
    if (arr.length === 0)
      throw new TypeError("At least one column is needed to construct a matrix.");
    var N = checkVectorTypeAndReturnLength(arr[0]);
    var result = [];
    for (var i2 = 0; i2 < N; i2++) {
      result[i2] = [];
    }
    for (var col of arr) {
      var colLength = checkVectorTypeAndReturnLength(col);
      if (colLength !== N) {
        throw new TypeError("The vectors had different length: " + (N | 0) + " \u2260 " + (colLength | 0));
      }
      var f = flatten3(col);
      for (var _i = 0; _i < N; _i++) {
        result[_i].push(f[_i]);
      }
    }
    return result;
  }
  function checkVectorTypeAndReturnLength(vec) {
    var s = size2(vec);
    if (s.length === 1) {
      return s[0];
    } else if (s.length === 2) {
      if (s[0] === 1) {
        return s[1];
      } else if (s[1] === 1) {
        return s[0];
      } else {
        throw new TypeError("At least one of the arguments is not a vector.");
      }
    } else {
      throw new TypeError("Only one- or two-dimensional vectors are supported.");
    }
  }
});

// node_modules/mathjs/lib/esm/type/unit/function/splitUnit.js
var name30 = "splitUnit";
var dependencies31 = ["typed"];
var createSplitUnit = /* @__PURE__ */ factory(name30, dependencies31, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name30, {
    "Unit, Array": function UnitArray(unit2, parts) {
      return unit2.splitUnit(parts);
    }
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/unaryMinus.js
var name31 = "unaryMinus";
var dependencies32 = ["typed"];
var createUnaryMinus = /* @__PURE__ */ factory(name31, dependencies32, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name31, {
    number: unaryMinusNumber,
    "Complex | BigNumber | Fraction": (x) => x.neg(),
    bigint: (x) => -x,
    Unit: typed3.referToSelf((self2) => (x) => {
      var res = x.clone();
      res.value = typed3.find(self2, res.valueType())(x.value);
      return res;
    }),
    // deep map collection, skip zeros since unaryMinus(0) = 0
    "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2, true))
    // TODO: add support for string
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/unaryPlus.js
var name32 = "unaryPlus";
var dependencies33 = ["typed", "config", "numeric"];
var createUnaryPlus = /* @__PURE__ */ factory(name32, dependencies33, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    numeric: numeric3
  } = _ref;
  return typed3(name32, {
    number: unaryPlusNumber,
    Complex: function Complex3(x) {
      return x;
    },
    BigNumber: function BigNumber2(x) {
      return x;
    },
    bigint: function bigint2(x) {
      return x;
    },
    Fraction: function Fraction3(x) {
      return x;
    },
    Unit: function Unit2(x) {
      return x.clone();
    },
    // deep map collection, skip zeros since unaryPlus(0) = 0
    "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2, true)),
    boolean: function boolean2(x) {
      return numeric3(x ? 1 : 0, config5.number);
    },
    string: function string2(x) {
      return numeric3(x, safeNumberType(x, config5));
    }
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/abs.js
var name33 = "abs";
var dependencies34 = ["typed"];
var createAbs = /* @__PURE__ */ factory(name33, dependencies34, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name33, {
    number: absNumber,
    "Complex | BigNumber | Fraction | Unit": (x) => x.abs(),
    bigint: (x) => x < 0n ? -x : x,
    // deep map collection, skip zeros since abs(0) = 0
    "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2, true))
  });
});

// node_modules/mathjs/lib/esm/function/matrix/apply.js
var name34 = "apply";
var dependencies35 = ["typed", "isInteger"];
var createApply = /* @__PURE__ */ factory(name34, dependencies35, (_ref) => {
  var {
    typed: typed3,
    isInteger: isInteger3
  } = _ref;
  return typed3(name34, {
    "Array | Matrix, number | BigNumber, function": function ArrayMatrixNumberBigNumberFunction(mat, dim, callback) {
      if (!isInteger3(dim)) {
        throw new TypeError("Integer number expected for dimension");
      }
      var size2 = Array.isArray(mat) ? arraySize(mat) : mat.size();
      if (dim < 0 || dim >= size2.length) {
        throw new IndexError(dim, size2.length);
      }
      if (isMatrix(mat)) {
        return mat.create(_apply(mat.valueOf(), dim, callback));
      } else {
        return _apply(mat, dim, callback);
      }
    }
  });
});
function _apply(mat, dim, callback) {
  var i2, ret, tran;
  if (dim <= 0) {
    if (!Array.isArray(mat[0])) {
      return callback(mat);
    } else {
      tran = _switch2(mat);
      ret = [];
      for (i2 = 0; i2 < tran.length; i2++) {
        ret[i2] = _apply(tran[i2], dim - 1, callback);
      }
      return ret;
    }
  } else {
    ret = [];
    for (i2 = 0; i2 < mat.length; i2++) {
      ret[i2] = _apply(mat[i2], dim - 1, callback);
    }
    return ret;
  }
}
function _switch2(mat) {
  var I = mat.length;
  var J = mat[0].length;
  var i2, j;
  var ret = [];
  for (j = 0; j < J; j++) {
    var tmp = [];
    for (i2 = 0; i2 < I; i2++) {
      tmp.push(mat[i2][j]);
    }
    ret.push(tmp);
  }
  return ret;
}

// node_modules/mathjs/lib/esm/function/arithmetic/addScalar.js
var name35 = "addScalar";
var dependencies36 = ["typed"];
var createAddScalar = /* @__PURE__ */ factory(name35, dependencies36, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name35, {
    "number, number": addNumber,
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.add(y);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.plus(y);
    },
    "bigint, bigint": function bigintBigint(x, y) {
      return x + y;
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return x.add(y);
    },
    "Unit, Unit": typed3.referToSelf((self2) => (x, y) => {
      if (x.value === null || x.value === void 0) {
        throw new Error("Parameter x contains a unit with undefined value");
      }
      if (y.value === null || y.value === void 0) {
        throw new Error("Parameter y contains a unit with undefined value");
      }
      if (!x.equalBase(y))
        throw new Error("Units do not match");
      var res = x.clone();
      res.value = typed3.find(self2, [res.valueType(), y.valueType()])(res.value, y.value);
      res.fixPrefix = false;
      return res;
    })
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/subtractScalar.js
var name36 = "subtractScalar";
var dependencies37 = ["typed"];
var createSubtractScalar = /* @__PURE__ */ factory(name36, dependencies37, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name36, {
    "number, number": subtractNumber,
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.sub(y);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.minus(y);
    },
    "bigint, bigint": function bigintBigint(x, y) {
      return x - y;
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return x.sub(y);
    },
    "Unit, Unit": typed3.referToSelf((self2) => (x, y) => {
      if (x.value === null || x.value === void 0) {
        throw new Error("Parameter x contains a unit with undefined value");
      }
      if (y.value === null || y.value === void 0) {
        throw new Error("Parameter y contains a unit with undefined value");
      }
      if (!x.equalBase(y))
        throw new Error("Units do not match");
      var res = x.clone();
      res.value = typed3.find(self2, [res.valueType(), y.valueType()])(res.value, y.value);
      res.fixPrefix = false;
      return res;
    })
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/cbrt.js
var name37 = "cbrt";
var dependencies38 = ["config", "typed", "isNegative", "unaryMinus", "matrix", "Complex", "BigNumber", "Fraction"];
var createCbrt = /* @__PURE__ */ factory(name37, dependencies38, (_ref) => {
  var {
    config: config5,
    typed: typed3,
    isNegative: isNegative2,
    unaryMinus: unaryMinus2,
    matrix: matrix2,
    Complex: Complex3,
    BigNumber: BigNumber2,
    Fraction: Fraction3
  } = _ref;
  return typed3(name37, {
    number: cbrtNumber,
    // note: signature 'number, boolean' is also supported,
    //       created by typed as it knows how to convert number to Complex
    Complex: _cbrtComplex,
    "Complex, boolean": _cbrtComplex,
    BigNumber: function BigNumber3(x) {
      return x.cbrt();
    },
    Unit: _cbrtUnit
  });
  function _cbrtComplex(x, allRoots) {
    var arg3 = x.arg() / 3;
    var abs3 = x.abs();
    var principal = new Complex3(cbrtNumber(abs3), 0).mul(new Complex3(0, arg3).exp());
    if (allRoots) {
      var all = [principal, new Complex3(cbrtNumber(abs3), 0).mul(new Complex3(0, arg3 + Math.PI * 2 / 3).exp()), new Complex3(cbrtNumber(abs3), 0).mul(new Complex3(0, arg3 - Math.PI * 2 / 3).exp())];
      return config5.matrix === "Array" ? all : matrix2(all);
    } else {
      return principal;
    }
  }
  function _cbrtUnit(x) {
    if (x.value && isComplex(x.value)) {
      var result = x.clone();
      result.value = 1;
      result = result.pow(1 / 3);
      result.value = _cbrtComplex(x.value);
      return result;
    } else {
      var negate = isNegative2(x.value);
      if (negate) {
        x.value = unaryMinus2(x.value);
      }
      var third;
      if (isBigNumber(x.value)) {
        third = new BigNumber2(1).div(3);
      } else if (isFraction(x.value)) {
        third = new Fraction3(1, 3);
      } else {
        third = 1 / 3;
      }
      var _result = x.pow(third);
      if (negate) {
        _result.value = unaryMinus2(_result.value);
      }
      return _result;
    }
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js
var name38 = "matAlgo11xS0s";
var dependencies39 = ["typed", "equalScalar"];
var createMatAlgo11xS0s = /* @__PURE__ */ factory(name38, dependencies39, (_ref) => {
  var {
    typed: typed3,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo11xS0s(s, b, callback, inverse) {
    var avalues = s._values;
    var aindex = s._index;
    var aptr = s._ptr;
    var asize = s._size;
    var adt = s._datatype;
    if (!avalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string") {
      dt = adt;
      eq = typed3.find(equalScalar2, [dt, dt]);
      zero = typed3.convert(0, dt);
      b = typed3.convert(b, dt);
      cf = typed3.find(callback, [dt, dt]);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    for (var j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        var i2 = aindex[k];
        var v = inverse ? cf(b, avalues[k]) : cf(avalues[k], b);
        if (!eq(v, zero)) {
          cindex.push(i2);
          cvalues.push(v);
        }
      }
    }
    cptr[columns] = cindex.length;
    return s.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js
var name39 = "matAlgo12xSfs";
var dependencies40 = ["typed", "DenseMatrix"];
var createMatAlgo12xSfs = /* @__PURE__ */ factory(name39, dependencies40, (_ref) => {
  var {
    typed: typed3,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return function matAlgo12xSfs(s, b, callback, inverse) {
    var avalues = s._values;
    var aindex = s._index;
    var aptr = s._ptr;
    var asize = s._size;
    var adt = s._datatype;
    if (!avalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var cf = callback;
    if (typeof adt === "string") {
      dt = adt;
      b = typed3.convert(b, dt);
      cf = typed3.find(callback, [dt, dt]);
    }
    var cdata = [];
    var x = [];
    var w = [];
    for (var j = 0; j < columns; j++) {
      var mark = j + 1;
      for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        var r = aindex[k];
        x[r] = avalues[k];
        w[r] = mark;
      }
      for (var i2 = 0; i2 < rows; i2++) {
        if (j === 0) {
          cdata[i2] = [];
        }
        if (w[i2] === mark) {
          cdata[i2][j] = inverse ? cf(b, x[i2]) : cf(x[i2], b);
        } else {
          cdata[i2][j] = inverse ? cf(b, 0) : cf(0, b);
        }
      }
    }
    return new DenseMatrix2({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo14xDs.js
var name40 = "matAlgo14xDs";
var dependencies41 = ["typed"];
var createMatAlgo14xDs = /* @__PURE__ */ factory(name40, dependencies41, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return function matAlgo14xDs(a, b, callback, inverse) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    var dt;
    var cf = callback;
    if (typeof adt === "string") {
      dt = adt;
      b = typed3.convert(b, dt);
      cf = typed3.find(callback, [dt, dt]);
    }
    var cdata = asize.length > 0 ? _iterate(cf, 0, asize, asize[0], adata, b, inverse) : [];
    return a.createDenseMatrix({
      data: cdata,
      size: clone(asize),
      datatype: dt
    });
  };
  function _iterate(f, level, s, n, av, bv, inverse) {
    var cv = [];
    if (level === s.length - 1) {
      for (var i2 = 0; i2 < n; i2++) {
        cv[i2] = inverse ? f(bv, av[i2]) : f(av[i2], bv);
      }
    } else {
      for (var j = 0; j < n; j++) {
        cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv, inverse);
      }
    }
    return cv;
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/ceil.js
var name41 = "ceil";
var dependencies42 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix"];
var createCeilNumber = /* @__PURE__ */ factory(name41, ["typed", "config", "round"], (_ref) => {
  var {
    typed: typed3,
    config: config5,
    round: round3
  } = _ref;
  return typed3(name41, {
    number: function number2(x) {
      if (nearlyEqual(x, round3(x), config5.relTol, config5.absTol)) {
        return round3(x);
      } else {
        return Math.ceil(x);
      }
    },
    "number, number": function numberNumber(x, n) {
      if (nearlyEqual(x, round3(x, n), config5.relTol, config5.absTol)) {
        return round3(x, n);
      } else {
        var [number2, exponent] = "".concat(x, "e").split("e");
        var result = Math.ceil(Number("".concat(number2, "e").concat(Number(exponent) + n)));
        [number2, exponent] = "".concat(result, "e").split("e");
        return Number("".concat(number2, "e").concat(Number(exponent) - n));
      }
    }
  });
});
var createCeil = /* @__PURE__ */ factory(name41, dependencies42, (_ref2) => {
  var {
    typed: typed3,
    config: config5,
    round: round3,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros3,
    DenseMatrix: DenseMatrix2
  } = _ref2;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed3
  });
  var ceilNumber = createCeilNumber({
    typed: typed3,
    config: config5,
    round: round3
  });
  return typed3("ceil", {
    number: ceilNumber.signatures.number,
    "number,number": ceilNumber.signatures["number,number"],
    Complex: function Complex3(x) {
      return x.ceil();
    },
    "Complex, number": function ComplexNumber(x, n) {
      return x.ceil(n);
    },
    "Complex, BigNumber": function ComplexBigNumber(x, n) {
      return x.ceil(n.toNumber());
    },
    BigNumber: function BigNumber2(x) {
      if (nearlyEqual2(x, round3(x), config5.relTol, config5.absTol)) {
        return round3(x);
      } else {
        return x.ceil();
      }
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, n) {
      if (nearlyEqual2(x, round3(x, n), config5.relTol, config5.absTol)) {
        return round3(x, n);
      } else {
        return x.toDecimalPlaces(n.toNumber(), decimal_default.ROUND_CEIL);
      }
    },
    Fraction: function Fraction3(x) {
      return x.ceil();
    },
    "Fraction, number": function FractionNumber(x, n) {
      return x.ceil(n);
    },
    "Fraction, BigNumber": function FractionBigNumber(x, n) {
      return x.ceil(n.toNumber());
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x) => {
      return deepMap(x, self2, true);
    }),
    "Array, number | BigNumber": typed3.referToSelf((self2) => (x, n) => {
      return deepMap(x, (i2) => self2(i2, n), true);
    }),
    "SparseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x, y) => {
      return matAlgo11xS0s(x, y, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs(x, y, self2, false);
    }),
    "number | Complex | Fraction | BigNumber, Array": typed3.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs(matrix2(y), x, self2, true).valueOf();
    }),
    "number | Complex | Fraction | BigNumber, Matrix": typed3.referToSelf((self2) => (x, y) => {
      if (equalScalar2(x, 0))
        return zeros3(y.size(), y.storage());
      if (y.storage() === "dense") {
        return matAlgo14xDs(y, x, self2, true);
      }
      return matAlgo12xSfs(y, x, self2, true);
    })
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/cube.js
var name42 = "cube";
var dependencies43 = ["typed"];
var createCube = /* @__PURE__ */ factory(name42, dependencies43, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name42, {
    number: cubeNumber,
    Complex: function Complex3(x) {
      return x.mul(x).mul(x);
    },
    BigNumber: function BigNumber2(x) {
      return x.times(x).times(x);
    },
    bigint: function bigint2(x) {
      return x * x * x;
    },
    Fraction: function Fraction3(x) {
      return x.pow(3);
    },
    Unit: function Unit2(x) {
      return x.pow(3);
    }
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/exp.js
var name43 = "exp";
var dependencies44 = ["typed"];
var createExp = /* @__PURE__ */ factory(name43, dependencies44, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name43, {
    number: expNumber,
    Complex: function Complex3(x) {
      return x.exp();
    },
    BigNumber: function BigNumber2(x) {
      return x.exp();
    }
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/expm1.js
var name44 = "expm1";
var dependencies45 = ["typed", "Complex"];
var createExpm1 = /* @__PURE__ */ factory(name44, dependencies45, (_ref) => {
  var {
    typed: typed3,
    Complex: _Complex
  } = _ref;
  return typed3(name44, {
    number: expm1Number,
    Complex: function Complex3(x) {
      var r = Math.exp(x.re);
      return new _Complex(r * Math.cos(x.im) - 1, r * Math.sin(x.im));
    },
    BigNumber: function BigNumber2(x) {
      return x.exp().minus(1);
    }
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/fix.js
var name45 = "fix";
var dependencies46 = ["typed", "Complex", "matrix", "ceil", "floor", "equalScalar", "zeros", "DenseMatrix"];
var createFixNumber = /* @__PURE__ */ factory(name45, ["typed", "ceil", "floor"], (_ref) => {
  var {
    typed: typed3,
    ceil: ceil3,
    floor: floor3
  } = _ref;
  return typed3(name45, {
    number: function number2(x) {
      return x > 0 ? floor3(x) : ceil3(x);
    },
    "number, number": function numberNumber(x, n) {
      return x > 0 ? floor3(x, n) : ceil3(x, n);
    }
  });
});
var createFix = /* @__PURE__ */ factory(name45, dependencies46, (_ref2) => {
  var {
    typed: typed3,
    Complex: _Complex,
    matrix: matrix2,
    ceil: ceil3,
    floor: floor3,
    equalScalar: equalScalar2,
    zeros: zeros3,
    DenseMatrix: DenseMatrix2
  } = _ref2;
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed3
  });
  var fixNumber = createFixNumber({
    typed: typed3,
    ceil: ceil3,
    floor: floor3
  });
  return typed3("fix", {
    number: fixNumber.signatures.number,
    "number, number | BigNumber": fixNumber.signatures["number,number"],
    Complex: function Complex3(x) {
      return new _Complex(x.re > 0 ? Math.floor(x.re) : Math.ceil(x.re), x.im > 0 ? Math.floor(x.im) : Math.ceil(x.im));
    },
    "Complex, number": function ComplexNumber(x, n) {
      return new _Complex(x.re > 0 ? floor3(x.re, n) : ceil3(x.re, n), x.im > 0 ? floor3(x.im, n) : ceil3(x.im, n));
    },
    "Complex, BigNumber": function ComplexBigNumber(x, bn) {
      var n = bn.toNumber();
      return new _Complex(x.re > 0 ? floor3(x.re, n) : ceil3(x.re, n), x.im > 0 ? floor3(x.im, n) : ceil3(x.im, n));
    },
    BigNumber: function BigNumber2(x) {
      return x.isNegative() ? ceil3(x) : floor3(x);
    },
    "BigNumber, number | BigNumber": function BigNumberNumberBigNumber(x, n) {
      return x.isNegative() ? ceil3(x, n) : floor3(x, n);
    },
    Fraction: function Fraction3(x) {
      return x.s < 0 ? x.ceil() : x.floor();
    },
    "Fraction, number | BigNumber": function FractionNumberBigNumber(x, n) {
      return x.s < 0 ? ceil3(x, n) : floor3(x, n);
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x) => {
      return deepMap(x, self2, true);
    }),
    "Array | Matrix, number | BigNumber": typed3.referToSelf((self2) => (x, n) => {
      return deepMap(x, (i2) => self2(i2, n), true);
    }),
    "number | Complex | Fraction | BigNumber, Array": typed3.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs(matrix2(y), x, self2, true).valueOf();
    }),
    "number | Complex | Fraction | BigNumber, Matrix": typed3.referToSelf((self2) => (x, y) => {
      if (equalScalar2(x, 0))
        return zeros3(y.size(), y.storage());
      if (y.storage() === "dense") {
        return matAlgo14xDs(y, x, self2, true);
      }
      return matAlgo12xSfs(y, x, self2, true);
    })
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/floor.js
var name46 = "floor";
var dependencies47 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix"];
var createFloorNumber = /* @__PURE__ */ factory(name46, ["typed", "config", "round"], (_ref) => {
  var {
    typed: typed3,
    config: config5,
    round: round3
  } = _ref;
  return typed3(name46, {
    number: function number2(x) {
      if (nearlyEqual(x, round3(x), config5.relTol, config5.absTol)) {
        return round3(x);
      } else {
        return Math.floor(x);
      }
    },
    "number, number": function numberNumber(x, n) {
      if (nearlyEqual(x, round3(x, n), config5.relTol, config5.absTol)) {
        return round3(x, n);
      } else {
        var [number2, exponent] = "".concat(x, "e").split("e");
        var result = Math.floor(Number("".concat(number2, "e").concat(Number(exponent) + n)));
        [number2, exponent] = "".concat(result, "e").split("e");
        return Number("".concat(number2, "e").concat(Number(exponent) - n));
      }
    }
  });
});
var createFloor = /* @__PURE__ */ factory(name46, dependencies47, (_ref2) => {
  var {
    typed: typed3,
    config: config5,
    round: round3,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros3,
    DenseMatrix: DenseMatrix2
  } = _ref2;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed3
  });
  var floorNumber = createFloorNumber({
    typed: typed3,
    config: config5,
    round: round3
  });
  return typed3("floor", {
    number: floorNumber.signatures.number,
    "number,number": floorNumber.signatures["number,number"],
    Complex: function Complex3(x) {
      return x.floor();
    },
    "Complex, number": function ComplexNumber(x, n) {
      return x.floor(n);
    },
    "Complex, BigNumber": function ComplexBigNumber(x, n) {
      return x.floor(n.toNumber());
    },
    BigNumber: function BigNumber2(x) {
      if (nearlyEqual2(x, round3(x), config5.relTol, config5.absTol)) {
        return round3(x);
      } else {
        return x.floor();
      }
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, n) {
      if (nearlyEqual2(x, round3(x, n), config5.relTol, config5.absTol)) {
        return round3(x, n);
      } else {
        return x.toDecimalPlaces(n.toNumber(), decimal_default.ROUND_FLOOR);
      }
    },
    Fraction: function Fraction3(x) {
      return x.floor();
    },
    "Fraction, number": function FractionNumber(x, n) {
      return x.floor(n);
    },
    "Fraction, BigNumber": function FractionBigNumber(x, n) {
      return x.floor(n.toNumber());
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x) => {
      return deepMap(x, self2, true);
    }),
    "Array, number | BigNumber": typed3.referToSelf((self2) => (x, n) => {
      return deepMap(x, (i2) => self2(i2, n), true);
    }),
    "SparseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x, y) => {
      return matAlgo11xS0s(x, y, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs(x, y, self2, false);
    }),
    "number | Complex | Fraction | BigNumber, Array": typed3.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs(matrix2(y), x, self2, true).valueOf();
    }),
    "number | Complex | Fraction | BigNumber, Matrix": typed3.referToSelf((self2) => (x, y) => {
      if (equalScalar2(x, 0))
        return zeros3(y.size(), y.storage());
      if (y.storage() === "dense") {
        return matAlgo14xDs(y, x, self2, true);
      }
      return matAlgo12xSfs(y, x, self2, true);
    })
  });
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo02xDS0.js
var name47 = "matAlgo02xDS0";
var dependencies48 = ["typed", "equalScalar"];
var createMatAlgo02xDS0 = /* @__PURE__ */ factory(name47, dependencies48, (_ref) => {
  var {
    typed: typed3,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo02xDS0(denseMatrix, sparseMatrix, callback, inverse) {
    var adata = denseMatrix._data;
    var asize = denseMatrix._size;
    var adt = denseMatrix._datatype || denseMatrix.getDataType();
    var bvalues = sparseMatrix._values;
    var bindex = sparseMatrix._index;
    var bptr = sparseMatrix._ptr;
    var bsize = sparseMatrix._size;
    var bdt = sparseMatrix._datatype || sparseMatrix._data === void 0 ? sparseMatrix._datatype : sparseMatrix.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!bvalues) {
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
      dt = adt;
      eq = typed3.find(equalScalar2, [dt, dt]);
      zero = typed3.convert(0, dt);
      cf = typed3.find(callback, [dt, dt]);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    for (var j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        var i2 = bindex[k];
        var cij = inverse ? cf(bvalues[k], adata[i2][j]) : cf(adata[i2][j], bvalues[k]);
        if (!eq(cij, zero)) {
          cindex.push(i2);
          cvalues.push(cij);
        }
      }
    }
    cptr[columns] = cindex.length;
    return sparseMatrix.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: adt === denseMatrix._datatype && bdt === sparseMatrix._datatype ? dt : void 0
    });
  };
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo03xDSf.js
var name48 = "matAlgo03xDSf";
var dependencies49 = ["typed"];
var createMatAlgo03xDSf = /* @__PURE__ */ factory(name48, dependencies49, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return function matAlgo03xDSf(denseMatrix, sparseMatrix, callback, inverse) {
    var adata = denseMatrix._data;
    var asize = denseMatrix._size;
    var adt = denseMatrix._datatype || denseMatrix.getDataType();
    var bvalues = sparseMatrix._values;
    var bindex = sparseMatrix._index;
    var bptr = sparseMatrix._ptr;
    var bsize = sparseMatrix._size;
    var bdt = sparseMatrix._datatype || sparseMatrix._data === void 0 ? sparseMatrix._datatype : sparseMatrix.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!bvalues) {
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
      dt = adt;
      zero = typed3.convert(0, dt);
      cf = typed3.find(callback, [dt, dt]);
    }
    var cdata = [];
    for (var z = 0; z < rows; z++) {
      cdata[z] = [];
    }
    var x = [];
    var w = [];
    for (var j = 0; j < columns; j++) {
      var mark = j + 1;
      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        var i2 = bindex[k];
        x[i2] = inverse ? cf(bvalues[k], adata[i2][j]) : cf(adata[i2][j], bvalues[k]);
        w[i2] = mark;
      }
      for (var y = 0; y < rows; y++) {
        if (w[y] === mark) {
          cdata[y][j] = x[y];
        } else {
          cdata[y][j] = inverse ? cf(zero, adata[y][j]) : cf(adata[y][j], zero);
        }
      }
    }
    return denseMatrix.createDenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: adt === denseMatrix._datatype && bdt === sparseMatrix._datatype ? dt : void 0
    });
  };
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo05xSfSf.js
var name49 = "matAlgo05xSfSf";
var dependencies50 = ["typed", "equalScalar"];
var createMatAlgo05xSfSf = /* @__PURE__ */ factory(name49, dependencies50, (_ref) => {
  var {
    typed: typed3,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo05xSfSf(a, b, callback) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
      dt = adt;
      eq = typed3.find(equalScalar2, [dt, dt]);
      zero = typed3.convert(0, dt);
      cf = typed3.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var xa = cvalues ? [] : void 0;
    var xb = cvalues ? [] : void 0;
    var wa = [];
    var wb = [];
    var i2, j, k, k1;
    for (j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      for (k = aptr[j], k1 = aptr[j + 1]; k < k1; k++) {
        i2 = aindex[k];
        cindex.push(i2);
        wa[i2] = mark;
        if (xa) {
          xa[i2] = avalues[k];
        }
      }
      for (k = bptr[j], k1 = bptr[j + 1]; k < k1; k++) {
        i2 = bindex[k];
        if (wa[i2] !== mark) {
          cindex.push(i2);
        }
        wb[i2] = mark;
        if (xb) {
          xb[i2] = bvalues[k];
        }
      }
      if (cvalues) {
        k = cptr[j];
        while (k < cindex.length) {
          i2 = cindex[k];
          var wai = wa[i2];
          var wbi = wb[i2];
          if (wai === mark || wbi === mark) {
            var va = wai === mark ? xa[i2] : zero;
            var vb = wbi === mark ? xb[i2] : zero;
            var vc = cf(va, vb);
            if (!eq(vc, zero)) {
              cvalues.push(vc);
              k++;
            } else {
              cindex.splice(k, 1);
            }
          }
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
  };
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo13xDD.js
var name50 = "matAlgo13xDD";
var dependencies51 = ["typed"];
var createMatAlgo13xDD = /* @__PURE__ */ factory(name50, dependencies51, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return function matAlgo13xDD(a, b, callback) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype;
    var csize = [];
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    for (var s = 0; s < asize.length; s++) {
      if (asize[s] !== bsize[s]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      csize[s] = asize[s];
    }
    var dt;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      cf = typed3.find(callback, [dt, dt]);
    }
    var cdata = csize.length > 0 ? _iterate(cf, 0, csize, csize[0], adata, bdata) : [];
    return a.createDenseMatrix({
      data: cdata,
      size: csize,
      datatype: dt
    });
  };
  function _iterate(f, level, s, n, av, bv) {
    var cv = [];
    if (level === s.length - 1) {
      for (var i2 = 0; i2 < n; i2++) {
        cv[i2] = f(av[i2], bv[i2]);
      }
    } else {
      for (var j = 0; j < n; j++) {
        cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv[j]);
      }
    }
    return cv;
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/broadcast.js
function broadcast(A, B) {
  if (deepStrictEqual(A.size(), B.size())) {
    return [A, B];
  }
  var newSize = broadcastSizes(A.size(), B.size());
  return [A, B].map((M) => _broadcastTo(M, newSize));
}
function _broadcastTo(M, size2) {
  if (deepStrictEqual(M.size(), size2)) {
    return M;
  }
  return M.create(broadcastTo(M.valueOf(), size2), M.datatype());
}

// node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js
var name51 = "matrixAlgorithmSuite";
var dependencies52 = ["typed", "matrix"];
var createMatrixAlgorithmSuite = /* @__PURE__ */ factory(name51, dependencies52, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2
  } = _ref;
  var matAlgo13xDD = createMatAlgo13xDD({
    typed: typed3
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed3
  });
  return function matrixAlgorithmSuite(options2) {
    var elop = options2.elop;
    var SD = options2.SD || options2.DS;
    var matrixSignatures;
    if (elop) {
      matrixSignatures = {
        "DenseMatrix, DenseMatrix": (x, y) => matAlgo13xDD(...broadcast(x, y), elop),
        "Array, Array": (x, y) => matAlgo13xDD(...broadcast(matrix2(x), matrix2(y)), elop).valueOf(),
        "Array, DenseMatrix": (x, y) => matAlgo13xDD(...broadcast(matrix2(x), y), elop),
        "DenseMatrix, Array": (x, y) => matAlgo13xDD(...broadcast(x, matrix2(y)), elop)
      };
      if (options2.SS) {
        matrixSignatures["SparseMatrix, SparseMatrix"] = (x, y) => options2.SS(...broadcast(x, y), elop, false);
      }
      if (options2.DS) {
        matrixSignatures["DenseMatrix, SparseMatrix"] = (x, y) => options2.DS(...broadcast(x, y), elop, false);
        matrixSignatures["Array, SparseMatrix"] = (x, y) => options2.DS(...broadcast(matrix2(x), y), elop, false);
      }
      if (SD) {
        matrixSignatures["SparseMatrix, DenseMatrix"] = (x, y) => SD(...broadcast(y, x), elop, true);
        matrixSignatures["SparseMatrix, Array"] = (x, y) => SD(...broadcast(matrix2(y), x), elop, true);
      }
    } else {
      matrixSignatures = {
        "DenseMatrix, DenseMatrix": typed3.referToSelf((self2) => (x, y) => {
          return matAlgo13xDD(...broadcast(x, y), self2);
        }),
        "Array, Array": typed3.referToSelf((self2) => (x, y) => {
          return matAlgo13xDD(...broadcast(matrix2(x), matrix2(y)), self2).valueOf();
        }),
        "Array, DenseMatrix": typed3.referToSelf((self2) => (x, y) => {
          return matAlgo13xDD(...broadcast(matrix2(x), y), self2);
        }),
        "DenseMatrix, Array": typed3.referToSelf((self2) => (x, y) => {
          return matAlgo13xDD(...broadcast(x, matrix2(y)), self2);
        })
      };
      if (options2.SS) {
        matrixSignatures["SparseMatrix, SparseMatrix"] = typed3.referToSelf((self2) => (x, y) => {
          return options2.SS(...broadcast(x, y), self2, false);
        });
      }
      if (options2.DS) {
        matrixSignatures["DenseMatrix, SparseMatrix"] = typed3.referToSelf((self2) => (x, y) => {
          return options2.DS(...broadcast(x, y), self2, false);
        });
        matrixSignatures["Array, SparseMatrix"] = typed3.referToSelf((self2) => (x, y) => {
          return options2.DS(...broadcast(matrix2(x), y), self2, false);
        });
      }
      if (SD) {
        matrixSignatures["SparseMatrix, DenseMatrix"] = typed3.referToSelf((self2) => (x, y) => {
          return SD(...broadcast(y, x), self2, true);
        });
        matrixSignatures["SparseMatrix, Array"] = typed3.referToSelf((self2) => (x, y) => {
          return SD(...broadcast(matrix2(y), x), self2, true);
        });
      }
    }
    var scalar = options2.scalar || "any";
    var Ds = options2.Ds || options2.Ss;
    if (Ds) {
      if (elop) {
        matrixSignatures["DenseMatrix," + scalar] = (x, y) => matAlgo14xDs(x, y, elop, false);
        matrixSignatures[scalar + ", DenseMatrix"] = (x, y) => matAlgo14xDs(y, x, elop, true);
        matrixSignatures["Array," + scalar] = (x, y) => matAlgo14xDs(matrix2(x), y, elop, false).valueOf();
        matrixSignatures[scalar + ", Array"] = (x, y) => matAlgo14xDs(matrix2(y), x, elop, true).valueOf();
      } else {
        matrixSignatures["DenseMatrix," + scalar] = typed3.referToSelf((self2) => (x, y) => {
          return matAlgo14xDs(x, y, self2, false);
        });
        matrixSignatures[scalar + ", DenseMatrix"] = typed3.referToSelf((self2) => (x, y) => {
          return matAlgo14xDs(y, x, self2, true);
        });
        matrixSignatures["Array," + scalar] = typed3.referToSelf((self2) => (x, y) => {
          return matAlgo14xDs(matrix2(x), y, self2, false).valueOf();
        });
        matrixSignatures[scalar + ", Array"] = typed3.referToSelf((self2) => (x, y) => {
          return matAlgo14xDs(matrix2(y), x, self2, true).valueOf();
        });
      }
    }
    var sS = options2.sS !== void 0 ? options2.sS : options2.Ss;
    if (elop) {
      if (options2.Ss) {
        matrixSignatures["SparseMatrix," + scalar] = (x, y) => options2.Ss(x, y, elop, false);
      }
      if (sS) {
        matrixSignatures[scalar + ", SparseMatrix"] = (x, y) => sS(y, x, elop, true);
      }
    } else {
      if (options2.Ss) {
        matrixSignatures["SparseMatrix," + scalar] = typed3.referToSelf((self2) => (x, y) => {
          return options2.Ss(x, y, self2, false);
        });
      }
      if (sS) {
        matrixSignatures[scalar + ", SparseMatrix"] = typed3.referToSelf((self2) => (x, y) => {
          return sS(y, x, self2, true);
        });
      }
    }
    if (elop && elop.signatures) {
      extend(matrixSignatures, elop.signatures);
    }
    return matrixSignatures;
  };
});

// node_modules/mathjs/lib/esm/function/arithmetic/mod.js
var name52 = "mod";
var dependencies53 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
var createMod = /* @__PURE__ */ factory(name52, dependencies53, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    round: round3,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros3,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var floor3 = createFloor({
    typed: typed3,
    config: config5,
    round: round3,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed3
  });
  var matAlgo05xSfSf = createMatAlgo05xSfSf({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix: matrix2,
    concat: concat3
  });
  return typed3(name52, {
    "number, number": _modNumber,
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return y.isZero() ? x : x.sub(y.mul(floor3(x.div(y))));
    },
    "bigint, bigint": function bigintBigint(x, y) {
      if (y === 0n) {
        return x;
      }
      if (x < 0) {
        var m = x % y;
        return m === 0n ? m : m + y;
      }
      return x % y;
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return y.equals(0) ? x : x.sub(y.mul(floor3(x.div(y))));
    }
  }, matrixAlgorithmSuite({
    SS: matAlgo05xSfSf,
    DS: matAlgo03xDSf,
    SD: matAlgo02xDS0,
    Ss: matAlgo11xS0s,
    sS: matAlgo12xSfs
  }));
  function _modNumber(x, y) {
    return y === 0 ? x : x - y * floor3(x / y);
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo01xDSid.js
var name53 = "matAlgo01xDSid";
var dependencies54 = ["typed"];
var createMatAlgo01xDSid = /* @__PURE__ */ factory(name53, dependencies54, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return function algorithm1(denseMatrix, sparseMatrix, callback, inverse) {
    var adata = denseMatrix._data;
    var asize = denseMatrix._size;
    var adt = denseMatrix._datatype || denseMatrix.getDataType();
    var bvalues = sparseMatrix._values;
    var bindex = sparseMatrix._index;
    var bptr = sparseMatrix._ptr;
    var bsize = sparseMatrix._size;
    var bdt = sparseMatrix._datatype || sparseMatrix._data === void 0 ? sparseMatrix._datatype : sparseMatrix.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!bvalues) {
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt = typeof adt === "string" && adt !== "mixed" && adt === bdt ? adt : void 0;
    var cf = dt ? typed3.find(callback, [dt, dt]) : callback;
    var i2, j;
    var cdata = [];
    for (i2 = 0; i2 < rows; i2++) {
      cdata[i2] = [];
    }
    var x = [];
    var w = [];
    for (j = 0; j < columns; j++) {
      var mark = j + 1;
      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        i2 = bindex[k];
        x[i2] = inverse ? cf(bvalues[k], adata[i2][j]) : cf(adata[i2][j], bvalues[k]);
        w[i2] = mark;
      }
      for (i2 = 0; i2 < rows; i2++) {
        if (w[i2] === mark) {
          cdata[i2][j] = x[i2];
        } else {
          cdata[i2][j] = adata[i2][j];
        }
      }
    }
    return denseMatrix.createDenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: adt === denseMatrix._datatype && bdt === sparseMatrix._datatype ? dt : void 0
    });
  };
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo04xSidSid.js
var name54 = "matAlgo04xSidSid";
var dependencies55 = ["typed", "equalScalar"];
var createMatAlgo04xSidSid = /* @__PURE__ */ factory(name54, dependencies55, (_ref) => {
  var {
    typed: typed3,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo04xSidSid(a, b, callback) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
      dt = adt;
      eq = typed3.find(equalScalar2, [dt, dt]);
      zero = typed3.convert(0, dt);
      cf = typed3.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var xa = avalues && bvalues ? [] : void 0;
    var xb = avalues && bvalues ? [] : void 0;
    var wa = [];
    var wb = [];
    var i2, j, k, k0, k1;
    for (j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        i2 = aindex[k];
        cindex.push(i2);
        wa[i2] = mark;
        if (xa) {
          xa[i2] = avalues[k];
        }
      }
      for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        i2 = bindex[k];
        if (wa[i2] === mark) {
          if (xa) {
            var v = cf(xa[i2], bvalues[k]);
            if (!eq(v, zero)) {
              xa[i2] = v;
            } else {
              wa[i2] = null;
            }
          }
        } else {
          cindex.push(i2);
          wb[i2] = mark;
          if (xb) {
            xb[i2] = bvalues[k];
          }
        }
      }
      if (xa && xb) {
        k = cptr[j];
        while (k < cindex.length) {
          i2 = cindex[k];
          if (wa[i2] === mark) {
            cvalues[k] = xa[i2];
            k++;
          } else if (wb[i2] === mark) {
            cvalues[k] = xb[i2];
            k++;
          } else {
            cindex.splice(k, 1);
          }
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
  };
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo10xSids.js
var name55 = "matAlgo10xSids";
var dependencies56 = ["typed", "DenseMatrix"];
var createMatAlgo10xSids = /* @__PURE__ */ factory(name55, dependencies56, (_ref) => {
  var {
    typed: typed3,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return function matAlgo10xSids(s, b, callback, inverse) {
    var avalues = s._values;
    var aindex = s._index;
    var aptr = s._ptr;
    var asize = s._size;
    var adt = s._datatype;
    if (!avalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var cf = callback;
    if (typeof adt === "string") {
      dt = adt;
      b = typed3.convert(b, dt);
      cf = typed3.find(callback, [dt, dt]);
    }
    var cdata = [];
    var x = [];
    var w = [];
    for (var j = 0; j < columns; j++) {
      var mark = j + 1;
      for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        var r = aindex[k];
        x[r] = avalues[k];
        w[r] = mark;
      }
      for (var i2 = 0; i2 < rows; i2++) {
        if (j === 0) {
          cdata[i2] = [];
        }
        if (w[i2] === mark) {
          cdata[i2][j] = inverse ? cf(b, x[i2]) : cf(x[i2], b);
        } else {
          cdata[i2][j] = b;
        }
      }
    }
    return new DenseMatrix2({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
});

// node_modules/mathjs/lib/esm/error/ArgumentsError.js
function ArgumentsError(fn, count2, min3, max3) {
  if (!(this instanceof ArgumentsError)) {
    throw new SyntaxError("Constructor must be called with the new operator");
  }
  this.fn = fn;
  this.count = count2;
  this.min = min3;
  this.max = max3;
  this.message = "Wrong number of arguments in function " + fn + " (" + count2 + " provided, " + min3 + (max3 !== void 0 && max3 !== null ? "-" + max3 : "") + " expected)";
  this.stack = new Error().stack;
}
ArgumentsError.prototype = new Error();
ArgumentsError.prototype.constructor = Error;
ArgumentsError.prototype.name = "ArgumentsError";
ArgumentsError.prototype.isArgumentsError = true;

// node_modules/mathjs/lib/esm/function/arithmetic/gcd.js
var name56 = "gcd";
var dependencies57 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "BigNumber", "DenseMatrix", "concat"];
var gcdTypes = "number | BigNumber | Fraction | Matrix | Array";
var gcdManyTypesSignature = "".concat(gcdTypes, ", ").concat(gcdTypes, ", ...").concat(gcdTypes);
function is1d(array) {
  return !array.some((element) => Array.isArray(element));
}
var createGcd = /* @__PURE__ */ factory(name56, dependencies57, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    config: config5,
    round: round3,
    equalScalar: equalScalar2,
    zeros: zeros3,
    BigNumber: BigNumber2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var mod3 = createMod({
    typed: typed3,
    config: config5,
    round: round3,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros3,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  });
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed3
  });
  var matAlgo04xSidSid = createMatAlgo04xSidSid({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix: matrix2,
    concat: concat3
  });
  return typed3(name56, {
    "number, number": _gcdNumber,
    "BigNumber, BigNumber": _gcdBigNumber,
    "Fraction, Fraction": (x, y) => x.gcd(y)
  }, matrixAlgorithmSuite({
    SS: matAlgo04xSidSid,
    DS: matAlgo01xDSid,
    Ss: matAlgo10xSids
  }), {
    [gcdManyTypesSignature]: typed3.referToSelf((self2) => (a, b, args) => {
      var res = self2(a, b);
      for (var i2 = 0; i2 < args.length; i2++) {
        res = self2(res, args[i2]);
      }
      return res;
    }),
    Array: typed3.referToSelf((self2) => (array) => {
      if (array.length === 1 && Array.isArray(array[0]) && is1d(array[0])) {
        return self2(...array[0]);
      }
      if (is1d(array)) {
        return self2(...array);
      }
      throw new ArgumentsError("gcd() supports only 1d matrices!");
    }),
    Matrix: typed3.referToSelf((self2) => (matrix3) => {
      return self2(matrix3.toArray());
    })
  });
  function _gcdNumber(a, b) {
    if (!isInteger(a) || !isInteger(b)) {
      throw new Error("Parameters in function gcd must be integer numbers");
    }
    var r;
    while (b !== 0) {
      r = mod3(a, b);
      a = b;
      b = r;
    }
    return a < 0 ? -a : a;
  }
  function _gcdBigNumber(a, b) {
    if (!a.isInt() || !b.isInt()) {
      throw new Error("Parameters in function gcd must be integer numbers");
    }
    var zero = new BigNumber2(0);
    while (!b.isZero()) {
      var r = mod3(a, b);
      a = b;
      b = r;
    }
    return a.lt(zero) ? a.neg() : a;
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo06xS0S0.js
var name57 = "matAlgo06xS0S0";
var dependencies58 = ["typed", "equalScalar"];
var createMatAlgo06xS0S0 = /* @__PURE__ */ factory(name57, dependencies58, (_ref) => {
  var {
    typed: typed3,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo06xS0S0(a, b, callback) {
    var avalues = a._values;
    var asize = a._size;
    var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    var bvalues = b._values;
    var bsize = b._size;
    var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
      dt = adt;
      eq = typed3.find(equalScalar2, [dt, dt]);
      zero = typed3.convert(0, dt);
      cf = typed3.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var x = cvalues ? [] : void 0;
    var w = [];
    var u = [];
    for (var j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      scatter(a, j, w, x, u, mark, cindex, cf);
      scatter(b, j, w, x, u, mark, cindex, cf);
      if (x) {
        var k = cptr[j];
        while (k < cindex.length) {
          var i2 = cindex[k];
          if (u[i2] === mark) {
            var v = x[i2];
            if (!eq(v, zero)) {
              cvalues.push(v);
              k++;
            } else {
              cindex.splice(k, 1);
            }
          } else {
            cindex.splice(k, 1);
          }
        }
      } else {
        var p = cptr[j];
        while (p < cindex.length) {
          var r = cindex[p];
          if (u[r] !== mark) {
            cindex.splice(p, 1);
          } else {
            p++;
          }
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
  };
});

// node_modules/mathjs/lib/esm/function/arithmetic/lcm.js
var name58 = "lcm";
var dependencies59 = ["typed", "matrix", "equalScalar", "concat"];
var createLcm = /* @__PURE__ */ factory(name58, dependencies59, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    equalScalar: equalScalar2,
    concat: concat3
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo06xS0S0 = createMatAlgo06xS0S0({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix: matrix2,
    concat: concat3
  });
  var lcmTypes = "number | BigNumber | Fraction | Matrix | Array";
  var lcmManySignature = {};
  lcmManySignature["".concat(lcmTypes, ", ").concat(lcmTypes, ", ...").concat(lcmTypes)] = typed3.referToSelf((self2) => (a, b, args) => {
    var res = self2(a, b);
    for (var i2 = 0; i2 < args.length; i2++) {
      res = self2(res, args[i2]);
    }
    return res;
  });
  return typed3(name58, {
    "number, number": lcmNumber,
    "BigNumber, BigNumber": _lcmBigNumber,
    "Fraction, Fraction": (x, y) => x.lcm(y)
  }, matrixAlgorithmSuite({
    SS: matAlgo06xS0S0,
    DS: matAlgo02xDS0,
    Ss: matAlgo11xS0s
  }), lcmManySignature);
  function _lcmBigNumber(a, b) {
    if (!a.isInt() || !b.isInt()) {
      throw new Error("Parameters in function lcm must be integer numbers");
    }
    if (a.isZero()) {
      return a;
    }
    if (b.isZero()) {
      return b;
    }
    var prod2 = a.times(b);
    while (!b.isZero()) {
      var t = b;
      b = a.mod(t);
      a = t;
    }
    return prod2.div(a).abs();
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/log10.js
var name59 = "log10";
var dependencies60 = ["typed", "config", "Complex"];
var createLog10 = /* @__PURE__ */ factory(name59, dependencies60, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    Complex: _Complex
  } = _ref;
  return typed3(name59, {
    number: function number2(x) {
      if (x >= 0 || config5.predictable) {
        return log10Number(x);
      } else {
        return new _Complex(x, 0).log().div(Math.LN10);
      }
    },
    Complex: function Complex3(x) {
      return new _Complex(x).log().div(Math.LN10);
    },
    BigNumber: function BigNumber2(x) {
      if (!x.isNegative() || config5.predictable) {
        return x.log();
      } else {
        return new _Complex(x.toNumber(), 0).log().div(Math.LN10);
      }
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/log2.js
var name60 = "log2";
var dependencies61 = ["typed", "config", "Complex"];
var createLog2 = /* @__PURE__ */ factory(name60, dependencies61, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    Complex: Complex3
  } = _ref;
  return typed3(name60, {
    number: function number2(x) {
      if (x >= 0 || config5.predictable) {
        return log2Number(x);
      } else {
        return _log2Complex(new Complex3(x, 0));
      }
    },
    Complex: _log2Complex,
    BigNumber: function BigNumber2(x) {
      if (!x.isNegative() || config5.predictable) {
        return x.log(2);
      } else {
        return _log2Complex(new Complex3(x.toNumber(), 0));
      }
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
  });
  function _log2Complex(x) {
    var newX = Math.sqrt(x.re * x.re + x.im * x.im);
    return new Complex3(Math.log2 ? Math.log2(newX) : Math.log(newX) / Math.LN2, Math.atan2(x.im, x.re) / Math.LN2);
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/multiplyScalar.js
var name61 = "multiplyScalar";
var dependencies62 = ["typed"];
var createMultiplyScalar = /* @__PURE__ */ factory(name61, dependencies62, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3("multiplyScalar", {
    "number, number": multiplyNumber,
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.mul(y);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.times(y);
    },
    "bigint, bigint": function bigintBigint(x, y) {
      return x * y;
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return x.mul(y);
    },
    "number | Fraction | BigNumber | Complex, Unit": (x, y) => y.multiply(x),
    "Unit, number | Fraction | BigNumber | Complex | Unit": (x, y) => x.multiply(y)
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/multiply.js
var name62 = "multiply";
var dependencies63 = ["typed", "matrix", "addScalar", "multiplyScalar", "equalScalar", "dot"];
var createMultiply = /* @__PURE__ */ factory(name62, dependencies63, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    addScalar: addScalar2,
    multiplyScalar: multiplyScalar2,
    equalScalar: equalScalar2,
    dot: dot2
  } = _ref;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed3
  });
  function _validateMatrixDimensions(size1, size2) {
    switch (size1.length) {
      case 1:
        switch (size2.length) {
          case 1:
            if (size1[0] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Vectors must have the same length");
            }
            break;
          case 2:
            if (size1[0] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Vector length (" + size1[0] + ") must match Matrix rows (" + size2[0] + ")");
            }
            break;
          default:
            throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
        }
        break;
      case 2:
        switch (size2.length) {
          case 1:
            if (size1[1] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Matrix columns (" + size1[1] + ") must match Vector length (" + size2[0] + ")");
            }
            break;
          case 2:
            if (size1[1] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Matrix A columns (" + size1[1] + ") must match Matrix B rows (" + size2[0] + ")");
            }
            break;
          default:
            throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
        }
        break;
      default:
        throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix A has " + size1.length + " dimensions)");
    }
  }
  function _multiplyVectorVector(a, b, n) {
    if (n === 0) {
      throw new Error("Cannot multiply two empty vectors");
    }
    return dot2(a, b);
  }
  function _multiplyVectorMatrix(a, b) {
    if (b.storage() !== "dense") {
      throw new Error("Support for SparseMatrix not implemented");
    }
    return _multiplyVectorDenseMatrix(a, b);
  }
  function _multiplyVectorDenseMatrix(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype || a.getDataType();
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype || b.getDataType();
    var alength = asize[0];
    var bcolumns = bsize[1];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
      dt = adt;
      af = typed3.find(addScalar2, [dt, dt]);
      mf = typed3.find(multiplyScalar2, [dt, dt]);
    }
    var c = [];
    for (var j = 0; j < bcolumns; j++) {
      var sum3 = mf(adata[0], bdata[0][j]);
      for (var i2 = 1; i2 < alength; i2++) {
        sum3 = af(sum3, mf(adata[i2], bdata[i2][j]));
      }
      c[j] = sum3;
    }
    return a.createDenseMatrix({
      data: c,
      size: [bcolumns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
  }
  var _multiplyMatrixVector = typed3("_multiplyMatrixVector", {
    "DenseMatrix, any": _multiplyDenseMatrixVector,
    "SparseMatrix, any": _multiplySparseMatrixVector
  });
  var _multiplyMatrixMatrix = typed3("_multiplyMatrixMatrix", {
    "DenseMatrix, DenseMatrix": _multiplyDenseMatrixDenseMatrix,
    "DenseMatrix, SparseMatrix": _multiplyDenseMatrixSparseMatrix,
    "SparseMatrix, DenseMatrix": _multiplySparseMatrixDenseMatrix,
    "SparseMatrix, SparseMatrix": _multiplySparseMatrixSparseMatrix
  });
  function _multiplyDenseMatrixVector(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype || a.getDataType();
    var bdata = b._data;
    var bdt = b._datatype || b.getDataType();
    var arows = asize[0];
    var acolumns = asize[1];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
      dt = adt;
      af = typed3.find(addScalar2, [dt, dt]);
      mf = typed3.find(multiplyScalar2, [dt, dt]);
    }
    var c = [];
    for (var i2 = 0; i2 < arows; i2++) {
      var row2 = adata[i2];
      var sum3 = mf(row2[0], bdata[0]);
      for (var j = 1; j < acolumns; j++) {
        sum3 = af(sum3, mf(row2[j], bdata[j]));
      }
      c[i2] = sum3;
    }
    return a.createDenseMatrix({
      data: c,
      size: [arows],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
  }
  function _multiplyDenseMatrixDenseMatrix(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype || a.getDataType();
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype || b.getDataType();
    var arows = asize[0];
    var acolumns = asize[1];
    var bcolumns = bsize[1];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed" && adt !== "mixed") {
      dt = adt;
      af = typed3.find(addScalar2, [dt, dt]);
      mf = typed3.find(multiplyScalar2, [dt, dt]);
    }
    var c = [];
    for (var i2 = 0; i2 < arows; i2++) {
      var row2 = adata[i2];
      c[i2] = [];
      for (var j = 0; j < bcolumns; j++) {
        var sum3 = mf(row2[0], bdata[0][j]);
        for (var x = 1; x < acolumns; x++) {
          sum3 = af(sum3, mf(row2[x], bdata[x][j]));
        }
        c[i2][j] = sum3;
      }
    }
    return a.createDenseMatrix({
      data: c,
      size: [arows, bcolumns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
  }
  function _multiplyDenseMatrixSparseMatrix(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype || a.getDataType();
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
    if (!bvalues) {
      throw new Error("Cannot multiply Dense Matrix times Pattern only Matrix");
    }
    var arows = asize[0];
    var bcolumns = bsize[1];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    var eq = equalScalar2;
    var zero = 0;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
      dt = adt;
      af = typed3.find(addScalar2, [dt, dt]);
      mf = typed3.find(multiplyScalar2, [dt, dt]);
      eq = typed3.find(equalScalar2, [dt, dt]);
      zero = typed3.convert(0, dt);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var c = b.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
    for (var jb = 0; jb < bcolumns; jb++) {
      cptr[jb] = cindex.length;
      var kb0 = bptr[jb];
      var kb1 = bptr[jb + 1];
      if (kb1 > kb0) {
        var last = 0;
        for (var i2 = 0; i2 < arows; i2++) {
          var mark = i2 + 1;
          var cij = void 0;
          for (var kb = kb0; kb < kb1; kb++) {
            var ib = bindex[kb];
            if (last !== mark) {
              cij = mf(adata[i2][ib], bvalues[kb]);
              last = mark;
            } else {
              cij = af(cij, mf(adata[i2][ib], bvalues[kb]));
            }
          }
          if (last === mark && !eq(cij, zero)) {
            cindex.push(i2);
            cvalues.push(cij);
          }
        }
      }
    }
    cptr[bcolumns] = cindex.length;
    return c;
  }
  function _multiplySparseMatrixVector(a, b) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    if (!avalues) {
      throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
    }
    var bdata = b._data;
    var bdt = b._datatype || b.getDataType();
    var arows = a._size[0];
    var brows = b._size[0];
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    var eq = equalScalar2;
    var zero = 0;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
      dt = adt;
      af = typed3.find(addScalar2, [dt, dt]);
      mf = typed3.find(multiplyScalar2, [dt, dt]);
      eq = typed3.find(equalScalar2, [dt, dt]);
      zero = typed3.convert(0, dt);
    }
    var x = [];
    var w = [];
    cptr[0] = 0;
    for (var ib = 0; ib < brows; ib++) {
      var vbi = bdata[ib];
      if (!eq(vbi, zero)) {
        for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
          var ia = aindex[ka];
          if (!w[ia]) {
            w[ia] = true;
            cindex.push(ia);
            x[ia] = mf(vbi, avalues[ka]);
          } else {
            x[ia] = af(x[ia], mf(vbi, avalues[ka]));
          }
        }
      }
    }
    for (var p1 = cindex.length, p = 0; p < p1; p++) {
      var ic = cindex[p];
      cvalues[p] = x[ic];
    }
    cptr[1] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, 1],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
  }
  function _multiplySparseMatrixDenseMatrix(a, b) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    if (!avalues) {
      throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
    }
    var bdata = b._data;
    var bdt = b._datatype || b.getDataType();
    var arows = a._size[0];
    var brows = b._size[0];
    var bcolumns = b._size[1];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    var eq = equalScalar2;
    var zero = 0;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
      dt = adt;
      af = typed3.find(addScalar2, [dt, dt]);
      mf = typed3.find(multiplyScalar2, [dt, dt]);
      eq = typed3.find(equalScalar2, [dt, dt]);
      zero = typed3.convert(0, dt);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var c = a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
    var x = [];
    var w = [];
    for (var jb = 0; jb < bcolumns; jb++) {
      cptr[jb] = cindex.length;
      var mark = jb + 1;
      for (var ib = 0; ib < brows; ib++) {
        var vbij = bdata[ib][jb];
        if (!eq(vbij, zero)) {
          for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            var ia = aindex[ka];
            if (w[ia] !== mark) {
              w[ia] = mark;
              cindex.push(ia);
              x[ia] = mf(vbij, avalues[ka]);
            } else {
              x[ia] = af(x[ia], mf(vbij, avalues[ka]));
            }
          }
        }
      }
      for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
        var ic = cindex[p];
        cvalues[p] = x[ic];
      }
    }
    cptr[bcolumns] = cindex.length;
    return c;
  }
  function _multiplySparseMatrixSparseMatrix(a, b) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
    var arows = a._size[0];
    var bcolumns = b._size[1];
    var values = avalues && bvalues;
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
      dt = adt;
      af = typed3.find(addScalar2, [dt, dt]);
      mf = typed3.find(multiplyScalar2, [dt, dt]);
    }
    var cvalues = values ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var c = a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
    var x = values ? [] : void 0;
    var w = [];
    var ka, ka0, ka1, kb, kb0, kb1, ia, ib;
    for (var jb = 0; jb < bcolumns; jb++) {
      cptr[jb] = cindex.length;
      var mark = jb + 1;
      for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {
        ib = bindex[kb];
        if (values) {
          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            ia = aindex[ka];
            if (w[ia] !== mark) {
              w[ia] = mark;
              cindex.push(ia);
              x[ia] = mf(bvalues[kb], avalues[ka]);
            } else {
              x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));
            }
          }
        } else {
          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            ia = aindex[ka];
            if (w[ia] !== mark) {
              w[ia] = mark;
              cindex.push(ia);
            }
          }
        }
      }
      if (values) {
        for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
          var ic = cindex[p];
          cvalues[p] = x[ic];
        }
      }
    }
    cptr[bcolumns] = cindex.length;
    return c;
  }
  return typed3(name62, multiplyScalar2, {
    // we extend the signatures of multiplyScalar with signatures dealing with matrices
    "Array, Array": typed3.referTo("Matrix, Matrix", (selfMM) => (x, y) => {
      _validateMatrixDimensions(arraySize(x), arraySize(y));
      var m = selfMM(matrix2(x), matrix2(y));
      return isMatrix(m) ? m.valueOf() : m;
    }),
    "Matrix, Matrix": function MatrixMatrix(x, y) {
      var xsize = x.size();
      var ysize = y.size();
      _validateMatrixDimensions(xsize, ysize);
      if (xsize.length === 1) {
        if (ysize.length === 1) {
          return _multiplyVectorVector(x, y, xsize[0]);
        }
        return _multiplyVectorMatrix(x, y);
      }
      if (ysize.length === 1) {
        return _multiplyMatrixVector(x, y);
      }
      return _multiplyMatrixMatrix(x, y);
    },
    "Matrix, Array": typed3.referTo("Matrix,Matrix", (selfMM) => (x, y) => selfMM(x, matrix2(y))),
    "Array, Matrix": typed3.referToSelf((self2) => (x, y) => {
      return self2(matrix2(x, y.storage()), y);
    }),
    "SparseMatrix, any": function SparseMatrixAny(x, y) {
      return matAlgo11xS0s(x, y, multiplyScalar2, false);
    },
    "DenseMatrix, any": function DenseMatrixAny(x, y) {
      return matAlgo14xDs(x, y, multiplyScalar2, false);
    },
    "any, SparseMatrix": function anySparseMatrix(x, y) {
      return matAlgo11xS0s(y, x, multiplyScalar2, true);
    },
    "any, DenseMatrix": function anyDenseMatrix(x, y) {
      return matAlgo14xDs(y, x, multiplyScalar2, true);
    },
    "Array, any": function ArrayAny(x, y) {
      return matAlgo14xDs(matrix2(x), y, multiplyScalar2, false).valueOf();
    },
    "any, Array": function anyArray(x, y) {
      return matAlgo14xDs(matrix2(y), x, multiplyScalar2, true).valueOf();
    },
    "any, any": multiplyScalar2,
    "any, any, ...any": typed3.referToSelf((self2) => (x, y, rest) => {
      var result = self2(x, y);
      for (var i2 = 0; i2 < rest.length; i2++) {
        result = self2(result, rest[i2]);
      }
      return result;
    })
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/nthRoot.js
var name63 = "nthRoot";
var dependencies64 = ["typed", "matrix", "equalScalar", "BigNumber", "concat"];
var createNthRoot = /* @__PURE__ */ factory(name63, dependencies64, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    equalScalar: equalScalar2,
    BigNumber: _BigNumber,
    concat: concat3
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed3
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo06xS0S0 = createMatAlgo06xS0S0({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix: matrix2,
    concat: concat3
  });
  function complexErr() {
    throw new Error("Complex number not supported in function nthRoot. Use nthRoots instead.");
  }
  return typed3(name63, {
    number: nthRootNumber,
    "number, number": nthRootNumber,
    BigNumber: (x) => _bigNthRoot(x, new _BigNumber(2)),
    "BigNumber, BigNumber": _bigNthRoot,
    Complex: complexErr,
    "Complex, number": complexErr,
    Array: typed3.referTo("DenseMatrix,number", (selfDn) => (x) => selfDn(matrix2(x), 2).valueOf()),
    DenseMatrix: typed3.referTo("DenseMatrix,number", (selfDn) => (x) => selfDn(x, 2)),
    SparseMatrix: typed3.referTo("SparseMatrix,number", (selfSn) => (x) => selfSn(x, 2)),
    "SparseMatrix, SparseMatrix": typed3.referToSelf((self2) => (x, y) => {
      if (y.density() === 1) {
        return matAlgo06xS0S0(x, y, self2);
      } else {
        throw new Error("Root must be non-zero");
      }
    }),
    "DenseMatrix, SparseMatrix": typed3.referToSelf((self2) => (x, y) => {
      if (y.density() === 1) {
        return matAlgo01xDSid(x, y, self2, false);
      } else {
        throw new Error("Root must be non-zero");
      }
    }),
    "Array, SparseMatrix": typed3.referTo("DenseMatrix,SparseMatrix", (selfDS) => (x, y) => selfDS(matrix2(x), y)),
    "number | BigNumber, SparseMatrix": typed3.referToSelf((self2) => (x, y) => {
      if (y.density() === 1) {
        return matAlgo11xS0s(y, x, self2, true);
      } else {
        throw new Error("Root must be non-zero");
      }
    })
  }, matrixAlgorithmSuite({
    scalar: "number | BigNumber",
    SD: matAlgo02xDS0,
    Ss: matAlgo11xS0s,
    sS: false
  }));
  function _bigNthRoot(a, root) {
    var precision = _BigNumber.precision;
    var Big = _BigNumber.clone({
      precision: precision + 2
    });
    var zero = new _BigNumber(0);
    var one = new Big(1);
    var inv2 = root.isNegative();
    if (inv2) {
      root = root.neg();
    }
    if (root.isZero()) {
      throw new Error("Root must be non-zero");
    }
    if (a.isNegative() && !root.abs().mod(2).equals(1)) {
      throw new Error("Root must be odd when a is negative.");
    }
    if (a.isZero()) {
      return inv2 ? new Big(Infinity) : 0;
    }
    if (!a.isFinite()) {
      return inv2 ? zero : a;
    }
    var x = a.abs().pow(one.div(root));
    x = a.isNeg() ? x.neg() : x;
    return new _BigNumber((inv2 ? one.div(x) : x).toPrecision(precision));
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/sign.js
var name64 = "sign";
var dependencies65 = ["typed", "BigNumber", "Fraction", "complex"];
var createSign = /* @__PURE__ */ factory(name64, dependencies65, (_ref) => {
  var {
    typed: typed3,
    BigNumber: _BigNumber,
    complex: complex2,
    Fraction: _Fraction
  } = _ref;
  return typed3(name64, {
    number: signNumber,
    Complex: function Complex3(x) {
      return x.im === 0 ? complex2(signNumber(x.re)) : x.sign();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(x.cmp(0));
    },
    bigint: function bigint2(x) {
      return x > 0n ? 1n : x < 0n ? -1n : 0n;
    },
    Fraction: function Fraction3(x) {
      return new _Fraction(x.s, 1);
    },
    // deep map collection, skip zeros since sign(0) = 0
    "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2, true)),
    Unit: typed3.referToSelf((self2) => (x) => {
      if (!x._isDerived() && x.units[0].unit.offset !== 0) {
        throw new TypeError("sign is ambiguous for units with offset");
      }
      return typed3.find(self2, x.valueType())(x.value);
    })
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/sqrt.js
var name65 = "sqrt";
var dependencies66 = ["config", "typed", "Complex"];
var createSqrt = /* @__PURE__ */ factory(name65, dependencies66, (_ref) => {
  var {
    config: config5,
    typed: typed3,
    Complex: Complex3
  } = _ref;
  return typed3("sqrt", {
    number: _sqrtNumber,
    Complex: function Complex4(x) {
      return x.sqrt();
    },
    BigNumber: function BigNumber2(x) {
      if (!x.isNegative() || config5.predictable) {
        return x.sqrt();
      } else {
        return _sqrtNumber(x.toNumber());
      }
    },
    Unit: function Unit2(x) {
      return x.pow(0.5);
    }
  });
  function _sqrtNumber(x) {
    if (isNaN(x)) {
      return NaN;
    } else if (x >= 0 || config5.predictable) {
      return Math.sqrt(x);
    } else {
      return new Complex3(x, 0).sqrt();
    }
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/square.js
var name66 = "square";
var dependencies67 = ["typed"];
var createSquare = /* @__PURE__ */ factory(name66, dependencies67, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name66, {
    number: squareNumber,
    Complex: function Complex3(x) {
      return x.mul(x);
    },
    BigNumber: function BigNumber2(x) {
      return x.times(x);
    },
    bigint: function bigint2(x) {
      return x * x;
    },
    Fraction: function Fraction3(x) {
      return x.mul(x);
    },
    Unit: function Unit2(x) {
      return x.pow(2);
    }
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/subtract.js
var name67 = "subtract";
var dependencies68 = ["typed", "matrix", "equalScalar", "subtractScalar", "unaryMinus", "DenseMatrix", "concat"];
var createSubtract = /* @__PURE__ */ factory(name67, dependencies68, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    equalScalar: equalScalar2,
    subtractScalar: subtractScalar2,
    unaryMinus: unaryMinus2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed3
  });
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed3
  });
  var matAlgo05xSfSf = createMatAlgo05xSfSf({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix: matrix2,
    concat: concat3
  });
  return typed3(name67, {
    "any, any": subtractScalar2
  }, matrixAlgorithmSuite({
    elop: subtractScalar2,
    SS: matAlgo05xSfSf,
    DS: matAlgo01xDSid,
    SD: matAlgo03xDSf,
    Ss: matAlgo12xSfs,
    sS: matAlgo10xSids
  }));
});

// node_modules/mathjs/lib/esm/function/arithmetic/xgcd.js
var name68 = "xgcd";
var dependencies69 = ["typed", "config", "matrix", "BigNumber"];
var createXgcd = /* @__PURE__ */ factory(name68, dependencies69, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    matrix: matrix2,
    BigNumber: BigNumber2
  } = _ref;
  return typed3(name68, {
    "number, number": function numberNumber(a, b) {
      var res = xgcdNumber(a, b);
      return config5.matrix === "Array" ? res : matrix2(res);
    },
    "BigNumber, BigNumber": _xgcdBigNumber
    // TODO: implement support for Fraction
  });
  function _xgcdBigNumber(a, b) {
    var t;
    var q;
    var r;
    var zero = new BigNumber2(0);
    var one = new BigNumber2(1);
    var x = zero;
    var lastx = one;
    var y = one;
    var lasty = zero;
    if (!a.isInt() || !b.isInt()) {
      throw new Error("Parameters in function xgcd must be integer numbers");
    }
    while (!b.isZero()) {
      q = a.div(b).floor();
      r = a.mod(b);
      t = x;
      x = lastx.minus(q.times(x));
      lastx = t;
      t = y;
      y = lasty.minus(q.times(y));
      lasty = t;
      a = b;
      b = r;
    }
    var res;
    if (a.lt(zero)) {
      res = [a.neg(), lastx.neg(), lasty.neg()];
    } else {
      res = [a, !a.isZero() ? lastx : 0, lasty];
    }
    return config5.matrix === "Array" ? res : matrix2(res);
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/invmod.js
var name69 = "invmod";
var dependencies70 = ["typed", "config", "BigNumber", "xgcd", "equal", "smaller", "mod", "add", "isInteger"];
var createInvmod = /* @__PURE__ */ factory(name69, dependencies70, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    BigNumber: BigNumber2,
    xgcd: xgcd2,
    equal: equal2,
    smaller: smaller2,
    mod: mod3,
    add: add3,
    isInteger: isInteger3
  } = _ref;
  return typed3(name69, {
    "number, number": invmod2,
    "BigNumber, BigNumber": invmod2
  });
  function invmod2(a, b) {
    if (!isInteger3(a) || !isInteger3(b))
      throw new Error("Parameters in function invmod must be integer numbers");
    a = mod3(a, b);
    if (equal2(b, 0))
      throw new Error("Divisor must be non zero");
    var res = xgcd2(a, b);
    res = res.valueOf();
    var [gcd3, inv2] = res;
    if (!equal2(gcd3, BigNumber2(1)))
      return NaN;
    inv2 = mod3(inv2, b);
    if (smaller2(inv2, BigNumber2(0)))
      inv2 = add3(inv2, b);
    return inv2;
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo09xS0Sf.js
var name70 = "matAlgo09xS0Sf";
var dependencies71 = ["typed", "equalScalar"];
var createMatAlgo09xS0Sf = /* @__PURE__ */ factory(name70, dependencies71, (_ref) => {
  var {
    typed: typed3,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo09xS0Sf(a, b, callback) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
      dt = adt;
      eq = typed3.find(equalScalar2, [dt, dt]);
      zero = typed3.convert(0, dt);
      cf = typed3.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var x = cvalues ? [] : void 0;
    var w = [];
    var i2, j, k, k0, k1;
    for (j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      if (x) {
        for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          i2 = bindex[k];
          w[i2] = mark;
          x[i2] = bvalues[k];
        }
      }
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        i2 = aindex[k];
        if (x) {
          var vb = w[i2] === mark ? x[i2] : zero;
          var vc = cf(avalues[k], vb);
          if (!eq(vc, zero)) {
            cindex.push(i2);
            cvalues.push(vc);
          }
        } else {
          cindex.push(i2);
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
  };
});

// node_modules/mathjs/lib/esm/function/arithmetic/dotMultiply.js
var name71 = "dotMultiply";
var dependencies72 = ["typed", "matrix", "equalScalar", "multiplyScalar", "concat"];
var createDotMultiply = /* @__PURE__ */ factory(name71, dependencies72, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    equalScalar: equalScalar2,
    multiplyScalar: multiplyScalar2,
    concat: concat3
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo09xS0Sf = createMatAlgo09xS0Sf({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix: matrix2,
    concat: concat3
  });
  return typed3(name71, matrixAlgorithmSuite({
    elop: multiplyScalar2,
    SS: matAlgo09xS0Sf,
    DS: matAlgo02xDS0,
    Ss: matAlgo11xS0s
  }));
});

// node_modules/mathjs/lib/esm/utils/bignumber/bitwise.js
function bitAndBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function bitAnd");
  }
  var BigNumber2 = x.constructor;
  if (x.isNaN() || y.isNaN()) {
    return new BigNumber2(NaN);
  }
  if (x.isZero() || y.eq(-1) || x.eq(y)) {
    return x;
  }
  if (y.isZero() || x.eq(-1)) {
    return y;
  }
  if (!x.isFinite() || !y.isFinite()) {
    if (!x.isFinite() && !y.isFinite()) {
      if (x.isNegative() === y.isNegative()) {
        return x;
      }
      return new BigNumber2(0);
    }
    if (!x.isFinite()) {
      if (y.isNegative()) {
        return x;
      }
      if (x.isNegative()) {
        return new BigNumber2(0);
      }
      return y;
    }
    if (!y.isFinite()) {
      if (x.isNegative()) {
        return y;
      }
      if (y.isNegative()) {
        return new BigNumber2(0);
      }
      return x;
    }
  }
  return bitwise(x, y, function(a, b) {
    return a & b;
  });
}
function bitNotBigNumber(x) {
  if (x.isFinite() && !x.isInteger()) {
    throw new Error("Integer expected in function bitNot");
  }
  var BigNumber2 = x.constructor;
  var prevPrec = BigNumber2.precision;
  BigNumber2.config({
    precision: 1e9
  });
  var result = x.plus(new BigNumber2(1));
  result.s = -result.s || null;
  BigNumber2.config({
    precision: prevPrec
  });
  return result;
}
function bitOrBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function bitOr");
  }
  var BigNumber2 = x.constructor;
  if (x.isNaN() || y.isNaN()) {
    return new BigNumber2(NaN);
  }
  var negOne = new BigNumber2(-1);
  if (x.isZero() || y.eq(negOne) || x.eq(y)) {
    return y;
  }
  if (y.isZero() || x.eq(negOne)) {
    return x;
  }
  if (!x.isFinite() || !y.isFinite()) {
    if (!x.isFinite() && !x.isNegative() && y.isNegative() || x.isNegative() && !y.isNegative() && !y.isFinite()) {
      return negOne;
    }
    if (x.isNegative() && y.isNegative()) {
      return x.isFinite() ? x : y;
    }
    return x.isFinite() ? y : x;
  }
  return bitwise(x, y, function(a, b) {
    return a | b;
  });
}
function bitwise(x, y, func) {
  var BigNumber2 = x.constructor;
  var xBits, yBits;
  var xSign = +(x.s < 0);
  var ySign = +(y.s < 0);
  if (xSign) {
    xBits = decCoefficientToBinaryString(bitNotBigNumber(x));
    for (var i2 = 0; i2 < xBits.length; ++i2) {
      xBits[i2] ^= 1;
    }
  } else {
    xBits = decCoefficientToBinaryString(x);
  }
  if (ySign) {
    yBits = decCoefficientToBinaryString(bitNotBigNumber(y));
    for (var _i = 0; _i < yBits.length; ++_i) {
      yBits[_i] ^= 1;
    }
  } else {
    yBits = decCoefficientToBinaryString(y);
  }
  var minBits, maxBits, minSign;
  if (xBits.length <= yBits.length) {
    minBits = xBits;
    maxBits = yBits;
    minSign = xSign;
  } else {
    minBits = yBits;
    maxBits = xBits;
    minSign = ySign;
  }
  var shortLen = minBits.length;
  var longLen = maxBits.length;
  var expFuncVal = func(xSign, ySign) ^ 1;
  var outVal = new BigNumber2(expFuncVal ^ 1);
  var twoPower = new BigNumber2(1);
  var two = new BigNumber2(2);
  var prevPrec = BigNumber2.precision;
  BigNumber2.config({
    precision: 1e9
  });
  while (shortLen > 0) {
    if (func(minBits[--shortLen], maxBits[--longLen]) === expFuncVal) {
      outVal = outVal.plus(twoPower);
    }
    twoPower = twoPower.times(two);
  }
  while (longLen > 0) {
    if (func(minSign, maxBits[--longLen]) === expFuncVal) {
      outVal = outVal.plus(twoPower);
    }
    twoPower = twoPower.times(two);
  }
  BigNumber2.config({
    precision: prevPrec
  });
  if (expFuncVal === 0) {
    outVal.s = -outVal.s;
  }
  return outVal;
}
function decCoefficientToBinaryString(x) {
  var a = x.d;
  var r = a[0] + "";
  for (var i2 = 1; i2 < a.length; ++i2) {
    var s = a[i2] + "";
    for (var z = 7 - s.length; z--; ) {
      s = "0" + s;
    }
    r += s;
  }
  var j = r.length;
  while (r.charAt(j) === "0") {
    j--;
  }
  var xe = x.e;
  var str = r.slice(0, j + 1 || 1);
  var strL = str.length;
  if (xe > 0) {
    if (++xe > strL) {
      xe -= strL;
      while (xe--) {
        str += "0";
      }
    } else if (xe < strL) {
      str = str.slice(0, xe) + "." + str.slice(xe);
    }
  }
  var arr = [0];
  for (var _i2 = 0; _i2 < str.length; ) {
    var arrL = arr.length;
    while (arrL--) {
      arr[arrL] *= 10;
    }
    arr[0] += parseInt(str.charAt(_i2++));
    for (var _j = 0; _j < arr.length; ++_j) {
      if (arr[_j] > 1) {
        if (arr[_j + 1] === null || arr[_j + 1] === void 0) {
          arr[_j + 1] = 0;
        }
        arr[_j + 1] += arr[_j] >> 1;
        arr[_j] &= 1;
      }
    }
  }
  return arr.reverse();
}
function bitXor(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function bitXor");
  }
  var BigNumber2 = x.constructor;
  if (x.isNaN() || y.isNaN()) {
    return new BigNumber2(NaN);
  }
  if (x.isZero()) {
    return y;
  }
  if (y.isZero()) {
    return x;
  }
  if (x.eq(y)) {
    return new BigNumber2(0);
  }
  var negOne = new BigNumber2(-1);
  if (x.eq(negOne)) {
    return bitNotBigNumber(y);
  }
  if (y.eq(negOne)) {
    return bitNotBigNumber(x);
  }
  if (!x.isFinite() || !y.isFinite()) {
    if (!x.isFinite() && !y.isFinite()) {
      return negOne;
    }
    return new BigNumber2(x.isNegative() === y.isNegative() ? Infinity : -Infinity);
  }
  return bitwise(x, y, function(a, b) {
    return a ^ b;
  });
}
function leftShiftBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function leftShift");
  }
  var BigNumber2 = x.constructor;
  if (x.isNaN() || y.isNaN() || y.isNegative() && !y.isZero()) {
    return new BigNumber2(NaN);
  }
  if (x.isZero() || y.isZero()) {
    return x;
  }
  if (!x.isFinite() && !y.isFinite()) {
    return new BigNumber2(NaN);
  }
  if (y.lt(55)) {
    return x.times(Math.pow(2, y.toNumber()) + "");
  }
  return x.times(new BigNumber2(2).pow(y));
}
function rightArithShiftBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function rightArithShift");
  }
  var BigNumber2 = x.constructor;
  if (x.isNaN() || y.isNaN() || y.isNegative() && !y.isZero()) {
    return new BigNumber2(NaN);
  }
  if (x.isZero() || y.isZero()) {
    return x;
  }
  if (!y.isFinite()) {
    if (x.isNegative()) {
      return new BigNumber2(-1);
    }
    if (!x.isFinite()) {
      return new BigNumber2(NaN);
    }
    return new BigNumber2(0);
  }
  if (y.lt(55)) {
    return x.div(Math.pow(2, y.toNumber()) + "").floor();
  }
  return x.div(new BigNumber2(2).pow(y)).floor();
}

// node_modules/mathjs/lib/esm/function/bitwise/bitAnd.js
var name72 = "bitAnd";
var dependencies73 = ["typed", "matrix", "equalScalar", "concat"];
var createBitAnd = /* @__PURE__ */ factory(name72, dependencies73, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    equalScalar: equalScalar2,
    concat: concat3
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo06xS0S0 = createMatAlgo06xS0S0({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix: matrix2,
    concat: concat3
  });
  return typed3(name72, {
    "number, number": bitAndNumber,
    "BigNumber, BigNumber": bitAndBigNumber,
    "bigint, bigint": (x, y) => x & y
  }, matrixAlgorithmSuite({
    SS: matAlgo06xS0S0,
    DS: matAlgo02xDS0,
    Ss: matAlgo11xS0s
  }));
});

// node_modules/mathjs/lib/esm/function/bitwise/bitNot.js
var name73 = "bitNot";
var dependencies74 = ["typed"];
var createBitNot = /* @__PURE__ */ factory(name73, dependencies74, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name73, {
    number: bitNotNumber,
    BigNumber: bitNotBigNumber,
    bigint: (x) => ~x,
    "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});

// node_modules/mathjs/lib/esm/function/bitwise/bitOr.js
var name74 = "bitOr";
var dependencies75 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
var createBitOr = /* @__PURE__ */ factory(name74, dependencies75, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed3
  });
  var matAlgo04xSidSid = createMatAlgo04xSidSid({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix: matrix2,
    concat: concat3
  });
  return typed3(name74, {
    "number, number": bitOrNumber,
    "BigNumber, BigNumber": bitOrBigNumber,
    "bigint, bigint": (x, y) => x | y
  }, matrixAlgorithmSuite({
    SS: matAlgo04xSidSid,
    DS: matAlgo01xDSid,
    Ss: matAlgo10xSids
  }));
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo07xSSf.js
var name75 = "matAlgo07xSSf";
var dependencies76 = ["typed", "DenseMatrix"];
var createMatAlgo07xSSf = /* @__PURE__ */ factory(name75, dependencies76, (_ref) => {
  var {
    typed: typed3,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return function matAlgo07xSSf(a, b, callback) {
    var asize = a._size;
    var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    var bsize = b._size;
    var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
      dt = adt;
      zero = typed3.convert(0, dt);
      cf = typed3.find(callback, [dt, dt]);
    }
    var i2, j;
    var cdata = [];
    for (i2 = 0; i2 < rows; i2++) {
      cdata[i2] = [];
    }
    var xa = [];
    var xb = [];
    var wa = [];
    var wb = [];
    for (j = 0; j < columns; j++) {
      var mark = j + 1;
      _scatter(a, j, wa, xa, mark);
      _scatter(b, j, wb, xb, mark);
      for (i2 = 0; i2 < rows; i2++) {
        var va = wa[i2] === mark ? xa[i2] : zero;
        var vb = wb[i2] === mark ? xb[i2] : zero;
        cdata[i2][j] = cf(va, vb);
      }
    }
    return new DenseMatrix2({
      data: cdata,
      size: [rows, columns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
  };
  function _scatter(m, j, w, x, mark) {
    var values = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    for (var k = ptr[j], k1 = ptr[j + 1]; k < k1; k++) {
      var i2 = index2[k];
      w[i2] = mark;
      x[i2] = values[k];
    }
  }
});

// node_modules/mathjs/lib/esm/function/bitwise/bitXor.js
var name76 = "bitXor";
var dependencies77 = ["typed", "matrix", "DenseMatrix", "concat"];
var createBitXor = /* @__PURE__ */ factory(name76, dependencies77, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed3
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix: matrix2,
    concat: concat3
  });
  return typed3(name76, {
    "number, number": bitXorNumber,
    "BigNumber, BigNumber": bitXor,
    "bigint, bigint": (x, y) => x ^ y
  }, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});

// node_modules/mathjs/lib/esm/function/complex/arg.js
var name77 = "arg";
var dependencies78 = ["typed"];
var createArg = /* @__PURE__ */ factory(name77, dependencies78, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name77, {
    number: function number2(x) {
      return Math.atan2(0, x);
    },
    BigNumber: function BigNumber2(x) {
      return x.constructor.atan2(0, x);
    },
    Complex: function Complex3(x) {
      return x.arg();
    },
    // TODO: implement BigNumber support for function arg
    "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});

// node_modules/mathjs/lib/esm/function/complex/conj.js
var name78 = "conj";
var dependencies79 = ["typed"];
var createConj = /* @__PURE__ */ factory(name78, dependencies79, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name78, {
    "number | BigNumber | Fraction": (x) => x,
    Complex: (x) => x.conjugate(),
    "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});

// node_modules/mathjs/lib/esm/function/complex/im.js
var name79 = "im";
var dependencies80 = ["typed"];
var createIm = /* @__PURE__ */ factory(name79, dependencies80, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name79, {
    number: () => 0,
    "BigNumber | Fraction": (x) => x.mul(0),
    Complex: (x) => x.im,
    "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});

// node_modules/mathjs/lib/esm/function/complex/re.js
var name80 = "re";
var dependencies81 = ["typed"];
var createRe = /* @__PURE__ */ factory(name80, dependencies81, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name80, {
    "number | BigNumber | Fraction": (x) => x,
    Complex: (x) => x.re,
    "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});

// node_modules/mathjs/lib/esm/function/logical/not.js
var name81 = "not";
var dependencies82 = ["typed"];
var createNot = /* @__PURE__ */ factory(name81, dependencies82, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name81, {
    "null | undefined": () => true,
    number: notNumber,
    Complex: function Complex3(x) {
      return x.re === 0 && x.im === 0;
    },
    BigNumber: function BigNumber2(x) {
      return x.isZero() || x.isNaN();
    },
    bigint: (x) => !x,
    Unit: typed3.referToSelf((self2) => (x) => typed3.find(self2, x.valueType())(x.value)),
    "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});

// node_modules/mathjs/lib/esm/function/logical/or.js
var name82 = "or";
var dependencies83 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
var createOr = /* @__PURE__ */ factory(name82, dependencies83, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed3
  });
  var matAlgo05xSfSf = createMatAlgo05xSfSf({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix: matrix2,
    concat: concat3
  });
  return typed3(name82, {
    "number, number": orNumber,
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.re !== 0 || x.im !== 0 || y.re !== 0 || y.im !== 0;
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return !x.isZero() && !x.isNaN() || !y.isZero() && !y.isNaN();
    },
    "bigint, bigint": orNumber,
    "Unit, Unit": typed3.referToSelf((self2) => (x, y) => self2(x.value || 0, y.value || 0))
  }, matrixAlgorithmSuite({
    SS: matAlgo05xSfSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});

// node_modules/mathjs/lib/esm/function/logical/xor.js
var name83 = "xor";
var dependencies84 = ["typed", "matrix", "DenseMatrix", "concat"];
var createXor = /* @__PURE__ */ factory(name83, dependencies84, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed3
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix: matrix2,
    concat: concat3
  });
  return typed3(name83, {
    "number, number": xorNumber,
    "Complex, Complex": function ComplexComplex(x, y) {
      return (x.re !== 0 || x.im !== 0) !== (y.re !== 0 || y.im !== 0);
    },
    "bigint, bigint": xorNumber,
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return (!x.isZero() && !x.isNaN()) !== (!y.isZero() && !y.isNaN());
    },
    "Unit, Unit": typed3.referToSelf((self2) => (x, y) => self2(x.value || 0, y.value || 0))
  }, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});

// node_modules/mathjs/lib/esm/function/matrix/concat.js
var name84 = "concat";
var dependencies85 = ["typed", "matrix", "isInteger"];
var createConcat = /* @__PURE__ */ factory(name84, dependencies85, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    isInteger: isInteger3
  } = _ref;
  return typed3(name84, {
    // TODO: change signature to '...Array | Matrix, dim?' when supported
    "...Array | Matrix | number | BigNumber": function ArrayMatrixNumberBigNumber(args) {
      var i2;
      var len = args.length;
      var dim = -1;
      var prevDim;
      var asMatrix = false;
      var matrices = [];
      for (i2 = 0; i2 < len; i2++) {
        var arg2 = args[i2];
        if (isMatrix(arg2)) {
          asMatrix = true;
        }
        if (isNumber(arg2) || isBigNumber(arg2)) {
          if (i2 !== len - 1) {
            throw new Error("Dimension must be specified as last argument");
          }
          prevDim = dim;
          dim = arg2.valueOf();
          if (!isInteger3(dim)) {
            throw new TypeError("Integer number expected for dimension");
          }
          if (dim < 0 || i2 > 0 && dim > prevDim) {
            throw new IndexError(dim, prevDim + 1);
          }
        } else {
          var m = clone(arg2).valueOf();
          var size2 = arraySize(m);
          matrices[i2] = m;
          prevDim = dim;
          dim = size2.length - 1;
          if (i2 > 0 && dim !== prevDim) {
            throw new DimensionError(prevDim + 1, dim + 1);
          }
        }
      }
      if (matrices.length === 0) {
        throw new SyntaxError("At least one matrix expected");
      }
      var res = matrices.shift();
      while (matrices.length) {
        res = concat(res, matrices.shift(), dim);
      }
      return asMatrix ? matrix2(res) : res;
    },
    "...string": function string2(args) {
      return args.join("");
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/column.js
var name85 = "column";
var dependencies86 = ["typed", "Index", "matrix", "range"];
var createColumn = /* @__PURE__ */ factory(name85, dependencies86, (_ref) => {
  var {
    typed: typed3,
    Index: Index2,
    matrix: matrix2,
    range: range2
  } = _ref;
  return typed3(name85, {
    "Matrix, number": _column,
    "Array, number": function ArrayNumber(value, column2) {
      return _column(matrix2(clone(value)), column2).valueOf();
    }
  });
  function _column(value, column2) {
    if (value.size().length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(column2, value.size()[1]);
    var rowRange = range2(0, value.size()[0]);
    var index2 = new Index2(rowRange, column2);
    var result = value.subset(index2);
    return isMatrix(result) ? result : matrix2([[result]]);
  }
});

// node_modules/mathjs/lib/esm/function/matrix/count.js
var name86 = "count";
var dependencies87 = ["typed", "size", "prod"];
var createCount = /* @__PURE__ */ factory(name86, dependencies87, (_ref) => {
  var {
    typed: typed3,
    size: size2,
    prod: prod2
  } = _ref;
  return typed3(name86, {
    string: function string2(x) {
      return x.length;
    },
    "Matrix | Array": function MatrixArray(x) {
      return prod2(size2(x));
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/cross.js
var name87 = "cross";
var dependencies88 = ["typed", "matrix", "subtract", "multiply"];
var createCross = /* @__PURE__ */ factory(name87, dependencies88, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    subtract: subtract2,
    multiply: multiply2
  } = _ref;
  return typed3(name87, {
    "Matrix, Matrix": function MatrixMatrix(x, y) {
      return matrix2(_cross(x.toArray(), y.toArray()));
    },
    "Matrix, Array": function MatrixArray(x, y) {
      return matrix2(_cross(x.toArray(), y));
    },
    "Array, Matrix": function ArrayMatrix(x, y) {
      return matrix2(_cross(x, y.toArray()));
    },
    "Array, Array": _cross
  });
  function _cross(x, y) {
    var highestDimension = Math.max(arraySize(x).length, arraySize(y).length);
    x = squeeze(x);
    y = squeeze(y);
    var xSize = arraySize(x);
    var ySize = arraySize(y);
    if (xSize.length !== 1 || ySize.length !== 1 || xSize[0] !== 3 || ySize[0] !== 3) {
      throw new RangeError("Vectors with length 3 expected (Size A = [" + xSize.join(", ") + "], B = [" + ySize.join(", ") + "])");
    }
    var product3 = [subtract2(multiply2(x[1], y[2]), multiply2(x[2], y[1])), subtract2(multiply2(x[2], y[0]), multiply2(x[0], y[2])), subtract2(multiply2(x[0], y[1]), multiply2(x[1], y[0]))];
    if (highestDimension > 1) {
      return [product3];
    } else {
      return product3;
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/diag.js
var name88 = "diag";
var dependencies89 = ["typed", "matrix", "DenseMatrix", "SparseMatrix"];
var createDiag = /* @__PURE__ */ factory(name88, dependencies89, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  return typed3(name88, {
    // FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments
    Array: function Array2(x) {
      return _diag(x, 0, arraySize(x), null);
    },
    "Array, number": function ArrayNumber(x, k) {
      return _diag(x, k, arraySize(x), null);
    },
    "Array, BigNumber": function ArrayBigNumber(x, k) {
      return _diag(x, k.toNumber(), arraySize(x), null);
    },
    "Array, string": function ArrayString(x, format5) {
      return _diag(x, 0, arraySize(x), format5);
    },
    "Array, number, string": function ArrayNumberString(x, k, format5) {
      return _diag(x, k, arraySize(x), format5);
    },
    "Array, BigNumber, string": function ArrayBigNumberString(x, k, format5) {
      return _diag(x, k.toNumber(), arraySize(x), format5);
    },
    Matrix: function Matrix2(x) {
      return _diag(x, 0, x.size(), x.storage());
    },
    "Matrix, number": function MatrixNumber(x, k) {
      return _diag(x, k, x.size(), x.storage());
    },
    "Matrix, BigNumber": function MatrixBigNumber(x, k) {
      return _diag(x, k.toNumber(), x.size(), x.storage());
    },
    "Matrix, string": function MatrixString(x, format5) {
      return _diag(x, 0, x.size(), format5);
    },
    "Matrix, number, string": function MatrixNumberString(x, k, format5) {
      return _diag(x, k, x.size(), format5);
    },
    "Matrix, BigNumber, string": function MatrixBigNumberString(x, k, format5) {
      return _diag(x, k.toNumber(), x.size(), format5);
    }
  });
  function _diag(x, k, size2, format5) {
    if (!isInteger(k)) {
      throw new TypeError("Second parameter in function diag must be an integer");
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    switch (size2.length) {
      case 1:
        return _createDiagonalMatrix(x, k, format5, size2[0], kSub, kSuper);
      case 2:
        return _getDiagonal(x, k, format5, size2, kSub, kSuper);
    }
    throw new RangeError("Matrix for function diag must be 2 dimensional");
  }
  function _createDiagonalMatrix(x, k, format5, l, kSub, kSuper) {
    var ms = [l + kSub, l + kSuper];
    if (format5 && format5 !== "sparse" && format5 !== "dense") {
      throw new TypeError("Unknown matrix type ".concat(format5, '"'));
    }
    var m = format5 === "sparse" ? SparseMatrix2.diagonal(ms, x, k) : DenseMatrix2.diagonal(ms, x, k);
    return format5 !== null ? m : m.valueOf();
  }
  function _getDiagonal(x, k, format5, s, kSub, kSuper) {
    if (isMatrix(x)) {
      var dm = x.diagonal(k);
      if (format5 !== null) {
        if (format5 !== dm.storage()) {
          return matrix2(dm, format5);
        }
        return dm;
      }
      return dm.valueOf();
    }
    var n = Math.min(s[0] - kSub, s[1] - kSuper);
    var vector = [];
    for (var i2 = 0; i2 < n; i2++) {
      vector[i2] = x[i2 + kSub][i2 + kSuper];
    }
    return format5 !== null ? matrix2(vector) : vector;
  }
});

// node_modules/mathjs/lib/esm/utils/applyCallback.js
var import_typed_function2 = __toESM(require_typed_function(), 1);
function applyCallback(callback, value, index2, array, mappingFnName) {
  if (import_typed_function2.default.isTypedFunction(callback)) {
    var args3 = [value, index2, array];
    var signature3 = import_typed_function2.default.resolve(callback, args3);
    if (signature3) {
      return tryWithArgs(signature3.implementation, args3);
    }
    var args2 = [value, index2];
    var signature2 = import_typed_function2.default.resolve(callback, args2);
    if (signature2) {
      return tryWithArgs(signature2.implementation, args2);
    }
    var args1 = [value];
    var signature1 = import_typed_function2.default.resolve(callback, args1);
    if (signature1) {
      return tryWithArgs(signature1.implementation, args1);
    }
    return tryWithArgs(callback, args3);
  } else {
    return callback(value, index2, array);
  }
  function tryWithArgs(signature, args) {
    try {
      return signature.apply(signature, args);
    } catch (err) {
      var _err$data;
      if (err instanceof TypeError && ((_err$data = err.data) === null || _err$data === void 0 ? void 0 : _err$data.category) === "wrongType") {
        var argsDesc = [];
        argsDesc.push("value: ".concat(typeOf(value)));
        if (args.length >= 2) {
          argsDesc.push("index: ".concat(typeOf(index2)));
        }
        if (args.length >= 3) {
          argsDesc.push("array: ".concat(typeOf(array)));
        }
        throw new TypeError("Function ".concat(mappingFnName, " cannot apply callback arguments ") + "".concat(callback.name, "(").concat(argsDesc.join(", "), ") at index ").concat(JSON.stringify(index2)));
      } else {
        throw new TypeError("Function ".concat(mappingFnName, " cannot apply callback arguments ") + "to function ".concat(callback.name, ": ").concat(err.message));
      }
    }
  }
}

// node_modules/mathjs/lib/esm/function/matrix/filter.js
var name89 = "filter";
var dependencies90 = ["typed"];
var createFilter = /* @__PURE__ */ factory(name89, dependencies90, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3("filter", {
    "Array, function": _filterCallback,
    "Matrix, function": function MatrixFunction(x, test) {
      return x.create(_filterCallback(x.toArray(), test));
    },
    "Array, RegExp": filterRegExp,
    "Matrix, RegExp": function MatrixRegExp(x, test) {
      return x.create(filterRegExp(x.toArray(), test));
    }
  });
});
function _filterCallback(x, callback) {
  return filter(x, function(value, index2, array) {
    return applyCallback(callback, value, [index2], array, "filter");
  });
}

// node_modules/mathjs/lib/esm/function/matrix/flatten.js
var name90 = "flatten";
var dependencies91 = ["typed", "matrix"];
var createFlatten = /* @__PURE__ */ factory(name90, dependencies91, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2
  } = _ref;
  return typed3(name90, {
    Array: function Array2(x) {
      return flatten(x);
    },
    Matrix: function Matrix2(x) {
      var flat = flatten(x.toArray());
      return matrix2(flat);
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/forEach.js
var name91 = "forEach";
var dependencies92 = ["typed"];
var createForEach = /* @__PURE__ */ factory(name91, dependencies92, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name91, {
    "Array, function": _forEach,
    "Matrix, function": function MatrixFunction(x, callback) {
      x.forEach(callback);
    }
  });
});
function _forEach(array, callback) {
  var recurse = function recurse2(value, index2) {
    if (Array.isArray(value)) {
      forEach(value, function(child, i2) {
        recurse2(child, index2.concat(i2));
      });
    } else {
      return applyCallback(callback, value, index2, array, "forEach");
    }
  };
  recurse(array, []);
}

// node_modules/mathjs/lib/esm/function/matrix/getMatrixDataType.js
var name92 = "getMatrixDataType";
var dependencies93 = ["typed"];
var createGetMatrixDataType = /* @__PURE__ */ factory(name92, dependencies93, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name92, {
    Array: function Array2(x) {
      return getArrayDataType(x, typeOf);
    },
    Matrix: function Matrix2(x) {
      return x.getDataType();
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/identity.js
var name93 = "identity";
var dependencies94 = ["typed", "config", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix"];
var createIdentity = /* @__PURE__ */ factory(name93, dependencies94, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    matrix: matrix2,
    BigNumber: BigNumber2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  return typed3(name93, {
    "": function _() {
      return config5.matrix === "Matrix" ? matrix2([]) : [];
    },
    string: function string2(format5) {
      return matrix2(format5);
    },
    "number | BigNumber": function numberBigNumber(rows) {
      return _identity(rows, rows, config5.matrix === "Matrix" ? "dense" : void 0);
    },
    "number | BigNumber, string": function numberBigNumberString(rows, format5) {
      return _identity(rows, rows, format5);
    },
    "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(rows, cols) {
      return _identity(rows, cols, config5.matrix === "Matrix" ? "dense" : void 0);
    },
    "number | BigNumber, number | BigNumber, string": function numberBigNumberNumberBigNumberString(rows, cols, format5) {
      return _identity(rows, cols, format5);
    },
    Array: function Array2(size2) {
      return _identityVector(size2);
    },
    "Array, string": function ArrayString(size2, format5) {
      return _identityVector(size2, format5);
    },
    Matrix: function Matrix2(size2) {
      return _identityVector(size2.valueOf(), size2.storage());
    },
    "Matrix, string": function MatrixString(size2, format5) {
      return _identityVector(size2.valueOf(), format5);
    }
  });
  function _identityVector(size2, format5) {
    switch (size2.length) {
      case 0:
        return format5 ? matrix2(format5) : [];
      case 1:
        return _identity(size2[0], size2[0], format5);
      case 2:
        return _identity(size2[0], size2[1], format5);
      default:
        throw new Error("Vector containing two values expected");
    }
  }
  function _identity(rows, cols, format5) {
    var Big = isBigNumber(rows) || isBigNumber(cols) ? BigNumber2 : null;
    if (isBigNumber(rows))
      rows = rows.toNumber();
    if (isBigNumber(cols))
      cols = cols.toNumber();
    if (!isInteger(rows) || rows < 1) {
      throw new Error("Parameters in function identity must be positive integers");
    }
    if (!isInteger(cols) || cols < 1) {
      throw new Error("Parameters in function identity must be positive integers");
    }
    var one = Big ? new BigNumber2(1) : 1;
    var defaultValue = Big ? new Big(0) : 0;
    var size2 = [rows, cols];
    if (format5) {
      if (format5 === "sparse") {
        return SparseMatrix2.diagonal(size2, one, 0, defaultValue);
      }
      if (format5 === "dense") {
        return DenseMatrix2.diagonal(size2, one, 0, defaultValue);
      }
      throw new TypeError('Unknown matrix type "'.concat(format5, '"'));
    }
    var res = resize([], size2, defaultValue);
    var minimum = rows < cols ? rows : cols;
    for (var d = 0; d < minimum; d++) {
      res[d][d] = one;
    }
    return res;
  }
});

// node_modules/mathjs/lib/esm/function/matrix/kron.js
var name94 = "kron";
var dependencies95 = ["typed", "matrix", "multiplyScalar"];
var createKron = /* @__PURE__ */ factory(name94, dependencies95, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    multiplyScalar: multiplyScalar2
  } = _ref;
  return typed3(name94, {
    "Matrix, Matrix": function MatrixMatrix(x, y) {
      return matrix2(_kron(x.toArray(), y.toArray()));
    },
    "Matrix, Array": function MatrixArray(x, y) {
      return matrix2(_kron(x.toArray(), y));
    },
    "Array, Matrix": function ArrayMatrix(x, y) {
      return matrix2(_kron(x, y.toArray()));
    },
    "Array, Array": _kron
  });
  function _kron(a, b) {
    if (arraySize(a).length === 1) {
      a = [a];
    }
    if (arraySize(b).length === 1) {
      b = [b];
    }
    if (arraySize(a).length > 2 || arraySize(b).length > 2) {
      throw new RangeError("Vectors with dimensions greater then 2 are not supported expected (Size x = " + JSON.stringify(a.length) + ", y = " + JSON.stringify(b.length) + ")");
    }
    var t = [];
    var r = [];
    return a.map(function(a2) {
      return b.map(function(b2) {
        r = [];
        t.push(r);
        return a2.map(function(y) {
          return b2.map(function(x) {
            return r.push(multiplyScalar2(y, x));
          });
        });
      });
    }) && t;
  }
});

// node_modules/mathjs/lib/esm/function/matrix/map.js
var name95 = "map";
var dependencies96 = ["typed"];
var createMap2 = /* @__PURE__ */ factory(name95, dependencies96, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name95, {
    "Array, function": _map,
    "Matrix, function": function MatrixFunction(x, callback) {
      return x.map(callback);
    }
  });
});
function _map(array, callback) {
  var recurse = function recurse2(value, index2) {
    if (Array.isArray(value)) {
      return value.map(function(child, i2) {
        return recurse2(child, index2.concat(i2));
      });
    } else {
      return applyCallback(callback, value, index2, array, "map");
    }
  };
  return recurse(array, []);
}

// node_modules/mathjs/lib/esm/function/matrix/diff.js
var name96 = "diff";
var dependencies97 = ["typed", "matrix", "subtract", "number"];
var createDiff = /* @__PURE__ */ factory(name96, dependencies97, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    subtract: subtract2,
    number: number2
  } = _ref;
  return typed3(name96, {
    "Array | Matrix": function ArrayMatrix(arr) {
      if (isMatrix(arr)) {
        return matrix2(_diff(arr.toArray()));
      } else {
        return _diff(arr);
      }
    },
    "Array | Matrix, number": function ArrayMatrixNumber(arr, dim) {
      if (!isInteger(dim))
        throw new RangeError("Dimension must be a whole number");
      if (isMatrix(arr)) {
        return matrix2(_recursive(arr.toArray(), dim));
      } else {
        return _recursive(arr, dim);
      }
    },
    "Array, BigNumber": typed3.referTo("Array,number", (selfAn) => (arr, dim) => selfAn(arr, number2(dim))),
    "Matrix, BigNumber": typed3.referTo("Matrix,number", (selfMn) => (arr, dim) => selfMn(arr, number2(dim)))
  });
  function _recursive(arr, dim) {
    if (isMatrix(arr)) {
      arr = arr.toArray();
    }
    if (!Array.isArray(arr)) {
      throw RangeError("Array/Matrix does not have that many dimensions");
    }
    if (dim > 0) {
      var result = [];
      arr.forEach((element) => {
        result.push(_recursive(element, dim - 1));
      });
      return result;
    } else if (dim === 0) {
      return _diff(arr);
    } else {
      throw RangeError("Cannot have negative dimension");
    }
  }
  function _diff(arr) {
    var result = [];
    var size2 = arr.length;
    for (var i2 = 1; i2 < size2; i2++) {
      result.push(_ElementDiff(arr[i2 - 1], arr[i2]));
    }
    return result;
  }
  function _ElementDiff(obj1, obj2) {
    if (isMatrix(obj1))
      obj1 = obj1.toArray();
    if (isMatrix(obj2))
      obj2 = obj2.toArray();
    var obj1IsArray = Array.isArray(obj1);
    var obj2IsArray = Array.isArray(obj2);
    if (obj1IsArray && obj2IsArray) {
      return _ArrayDiff(obj1, obj2);
    }
    if (!obj1IsArray && !obj2IsArray) {
      return subtract2(obj2, obj1);
    }
    throw TypeError("Cannot calculate difference between 1 array and 1 non-array");
  }
  function _ArrayDiff(arr1, arr2) {
    if (arr1.length !== arr2.length) {
      throw RangeError("Not all sub-arrays have the same length");
    }
    var result = [];
    var size2 = arr1.length;
    for (var i2 = 0; i2 < size2; i2++) {
      result.push(_ElementDiff(arr1[i2], arr2[i2]));
    }
    return result;
  }
});

// node_modules/mathjs/lib/esm/function/matrix/ones.js
var name97 = "ones";
var dependencies98 = ["typed", "config", "matrix", "BigNumber"];
var createOnes = /* @__PURE__ */ factory(name97, dependencies98, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    matrix: matrix2,
    BigNumber: BigNumber2
  } = _ref;
  return typed3("ones", {
    "": function _() {
      return config5.matrix === "Array" ? _ones([]) : _ones([], "default");
    },
    // math.ones(m, n, p, ..., format)
    // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
    "...number | BigNumber | string": function numberBigNumberString(size2) {
      var last = size2[size2.length - 1];
      if (typeof last === "string") {
        var format5 = size2.pop();
        return _ones(size2, format5);
      } else if (config5.matrix === "Array") {
        return _ones(size2);
      } else {
        return _ones(size2, "default");
      }
    },
    Array: _ones,
    Matrix: function Matrix2(size2) {
      var format5 = size2.storage();
      return _ones(size2.valueOf(), format5);
    },
    "Array | Matrix, string": function ArrayMatrixString(size2, format5) {
      return _ones(size2.valueOf(), format5);
    }
  });
  function _ones(size2, format5) {
    var hasBigNumbers = _normalize(size2);
    var defaultValue = hasBigNumbers ? new BigNumber2(1) : 1;
    _validate2(size2);
    if (format5) {
      var m = matrix2(format5);
      if (size2.length > 0) {
        return m.resize(size2, defaultValue);
      }
      return m;
    } else {
      var arr = [];
      if (size2.length > 0) {
        return resize(arr, size2, defaultValue);
      }
      return arr;
    }
  }
  function _normalize(size2) {
    var hasBigNumbers = false;
    size2.forEach(function(value, index2, arr) {
      if (isBigNumber(value)) {
        hasBigNumbers = true;
        arr[index2] = value.toNumber();
      }
    });
    return hasBigNumbers;
  }
  function _validate2(size2) {
    size2.forEach(function(value) {
      if (typeof value !== "number" || !isInteger(value) || value < 0) {
        throw new Error("Parameters in function ones must be positive integers");
      }
    });
  }
});

// node_modules/mathjs/lib/esm/utils/noop.js
function noBignumber() {
  throw new Error('No "bignumber" implementation available');
}
function noFraction() {
  throw new Error('No "fraction" implementation available');
}
function noMatrix() {
  throw new Error('No "matrix" implementation available');
}

// node_modules/mathjs/lib/esm/function/matrix/range.js
var name98 = "range";
var dependencies99 = ["typed", "config", "?matrix", "?bignumber", "smaller", "smallerEq", "larger", "largerEq", "add", "isPositive"];
var createRange = /* @__PURE__ */ factory(name98, dependencies99, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    matrix: matrix2,
    bignumber: bignumber2,
    smaller: smaller2,
    smallerEq: smallerEq2,
    larger: larger2,
    largerEq: largerEq2,
    add: add3,
    isPositive: isPositive2
  } = _ref;
  return typed3(name98, {
    // TODO: simplify signatures when typed-function supports default values and optional arguments
    // TODO: a number or boolean should not be converted to string here
    string: _strRange,
    "string, boolean": _strRange,
    "number, number": function numberNumber(start, end) {
      return _out(_range(start, end, 1, false));
    },
    "number, number, number": function numberNumberNumber(start, end, step) {
      return _out(_range(start, end, step, false));
    },
    "number, number, boolean": function numberNumberBoolean(start, end, includeEnd) {
      return _out(_range(start, end, 1, includeEnd));
    },
    "number, number, number, boolean": function numberNumberNumberBoolean(start, end, step, includeEnd) {
      return _out(_range(start, end, step, includeEnd));
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(start, end) {
      var BigNumber2 = start.constructor;
      return _out(_range(start, end, new BigNumber2(1), false));
    },
    "BigNumber, BigNumber, BigNumber": function BigNumberBigNumberBigNumber(start, end, step) {
      return _out(_range(start, end, step, false));
    },
    "BigNumber, BigNumber, boolean": function BigNumberBigNumberBoolean(start, end, includeEnd) {
      var BigNumber2 = start.constructor;
      return _out(_range(start, end, new BigNumber2(1), includeEnd));
    },
    "BigNumber, BigNumber, BigNumber, boolean": function BigNumberBigNumberBigNumberBoolean(start, end, step, includeEnd) {
      return _out(_range(start, end, step, includeEnd));
    },
    "Unit, Unit, Unit": function UnitUnitUnit(start, end, step) {
      return _out(_range(start, end, step, false));
    },
    "Unit, Unit, Unit, boolean": function UnitUnitUnitBoolean(start, end, step, includeEnd) {
      return _out(_range(start, end, step, includeEnd));
    }
  });
  function _out(arr) {
    if (config5.matrix === "Matrix") {
      return matrix2 ? matrix2(arr) : noMatrix();
    }
    return arr;
  }
  function _strRange(str, includeEnd) {
    var r = _parse(str);
    if (!r) {
      throw new SyntaxError('String "' + str + '" is no valid range');
    }
    if (config5.number === "BigNumber") {
      if (bignumber2 === void 0) {
        noBignumber();
      }
      return _out(_range(bignumber2(r.start), bignumber2(r.end), bignumber2(r.step)), includeEnd);
    } else {
      return _out(_range(r.start, r.end, r.step, includeEnd));
    }
  }
  function _range(start, end, step, includeEnd) {
    var array = [];
    var ongoing = isPositive2(step) ? includeEnd ? smallerEq2 : smaller2 : includeEnd ? largerEq2 : larger2;
    var x = start;
    while (ongoing(x, end)) {
      array.push(x);
      x = add3(x, step);
    }
    return array;
  }
  function _parse(str) {
    var args = str.split(":");
    var nums = args.map(function(arg2) {
      return Number(arg2);
    });
    var invalid = nums.some(function(num) {
      return isNaN(num);
    });
    if (invalid) {
      return null;
    }
    switch (nums.length) {
      case 2:
        return {
          start: nums[0],
          end: nums[1],
          step: 1
        };
      case 3:
        return {
          start: nums[0],
          end: nums[2],
          step: nums[1]
        };
      default:
        return null;
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/reshape.js
var name99 = "reshape";
var dependencies100 = ["typed", "isInteger", "matrix"];
var createReshape = /* @__PURE__ */ factory(name99, dependencies100, (_ref) => {
  var {
    typed: typed3,
    isInteger: isInteger3
  } = _ref;
  return typed3(name99, {
    "Matrix, Array": function MatrixArray(x, sizes) {
      return x.reshape(sizes, true);
    },
    "Array, Array": function ArrayArray(x, sizes) {
      sizes.forEach(function(size2) {
        if (!isInteger3(size2)) {
          throw new TypeError("Invalid size for dimension: " + size2);
        }
      });
      return reshape(x, sizes);
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/resize.js
var name100 = "resize";
var dependencies101 = ["config", "matrix"];
var createResize = /* @__PURE__ */ factory(name100, dependencies101, (_ref) => {
  var {
    config: config5,
    matrix: matrix2
  } = _ref;
  return function resize3(x, size2, defaultValue) {
    if (arguments.length !== 2 && arguments.length !== 3) {
      throw new ArgumentsError("resize", arguments.length, 2, 3);
    }
    if (isMatrix(size2)) {
      size2 = size2.valueOf();
    }
    if (isBigNumber(size2[0])) {
      size2 = size2.map(function(value) {
        return !isBigNumber(value) ? value : value.toNumber();
      });
    }
    if (isMatrix(x)) {
      return x.resize(size2, defaultValue, true);
    }
    if (typeof x === "string") {
      return _resizeString(x, size2, defaultValue);
    }
    var asMatrix = Array.isArray(x) ? false : config5.matrix !== "Array";
    if (size2.length === 0) {
      while (Array.isArray(x)) {
        x = x[0];
      }
      return clone(x);
    } else {
      if (!Array.isArray(x)) {
        x = [x];
      }
      x = clone(x);
      var res = resize(x, size2, defaultValue);
      return asMatrix ? matrix2(res) : res;
    }
  };
  function _resizeString(str, size2, defaultChar) {
    if (defaultChar !== void 0) {
      if (typeof defaultChar !== "string" || defaultChar.length !== 1) {
        throw new TypeError("Single character expected as defaultValue");
      }
    } else {
      defaultChar = " ";
    }
    if (size2.length !== 1) {
      throw new DimensionError(size2.length, 1);
    }
    var len = size2[0];
    if (typeof len !== "number" || !isInteger(len)) {
      throw new TypeError("Invalid size, must contain positive integers (size: " + format3(size2) + ")");
    }
    if (str.length > len) {
      return str.substring(0, len);
    } else if (str.length < len) {
      var res = str;
      for (var i2 = 0, ii = len - str.length; i2 < ii; i2++) {
        res += defaultChar;
      }
      return res;
    } else {
      return str;
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/rotate.js
var name101 = "rotate";
var dependencies102 = ["typed", "multiply", "rotationMatrix"];
var createRotate = /* @__PURE__ */ factory(name101, dependencies102, (_ref) => {
  var {
    typed: typed3,
    multiply: multiply2,
    rotationMatrix: rotationMatrix2
  } = _ref;
  return typed3(name101, {
    "Array , number | BigNumber | Complex | Unit": function ArrayNumberBigNumberComplexUnit(w, theta) {
      _validateSize(w, 2);
      var matrixRes = multiply2(rotationMatrix2(theta), w);
      return matrixRes.toArray();
    },
    "Matrix , number | BigNumber | Complex | Unit": function MatrixNumberBigNumberComplexUnit(w, theta) {
      _validateSize(w, 2);
      return multiply2(rotationMatrix2(theta), w);
    },
    "Array, number | BigNumber | Complex | Unit, Array | Matrix": function ArrayNumberBigNumberComplexUnitArrayMatrix(w, theta, v) {
      _validateSize(w, 3);
      var matrixRes = multiply2(rotationMatrix2(theta, v), w);
      return matrixRes;
    },
    "Matrix, number | BigNumber | Complex | Unit, Array | Matrix": function MatrixNumberBigNumberComplexUnitArrayMatrix(w, theta, v) {
      _validateSize(w, 3);
      return multiply2(rotationMatrix2(theta, v), w);
    }
  });
  function _validateSize(v, expectedSize) {
    var actualSize = Array.isArray(v) ? arraySize(v) : v.size();
    if (actualSize.length > 2) {
      throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
    }
    if (actualSize.length === 2 && actualSize[1] !== 1) {
      throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
    }
    if (actualSize[0] !== expectedSize) {
      throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/rotationMatrix.js
var name102 = "rotationMatrix";
var dependencies103 = ["typed", "config", "multiplyScalar", "addScalar", "unaryMinus", "norm", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix", "cos", "sin"];
var createRotationMatrix = /* @__PURE__ */ factory(name102, dependencies103, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    multiplyScalar: multiplyScalar2,
    addScalar: addScalar2,
    unaryMinus: unaryMinus2,
    norm: norm2,
    BigNumber: BigNumber2,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2,
    cos: cos3,
    sin: sin3
  } = _ref;
  return typed3(name102, {
    "": function _() {
      return config5.matrix === "Matrix" ? matrix2([]) : [];
    },
    string: function string2(format5) {
      return matrix2(format5);
    },
    "number | BigNumber | Complex | Unit": function numberBigNumberComplexUnit(theta) {
      return _rotationMatrix2x2(theta, config5.matrix === "Matrix" ? "dense" : void 0);
    },
    "number | BigNumber | Complex | Unit, string": function numberBigNumberComplexUnitString(theta, format5) {
      return _rotationMatrix2x2(theta, format5);
    },
    "number | BigNumber | Complex | Unit, Array": function numberBigNumberComplexUnitArray(theta, v) {
      var matrixV = matrix2(v);
      _validateVector(matrixV);
      return _rotationMatrix3x3(theta, matrixV, void 0);
    },
    "number | BigNumber | Complex | Unit, Matrix": function numberBigNumberComplexUnitMatrix(theta, v) {
      _validateVector(v);
      var storageType = v.storage() || (config5.matrix === "Matrix" ? "dense" : void 0);
      return _rotationMatrix3x3(theta, v, storageType);
    },
    "number | BigNumber | Complex | Unit, Array, string": function numberBigNumberComplexUnitArrayString(theta, v, format5) {
      var matrixV = matrix2(v);
      _validateVector(matrixV);
      return _rotationMatrix3x3(theta, matrixV, format5);
    },
    "number | BigNumber | Complex | Unit, Matrix, string": function numberBigNumberComplexUnitMatrixString(theta, v, format5) {
      _validateVector(v);
      return _rotationMatrix3x3(theta, v, format5);
    }
  });
  function _rotationMatrix2x2(theta, format5) {
    var Big = isBigNumber(theta);
    var minusOne = Big ? new BigNumber2(-1) : -1;
    var cosTheta = cos3(theta);
    var sinTheta = sin3(theta);
    var data = [[cosTheta, multiplyScalar2(minusOne, sinTheta)], [sinTheta, cosTheta]];
    return _convertToFormat(data, format5);
  }
  function _validateVector(v) {
    var size2 = v.size();
    if (size2.length < 1 || size2[0] !== 3) {
      throw new RangeError("Vector must be of dimensions 1x3");
    }
  }
  function _mul(array) {
    return array.reduce((p, curr) => multiplyScalar2(p, curr));
  }
  function _convertToFormat(data, format5) {
    if (format5) {
      if (format5 === "sparse") {
        return new SparseMatrix2(data);
      }
      if (format5 === "dense") {
        return new DenseMatrix2(data);
      }
      throw new TypeError('Unknown matrix type "'.concat(format5, '"'));
    }
    return data;
  }
  function _rotationMatrix3x3(theta, v, format5) {
    var normV = norm2(v);
    if (normV === 0) {
      throw new RangeError("Rotation around zero vector");
    }
    var Big = isBigNumber(theta) ? BigNumber2 : null;
    var one = Big ? new Big(1) : 1;
    var minusOne = Big ? new Big(-1) : -1;
    var vx = Big ? new Big(v.get([0]) / normV) : v.get([0]) / normV;
    var vy = Big ? new Big(v.get([1]) / normV) : v.get([1]) / normV;
    var vz = Big ? new Big(v.get([2]) / normV) : v.get([2]) / normV;
    var c = cos3(theta);
    var oneMinusC = addScalar2(one, unaryMinus2(c));
    var s = sin3(theta);
    var r11 = addScalar2(c, _mul([vx, vx, oneMinusC]));
    var r12 = addScalar2(_mul([vx, vy, oneMinusC]), _mul([minusOne, vz, s]));
    var r13 = addScalar2(_mul([vx, vz, oneMinusC]), _mul([vy, s]));
    var r21 = addScalar2(_mul([vx, vy, oneMinusC]), _mul([vz, s]));
    var r22 = addScalar2(c, _mul([vy, vy, oneMinusC]));
    var r23 = addScalar2(_mul([vy, vz, oneMinusC]), _mul([minusOne, vx, s]));
    var r31 = addScalar2(_mul([vx, vz, oneMinusC]), _mul([minusOne, vy, s]));
    var r32 = addScalar2(_mul([vy, vz, oneMinusC]), _mul([vx, s]));
    var r33 = addScalar2(c, _mul([vz, vz, oneMinusC]));
    var data = [[r11, r12, r13], [r21, r22, r23], [r31, r32, r33]];
    return _convertToFormat(data, format5);
  }
});

// node_modules/mathjs/lib/esm/function/matrix/row.js
var name103 = "row";
var dependencies104 = ["typed", "Index", "matrix", "range"];
var createRow = /* @__PURE__ */ factory(name103, dependencies104, (_ref) => {
  var {
    typed: typed3,
    Index: Index2,
    matrix: matrix2,
    range: range2
  } = _ref;
  return typed3(name103, {
    "Matrix, number": _row,
    "Array, number": function ArrayNumber(value, row2) {
      return _row(matrix2(clone(value)), row2).valueOf();
    }
  });
  function _row(value, row2) {
    if (value.size().length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(row2, value.size()[0]);
    var columnRange = range2(0, value.size()[1]);
    var index2 = new Index2(row2, columnRange);
    var result = value.subset(index2);
    return isMatrix(result) ? result : matrix2([[result]]);
  }
});

// node_modules/mathjs/lib/esm/function/matrix/size.js
var name104 = "size";
var dependencies105 = ["typed", "config", "?matrix"];
var createSize = /* @__PURE__ */ factory(name104, dependencies105, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    matrix: matrix2
  } = _ref;
  return typed3(name104, {
    Matrix: function Matrix2(x) {
      return x.create(x.size());
    },
    Array: arraySize,
    string: function string2(x) {
      return config5.matrix === "Array" ? [x.length] : matrix2([x.length]);
    },
    "number | Complex | BigNumber | Unit | boolean | null": function numberComplexBigNumberUnitBooleanNull(x) {
      return config5.matrix === "Array" ? [] : matrix2 ? matrix2([]) : noMatrix();
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/squeeze.js
var name105 = "squeeze";
var dependencies106 = ["typed", "matrix"];
var createSqueeze = /* @__PURE__ */ factory(name105, dependencies106, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2
  } = _ref;
  return typed3(name105, {
    Array: function Array2(x) {
      return squeeze(clone(x));
    },
    Matrix: function Matrix2(x) {
      var res = squeeze(x.toArray());
      return Array.isArray(res) ? matrix2(res) : res;
    },
    any: function any(x) {
      return clone(x);
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/subset.js
var name106 = "subset";
var dependencies107 = ["typed", "matrix", "zeros", "add"];
var createSubset = /* @__PURE__ */ factory(name106, dependencies107, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    zeros: zeros3,
    add: add3
  } = _ref;
  return typed3(name106, {
    // get subset
    "Matrix, Index": function MatrixIndex(value, index2) {
      if (isEmptyIndex(index2)) {
        return matrix2();
      }
      validateIndexSourceSize(value, index2);
      return value.subset(index2);
    },
    "Array, Index": typed3.referTo("Matrix, Index", function(subsetRef) {
      return function(value, index2) {
        var subsetResult = subsetRef(matrix2(value), index2);
        return index2.isScalar() ? subsetResult : subsetResult.valueOf();
      };
    }),
    "Object, Index": _getObjectProperty,
    "string, Index": _getSubstring,
    // set subset
    "Matrix, Index, any, any": function MatrixIndexAnyAny(value, index2, replacement, defaultValue) {
      if (isEmptyIndex(index2)) {
        return value;
      }
      validateIndexSourceSize(value, index2);
      return value.clone().subset(index2, _broadcastReplacement(replacement, index2), defaultValue);
    },
    "Array, Index, any, any": typed3.referTo("Matrix, Index, any, any", function(subsetRef) {
      return function(value, index2, replacement, defaultValue) {
        var subsetResult = subsetRef(matrix2(value), index2, replacement, defaultValue);
        return subsetResult.isMatrix ? subsetResult.valueOf() : subsetResult;
      };
    }),
    "Array, Index, any": typed3.referTo("Matrix, Index, any, any", function(subsetRef) {
      return function(value, index2, replacement) {
        return subsetRef(matrix2(value), index2, replacement, void 0).valueOf();
      };
    }),
    "Matrix, Index, any": typed3.referTo("Matrix, Index, any, any", function(subsetRef) {
      return function(value, index2, replacement) {
        return subsetRef(value, index2, replacement, void 0);
      };
    }),
    "string, Index, string": _setSubstring,
    "string, Index, string, string": _setSubstring,
    "Object, Index, any": _setObjectProperty
  });
  function _broadcastReplacement(replacement, index2) {
    if (typeof replacement === "string") {
      throw new Error("can't boradcast a string");
    }
    if (index2._isScalar) {
      return replacement;
    }
    var indexSize = index2.size();
    if (indexSize.every((d) => d > 0)) {
      try {
        return add3(replacement, zeros3(indexSize));
      } catch (error) {
        return replacement;
      }
    } else {
      return replacement;
    }
  }
});
function _getSubstring(str, index2) {
  if (!isIndex(index2)) {
    throw new TypeError("Index expected");
  }
  if (isEmptyIndex(index2)) {
    return "";
  }
  validateIndexSourceSize(Array.from(str), index2);
  if (index2.size().length !== 1) {
    throw new DimensionError(index2.size().length, 1);
  }
  var strLen = str.length;
  validateIndex(index2.min()[0], strLen);
  validateIndex(index2.max()[0], strLen);
  var range2 = index2.dimension(0);
  var substr = "";
  range2.forEach(function(v) {
    substr += str.charAt(v);
  });
  return substr;
}
function _setSubstring(str, index2, replacement, defaultValue) {
  if (!index2 || index2.isIndex !== true) {
    throw new TypeError("Index expected");
  }
  if (isEmptyIndex(index2)) {
    return str;
  }
  validateIndexSourceSize(Array.from(str), index2);
  if (index2.size().length !== 1) {
    throw new DimensionError(index2.size().length, 1);
  }
  if (defaultValue !== void 0) {
    if (typeof defaultValue !== "string" || defaultValue.length !== 1) {
      throw new TypeError("Single character expected as defaultValue");
    }
  } else {
    defaultValue = " ";
  }
  var range2 = index2.dimension(0);
  var len = range2.size()[0];
  if (len !== replacement.length) {
    throw new DimensionError(range2.size()[0], replacement.length);
  }
  var strLen = str.length;
  validateIndex(index2.min()[0]);
  validateIndex(index2.max()[0]);
  var chars = [];
  for (var i2 = 0; i2 < strLen; i2++) {
    chars[i2] = str.charAt(i2);
  }
  range2.forEach(function(v, i3) {
    chars[v] = replacement.charAt(i3[0]);
  });
  if (chars.length > strLen) {
    for (var _i = strLen - 1, _len = chars.length; _i < _len; _i++) {
      if (!chars[_i]) {
        chars[_i] = defaultValue;
      }
    }
  }
  return chars.join("");
}
function _getObjectProperty(object, index2) {
  if (isEmptyIndex(index2)) {
    return void 0;
  }
  if (index2.size().length !== 1) {
    throw new DimensionError(index2.size(), 1);
  }
  var key = index2.dimension(0);
  if (typeof key !== "string") {
    throw new TypeError("String expected as index to retrieve an object property");
  }
  return getSafeProperty(object, key);
}
function _setObjectProperty(object, index2, replacement) {
  if (isEmptyIndex(index2)) {
    return object;
  }
  if (index2.size().length !== 1) {
    throw new DimensionError(index2.size(), 1);
  }
  var key = index2.dimension(0);
  if (typeof key !== "string") {
    throw new TypeError("String expected as index to retrieve an object property");
  }
  var updated = clone(object);
  setSafeProperty(updated, key, replacement);
  return updated;
}

// node_modules/mathjs/lib/esm/function/matrix/transpose.js
var name107 = "transpose";
var dependencies108 = ["typed", "matrix"];
var createTranspose = /* @__PURE__ */ factory(name107, dependencies108, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2
  } = _ref;
  return typed3(name107, {
    Array: (x) => transposeMatrix(matrix2(x)).valueOf(),
    Matrix: transposeMatrix,
    any: clone
    // scalars
  });
  function transposeMatrix(x) {
    var size2 = x.size();
    var c;
    switch (size2.length) {
      case 1:
        c = x.clone();
        break;
      case 2:
        {
          var rows = size2[0];
          var columns = size2[1];
          if (columns === 0) {
            throw new RangeError("Cannot transpose a 2D matrix with no columns (size: " + format3(size2) + ")");
          }
          switch (x.storage()) {
            case "dense":
              c = _denseTranspose(x, rows, columns);
              break;
            case "sparse":
              c = _sparseTranspose(x, rows, columns);
              break;
          }
        }
        break;
      default:
        throw new RangeError("Matrix must be a vector or two dimensional (size: " + format3(size2) + ")");
    }
    return c;
  }
  function _denseTranspose(m, rows, columns) {
    var data = m._data;
    var transposed = [];
    var transposedRow;
    for (var j = 0; j < columns; j++) {
      transposedRow = transposed[j] = [];
      for (var i2 = 0; i2 < rows; i2++) {
        transposedRow[i2] = clone(data[i2][j]);
      }
    }
    return m.createDenseMatrix({
      data: transposed,
      size: [columns, rows],
      datatype: m._datatype
    });
  }
  function _sparseTranspose(m, rows, columns) {
    var values = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    var cvalues = values ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var w = [];
    for (var x = 0; x < rows; x++) {
      w[x] = 0;
    }
    var p, l, j;
    for (p = 0, l = index2.length; p < l; p++) {
      w[index2[p]]++;
    }
    var sum3 = 0;
    for (var i2 = 0; i2 < rows; i2++) {
      cptr.push(sum3);
      sum3 += w[i2];
      w[i2] = cptr[i2];
    }
    cptr.push(sum3);
    for (j = 0; j < columns; j++) {
      for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {
        var q = w[index2[k]]++;
        cindex[q] = j;
        if (values) {
          cvalues[q] = clone(values[k]);
        }
      }
    }
    return m.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [columns, rows],
      datatype: m._datatype
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/ctranspose.js
var name108 = "ctranspose";
var dependencies109 = ["typed", "transpose", "conj"];
var createCtranspose = /* @__PURE__ */ factory(name108, dependencies109, (_ref) => {
  var {
    typed: typed3,
    transpose: transpose2,
    conj: conj2
  } = _ref;
  return typed3(name108, {
    any: function any(x) {
      return conj2(transpose2(x));
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/zeros.js
var name109 = "zeros";
var dependencies110 = ["typed", "config", "matrix", "BigNumber"];
var createZeros = /* @__PURE__ */ factory(name109, dependencies110, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    matrix: matrix2,
    BigNumber: BigNumber2
  } = _ref;
  return typed3(name109, {
    "": function _() {
      return config5.matrix === "Array" ? _zeros([]) : _zeros([], "default");
    },
    // math.zeros(m, n, p, ..., format)
    // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
    "...number | BigNumber | string": function numberBigNumberString(size2) {
      var last = size2[size2.length - 1];
      if (typeof last === "string") {
        var format5 = size2.pop();
        return _zeros(size2, format5);
      } else if (config5.matrix === "Array") {
        return _zeros(size2);
      } else {
        return _zeros(size2, "default");
      }
    },
    Array: _zeros,
    Matrix: function Matrix2(size2) {
      var format5 = size2.storage();
      return _zeros(size2.valueOf(), format5);
    },
    "Array | Matrix, string": function ArrayMatrixString(size2, format5) {
      return _zeros(size2.valueOf(), format5);
    }
  });
  function _zeros(size2, format5) {
    var hasBigNumbers = _normalize(size2);
    var defaultValue = hasBigNumbers ? new BigNumber2(0) : 0;
    _validate2(size2);
    if (format5) {
      var m = matrix2(format5);
      if (size2.length > 0) {
        return m.resize(size2, defaultValue);
      }
      return m;
    } else {
      var arr = [];
      if (size2.length > 0) {
        return resize(arr, size2, defaultValue);
      }
      return arr;
    }
  }
  function _normalize(size2) {
    var hasBigNumbers = false;
    size2.forEach(function(value, index2, arr) {
      if (isBigNumber(value)) {
        hasBigNumbers = true;
        arr[index2] = value.toNumber();
      }
    });
    return hasBigNumbers;
  }
  function _validate2(size2) {
    size2.forEach(function(value) {
      if (typeof value !== "number" || !isInteger(value) || value < 0) {
        throw new Error("Parameters in function zeros must be positive integers");
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/fft.js
var name110 = "fft";
var dependencies111 = ["typed", "matrix", "addScalar", "multiplyScalar", "divideScalar", "exp", "tau", "i", "dotDivide", "conj", "pow", "ceil", "log2"];
var createFft = /* @__PURE__ */ factory(name110, dependencies111, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    addScalar: addScalar2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    exp: exp3,
    tau: tau3,
    i: I,
    dotDivide: dotDivide2,
    conj: conj2,
    pow: pow3,
    ceil: ceil3,
    log2: log25
  } = _ref;
  return typed3(name110, {
    Array: _ndFft,
    Matrix: function Matrix2(matrix3) {
      return matrix3.create(_ndFft(matrix3.toArray()));
    }
  });
  function _ndFft(arr) {
    var size2 = arraySize(arr);
    if (size2.length === 1)
      return _fft(arr, size2[0]);
    return _1dFft(arr.map((slice) => _ndFft(slice, size2.slice(1))), 0);
  }
  function _1dFft(arr, dim) {
    var size2 = arraySize(arr);
    if (dim !== 0)
      return new Array(size2[0]).fill(0).map((_, i2) => _1dFft(arr[i2], dim - 1));
    if (size2.length === 1)
      return _fft(arr);
    function _transpose(arr2) {
      var size3 = arraySize(arr2);
      return new Array(size3[1]).fill(0).map((_, j) => new Array(size3[0]).fill(0).map((_2, i2) => arr2[i2][j]));
    }
    return _transpose(_1dFft(_transpose(arr), 1));
  }
  function _czt(arr) {
    var n = arr.length;
    var w = exp3(divideScalar2(multiplyScalar2(-1, multiplyScalar2(I, tau3)), n));
    var chirp = [];
    for (var i2 = 1 - n; i2 < n; i2++) {
      chirp.push(pow3(w, divideScalar2(pow3(i2, 2), 2)));
    }
    var N2 = pow3(2, ceil3(log25(n + n - 1)));
    var xp = [...new Array(n).fill(0).map((_, i3) => multiplyScalar2(arr[i3], chirp[n - 1 + i3])), ...new Array(N2 - n).fill(0)];
    var ichirp = [...new Array(n + n - 1).fill(0).map((_, i3) => divideScalar2(1, chirp[i3])), ...new Array(N2 - (n + n - 1)).fill(0)];
    var fftXp = _fft(xp);
    var fftIchirp = _fft(ichirp);
    var fftProduct = new Array(N2).fill(0).map((_, i3) => multiplyScalar2(fftXp[i3], fftIchirp[i3]));
    var ifftProduct = dotDivide2(conj2(_ndFft(conj2(fftProduct))), N2);
    var ret = [];
    for (var _i = n - 1; _i < n + n - 1; _i++) {
      ret.push(multiplyScalar2(ifftProduct[_i], chirp[_i]));
    }
    return ret;
  }
  function _fft(arr) {
    var len = arr.length;
    if (len === 1)
      return [arr[0]];
    if (len % 2 === 0) {
      var ret = [..._fft(arr.filter((_, i2) => i2 % 2 === 0), len / 2), ..._fft(arr.filter((_, i2) => i2 % 2 === 1), len / 2)];
      for (var k = 0; k < len / 2; k++) {
        var p = ret[k];
        var q = multiplyScalar2(ret[k + len / 2], exp3(multiplyScalar2(multiplyScalar2(tau3, I), divideScalar2(-k, len))));
        ret[k] = addScalar2(p, q);
        ret[k + len / 2] = addScalar2(p, multiplyScalar2(-1, q));
      }
      return ret;
    } else {
      return _czt(arr);
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/ifft.js
var name111 = "ifft";
var dependencies112 = ["typed", "fft", "dotDivide", "conj"];
var createIfft = /* @__PURE__ */ factory(name111, dependencies112, (_ref) => {
  var {
    typed: typed3,
    fft: fft2,
    dotDivide: dotDivide2,
    conj: conj2
  } = _ref;
  return typed3(name111, {
    "Array | Matrix": function ArrayMatrix(arr) {
      var size2 = isMatrix(arr) ? arr.size() : arraySize(arr);
      return dotDivide2(conj2(fft2(conj2(arr))), size2.reduce((acc, curr) => acc * curr, 1));
    }
  });
});

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t)
    return t;
  var e3 = t[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t, r || "default");
    if ("object" != _typeof(i2))
      return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t) {
  var i2 = toPrimitive(t, "string");
  return "symbol" == _typeof(i2) ? i2 : i2 + "";
}

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(e3, r, t) {
  return (r = toPropertyKey(r)) in e3 ? Object.defineProperty(e3, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e3[r] = t, e3;
}

// node_modules/mathjs/lib/esm/function/numeric/solveODE.js
function ownKeys(e3, r) {
  var t = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e3);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e3, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e3) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e3, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e3, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e3;
}
var name112 = "solveODE";
var dependencies113 = ["typed", "add", "subtract", "multiply", "divide", "max", "map", "abs", "isPositive", "isNegative", "larger", "smaller", "matrix", "bignumber", "unaryMinus"];
var createSolveODE = /* @__PURE__ */ factory(name112, dependencies113, (_ref) => {
  var {
    typed: typed3,
    add: add3,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide3,
    max: max3,
    map: map3,
    abs: abs3,
    isPositive: isPositive2,
    isNegative: isNegative2,
    larger: larger2,
    smaller: smaller2,
    matrix: matrix2,
    bignumber: bignumber2,
    unaryMinus: unaryMinus2
  } = _ref;
  function _rk(butcherTableau) {
    return function(f, tspan, y0, options2) {
      var wrongTSpan = !(tspan.length === 2 && (tspan.every(isNumOrBig) || tspan.every(isUnit)));
      if (wrongTSpan) {
        throw new Error('"tspan" must be an Array of two numeric values or two units [tStart, tEnd]');
      }
      var t0 = tspan[0];
      var tf = tspan[1];
      var isForwards = larger2(tf, t0);
      var firstStep = options2.firstStep;
      if (firstStep !== void 0 && !isPositive2(firstStep)) {
        throw new Error('"firstStep" must be positive');
      }
      var maxStep = options2.maxStep;
      if (maxStep !== void 0 && !isPositive2(maxStep)) {
        throw new Error('"maxStep" must be positive');
      }
      var minStep = options2.minStep;
      if (minStep && isNegative2(minStep)) {
        throw new Error('"minStep" must be positive or zero');
      }
      var timeVars = [t0, tf, firstStep, minStep, maxStep].filter((x) => x !== void 0);
      if (!(timeVars.every(isNumOrBig) || timeVars.every(isUnit))) {
        throw new Error('Inconsistent type of "t" dependant variables');
      }
      var steps = 1;
      var tol = options2.tol ? options2.tol : 1e-4;
      var minDelta = options2.minDelta ? options2.minDelta : 0.2;
      var maxDelta = options2.maxDelta ? options2.maxDelta : 5;
      var maxIter = options2.maxIter ? options2.maxIter : 1e4;
      var hasBigNumbers = [t0, tf, ...y0, maxStep, minStep].some(isBigNumber);
      var [a, c, b, bp] = hasBigNumbers ? [bignumber2(butcherTableau.a), bignumber2(butcherTableau.c), bignumber2(butcherTableau.b), bignumber2(butcherTableau.bp)] : [butcherTableau.a, butcherTableau.c, butcherTableau.b, butcherTableau.bp];
      var h = firstStep ? isForwards ? firstStep : unaryMinus2(firstStep) : divide3(subtract2(tf, t0), steps);
      var t = [t0];
      var y = [y0];
      var deltaB = subtract2(b, bp);
      var n = 0;
      var iter = 0;
      var ongoing = _createOngoing(isForwards);
      var trimStep = _createTrimStep(isForwards);
      while (ongoing(t[n], tf)) {
        var k = [];
        h = trimStep(t[n], tf, h);
        k.push(f(t[n], y[n]));
        for (var i2 = 1; i2 < c.length; ++i2) {
          k.push(f(add3(t[n], multiply2(c[i2], h)), add3(y[n], multiply2(h, a[i2], k))));
        }
        var TE = max3(abs3(map3(multiply2(deltaB, k), (X) => isUnit(X) ? X.value : X)));
        if (TE < tol && tol / TE > 1 / 4) {
          t.push(add3(t[n], h));
          y.push(add3(y[n], multiply2(h, b, k)));
          n++;
        }
        var delta = 0.84 * (tol / TE) ** (1 / 5);
        if (smaller2(delta, minDelta)) {
          delta = minDelta;
        } else if (larger2(delta, maxDelta)) {
          delta = maxDelta;
        }
        delta = hasBigNumbers ? bignumber2(delta) : delta;
        h = multiply2(h, delta);
        if (maxStep && larger2(abs3(h), maxStep)) {
          h = isForwards ? maxStep : unaryMinus2(maxStep);
        } else if (minStep && smaller2(abs3(h), minStep)) {
          h = isForwards ? minStep : unaryMinus2(minStep);
        }
        iter++;
        if (iter > maxIter) {
          throw new Error("Maximum number of iterations reached, try changing options");
        }
      }
      return {
        t,
        y
      };
    };
  }
  function _rk23(f, tspan, y0, options2) {
    var a = [[], [1 / 2], [0, 3 / 4], [2 / 9, 1 / 3, 4 / 9]];
    var c = [null, 1 / 2, 3 / 4, 1];
    var b = [2 / 9, 1 / 3, 4 / 9, 0];
    var bp = [7 / 24, 1 / 4, 1 / 3, 1 / 8];
    var butcherTableau = {
      a,
      c,
      b,
      bp
    };
    return _rk(butcherTableau)(f, tspan, y0, options2);
  }
  function _rk45(f, tspan, y0, options2) {
    var a = [[], [1 / 5], [3 / 40, 9 / 40], [44 / 45, -56 / 15, 32 / 9], [19372 / 6561, -25360 / 2187, 64448 / 6561, -212 / 729], [9017 / 3168, -355 / 33, 46732 / 5247, 49 / 176, -5103 / 18656], [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84]];
    var c = [null, 1 / 5, 3 / 10, 4 / 5, 8 / 9, 1, 1];
    var b = [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84, 0];
    var bp = [5179 / 57600, 0, 7571 / 16695, 393 / 640, -92097 / 339200, 187 / 2100, 1 / 40];
    var butcherTableau = {
      a,
      c,
      b,
      bp
    };
    return _rk(butcherTableau)(f, tspan, y0, options2);
  }
  function _solveODE(f, tspan, y0, opt) {
    var method = opt.method ? opt.method : "RK45";
    var methods = {
      RK23: _rk23,
      RK45: _rk45
    };
    if (method.toUpperCase() in methods) {
      var methodOptions = _objectSpread({}, opt);
      delete methodOptions.method;
      return methods[method.toUpperCase()](f, tspan, y0, methodOptions);
    } else {
      var methodsWithQuotes = Object.keys(methods).map((x) => '"'.concat(x, '"'));
      var availableMethodsString = "".concat(methodsWithQuotes.slice(0, -1).join(", "), " and ").concat(methodsWithQuotes.slice(-1));
      throw new Error('Unavailable method "'.concat(method, '". Available methods are ').concat(availableMethodsString));
    }
  }
  function _createOngoing(isForwards) {
    return isForwards ? smaller2 : larger2;
  }
  function _createTrimStep(isForwards) {
    var outOfBounds = isForwards ? larger2 : smaller2;
    return function(t, tf, h) {
      var next = add3(t, h);
      return outOfBounds(next, tf) ? subtract2(tf, t) : h;
    };
  }
  function isNumOrBig(x) {
    return isBigNumber(x) || isNumber(x);
  }
  function _matrixSolveODE(f, T, y0, options2) {
    var sol = _solveODE(f, T.toArray(), y0.toArray(), options2);
    return {
      t: matrix2(sol.t),
      y: matrix2(sol.y)
    };
  }
  return typed3("solveODE", {
    "function, Array, Array, Object": _solveODE,
    "function, Matrix, Matrix, Object": _matrixSolveODE,
    "function, Array, Array": (f, T, y0) => _solveODE(f, T, y0, {}),
    "function, Matrix, Matrix": (f, T, y0) => _matrixSolveODE(f, T, y0, {}),
    "function, Array, number | BigNumber | Unit": (f, T, y0) => {
      var sol = _solveODE(f, T, [y0], {});
      return {
        t: sol.t,
        y: sol.y.map((Y) => Y[0])
      };
    },
    "function, Matrix, number | BigNumber | Unit": (f, T, y0) => {
      var sol = _solveODE(f, T.toArray(), [y0], {});
      return {
        t: matrix2(sol.t),
        y: matrix2(sol.y.map((Y) => Y[0]))
      };
    },
    "function, Array, number | BigNumber | Unit, Object": (f, T, y0, options2) => {
      var sol = _solveODE(f, T, [y0], options2);
      return {
        t: sol.t,
        y: sol.y.map((Y) => Y[0])
      };
    },
    "function, Matrix, number | BigNumber | Unit, Object": (f, T, y0, options2) => {
      var sol = _solveODE(f, T.toArray(), [y0], options2);
      return {
        t: matrix2(sol.t),
        y: matrix2(sol.y.map((Y) => Y[0]))
      };
    }
  });
});

// node_modules/mathjs/lib/esm/function/special/erf.js
var name113 = "erf";
var dependencies114 = ["typed"];
var createErf = /* @__PURE__ */ factory(name113, dependencies114, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3("name", {
    number: function number2(x) {
      var y = Math.abs(x);
      if (y >= MAX_NUM) {
        return sign(x);
      }
      if (y <= THRESH) {
        return sign(x) * erf1(y);
      }
      if (y <= 4) {
        return sign(x) * (1 - erfc2(y));
      }
      return sign(x) * (1 - erfc3(y));
    },
    "Array | Matrix": typed3.referToSelf((self2) => (n) => deepMap(n, self2))
    // TODO: For complex numbers, use the approximation for the Faddeeva function
    //  from "More Efficient Computation of the Complex Error Function" (AMS)
  });
  function erf1(y) {
    var ysq = y * y;
    var xnum = P3[0][4] * ysq;
    var xden = ysq;
    var i2;
    for (i2 = 0; i2 < 3; i2 += 1) {
      xnum = (xnum + P3[0][i2]) * ysq;
      xden = (xden + Q[0][i2]) * ysq;
    }
    return y * (xnum + P3[0][3]) / (xden + Q[0][3]);
  }
  function erfc2(y) {
    var xnum = P3[1][8] * y;
    var xden = y;
    var i2;
    for (i2 = 0; i2 < 7; i2 += 1) {
      xnum = (xnum + P3[1][i2]) * y;
      xden = (xden + Q[1][i2]) * y;
    }
    var result = (xnum + P3[1][7]) / (xden + Q[1][7]);
    var ysq = parseInt(y * 16) / 16;
    var del = (y - ysq) * (y + ysq);
    return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
  }
  function erfc3(y) {
    var ysq = 1 / (y * y);
    var xnum = P3[2][5] * ysq;
    var xden = ysq;
    var i2;
    for (i2 = 0; i2 < 4; i2 += 1) {
      xnum = (xnum + P3[2][i2]) * ysq;
      xden = (xden + Q[2][i2]) * ysq;
    }
    var result = ysq * (xnum + P3[2][4]) / (xden + Q[2][4]);
    result = (SQRPI - result) / y;
    ysq = parseInt(y * 16) / 16;
    var del = (y - ysq) * (y + ysq);
    return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
  }
});
var THRESH = 0.46875;
var SQRPI = 0.5641895835477563;
var P3 = [[3.1611237438705655, 113.86415415105016, 377.485237685302, 3209.3775891384694, 0.18577770618460315], [0.5641884969886701, 8.883149794388377, 66.11919063714163, 298.6351381974001, 881.952221241769, 1712.0476126340707, 2051.0783778260716, 1230.3393547979972, 21531153547440383e-24], [0.30532663496123236, 0.36034489994980445, 0.12578172611122926, 0.016083785148742275, 6587491615298378e-19, 0.016315387137302097]];
var Q = [[23.601290952344122, 244.02463793444417, 1282.6165260773723, 2844.236833439171], [15.744926110709835, 117.6939508913125, 537.1811018620099, 1621.3895745666903, 3290.7992357334597, 4362.619090143247, 3439.3676741437216, 1230.3393548037495], [2.568520192289822, 1.8729528499234604, 0.5279051029514285, 0.06051834131244132, 0.0023352049762686918]];
var MAX_NUM = Math.pow(2, 53);

// node_modules/mathjs/lib/esm/function/special/zeta.js
var name114 = "zeta";
var dependencies115 = ["typed", "config", "multiply", "pow", "divide", "factorial", "equal", "smallerEq", "isNegative", "gamma", "sin", "subtract", "add", "?Complex", "?BigNumber", "pi"];
var createZeta = /* @__PURE__ */ factory(name114, dependencies115, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    multiply: multiply2,
    pow: pow3,
    divide: divide3,
    factorial: factorial2,
    equal: equal2,
    smallerEq: smallerEq2,
    isNegative: isNegative2,
    gamma: gamma2,
    sin: sin3,
    subtract: subtract2,
    add: add3,
    Complex: Complex3,
    BigNumber: _BigNumber,
    pi: pi3
  } = _ref;
  return typed3(name114, {
    number: (s) => zetaNumeric(s, (value) => value, () => 20),
    BigNumber: (s) => zetaNumeric(s, (value) => new _BigNumber(value), () => {
      return Math.abs(Math.log10(config5.relTol));
    }),
    Complex: zetaComplex
  });
  function zetaNumeric(s, createValue, determineDigits) {
    if (equal2(s, 0)) {
      return createValue(-0.5);
    }
    if (equal2(s, 1)) {
      return createValue(NaN);
    }
    if (!isFinite(s)) {
      return isNegative2(s) ? createValue(NaN) : createValue(1);
    }
    return zeta2(s, createValue, determineDigits, (s2) => s2);
  }
  function zetaComplex(s) {
    if (s.re === 0 && s.im === 0) {
      return new Complex3(-0.5);
    }
    if (s.re === 1) {
      return new Complex3(NaN, NaN);
    }
    if (s.re === Infinity && s.im === 0) {
      return new Complex3(1);
    }
    if (s.im === Infinity || s.re === -Infinity) {
      return new Complex3(NaN, NaN);
    }
    return zeta2(s, (value) => value, (s2) => Math.round(1.3 * 15 + 0.9 * Math.abs(s2.im)), (s2) => s2.re);
  }
  function zeta2(s, createValue, determineDigits, getRe) {
    var n = determineDigits(s);
    if (getRe(s) > -(n - 1) / 2) {
      return f(s, createValue(n), createValue);
    } else {
      var c = multiply2(pow3(2, s), pow3(createValue(pi3), subtract2(s, 1)));
      c = multiply2(c, sin3(multiply2(divide3(createValue(pi3), 2), s)));
      c = multiply2(c, gamma2(subtract2(1, s)));
      return multiply2(c, zeta2(subtract2(1, s), createValue, determineDigits, getRe));
    }
  }
  function d(k, n) {
    var S = k;
    for (var j = k; smallerEq2(j, n); j = add3(j, 1)) {
      var factor = divide3(multiply2(factorial2(add3(n, subtract2(j, 1))), pow3(4, j)), multiply2(factorial2(subtract2(n, j)), factorial2(multiply2(2, j))));
      S = add3(S, factor);
    }
    return multiply2(n, S);
  }
  function f(s, n, createValue) {
    var c = divide3(1, multiply2(d(createValue(0), n), subtract2(1, pow3(2, subtract2(1, s)))));
    var S = createValue(0);
    for (var k = createValue(1); smallerEq2(k, n); k = add3(k, 1)) {
      S = add3(S, divide3(multiply2((-1) ** (k - 1), d(k, n)), pow3(k, s)));
    }
    return multiply2(c, S);
  }
});

// node_modules/mathjs/lib/esm/function/statistics/mode.js
var name115 = "mode";
var dependencies116 = ["typed", "isNaN", "isNumeric"];
var createMode = /* @__PURE__ */ factory(name115, dependencies116, (_ref) => {
  var {
    typed: typed3,
    isNaN: isNaN3,
    isNumeric: isNumeric2
  } = _ref;
  return typed3(name115, {
    "Array | Matrix": _mode,
    "...": function _(args) {
      return _mode(args);
    }
  });
  function _mode(values) {
    values = flatten(values.valueOf());
    var num = values.length;
    if (num === 0) {
      throw new Error("Cannot calculate mode of an empty array");
    }
    var count2 = {};
    var mode2 = [];
    var max3 = 0;
    for (var i2 = 0; i2 < values.length; i2++) {
      var value = values[i2];
      if (isNumeric2(value) && isNaN3(value)) {
        throw new Error("Cannot calculate mode of an array containing NaN values");
      }
      if (!(value in count2)) {
        count2[value] = 0;
      }
      count2[value]++;
      if (count2[value] === max3) {
        mode2.push(value);
      } else if (count2[value] > max3) {
        max3 = count2[value];
        mode2 = [value];
      }
    }
    return mode2;
  }
});

// node_modules/mathjs/lib/esm/function/statistics/utils/improveErrorMessage.js
function improveErrorMessage(err, fnName, value) {
  var details;
  if (String(err).includes("Unexpected type")) {
    details = arguments.length > 2 ? " (type: " + typeOf(value) + ", value: " + JSON.stringify(value) + ")" : " (type: " + err.data.actual + ")";
    return new TypeError("Cannot calculate " + fnName + ", unexpected type of argument" + details);
  }
  if (String(err).includes("complex numbers")) {
    details = arguments.length > 2 ? " (type: " + typeOf(value) + ", value: " + JSON.stringify(value) + ")" : "";
    return new TypeError("Cannot calculate " + fnName + ", no ordering relation is defined for complex numbers" + details);
  }
  return err;
}

// node_modules/mathjs/lib/esm/function/statistics/prod.js
var name116 = "prod";
var dependencies117 = ["typed", "config", "multiplyScalar", "numeric"];
var createProd = /* @__PURE__ */ factory(name116, dependencies117, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    multiplyScalar: multiplyScalar2,
    numeric: numeric3
  } = _ref;
  return typed3(name116, {
    // prod([a, b, c, d, ...])
    "Array | Matrix": _prod,
    // prod([a, b, c, d, ...], dim)
    "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
      throw new Error("prod(A, dim) is not yet supported");
    },
    // prod(a, b, c, d, ...)
    "...": function _(args) {
      return _prod(args);
    }
  });
  function _prod(array) {
    var prod2;
    deepForEach(array, function(value) {
      try {
        prod2 = prod2 === void 0 ? value : multiplyScalar2(prod2, value);
      } catch (err) {
        throw improveErrorMessage(err, "prod", value);
      }
    });
    if (typeof prod2 === "string") {
      prod2 = numeric3(prod2, safeNumberType(prod2, config5));
    }
    if (prod2 === void 0) {
      throw new Error("Cannot calculate prod of an empty array");
    }
    return prod2;
  }
});

// node_modules/mathjs/lib/esm/function/string/format.js
var name117 = "format";
var dependencies118 = ["typed"];
var createFormat = /* @__PURE__ */ factory(name117, dependencies118, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name117, {
    any: format3,
    "any, Object | function | number | BigNumber": format3
  });
});

// node_modules/mathjs/lib/esm/function/string/bin.js
var name118 = "bin";
var dependencies119 = ["typed", "format"];
var createBin = factory(name118, dependencies119, (_ref) => {
  var {
    typed: typed3,
    format: format5
  } = _ref;
  return typed3(name118, {
    "number | BigNumber": function numberBigNumber(n) {
      return format5(n, {
        notation: "bin"
      });
    },
    "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n, wordSize) {
      return format5(n, {
        notation: "bin",
        wordSize
      });
    }
  });
});

// node_modules/mathjs/lib/esm/function/string/oct.js
var name119 = "oct";
var dependencies120 = ["typed", "format"];
var createOct = factory(name119, dependencies120, (_ref) => {
  var {
    typed: typed3,
    format: format5
  } = _ref;
  return typed3(name119, {
    "number | BigNumber": function numberBigNumber(n) {
      return format5(n, {
        notation: "oct"
      });
    },
    "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n, wordSize) {
      return format5(n, {
        notation: "oct",
        wordSize
      });
    }
  });
});

// node_modules/mathjs/lib/esm/function/string/hex.js
var name120 = "hex";
var dependencies121 = ["typed", "format"];
var createHex = factory(name120, dependencies121, (_ref) => {
  var {
    typed: typed3,
    format: format5
  } = _ref;
  return typed3(name120, {
    "number | BigNumber": function numberBigNumber(n) {
      return format5(n, {
        notation: "hex"
      });
    },
    "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n, wordSize) {
      return format5(n, {
        notation: "hex",
        wordSize
      });
    }
  });
});

// node_modules/mathjs/lib/esm/utils/print.js
var printTemplate = /\$([\w.]+)/g;

// node_modules/mathjs/lib/esm/function/string/print.js
var name121 = "print";
var dependencies122 = ["typed"];
var createPrint = /* @__PURE__ */ factory(name121, dependencies122, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name121, {
    // note: Matrix will be converted automatically to an Array
    "string, Object | Array": _print,
    "string, Object | Array, number | Object": _print
  });
});
function _print(template, values, options2) {
  return template.replace(printTemplate, function(original, key) {
    var keys = key.split(".");
    var value = values[keys.shift()];
    if (value !== void 0 && value.isMatrix) {
      value = value.toArray();
    }
    while (keys.length && value !== void 0) {
      var k = keys.shift();
      value = k ? value[k] : value + ".";
    }
    if (value !== void 0) {
      if (!isString(value)) {
        return format3(value, options2);
      } else {
        return value;
      }
    }
    return original;
  });
}

// node_modules/mathjs/lib/esm/function/unit/to.js
var name122 = "to";
var dependencies123 = ["typed", "matrix", "concat"];
var createTo = /* @__PURE__ */ factory(name122, dependencies123, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    concat: concat3
  } = _ref;
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix: matrix2,
    concat: concat3
  });
  return typed3(name122, {
    "Unit, Unit | string": (x, unit2) => x.to(unit2)
  }, matrixAlgorithmSuite({
    Ds: true
  }));
});

// node_modules/mathjs/lib/esm/function/utils/isPrime.js
var name123 = "isPrime";
var dependencies124 = ["typed"];
var createIsPrime = /* @__PURE__ */ factory(name123, dependencies124, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name123, {
    number: function number2(x) {
      if (x <= 3) {
        return x > 1;
      }
      if (x % 2 === 0 || x % 3 === 0) {
        return false;
      }
      for (var i2 = 5; i2 * i2 <= x; i2 += 6) {
        if (x % i2 === 0 || x % (i2 + 2) === 0) {
          return false;
        }
      }
      return true;
    },
    bigint: function bigint2(x) {
      if (x <= 3n) {
        return x > 1n;
      }
      if (x % 2n === 0n || x % 3n === 0n) {
        return false;
      }
      for (var i2 = 5n; i2 * i2 <= x; i2 += 6n) {
        if (x % i2 === 0n || x % (i2 + 2n) === 0n) {
          return false;
        }
      }
      return true;
    },
    BigNumber: function BigNumber2(n) {
      if (n.lte(3))
        return n.gt(1);
      if (n.mod(2).eq(0) || n.mod(3).eq(0))
        return false;
      if (n.lt(Math.pow(2, 32))) {
        var x = n.toNumber();
        for (var i2 = 5; i2 * i2 <= x; i2 += 6) {
          if (x % i2 === 0 || x % (i2 + 2) === 0) {
            return false;
          }
        }
        return true;
      }
      function modPow(base, exponent, modulus) {
        var accumulator = 1;
        while (!exponent.eq(0)) {
          if (exponent.mod(2).eq(0)) {
            exponent = exponent.div(2);
            base = base.mul(base).mod(modulus);
          } else {
            exponent = exponent.sub(1);
            accumulator = base.mul(accumulator).mod(modulus);
          }
        }
        return accumulator;
      }
      var Decimal2 = n.constructor.clone({
        precision: n.toFixed(0).length * 2
      });
      n = new Decimal2(n);
      var r = 0;
      var d = n.sub(1);
      while (d.mod(2).eq(0)) {
        d = d.div(2);
        r += 1;
      }
      var bases = null;
      if (n.lt("3317044064679887385961981")) {
        bases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41].filter((x2) => x2 < n);
      } else {
        var max3 = Math.min(n.toNumber() - 2, Math.floor(2 * Math.pow(n.toFixed(0).length * Math.log(10), 2)));
        bases = [];
        for (var _i = 2; _i <= max3; _i += 1) {
          bases.push(max3);
        }
      }
      for (var _i2 = 0; _i2 < bases.length; _i2 += 1) {
        var a = bases[_i2];
        var adn = modPow(n.sub(n).add(a), d, n);
        if (!adn.eq(1)) {
          for (var _i3 = 0, _x = adn; !_x.eq(n.sub(1)); _i3 += 1, _x = _x.mul(_x).mod(n)) {
            if (_i3 === r - 1) {
              return false;
            }
          }
        }
      }
      return true;
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});

// node_modules/mathjs/lib/esm/function/utils/numeric.js
var name124 = "numeric";
var dependencies125 = ["number", "?bignumber", "?fraction"];
var createNumeric = /* @__PURE__ */ factory(name124, dependencies125, (_ref) => {
  var {
    number: _number,
    bignumber: bignumber2,
    fraction: fraction2
  } = _ref;
  var validInputTypes = {
    string: true,
    number: true,
    BigNumber: true,
    Fraction: true
  };
  var validOutputTypes = {
    number: (x) => _number(x),
    BigNumber: bignumber2 ? (x) => bignumber2(x) : noBignumber,
    bigint: (x) => BigInt(x),
    Fraction: fraction2 ? (x) => fraction2(x) : noFraction
  };
  return function numeric3(value) {
    var outputType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "number";
    var check = arguments.length > 2 ? arguments[2] : void 0;
    if (check !== void 0) {
      throw new SyntaxError("numeric() takes one or two arguments");
    }
    var inputType = typeOf(value);
    if (!(inputType in validInputTypes)) {
      throw new TypeError("Cannot convert " + value + ' of type "' + inputType + '"; valid input types are ' + Object.keys(validInputTypes).join(", "));
    }
    if (!(outputType in validOutputTypes)) {
      throw new TypeError("Cannot convert " + value + ' to type "' + outputType + '"; valid output types are ' + Object.keys(validOutputTypes).join(", "));
    }
    if (outputType === inputType) {
      return value;
    } else {
      return validOutputTypes[outputType](value);
    }
  };
});

// node_modules/mathjs/lib/esm/function/arithmetic/divideScalar.js
var name125 = "divideScalar";
var dependencies126 = ["typed", "numeric"];
var createDivideScalar = /* @__PURE__ */ factory(name125, dependencies126, (_ref) => {
  var {
    typed: typed3,
    numeric: numeric3
  } = _ref;
  return typed3(name125, {
    "number, number": function numberNumber(x, y) {
      return x / y;
    },
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.div(y);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.div(y);
    },
    "bigint, bigint": function bigintBigint(x, y) {
      return x / y;
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return x.div(y);
    },
    "Unit, number | Complex | Fraction | BigNumber | Unit": (x, y) => x.divide(y),
    "number | Fraction | Complex | BigNumber, Unit": (x, y) => y.divideInto(x)
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/pow.js
var name126 = "pow";
var dependencies127 = ["typed", "config", "identity", "multiply", "matrix", "inv", "fraction", "number", "Complex"];
var createPow = /* @__PURE__ */ factory(name126, dependencies127, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    identity: identity2,
    multiply: multiply2,
    matrix: matrix2,
    inv: inv2,
    number: number2,
    fraction: fraction2,
    Complex: Complex3
  } = _ref;
  return typed3(name126, {
    "number, number": _pow,
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.pow(y);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      if (y.isInteger() || x >= 0 || config5.predictable) {
        return x.pow(y);
      } else {
        return new Complex3(x.toNumber(), 0).pow(y.toNumber(), 0);
      }
    },
    "bigint, bigint": (x, y) => x ** y,
    "Fraction, Fraction": function FractionFraction(x, y) {
      var result = x.pow(y);
      if (result != null) {
        return result;
      }
      if (config5.predictable) {
        throw new Error("Result of pow is non-rational and cannot be expressed as a fraction");
      } else {
        return _pow(x.valueOf(), y.valueOf());
      }
    },
    "Array, number": _powArray,
    "Array, BigNumber": function ArrayBigNumber(x, y) {
      return _powArray(x, y.toNumber());
    },
    "Matrix, number": _powMatrix,
    "Matrix, BigNumber": function MatrixBigNumber(x, y) {
      return _powMatrix(x, y.toNumber());
    },
    "Unit, number | BigNumber": function UnitNumberBigNumber(x, y) {
      return x.pow(y);
    }
  });
  function _pow(x, y) {
    if (config5.predictable && !isInteger(y) && x < 0) {
      try {
        var yFrac = fraction2(y);
        var yNum = number2(yFrac);
        if (y === yNum || Math.abs((y - yNum) / y) < 1e-14) {
          if (yFrac.d % 2 === 1) {
            return (yFrac.n % 2 === 0 ? 1 : -1) * Math.pow(-x, y);
          }
        }
      } catch (ex) {
      }
    }
    if (config5.predictable && (x < -1 && y === Infinity || x > -1 && x < 0 && y === -Infinity)) {
      return NaN;
    }
    if (isInteger(y) || x >= 0 || config5.predictable) {
      return powNumber(x, y);
    } else {
      if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
        return 0;
      }
      return new Complex3(x, 0).pow(y, 0);
    }
  }
  function _powArray(x, y) {
    if (!isInteger(y)) {
      throw new TypeError("For A^b, b must be an integer (value is " + y + ")");
    }
    var s = arraySize(x);
    if (s.length !== 2) {
      throw new Error("For A^b, A must be 2 dimensional (A has " + s.length + " dimensions)");
    }
    if (s[0] !== s[1]) {
      throw new Error("For A^b, A must be square (size is " + s[0] + "x" + s[1] + ")");
    }
    if (y < 0) {
      try {
        return _powArray(inv2(x), -y);
      } catch (error) {
        if (error.message === "Cannot calculate inverse, determinant is zero") {
          throw new TypeError("For A^b, when A is not invertible, b must be a positive integer (value is " + y + ")");
        }
        throw error;
      }
    }
    var res = identity2(s[0]).valueOf();
    var px = x;
    while (y >= 1) {
      if ((y & 1) === 1) {
        res = multiply2(px, res);
      }
      y >>= 1;
      px = multiply2(px, px);
    }
    return res;
  }
  function _powMatrix(x, y) {
    return matrix2(_powArray(x.valueOf(), y));
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/round.js
var NO_INT = "Number of decimals in function round must be an integer";
var name127 = "round";
var dependencies128 = ["typed", "config", "matrix", "equalScalar", "zeros", "BigNumber", "DenseMatrix"];
var createRound = /* @__PURE__ */ factory(name127, dependencies128, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros3,
    BigNumber: _BigNumber,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed3
  });
  function toExponent(epsilon) {
    return Math.abs(splitNumber(epsilon).exponent);
  }
  return typed3(name127, {
    number: function number2(x) {
      var xEpsilon = roundNumber(x, toExponent(config5.relTol));
      var xSelected = nearlyEqual(x, xEpsilon, config5.relTol, config5.absTol) ? xEpsilon : x;
      return roundNumber(xSelected);
    },
    "number, number": function numberNumber(x, n) {
      var epsilonExponent = toExponent(config5.relTol);
      if (n >= epsilonExponent) {
        return roundNumber(x, n);
      }
      var xEpsilon = roundNumber(x, epsilonExponent);
      var xSelected = nearlyEqual(x, xEpsilon, config5.relTol, config5.absTol) ? xEpsilon : x;
      return roundNumber(xSelected, n);
    },
    "number, BigNumber": function numberBigNumber(x, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      return new _BigNumber(x).toDecimalPlaces(n.toNumber());
    },
    Complex: function Complex3(x) {
      return x.round();
    },
    "Complex, number": function ComplexNumber(x, n) {
      if (n % 1) {
        throw new TypeError(NO_INT);
      }
      return x.round(n);
    },
    "Complex, BigNumber": function ComplexBigNumber(x, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      var _n = n.toNumber();
      return x.round(_n);
    },
    BigNumber: function BigNumber2(x) {
      var xEpsilon = new _BigNumber(x).toDecimalPlaces(toExponent(config5.relTol));
      var xSelected = nearlyEqual2(x, xEpsilon, config5.relTol, config5.absTol) ? xEpsilon : x;
      return xSelected.toDecimalPlaces(0);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      var epsilonExponent = toExponent(config5.relTol);
      if (n >= epsilonExponent) {
        return x.toDecimalPlaces(n.toNumber());
      }
      var xEpsilon = x.toDecimalPlaces(epsilonExponent);
      var xSelected = nearlyEqual2(x, xEpsilon, config5.relTol, config5.absTol) ? xEpsilon : x;
      return xSelected.toDecimalPlaces(n.toNumber());
    },
    Fraction: function Fraction3(x) {
      return x.round();
    },
    "Fraction, number": function FractionNumber(x, n) {
      if (n % 1) {
        throw new TypeError(NO_INT);
      }
      return x.round(n);
    },
    "Fraction, BigNumber": function FractionBigNumber(x, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      return x.round(n.toNumber());
    },
    "Unit, number, Unit": typed3.referToSelf((self2) => function(x, n, unit2) {
      var valueless = x.toNumeric(unit2);
      return unit2.multiply(self2(valueless, n));
    }),
    "Unit, BigNumber, Unit": typed3.referToSelf((self2) => (x, n, unit2) => self2(x, n.toNumber(), unit2)),
    "Unit, Unit": typed3.referToSelf((self2) => (x, unit2) => self2(x, 0, unit2)),
    "Array | Matrix, number, Unit": typed3.referToSelf((self2) => (x, n, unit2) => {
      return deepMap(x, (value) => self2(value, n, unit2), true);
    }),
    "Array | Matrix, BigNumber, Unit": typed3.referToSelf((self2) => (x, n, unit2) => self2(x, n.toNumber(), unit2)),
    "Array | Matrix, Unit": typed3.referToSelf((self2) => (x, unit2) => self2(x, 0, unit2)),
    "Array | Matrix": typed3.referToSelf((self2) => (x) => {
      return deepMap(x, self2, true);
    }),
    "SparseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x, n) => {
      return matAlgo11xS0s(x, n, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x, n) => {
      return matAlgo14xDs(x, n, self2, false);
    }),
    "Array, number | BigNumber": typed3.referToSelf((self2) => (x, n) => {
      return matAlgo14xDs(matrix2(x), n, self2, false).valueOf();
    }),
    "number | Complex | BigNumber | Fraction, SparseMatrix": typed3.referToSelf((self2) => (x, n) => {
      if (equalScalar2(x, 0)) {
        return zeros3(n.size(), n.storage());
      }
      return matAlgo12xSfs(n, x, self2, true);
    }),
    "number | Complex | BigNumber | Fraction, DenseMatrix": typed3.referToSelf((self2) => (x, n) => {
      if (equalScalar2(x, 0)) {
        return zeros3(n.size(), n.storage());
      }
      return matAlgo14xDs(n, x, self2, true);
    }),
    "number | Complex | BigNumber | Fraction, Array": typed3.referToSelf((self2) => (x, n) => {
      return matAlgo14xDs(matrix2(n), x, self2, true).valueOf();
    })
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/log.js
var name128 = "log";
var dependencies129 = ["config", "typed", "divideScalar", "Complex"];
var createLog = /* @__PURE__ */ factory(name128, dependencies129, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    divideScalar: divideScalar2,
    Complex: Complex3
  } = _ref;
  return typed3(name128, {
    number: function number2(x) {
      if (x >= 0 || config5.predictable) {
        return logNumber(x);
      } else {
        return new Complex3(x, 0).log();
      }
    },
    Complex: function Complex4(x) {
      return x.log();
    },
    BigNumber: function BigNumber2(x) {
      if (!x.isNegative() || config5.predictable) {
        return x.ln();
      } else {
        return new Complex3(x.toNumber(), 0).log();
      }
    },
    "any, any": typed3.referToSelf((self2) => (x, base) => {
      return divideScalar2(self2(x), self2(base));
    })
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/log1p.js
var name129 = "log1p";
var dependencies130 = ["typed", "config", "divideScalar", "log", "Complex"];
var createLog1p = /* @__PURE__ */ factory(name129, dependencies130, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    divideScalar: divideScalar2,
    log: log4,
    Complex: Complex3
  } = _ref;
  return typed3(name129, {
    number: function number2(x) {
      if (x >= -1 || config5.predictable) {
        return log1p(x);
      } else {
        return _log1pComplex(new Complex3(x, 0));
      }
    },
    Complex: _log1pComplex,
    BigNumber: function BigNumber2(x) {
      var y = x.plus(1);
      if (!y.isNegative() || config5.predictable) {
        return y.ln();
      } else {
        return _log1pComplex(new Complex3(x.toNumber(), 0));
      }
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2)),
    "any, any": typed3.referToSelf((self2) => (x, base) => {
      return divideScalar2(self2(x), log4(base));
    })
  });
  function _log1pComplex(x) {
    var xRe1p = x.re + 1;
    return new Complex3(Math.log(Math.sqrt(xRe1p * xRe1p + x.im * x.im)), Math.atan2(x.im, xRe1p));
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/nthRoots.js
var name130 = "nthRoots";
var dependencies131 = ["config", "typed", "divideScalar", "Complex"];
var createNthRoots = /* @__PURE__ */ factory(name130, dependencies131, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    divideScalar: divideScalar2,
    Complex: Complex3
  } = _ref;
  var _calculateExactResult = [function realPos(val) {
    return new Complex3(val, 0);
  }, function imagPos(val) {
    return new Complex3(0, val);
  }, function realNeg(val) {
    return new Complex3(-val, 0);
  }, function imagNeg(val) {
    return new Complex3(0, -val);
  }];
  function _nthComplexRoots(a, root) {
    if (root < 0)
      throw new Error("Root must be greater than zero");
    if (root === 0)
      throw new Error("Root must be non-zero");
    if (root % 1 !== 0)
      throw new Error("Root must be an integer");
    if (a === 0 || a.abs() === 0)
      return [new Complex3(0, 0)];
    var aIsNumeric = typeof a === "number";
    var offset;
    if (aIsNumeric || a.re === 0 || a.im === 0) {
      if (aIsNumeric) {
        offset = 2 * +(a < 0);
      } else if (a.im === 0) {
        offset = 2 * +(a.re < 0);
      } else {
        offset = 2 * +(a.im < 0) + 1;
      }
    }
    var arg2 = a.arg();
    var abs3 = a.abs();
    var roots = [];
    var r = Math.pow(abs3, 1 / root);
    for (var k = 0; k < root; k++) {
      var halfPiFactor = (offset + 4 * k) / root;
      if (halfPiFactor === Math.round(halfPiFactor)) {
        roots.push(_calculateExactResult[halfPiFactor % 4](r));
        continue;
      }
      roots.push(new Complex3({
        r,
        phi: (arg2 + 2 * Math.PI * k) / root
      }));
    }
    return roots;
  }
  return typed3(name130, {
    Complex: function Complex4(x) {
      return _nthComplexRoots(x, 2);
    },
    "Complex, number": _nthComplexRoots
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/dotPow.js
var name131 = "dotPow";
var dependencies132 = ["typed", "equalScalar", "matrix", "pow", "DenseMatrix", "concat"];
var createDotPow = /* @__PURE__ */ factory(name131, dependencies132, (_ref) => {
  var {
    typed: typed3,
    equalScalar: equalScalar2,
    matrix: matrix2,
    pow: pow3,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed3
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix: matrix2,
    concat: concat3
  });
  var powScalarSignatures = {};
  for (var signature in pow3.signatures) {
    if (Object.prototype.hasOwnProperty.call(pow3.signatures, signature)) {
      if (!signature.includes("Matrix") && !signature.includes("Array")) {
        powScalarSignatures[signature] = pow3.signatures[signature];
      }
    }
  }
  var powScalar = typed3(powScalarSignatures);
  return typed3(name131, matrixAlgorithmSuite({
    elop: powScalar,
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo11xS0s,
    sS: matAlgo12xSfs
  }));
});

// node_modules/mathjs/lib/esm/function/arithmetic/dotDivide.js
var name132 = "dotDivide";
var dependencies133 = ["typed", "matrix", "equalScalar", "divideScalar", "DenseMatrix", "concat"];
var createDotDivide = /* @__PURE__ */ factory(name132, dependencies133, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    equalScalar: equalScalar2,
    divideScalar: divideScalar2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed3
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix: matrix2,
    concat: concat3
  });
  return typed3(name132, matrixAlgorithmSuite({
    elop: divideScalar2,
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    SD: matAlgo02xDS0,
    Ss: matAlgo11xS0s,
    sS: matAlgo12xSfs
  }));
});

// node_modules/mathjs/lib/esm/function/algebra/solver/utils/solveValidation.js
function createSolveValidation(_ref) {
  var {
    DenseMatrix: DenseMatrix2
  } = _ref;
  return function solveValidation(m, b, copy) {
    var mSize = m.size();
    if (mSize.length !== 2) {
      throw new RangeError("Matrix must be two dimensional (size: " + format3(mSize) + ")");
    }
    var rows = mSize[0];
    var columns = mSize[1];
    if (rows !== columns) {
      throw new RangeError("Matrix must be square (size: " + format3(mSize) + ")");
    }
    var data = [];
    if (isMatrix(b)) {
      var bSize = b.size();
      var bdata = b._data;
      if (bSize.length === 1) {
        if (bSize[0] !== rows) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        for (var i2 = 0; i2 < rows; i2++) {
          data[i2] = [bdata[i2]];
        }
        return new DenseMatrix2({
          data,
          size: [rows, 1],
          datatype: b._datatype
        });
      }
      if (bSize.length === 2) {
        if (bSize[0] !== rows || bSize[1] !== 1) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        if (isDenseMatrix(b)) {
          if (copy) {
            data = [];
            for (var _i = 0; _i < rows; _i++) {
              data[_i] = [bdata[_i][0]];
            }
            return new DenseMatrix2({
              data,
              size: [rows, 1],
              datatype: b._datatype
            });
          }
          return b;
        }
        if (isSparseMatrix(b)) {
          for (var _i2 = 0; _i2 < rows; _i2++) {
            data[_i2] = [0];
          }
          var values = b._values;
          var index2 = b._index;
          var ptr = b._ptr;
          for (var k1 = ptr[1], k = ptr[0]; k < k1; k++) {
            var _i3 = index2[k];
            data[_i3][0] = values[k];
          }
          return new DenseMatrix2({
            data,
            size: [rows, 1],
            datatype: b._datatype
          });
        }
      }
      throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
    }
    if (isArray(b)) {
      var bsize = arraySize(b);
      if (bsize.length === 1) {
        if (bsize[0] !== rows) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        for (var _i4 = 0; _i4 < rows; _i4++) {
          data[_i4] = [b[_i4]];
        }
        return new DenseMatrix2({
          data,
          size: [rows, 1]
        });
      }
      if (bsize.length === 2) {
        if (bsize[0] !== rows || bsize[1] !== 1) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        for (var _i5 = 0; _i5 < rows; _i5++) {
          data[_i5] = [b[_i5][0]];
        }
        return new DenseMatrix2({
          data,
          size: [rows, 1]
        });
      }
      throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
    }
  };
}

// node_modules/mathjs/lib/esm/function/algebra/solver/lsolve.js
var name133 = "lsolve";
var dependencies134 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"];
var createLsolve = /* @__PURE__ */ factory(name133, dependencies134, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtractScalar: subtractScalar2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix: DenseMatrix2
  });
  return typed3(name133, {
    "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
      return _sparseForwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
      return _denseForwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
      var m = matrix2(a);
      var r = _denseForwardSubstitution(m, b);
      return r.valueOf();
    }
  });
  function _denseForwardSubstitution(m, b) {
    b = solveValidation(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var x = [];
    var mdata = m._data;
    for (var j = 0; j < columns; j++) {
      var bj = bdata[j][0] || 0;
      var xj = void 0;
      if (!equalScalar2(bj, 0)) {
        var vjj = mdata[j][j];
        if (equalScalar2(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        xj = divideScalar2(bj, vjj);
        for (var i2 = j + 1; i2 < rows; i2++) {
          bdata[i2] = [subtractScalar2(bdata[i2][0] || 0, multiplyScalar2(xj, mdata[i2][j]))];
        }
      } else {
        xj = 0;
      }
      x[j] = [xj];
    }
    return new DenseMatrix2({
      data: x,
      size: [rows, 1]
    });
  }
  function _sparseForwardSubstitution(m, b) {
    b = solveValidation(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var values = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    var x = [];
    for (var j = 0; j < columns; j++) {
      var bj = bdata[j][0] || 0;
      if (!equalScalar2(bj, 0)) {
        var vjj = 0;
        var jValues = [];
        var jIndices = [];
        var firstIndex = ptr[j];
        var lastIndex = ptr[j + 1];
        for (var k = firstIndex; k < lastIndex; k++) {
          var i2 = index2[k];
          if (i2 === j) {
            vjj = values[k];
          } else if (i2 > j) {
            jValues.push(values[k]);
            jIndices.push(i2);
          }
        }
        if (equalScalar2(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        var xj = divideScalar2(bj, vjj);
        for (var _k = 0, l = jIndices.length; _k < l; _k++) {
          var _i = jIndices[_k];
          bdata[_i] = [subtractScalar2(bdata[_i][0] || 0, multiplyScalar2(xj, jValues[_k]))];
        }
        x[j] = [xj];
      } else {
        x[j] = [0];
      }
    }
    return new DenseMatrix2({
      data: x,
      size: [rows, 1]
    });
  }
});

// node_modules/mathjs/lib/esm/function/algebra/solver/usolve.js
var name134 = "usolve";
var dependencies135 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"];
var createUsolve = /* @__PURE__ */ factory(name134, dependencies135, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtractScalar: subtractScalar2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix: DenseMatrix2
  });
  return typed3(name134, {
    "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
      return _sparseBackwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
      return _denseBackwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
      var m = matrix2(a);
      var r = _denseBackwardSubstitution(m, b);
      return r.valueOf();
    }
  });
  function _denseBackwardSubstitution(m, b) {
    b = solveValidation(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var x = [];
    var mdata = m._data;
    for (var j = columns - 1; j >= 0; j--) {
      var bj = bdata[j][0] || 0;
      var xj = void 0;
      if (!equalScalar2(bj, 0)) {
        var vjj = mdata[j][j];
        if (equalScalar2(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        xj = divideScalar2(bj, vjj);
        for (var i2 = j - 1; i2 >= 0; i2--) {
          bdata[i2] = [subtractScalar2(bdata[i2][0] || 0, multiplyScalar2(xj, mdata[i2][j]))];
        }
      } else {
        xj = 0;
      }
      x[j] = [xj];
    }
    return new DenseMatrix2({
      data: x,
      size: [rows, 1]
    });
  }
  function _sparseBackwardSubstitution(m, b) {
    b = solveValidation(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var values = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    var x = [];
    for (var j = columns - 1; j >= 0; j--) {
      var bj = bdata[j][0] || 0;
      if (!equalScalar2(bj, 0)) {
        var vjj = 0;
        var jValues = [];
        var jIndices = [];
        var firstIndex = ptr[j];
        var lastIndex = ptr[j + 1];
        for (var k = lastIndex - 1; k >= firstIndex; k--) {
          var i2 = index2[k];
          if (i2 === j) {
            vjj = values[k];
          } else if (i2 < j) {
            jValues.push(values[k]);
            jIndices.push(i2);
          }
        }
        if (equalScalar2(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        var xj = divideScalar2(bj, vjj);
        for (var _k = 0, _lastIndex = jIndices.length; _k < _lastIndex; _k++) {
          var _i = jIndices[_k];
          bdata[_i] = [subtractScalar2(bdata[_i][0], multiplyScalar2(xj, jValues[_k]))];
        }
        x[j] = [xj];
      } else {
        x[j] = [0];
      }
    }
    return new DenseMatrix2({
      data: x,
      size: [rows, 1]
    });
  }
});

// node_modules/mathjs/lib/esm/function/algebra/solver/lsolveAll.js
var name135 = "lsolveAll";
var dependencies136 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"];
var createLsolveAll = /* @__PURE__ */ factory(name135, dependencies136, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtractScalar: subtractScalar2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix: DenseMatrix2
  });
  return typed3(name135, {
    "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
      return _sparseForwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
      return _denseForwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
      var m = matrix2(a);
      var R = _denseForwardSubstitution(m, b);
      return R.map((r) => r.valueOf());
    }
  });
  function _denseForwardSubstitution(m, b_) {
    var B = [solveValidation(m, b_, true)._data.map((e3) => e3[0])];
    var M = m._data;
    var rows = m._size[0];
    var columns = m._size[1];
    for (var i2 = 0; i2 < columns; i2++) {
      var L = B.length;
      for (var k = 0; k < L; k++) {
        var b = B[k];
        if (!equalScalar2(M[i2][i2], 0)) {
          b[i2] = divideScalar2(b[i2], M[i2][i2]);
          for (var j = i2 + 1; j < columns; j++) {
            b[j] = subtractScalar2(b[j], multiplyScalar2(b[i2], M[j][i2]));
          }
        } else if (!equalScalar2(b[i2], 0)) {
          if (k === 0) {
            return [];
          } else {
            B.splice(k, 1);
            k -= 1;
            L -= 1;
          }
        } else if (k === 0) {
          var bNew = [...b];
          bNew[i2] = 1;
          for (var _j = i2 + 1; _j < columns; _j++) {
            bNew[_j] = subtractScalar2(bNew[_j], M[_j][i2]);
          }
          B.push(bNew);
        }
      }
    }
    return B.map((x) => new DenseMatrix2({
      data: x.map((e3) => [e3]),
      size: [rows, 1]
    }));
  }
  function _sparseForwardSubstitution(m, b_) {
    var B = [solveValidation(m, b_, true)._data.map((e3) => e3[0])];
    var rows = m._size[0];
    var columns = m._size[1];
    var values = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    for (var i2 = 0; i2 < columns; i2++) {
      var L = B.length;
      for (var k = 0; k < L; k++) {
        var b = B[k];
        var iValues = [];
        var iIndices = [];
        var firstIndex = ptr[i2];
        var lastIndex = ptr[i2 + 1];
        var Mii = 0;
        for (var j = firstIndex; j < lastIndex; j++) {
          var J = index2[j];
          if (J === i2) {
            Mii = values[j];
          } else if (J > i2) {
            iValues.push(values[j]);
            iIndices.push(J);
          }
        }
        if (!equalScalar2(Mii, 0)) {
          b[i2] = divideScalar2(b[i2], Mii);
          for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {
            var _J = iIndices[_j2];
            b[_J] = subtractScalar2(b[_J], multiplyScalar2(b[i2], iValues[_j2]));
          }
        } else if (!equalScalar2(b[i2], 0)) {
          if (k === 0) {
            return [];
          } else {
            B.splice(k, 1);
            k -= 1;
            L -= 1;
          }
        } else if (k === 0) {
          var bNew = [...b];
          bNew[i2] = 1;
          for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {
            var _J2 = iIndices[_j3];
            bNew[_J2] = subtractScalar2(bNew[_J2], iValues[_j3]);
          }
          B.push(bNew);
        }
      }
    }
    return B.map((x) => new DenseMatrix2({
      data: x.map((e3) => [e3]),
      size: [rows, 1]
    }));
  }
});

// node_modules/mathjs/lib/esm/function/algebra/solver/usolveAll.js
var name136 = "usolveAll";
var dependencies137 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"];
var createUsolveAll = /* @__PURE__ */ factory(name136, dependencies137, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtractScalar: subtractScalar2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix: DenseMatrix2
  });
  return typed3(name136, {
    "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
      return _sparseBackwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
      return _denseBackwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
      var m = matrix2(a);
      var R = _denseBackwardSubstitution(m, b);
      return R.map((r) => r.valueOf());
    }
  });
  function _denseBackwardSubstitution(m, b_) {
    var B = [solveValidation(m, b_, true)._data.map((e3) => e3[0])];
    var M = m._data;
    var rows = m._size[0];
    var columns = m._size[1];
    for (var i2 = columns - 1; i2 >= 0; i2--) {
      var L = B.length;
      for (var k = 0; k < L; k++) {
        var b = B[k];
        if (!equalScalar2(M[i2][i2], 0)) {
          b[i2] = divideScalar2(b[i2], M[i2][i2]);
          for (var j = i2 - 1; j >= 0; j--) {
            b[j] = subtractScalar2(b[j], multiplyScalar2(b[i2], M[j][i2]));
          }
        } else if (!equalScalar2(b[i2], 0)) {
          if (k === 0) {
            return [];
          } else {
            B.splice(k, 1);
            k -= 1;
            L -= 1;
          }
        } else if (k === 0) {
          var bNew = [...b];
          bNew[i2] = 1;
          for (var _j = i2 - 1; _j >= 0; _j--) {
            bNew[_j] = subtractScalar2(bNew[_j], M[_j][i2]);
          }
          B.push(bNew);
        }
      }
    }
    return B.map((x) => new DenseMatrix2({
      data: x.map((e3) => [e3]),
      size: [rows, 1]
    }));
  }
  function _sparseBackwardSubstitution(m, b_) {
    var B = [solveValidation(m, b_, true)._data.map((e3) => e3[0])];
    var rows = m._size[0];
    var columns = m._size[1];
    var values = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    for (var i2 = columns - 1; i2 >= 0; i2--) {
      var L = B.length;
      for (var k = 0; k < L; k++) {
        var b = B[k];
        var iValues = [];
        var iIndices = [];
        var firstIndex = ptr[i2];
        var lastIndex = ptr[i2 + 1];
        var Mii = 0;
        for (var j = lastIndex - 1; j >= firstIndex; j--) {
          var J = index2[j];
          if (J === i2) {
            Mii = values[j];
          } else if (J < i2) {
            iValues.push(values[j]);
            iIndices.push(J);
          }
        }
        if (!equalScalar2(Mii, 0)) {
          b[i2] = divideScalar2(b[i2], Mii);
          for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {
            var _J = iIndices[_j2];
            b[_J] = subtractScalar2(b[_J], multiplyScalar2(b[i2], iValues[_j2]));
          }
        } else if (!equalScalar2(b[i2], 0)) {
          if (k === 0) {
            return [];
          } else {
            B.splice(k, 1);
            k -= 1;
            L -= 1;
          }
        } else if (k === 0) {
          var bNew = [...b];
          bNew[i2] = 1;
          for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {
            var _J2 = iIndices[_j3];
            bNew[_J2] = subtractScalar2(bNew[_J2], iValues[_j3]);
          }
          B.push(bNew);
        }
      }
    }
    return B.map((x) => new DenseMatrix2({
      data: x.map((e3) => [e3]),
      size: [rows, 1]
    }));
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo08xS0Sid.js
var name137 = "matAlgo08xS0Sid";
var dependencies138 = ["typed", "equalScalar"];
var createMatAlgo08xS0Sid = /* @__PURE__ */ factory(name137, dependencies138, (_ref) => {
  var {
    typed: typed3,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo08xS0Sid(a, b, callback) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!avalues || !bvalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrices");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
      dt = adt;
      eq = typed3.find(equalScalar2, [dt, dt]);
      zero = typed3.convert(0, dt);
      cf = typed3.find(callback, [dt, dt]);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var x = [];
    var w = [];
    var k, k0, k1, i2;
    for (var j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        i2 = aindex[k];
        w[i2] = mark;
        x[i2] = avalues[k];
        cindex.push(i2);
      }
      for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        i2 = bindex[k];
        if (w[i2] === mark) {
          x[i2] = cf(x[i2], bvalues[k]);
        }
      }
      k = cptr[j];
      while (k < cindex.length) {
        i2 = cindex[k];
        var v = x[i2];
        if (!eq(v, zero)) {
          cvalues.push(v);
          k++;
        } else {
          cindex.splice(k, 1);
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
  };
});

// node_modules/mathjs/lib/esm/function/bitwise/useMatrixForArrayScalar.js
var createUseMatrixForArrayScalar = /* @__PURE__ */ factory("useMatrixForArrayScalar", ["typed", "matrix"], (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2
  } = _ref;
  return {
    "Array, number": typed3.referTo("DenseMatrix, number", (selfDn) => (x, y) => selfDn(matrix2(x), y).valueOf()),
    "Array, BigNumber": typed3.referTo("DenseMatrix, BigNumber", (selfDB) => (x, y) => selfDB(matrix2(x), y).valueOf()),
    "number, Array": typed3.referTo("number, DenseMatrix", (selfnD) => (x, y) => selfnD(x, matrix2(y)).valueOf()),
    "BigNumber, Array": typed3.referTo("BigNumber, DenseMatrix", (selfBD) => (x, y) => selfBD(x, matrix2(y)).valueOf())
  };
});

// node_modules/mathjs/lib/esm/function/bitwise/leftShift.js
var name138 = "leftShift";
var dependencies139 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
var createLeftShift = /* @__PURE__ */ factory(name138, dependencies139, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros3,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed3
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed3
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix: matrix2,
    concat: concat3
  });
  var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
    typed: typed3,
    matrix: matrix2
  });
  return typed3(name138, {
    "number, number": leftShiftNumber,
    "BigNumber, BigNumber": leftShiftBigNumber,
    "bigint, bigint": (x, y) => x << y,
    "SparseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x, y) => {
      if (equalScalar2(y, 0)) {
        return x.clone();
      }
      return matAlgo11xS0s(x, y, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x, y) => {
      if (equalScalar2(y, 0)) {
        return x.clone();
      }
      return matAlgo14xDs(x, y, self2, false);
    }),
    "number | BigNumber, SparseMatrix": typed3.referToSelf((self2) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros3(y.size(), y.storage());
      }
      return matAlgo10xSids(y, x, self2, true);
    }),
    "number | BigNumber, DenseMatrix": typed3.referToSelf((self2) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros3(y.size(), y.storage());
      }
      return matAlgo14xDs(y, x, self2, true);
    })
  }, useMatrixForArrayScalar, matrixAlgorithmSuite({
    SS: matAlgo08xS0Sid,
    DS: matAlgo01xDSid,
    SD: matAlgo02xDS0
  }));
});

// node_modules/mathjs/lib/esm/function/bitwise/rightArithShift.js
var name139 = "rightArithShift";
var dependencies140 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
var createRightArithShift = /* @__PURE__ */ factory(name139, dependencies140, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros3,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed3
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed3
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix: matrix2,
    concat: concat3
  });
  var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
    typed: typed3,
    matrix: matrix2
  });
  return typed3(name139, {
    "number, number": rightArithShiftNumber,
    "BigNumber, BigNumber": rightArithShiftBigNumber,
    "bigint, bigint": (x, y) => x >> y,
    "SparseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x, y) => {
      if (equalScalar2(y, 0)) {
        return x.clone();
      }
      return matAlgo11xS0s(x, y, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x, y) => {
      if (equalScalar2(y, 0)) {
        return x.clone();
      }
      return matAlgo14xDs(x, y, self2, false);
    }),
    "number | BigNumber, SparseMatrix": typed3.referToSelf((self2) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros3(y.size(), y.storage());
      }
      return matAlgo10xSids(y, x, self2, true);
    }),
    "number | BigNumber, DenseMatrix": typed3.referToSelf((self2) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros3(y.size(), y.storage());
      }
      return matAlgo14xDs(y, x, self2, true);
    })
  }, useMatrixForArrayScalar, matrixAlgorithmSuite({
    SS: matAlgo08xS0Sid,
    DS: matAlgo01xDSid,
    SD: matAlgo02xDS0
  }));
});

// node_modules/mathjs/lib/esm/function/bitwise/rightLogShift.js
var name140 = "rightLogShift";
var dependencies141 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
var createRightLogShift = /* @__PURE__ */ factory(name140, dependencies141, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros3,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed3
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed3
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix: matrix2,
    concat: concat3
  });
  var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
    typed: typed3,
    matrix: matrix2
  });
  return typed3(name140, {
    "number, number": rightLogShiftNumber,
    // 'BigNumber, BigNumber': ..., // TODO: implement BigNumber support for rightLogShift
    "SparseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x, y) => {
      if (equalScalar2(y, 0)) {
        return x.clone();
      }
      return matAlgo11xS0s(x, y, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x, y) => {
      if (equalScalar2(y, 0)) {
        return x.clone();
      }
      return matAlgo14xDs(x, y, self2, false);
    }),
    "number | BigNumber, SparseMatrix": typed3.referToSelf((self2) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros3(y.size(), y.storage());
      }
      return matAlgo10xSids(y, x, self2, true);
    }),
    "number | BigNumber, DenseMatrix": typed3.referToSelf((self2) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros3(y.size(), y.storage());
      }
      return matAlgo14xDs(y, x, self2, true);
    })
  }, useMatrixForArrayScalar, matrixAlgorithmSuite({
    SS: matAlgo08xS0Sid,
    DS: matAlgo01xDSid,
    SD: matAlgo02xDS0
  }));
});

// node_modules/mathjs/lib/esm/function/logical/and.js
var name141 = "and";
var dependencies142 = ["typed", "matrix", "equalScalar", "zeros", "not", "concat"];
var createAnd = /* @__PURE__ */ factory(name141, dependencies142, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros3,
    not: not2,
    concat: concat3
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo06xS0S0 = createMatAlgo06xS0S0({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed3
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix: matrix2,
    concat: concat3
  });
  return typed3(name141, {
    "number, number": andNumber,
    "Complex, Complex": function ComplexComplex(x, y) {
      return (x.re !== 0 || x.im !== 0) && (y.re !== 0 || y.im !== 0);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return !x.isZero() && !y.isZero() && !x.isNaN() && !y.isNaN();
    },
    "bigint, bigint": andNumber,
    "Unit, Unit": typed3.referToSelf((self2) => (x, y) => self2(x.value || 0, y.value || 0)),
    "SparseMatrix, any": typed3.referToSelf((self2) => (x, y) => {
      if (not2(y)) {
        return zeros3(x.size(), x.storage());
      }
      return matAlgo11xS0s(x, y, self2, false);
    }),
    "DenseMatrix, any": typed3.referToSelf((self2) => (x, y) => {
      if (not2(y)) {
        return zeros3(x.size(), x.storage());
      }
      return matAlgo14xDs(x, y, self2, false);
    }),
    "any, SparseMatrix": typed3.referToSelf((self2) => (x, y) => {
      if (not2(x)) {
        return zeros3(x.size(), x.storage());
      }
      return matAlgo11xS0s(y, x, self2, true);
    }),
    "any, DenseMatrix": typed3.referToSelf((self2) => (x, y) => {
      if (not2(x)) {
        return zeros3(x.size(), x.storage());
      }
      return matAlgo14xDs(y, x, self2, true);
    }),
    "Array, any": typed3.referToSelf((self2) => (x, y) => {
      return self2(matrix2(x), y).valueOf();
    }),
    "any, Array": typed3.referToSelf((self2) => (x, y) => {
      return self2(x, matrix2(y)).valueOf();
    })
  }, matrixAlgorithmSuite({
    SS: matAlgo06xS0S0,
    DS: matAlgo02xDS0
  }));
});

// node_modules/mathjs/lib/esm/function/relational/compare.js
var name142 = "compare";
var dependencies143 = ["typed", "config", "matrix", "equalScalar", "BigNumber", "Fraction", "DenseMatrix", "concat"];
var createCompare = /* @__PURE__ */ factory(name142, dependencies143, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    equalScalar: equalScalar2,
    matrix: matrix2,
    BigNumber: BigNumber2,
    Fraction: Fraction3,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed3
  });
  var matAlgo05xSfSf = createMatAlgo05xSfSf({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix: matrix2,
    concat: concat3
  });
  var compareUnits = createCompareUnits({
    typed: typed3
  });
  return typed3(name142, createCompareNumber({
    typed: typed3,
    config: config5
  }), {
    "boolean, boolean": function booleanBoolean(x, y) {
      return x === y ? 0 : x > y ? 1 : -1;
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return nearlyEqual2(x, y, config5.relTol, config5.absTol) ? new BigNumber2(0) : new BigNumber2(x.cmp(y));
    },
    "bigint, bigint": function bigintBigint(x, y) {
      return x === y ? 0n : x > y ? 1n : -1n;
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return new Fraction3(x.compare(y));
    },
    "Complex, Complex": function ComplexComplex() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, compareUnits, matrixAlgorithmSuite({
    SS: matAlgo05xSfSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var createCompareNumber = /* @__PURE__ */ factory(name142, ["typed", "config"], (_ref2) => {
  var {
    typed: typed3,
    config: config5
  } = _ref2;
  return typed3(name142, {
    "number, number": function numberNumber(x, y) {
      return nearlyEqual(x, y, config5.relTol, config5.absTol) ? 0 : x > y ? 1 : -1;
    }
  });
});

// node_modules/mathjs/lib/esm/function/relational/compareNatural.js
var import_javascript_natural_sort = __toESM(require_naturalSort(), 1);
var name143 = "compareNatural";
var dependencies144 = ["typed", "compare"];
var createCompareNatural = /* @__PURE__ */ factory(name143, dependencies144, (_ref) => {
  var {
    typed: typed3,
    compare: compare2
  } = _ref;
  var compareBooleans = compare2.signatures["boolean,boolean"];
  return typed3(name143, {
    "any, any": _compareNatural
  });
  function _compareNatural(x, y) {
    var typeX = typeOf(x);
    var typeY = typeOf(y);
    var c;
    if ((typeX === "number" || typeX === "BigNumber" || typeX === "Fraction") && (typeY === "number" || typeY === "BigNumber" || typeY === "Fraction")) {
      c = compare2(x, y);
      if (c.toString() !== "0") {
        return c > 0 ? 1 : -1;
      } else {
        return (0, import_javascript_natural_sort.default)(typeX, typeY);
      }
    }
    var matTypes = ["Array", "DenseMatrix", "SparseMatrix"];
    if (matTypes.includes(typeX) || matTypes.includes(typeY)) {
      c = compareMatricesAndArrays(_compareNatural, x, y);
      if (c !== 0) {
        return c;
      } else {
        return (0, import_javascript_natural_sort.default)(typeX, typeY);
      }
    }
    if (typeX !== typeY) {
      return (0, import_javascript_natural_sort.default)(typeX, typeY);
    }
    if (typeX === "Complex") {
      return compareComplexNumbers(x, y);
    }
    if (typeX === "Unit") {
      if (x.equalBase(y)) {
        return _compareNatural(x.value, y.value);
      }
      return compareArrays(_compareNatural, x.formatUnits(), y.formatUnits());
    }
    if (typeX === "boolean") {
      return compareBooleans(x, y);
    }
    if (typeX === "string") {
      return (0, import_javascript_natural_sort.default)(x, y);
    }
    if (typeX === "Object") {
      return compareObjects(_compareNatural, x, y);
    }
    if (typeX === "null") {
      return 0;
    }
    if (typeX === "undefined") {
      return 0;
    }
    throw new TypeError('Unsupported type of value "' + typeX + '"');
  }
  function compareMatricesAndArrays(compareNatural2, x, y) {
    if (isSparseMatrix(x) && isSparseMatrix(y)) {
      return compareArrays(compareNatural2, x.toJSON().values, y.toJSON().values);
    }
    if (isSparseMatrix(x)) {
      return compareMatricesAndArrays(compareNatural2, x.toArray(), y);
    }
    if (isSparseMatrix(y)) {
      return compareMatricesAndArrays(compareNatural2, x, y.toArray());
    }
    if (isDenseMatrix(x)) {
      return compareMatricesAndArrays(compareNatural2, x.toJSON().data, y);
    }
    if (isDenseMatrix(y)) {
      return compareMatricesAndArrays(compareNatural2, x, y.toJSON().data);
    }
    if (!Array.isArray(x)) {
      return compareMatricesAndArrays(compareNatural2, [x], y);
    }
    if (!Array.isArray(y)) {
      return compareMatricesAndArrays(compareNatural2, x, [y]);
    }
    return compareArrays(compareNatural2, x, y);
  }
  function compareArrays(compareNatural2, x, y) {
    for (var i2 = 0, ii = Math.min(x.length, y.length); i2 < ii; i2++) {
      var v = compareNatural2(x[i2], y[i2]);
      if (v !== 0) {
        return v;
      }
    }
    if (x.length > y.length) {
      return 1;
    }
    if (x.length < y.length) {
      return -1;
    }
    return 0;
  }
  function compareObjects(compareNatural2, x, y) {
    var keysX = Object.keys(x);
    var keysY = Object.keys(y);
    keysX.sort(import_javascript_natural_sort.default);
    keysY.sort(import_javascript_natural_sort.default);
    var c = compareArrays(compareNatural2, keysX, keysY);
    if (c !== 0) {
      return c;
    }
    for (var i2 = 0; i2 < keysX.length; i2++) {
      var v = compareNatural2(x[keysX[i2]], y[keysY[i2]]);
      if (v !== 0) {
        return v;
      }
    }
    return 0;
  }
});
function compareComplexNumbers(x, y) {
  if (x.re > y.re) {
    return 1;
  }
  if (x.re < y.re) {
    return -1;
  }
  if (x.im > y.im) {
    return 1;
  }
  if (x.im < y.im) {
    return -1;
  }
  return 0;
}

// node_modules/mathjs/lib/esm/function/relational/compareText.js
var name144 = "compareText";
var dependencies145 = ["typed", "matrix", "concat"];
compareText.signature = "any, any";
var createCompareText = /* @__PURE__ */ factory(name144, dependencies145, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    concat: concat3
  } = _ref;
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix: matrix2,
    concat: concat3
  });
  return typed3(name144, compareText, matrixAlgorithmSuite({
    elop: compareText,
    Ds: true
  }));
});

// node_modules/mathjs/lib/esm/function/relational/equal.js
var name145 = "equal";
var dependencies146 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
var createEqual = /* @__PURE__ */ factory(name145, dependencies146, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed3
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix: matrix2,
    concat: concat3
  });
  return typed3(name145, createEqualNumber({
    typed: typed3,
    equalScalar: equalScalar2
  }), matrixAlgorithmSuite({
    elop: equalScalar2,
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var createEqualNumber = factory(name145, ["typed", "equalScalar"], (_ref2) => {
  var {
    typed: typed3,
    equalScalar: equalScalar2
  } = _ref2;
  return typed3(name145, {
    "any, any": function anyAny(x, y) {
      if (x === null) {
        return y === null;
      }
      if (y === null) {
        return x === null;
      }
      if (x === void 0) {
        return y === void 0;
      }
      if (y === void 0) {
        return x === void 0;
      }
      return equalScalar2(x, y);
    }
  });
});

// node_modules/mathjs/lib/esm/function/relational/equalText.js
var name146 = "equalText";
var dependencies147 = ["typed", "compareText", "isZero"];
var createEqualText = /* @__PURE__ */ factory(name146, dependencies147, (_ref) => {
  var {
    typed: typed3,
    compareText: compareText3,
    isZero: isZero2
  } = _ref;
  return typed3(name146, {
    "any, any": function anyAny(x, y) {
      return isZero2(compareText3(x, y));
    }
  });
});

// node_modules/mathjs/lib/esm/function/relational/smaller.js
var name147 = "smaller";
var dependencies148 = ["typed", "config", "matrix", "DenseMatrix", "concat"];
var createSmaller = /* @__PURE__ */ factory(name147, dependencies148, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed3
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix: matrix2,
    concat: concat3
  });
  var compareUnits = createCompareUnits({
    typed: typed3
  });
  return typed3(name147, createSmallerNumber({
    typed: typed3,
    config: config5
  }), {
    "boolean, boolean": (x, y) => x < y,
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.lt(y) && !nearlyEqual2(x, y, config5.relTol, config5.absTol);
    },
    "bigint, bigint": (x, y) => x < y,
    "Fraction, Fraction": (x, y) => x.compare(y) === -1,
    "Complex, Complex": function ComplexComplex(x, y) {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, compareUnits, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var createSmallerNumber = /* @__PURE__ */ factory(name147, ["typed", "config"], (_ref2) => {
  var {
    typed: typed3,
    config: config5
  } = _ref2;
  return typed3(name147, {
    "number, number": function numberNumber(x, y) {
      return x < y && !nearlyEqual(x, y, config5.relTol, config5.absTol);
    }
  });
});

// node_modules/mathjs/lib/esm/function/relational/smallerEq.js
var name148 = "smallerEq";
var dependencies149 = ["typed", "config", "matrix", "DenseMatrix", "concat"];
var createSmallerEq = /* @__PURE__ */ factory(name148, dependencies149, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed3
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix: matrix2,
    concat: concat3
  });
  var compareUnits = createCompareUnits({
    typed: typed3
  });
  return typed3(name148, createSmallerEqNumber({
    typed: typed3,
    config: config5
  }), {
    "boolean, boolean": (x, y) => x <= y,
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.lte(y) || nearlyEqual2(x, y, config5.relTol, config5.absTol);
    },
    "bigint, bigint": (x, y) => x <= y,
    "Fraction, Fraction": (x, y) => x.compare(y) !== 1,
    "Complex, Complex": function ComplexComplex() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, compareUnits, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var createSmallerEqNumber = /* @__PURE__ */ factory(name148, ["typed", "config"], (_ref2) => {
  var {
    typed: typed3,
    config: config5
  } = _ref2;
  return typed3(name148, {
    "number, number": function numberNumber(x, y) {
      return x <= y || nearlyEqual(x, y, config5.relTol, config5.absTol);
    }
  });
});

// node_modules/mathjs/lib/esm/function/relational/larger.js
var name149 = "larger";
var dependencies150 = ["typed", "config", "matrix", "DenseMatrix", "concat"];
var createLarger = /* @__PURE__ */ factory(name149, dependencies150, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed3
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix: matrix2,
    concat: concat3
  });
  var compareUnits = createCompareUnits({
    typed: typed3
  });
  return typed3(name149, createLargerNumber({
    typed: typed3,
    config: config5
  }), {
    "boolean, boolean": (x, y) => x > y,
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.gt(y) && !nearlyEqual2(x, y, config5.relTol, config5.absTol);
    },
    "bigint, bigint": (x, y) => x > y,
    "Fraction, Fraction": (x, y) => x.compare(y) === 1,
    "Complex, Complex": function ComplexComplex() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, compareUnits, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var createLargerNumber = /* @__PURE__ */ factory(name149, ["typed", "config"], (_ref2) => {
  var {
    typed: typed3,
    config: config5
  } = _ref2;
  return typed3(name149, {
    "number, number": function numberNumber(x, y) {
      return x > y && !nearlyEqual(x, y, config5.relTol, config5.absTol);
    }
  });
});

// node_modules/mathjs/lib/esm/function/relational/largerEq.js
var name150 = "largerEq";
var dependencies151 = ["typed", "config", "matrix", "DenseMatrix", "concat"];
var createLargerEq = /* @__PURE__ */ factory(name150, dependencies151, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed3
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix: matrix2,
    concat: concat3
  });
  var compareUnits = createCompareUnits({
    typed: typed3
  });
  return typed3(name150, createLargerEqNumber({
    typed: typed3,
    config: config5
  }), {
    "boolean, boolean": (x, y) => x >= y,
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.gte(y) || nearlyEqual2(x, y, config5.relTol, config5.absTol);
    },
    "bigint, bigint": function bigintBigint(x, y) {
      return x >= y;
    },
    "Fraction, Fraction": (x, y) => x.compare(y) !== -1,
    "Complex, Complex": function ComplexComplex() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, compareUnits, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var createLargerEqNumber = /* @__PURE__ */ factory(name150, ["typed", "config"], (_ref2) => {
  var {
    typed: typed3,
    config: config5
  } = _ref2;
  return typed3(name150, {
    "number, number": function numberNumber(x, y) {
      return x >= y || nearlyEqual(x, y, config5.relTol, config5.absTol);
    }
  });
});

// node_modules/mathjs/lib/esm/function/relational/deepEqual.js
var name151 = "deepEqual";
var dependencies152 = ["typed", "equal"];
var createDeepEqual = /* @__PURE__ */ factory(name151, dependencies152, (_ref) => {
  var {
    typed: typed3,
    equal: equal2
  } = _ref;
  return typed3(name151, {
    "any, any": function anyAny(x, y) {
      return _deepEqual(x.valueOf(), y.valueOf());
    }
  });
  function _deepEqual(x, y) {
    if (Array.isArray(x)) {
      if (Array.isArray(y)) {
        var len = x.length;
        if (len !== y.length) {
          return false;
        }
        for (var i2 = 0; i2 < len; i2++) {
          if (!_deepEqual(x[i2], y[i2])) {
            return false;
          }
        }
        return true;
      } else {
        return false;
      }
    } else {
      if (Array.isArray(y)) {
        return false;
      } else {
        return equal2(x, y);
      }
    }
  }
});

// node_modules/mathjs/lib/esm/function/relational/unequal.js
var name152 = "unequal";
var dependencies153 = ["typed", "config", "equalScalar", "matrix", "DenseMatrix", "concat"];
var createUnequal = /* @__PURE__ */ factory(name152, dependencies153, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    equalScalar: equalScalar2,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed3
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix: matrix2,
    concat: concat3
  });
  return typed3(name152, createUnequalNumber({
    typed: typed3,
    equalScalar: equalScalar2
  }), matrixAlgorithmSuite({
    elop: _unequal,
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
  function _unequal(x, y) {
    return !equalScalar2(x, y);
  }
});
var createUnequalNumber = factory(name152, ["typed", "equalScalar"], (_ref2) => {
  var {
    typed: typed3,
    equalScalar: equalScalar2
  } = _ref2;
  return typed3(name152, {
    "any, any": function anyAny(x, y) {
      if (x === null) {
        return y !== null;
      }
      if (y === null) {
        return x !== null;
      }
      if (x === void 0) {
        return y !== void 0;
      }
      if (y === void 0) {
        return x !== void 0;
      }
      return !equalScalar2(x, y);
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/partitionSelect.js
var name153 = "partitionSelect";
var dependencies154 = ["typed", "isNumeric", "isNaN", "compare"];
var createPartitionSelect = /* @__PURE__ */ factory(name153, dependencies154, (_ref) => {
  var {
    typed: typed3,
    isNumeric: isNumeric2,
    isNaN: isNaN3,
    compare: compare2
  } = _ref;
  var asc = compare2;
  var desc = (a, b) => -compare2(a, b);
  return typed3(name153, {
    "Array | Matrix, number": function ArrayMatrixNumber(x, k) {
      return _partitionSelect(x, k, asc);
    },
    "Array | Matrix, number, string": function ArrayMatrixNumberString(x, k, compare3) {
      if (compare3 === "asc") {
        return _partitionSelect(x, k, asc);
      } else if (compare3 === "desc") {
        return _partitionSelect(x, k, desc);
      } else {
        throw new Error('Compare string must be "asc" or "desc"');
      }
    },
    "Array | Matrix, number, function": _partitionSelect
  });
  function _partitionSelect(x, k, compare3) {
    if (!isInteger(k) || k < 0) {
      throw new Error("k must be a non-negative integer");
    }
    if (isMatrix(x)) {
      var size2 = x.size();
      if (size2.length > 1) {
        throw new Error("Only one dimensional matrices supported");
      }
      return quickSelect(x.valueOf(), k, compare3);
    }
    if (Array.isArray(x)) {
      return quickSelect(x, k, compare3);
    }
  }
  function quickSelect(arr, k, compare3) {
    if (k >= arr.length) {
      throw new Error("k out of bounds");
    }
    for (var i2 = 0; i2 < arr.length; i2++) {
      if (isNumeric2(arr[i2]) && isNaN3(arr[i2])) {
        return arr[i2];
      }
    }
    var from = 0;
    var to2 = arr.length - 1;
    while (from < to2) {
      var r = from;
      var w = to2;
      var pivot = arr[Math.floor(Math.random() * (to2 - from + 1)) + from];
      while (r < w) {
        if (compare3(arr[r], pivot) >= 0) {
          var tmp = arr[w];
          arr[w] = arr[r];
          arr[r] = tmp;
          --w;
        } else {
          ++r;
        }
      }
      if (compare3(arr[r], pivot) > 0) {
        --r;
      }
      if (k <= r) {
        to2 = r;
      } else {
        from = r + 1;
      }
    }
    return arr[k];
  }
});

// node_modules/mathjs/lib/esm/function/matrix/sort.js
var name154 = "sort";
var dependencies155 = ["typed", "matrix", "compare", "compareNatural"];
var createSort = /* @__PURE__ */ factory(name154, dependencies155, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    compare: compare2,
    compareNatural: compareNatural2
  } = _ref;
  var compareAsc = compare2;
  var compareDesc = (a, b) => -compare2(a, b);
  return typed3(name154, {
    Array: function Array2(x) {
      _arrayIsVector(x);
      return x.sort(compareAsc);
    },
    Matrix: function Matrix2(x) {
      _matrixIsVector(x);
      return matrix2(x.toArray().sort(compareAsc), x.storage());
    },
    "Array, function": function ArrayFunction(x, _comparator2) {
      _arrayIsVector(x);
      return x.sort(_comparator2);
    },
    "Matrix, function": function MatrixFunction(x, _comparator2) {
      _matrixIsVector(x);
      return matrix2(x.toArray().sort(_comparator2), x.storage());
    },
    "Array, string": function ArrayString(x, order) {
      _arrayIsVector(x);
      return x.sort(_comparator(order));
    },
    "Matrix, string": function MatrixString(x, order) {
      _matrixIsVector(x);
      return matrix2(x.toArray().sort(_comparator(order)), x.storage());
    }
  });
  function _comparator(order) {
    if (order === "asc") {
      return compareAsc;
    } else if (order === "desc") {
      return compareDesc;
    } else if (order === "natural") {
      return compareNatural2;
    } else {
      throw new Error('String "asc", "desc", or "natural" expected');
    }
  }
  function _arrayIsVector(array) {
    if (arraySize(array).length !== 1) {
      throw new Error("One dimensional array expected");
    }
  }
  function _matrixIsVector(matrix3) {
    if (matrix3.size().length !== 1) {
      throw new Error("One dimensional matrix expected");
    }
  }
});

// node_modules/mathjs/lib/esm/function/statistics/max.js
var name155 = "max";
var dependencies156 = ["typed", "config", "numeric", "larger"];
var createMax = /* @__PURE__ */ factory(name155, dependencies156, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    numeric: numeric3,
    larger: larger2
  } = _ref;
  return typed3(name155, {
    // max([a, b, c, d, ...])
    "Array | Matrix": _max,
    // max([a, b, c, d, ...], dim)
    "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
      return reduce(array, dim.valueOf(), _largest);
    },
    // max(a, b, c, d, ...)
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("Scalar values expected in function max");
      }
      return _max(args);
    }
  });
  function _largest(x, y) {
    try {
      return larger2(x, y) ? x : y;
    } catch (err) {
      throw improveErrorMessage(err, "max", y);
    }
  }
  function _max(array) {
    var res;
    deepForEach(array, function(value) {
      try {
        if (isNaN(value) && typeof value === "number") {
          res = NaN;
        } else if (res === void 0 || larger2(value, res)) {
          res = value;
        }
      } catch (err) {
        throw improveErrorMessage(err, "max", value);
      }
    });
    if (res === void 0) {
      throw new Error("Cannot calculate max of an empty array");
    }
    if (typeof res === "string") {
      res = numeric3(res, safeNumberType(res, config5));
    }
    return res;
  }
});

// node_modules/mathjs/lib/esm/function/statistics/min.js
var name156 = "min";
var dependencies157 = ["typed", "config", "numeric", "smaller"];
var createMin = /* @__PURE__ */ factory(name156, dependencies157, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    numeric: numeric3,
    smaller: smaller2
  } = _ref;
  return typed3(name156, {
    // min([a, b, c, d, ...])
    "Array | Matrix": _min,
    // min([a, b, c, d, ...], dim)
    "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
      return reduce(array, dim.valueOf(), _smallest);
    },
    // min(a, b, c, d, ...)
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("Scalar values expected in function min");
      }
      return _min(args);
    }
  });
  function _smallest(x, y) {
    try {
      return smaller2(x, y) ? x : y;
    } catch (err) {
      throw improveErrorMessage(err, "min", y);
    }
  }
  function _min(array) {
    var min3;
    deepForEach(array, function(value) {
      try {
        if (isNaN(value) && typeof value === "number") {
          min3 = NaN;
        } else if (min3 === void 0 || smaller2(value, min3)) {
          min3 = value;
        }
      } catch (err) {
        throw improveErrorMessage(err, "min", value);
      }
    });
    if (min3 === void 0) {
      throw new Error("Cannot calculate min of an empty array");
    }
    if (typeof min3 === "string") {
      min3 = numeric3(min3, safeNumberType(min3, config5));
    }
    return min3;
  }
});

// node_modules/mathjs/lib/esm/type/matrix/ImmutableDenseMatrix.js
var name157 = "ImmutableDenseMatrix";
var dependencies158 = ["smaller", "DenseMatrix"];
var createImmutableDenseMatrixClass = /* @__PURE__ */ factory(name157, dependencies158, (_ref) => {
  var {
    smaller: smaller2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  function ImmutableDenseMatrix2(data, datatype) {
    if (!(this instanceof ImmutableDenseMatrix2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (datatype && !isString(datatype)) {
      throw new Error("Invalid datatype: " + datatype);
    }
    if (isMatrix(data) || isArray(data)) {
      var matrix2 = new DenseMatrix2(data, datatype);
      this._data = matrix2._data;
      this._size = matrix2._size;
      this._datatype = matrix2._datatype;
      this._min = null;
      this._max = null;
    } else if (data && isArray(data.data) && isArray(data.size)) {
      this._data = data.data;
      this._size = data.size;
      this._datatype = data.datatype;
      this._min = typeof data.min !== "undefined" ? data.min : null;
      this._max = typeof data.max !== "undefined" ? data.max : null;
    } else if (data) {
      throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
    } else {
      this._data = [];
      this._size = [0];
      this._datatype = datatype;
      this._min = null;
      this._max = null;
    }
  }
  ImmutableDenseMatrix2.prototype = new DenseMatrix2();
  ImmutableDenseMatrix2.prototype.type = "ImmutableDenseMatrix";
  ImmutableDenseMatrix2.prototype.isImmutableDenseMatrix = true;
  ImmutableDenseMatrix2.prototype.subset = function(index2) {
    switch (arguments.length) {
      case 1: {
        var m = DenseMatrix2.prototype.subset.call(this, index2);
        if (isMatrix(m)) {
          return new ImmutableDenseMatrix2({
            data: m._data,
            size: m._size,
            datatype: m._datatype
          });
        }
        return m;
      }
      case 2:
      case 3:
        throw new Error("Cannot invoke set subset on an Immutable Matrix instance");
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  };
  ImmutableDenseMatrix2.prototype.set = function() {
    throw new Error("Cannot invoke set on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix2.prototype.resize = function() {
    throw new Error("Cannot invoke resize on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix2.prototype.reshape = function() {
    throw new Error("Cannot invoke reshape on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix2.prototype.clone = function() {
    return new ImmutableDenseMatrix2({
      data: clone(this._data),
      size: clone(this._size),
      datatype: this._datatype
    });
  };
  ImmutableDenseMatrix2.prototype.toJSON = function() {
    return {
      mathjs: "ImmutableDenseMatrix",
      data: this._data,
      size: this._size,
      datatype: this._datatype
    };
  };
  ImmutableDenseMatrix2.fromJSON = function(json) {
    return new ImmutableDenseMatrix2(json);
  };
  ImmutableDenseMatrix2.prototype.swapRows = function() {
    throw new Error("Cannot invoke swapRows on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix2.prototype.min = function() {
    if (this._min === null) {
      var m = null;
      this.forEach(function(v) {
        if (m === null || smaller2(v, m)) {
          m = v;
        }
      });
      this._min = m !== null ? m : void 0;
    }
    return this._min;
  };
  ImmutableDenseMatrix2.prototype.max = function() {
    if (this._max === null) {
      var m = null;
      this.forEach(function(v) {
        if (m === null || smaller2(m, v)) {
          m = v;
        }
      });
      this._max = m !== null ? m : void 0;
    }
    return this._max;
  };
  return ImmutableDenseMatrix2;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/matrix/MatrixIndex.js
var name158 = "Index";
var dependencies159 = ["ImmutableDenseMatrix", "getMatrixDataType"];
var createIndexClass = /* @__PURE__ */ factory(name158, dependencies159, (_ref) => {
  var {
    ImmutableDenseMatrix: ImmutableDenseMatrix2,
    getMatrixDataType: getMatrixDataType2
  } = _ref;
  function Index2(ranges) {
    if (!(this instanceof Index2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this._dimensions = [];
    this._sourceSize = [];
    this._isScalar = true;
    for (var i2 = 0, ii = arguments.length; i2 < ii; i2++) {
      var arg2 = arguments[i2];
      var argIsArray = isArray(arg2);
      var argIsMatrix = isMatrix(arg2);
      var sourceSize = null;
      if (isRange(arg2)) {
        this._dimensions.push(arg2);
        this._isScalar = false;
      } else if (argIsArray || argIsMatrix) {
        var m = void 0;
        if (getMatrixDataType2(arg2) === "boolean") {
          if (argIsArray)
            m = _createImmutableMatrix(_booleansArrayToNumbersForIndex(arg2).valueOf());
          if (argIsMatrix)
            m = _createImmutableMatrix(_booleansArrayToNumbersForIndex(arg2._data).valueOf());
          sourceSize = arg2.valueOf().length;
        } else {
          m = _createImmutableMatrix(arg2.valueOf());
        }
        this._dimensions.push(m);
        var size2 = m.size();
        if (size2.length !== 1 || size2[0] !== 1 || sourceSize !== null) {
          this._isScalar = false;
        }
      } else if (typeof arg2 === "number") {
        this._dimensions.push(_createImmutableMatrix([arg2]));
      } else if (typeof arg2 === "string") {
        this._dimensions.push(arg2);
      } else {
        throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");
      }
      this._sourceSize.push(sourceSize);
    }
  }
  Index2.prototype.type = "Index";
  Index2.prototype.isIndex = true;
  function _createImmutableMatrix(arg2) {
    for (var i2 = 0, l = arg2.length; i2 < l; i2++) {
      if (typeof arg2[i2] !== "number" || !isInteger(arg2[i2])) {
        throw new TypeError("Index parameters must be positive integer numbers");
      }
    }
    return new ImmutableDenseMatrix2(arg2);
  }
  Index2.prototype.clone = function() {
    var index2 = new Index2();
    index2._dimensions = clone(this._dimensions);
    index2._isScalar = this._isScalar;
    index2._sourceSize = this._sourceSize;
    return index2;
  };
  Index2.create = function(ranges) {
    var index2 = new Index2();
    Index2.apply(index2, ranges);
    return index2;
  };
  Index2.prototype.size = function() {
    var size2 = [];
    for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
      var d = this._dimensions[i2];
      size2[i2] = typeof d === "string" ? 1 : d.size()[0];
    }
    return size2;
  };
  Index2.prototype.max = function() {
    var values = [];
    for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
      var range2 = this._dimensions[i2];
      values[i2] = typeof range2 === "string" ? range2 : range2.max();
    }
    return values;
  };
  Index2.prototype.min = function() {
    var values = [];
    for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
      var range2 = this._dimensions[i2];
      values[i2] = typeof range2 === "string" ? range2 : range2.min();
    }
    return values;
  };
  Index2.prototype.forEach = function(callback) {
    for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
      callback(this._dimensions[i2], i2, this);
    }
  };
  Index2.prototype.dimension = function(dim) {
    return this._dimensions[dim] || null;
  };
  Index2.prototype.isObjectProperty = function() {
    return this._dimensions.length === 1 && typeof this._dimensions[0] === "string";
  };
  Index2.prototype.getObjectProperty = function() {
    return this.isObjectProperty() ? this._dimensions[0] : null;
  };
  Index2.prototype.isScalar = function() {
    return this._isScalar;
  };
  Index2.prototype.toArray = function() {
    var array = [];
    for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
      var dimension = this._dimensions[i2];
      array.push(typeof dimension === "string" ? dimension : dimension.toArray());
    }
    return array;
  };
  Index2.prototype.valueOf = Index2.prototype.toArray;
  Index2.prototype.toString = function() {
    var strings = [];
    for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
      var dimension = this._dimensions[i2];
      if (typeof dimension === "string") {
        strings.push(JSON.stringify(dimension));
      } else {
        strings.push(dimension.toString());
      }
    }
    return "[" + strings.join(", ") + "]";
  };
  Index2.prototype.toJSON = function() {
    return {
      mathjs: "Index",
      dimensions: this._dimensions
    };
  };
  Index2.fromJSON = function(json) {
    return Index2.create(json.dimensions);
  };
  return Index2;
}, {
  isClass: true
});
function _booleansArrayToNumbersForIndex(booleanArrayIndex) {
  var indexOfNumbers = [];
  booleanArrayIndex.forEach((bool, idx) => {
    if (bool) {
      indexOfNumbers.push(idx);
    }
  });
  return indexOfNumbers;
}

// node_modules/mathjs/lib/esm/type/matrix/FibonacciHeap.js
var name159 = "FibonacciHeap";
var dependencies160 = ["smaller", "larger"];
var createFibonacciHeapClass = /* @__PURE__ */ factory(name159, dependencies160, (_ref) => {
  var {
    smaller: smaller2,
    larger: larger2
  } = _ref;
  var oneOverLogPhi = 1 / Math.log((1 + Math.sqrt(5)) / 2);
  function FibonacciHeap2() {
    if (!(this instanceof FibonacciHeap2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this._minimum = null;
    this._size = 0;
  }
  FibonacciHeap2.prototype.type = "FibonacciHeap";
  FibonacciHeap2.prototype.isFibonacciHeap = true;
  FibonacciHeap2.prototype.insert = function(key, value) {
    var node = {
      key,
      value,
      degree: 0
    };
    if (this._minimum) {
      var minimum = this._minimum;
      node.left = minimum;
      node.right = minimum.right;
      minimum.right = node;
      node.right.left = node;
      if (smaller2(key, minimum.key)) {
        this._minimum = node;
      }
    } else {
      node.left = node;
      node.right = node;
      this._minimum = node;
    }
    this._size++;
    return node;
  };
  FibonacciHeap2.prototype.size = function() {
    return this._size;
  };
  FibonacciHeap2.prototype.clear = function() {
    this._minimum = null;
    this._size = 0;
  };
  FibonacciHeap2.prototype.isEmpty = function() {
    return this._size === 0;
  };
  FibonacciHeap2.prototype.extractMinimum = function() {
    var node = this._minimum;
    if (node === null) {
      return node;
    }
    var minimum = this._minimum;
    var numberOfChildren = node.degree;
    var x = node.child;
    while (numberOfChildren > 0) {
      var tempRight = x.right;
      x.left.right = x.right;
      x.right.left = x.left;
      x.left = minimum;
      x.right = minimum.right;
      minimum.right = x;
      x.right.left = x;
      x.parent = null;
      x = tempRight;
      numberOfChildren--;
    }
    node.left.right = node.right;
    node.right.left = node.left;
    if (node === node.right) {
      minimum = null;
    } else {
      minimum = node.right;
      minimum = _findMinimumNode(minimum, this._size);
    }
    this._size--;
    this._minimum = minimum;
    return node;
  };
  FibonacciHeap2.prototype.remove = function(node) {
    this._minimum = _decreaseKey(this._minimum, node, -1);
    this.extractMinimum();
  };
  function _decreaseKey(minimum, node, key) {
    node.key = key;
    var parent = node.parent;
    if (parent && smaller2(node.key, parent.key)) {
      _cut(minimum, node, parent);
      _cascadingCut(minimum, parent);
    }
    if (smaller2(node.key, minimum.key)) {
      minimum = node;
    }
    return minimum;
  }
  function _cut(minimum, node, parent) {
    node.left.right = node.right;
    node.right.left = node.left;
    parent.degree--;
    if (parent.child === node) {
      parent.child = node.right;
    }
    if (parent.degree === 0) {
      parent.child = null;
    }
    node.left = minimum;
    node.right = minimum.right;
    minimum.right = node;
    node.right.left = node;
    node.parent = null;
    node.mark = false;
  }
  function _cascadingCut(minimum, node) {
    var parent = node.parent;
    if (!parent) {
      return;
    }
    if (!node.mark) {
      node.mark = true;
    } else {
      _cut(minimum, node, parent);
      _cascadingCut(parent);
    }
  }
  var _linkNodes = function _linkNodes2(node, parent) {
    node.left.right = node.right;
    node.right.left = node.left;
    node.parent = parent;
    if (!parent.child) {
      parent.child = node;
      node.right = node;
      node.left = node;
    } else {
      node.left = parent.child;
      node.right = parent.child.right;
      parent.child.right = node;
      node.right.left = node;
    }
    parent.degree++;
    node.mark = false;
  };
  function _findMinimumNode(minimum, size2) {
    var arraySize2 = Math.floor(Math.log(size2) * oneOverLogPhi) + 1;
    var array = new Array(arraySize2);
    var numRoots = 0;
    var x = minimum;
    if (x) {
      numRoots++;
      x = x.right;
      while (x !== minimum) {
        numRoots++;
        x = x.right;
      }
    }
    var y;
    while (numRoots > 0) {
      var d = x.degree;
      var next = x.right;
      while (true) {
        y = array[d];
        if (!y) {
          break;
        }
        if (larger2(x.key, y.key)) {
          var temp = y;
          y = x;
          x = temp;
        }
        _linkNodes(y, x);
        array[d] = null;
        d++;
      }
      array[d] = x;
      x = next;
      numRoots--;
    }
    minimum = null;
    for (var i2 = 0; i2 < arraySize2; i2++) {
      y = array[i2];
      if (!y) {
        continue;
      }
      if (minimum) {
        y.left.right = y.right;
        y.right.left = y.left;
        y.left = minimum;
        y.right = minimum.right;
        minimum.right = y;
        y.right.left = y;
        if (smaller2(y.key, minimum.key)) {
          minimum = y;
        }
      } else {
        minimum = y;
      }
    }
    return minimum;
  }
  return FibonacciHeap2;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/matrix/Spa.js
var name160 = "Spa";
var dependencies161 = ["addScalar", "equalScalar", "FibonacciHeap"];
var createSpaClass = /* @__PURE__ */ factory(name160, dependencies161, (_ref) => {
  var {
    addScalar: addScalar2,
    equalScalar: equalScalar2,
    FibonacciHeap: FibonacciHeap2
  } = _ref;
  function Spa2() {
    if (!(this instanceof Spa2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this._values = [];
    this._heap = new FibonacciHeap2();
  }
  Spa2.prototype.type = "Spa";
  Spa2.prototype.isSpa = true;
  Spa2.prototype.set = function(i2, v) {
    if (!this._values[i2]) {
      var node = this._heap.insert(i2, v);
      this._values[i2] = node;
    } else {
      this._values[i2].value = v;
    }
  };
  Spa2.prototype.get = function(i2) {
    var node = this._values[i2];
    if (node) {
      return node.value;
    }
    return 0;
  };
  Spa2.prototype.accumulate = function(i2, v) {
    var node = this._values[i2];
    if (!node) {
      node = this._heap.insert(i2, v);
      this._values[i2] = node;
    } else {
      node.value = addScalar2(node.value, v);
    }
  };
  Spa2.prototype.forEach = function(from, to2, callback) {
    var heap = this._heap;
    var values = this._values;
    var nodes = [];
    var node = heap.extractMinimum();
    if (node) {
      nodes.push(node);
    }
    while (node && node.key <= to2) {
      if (node.key >= from) {
        if (!equalScalar2(node.value, 0)) {
          callback(node.key, node.value, this);
        }
      }
      node = heap.extractMinimum();
      if (node) {
        nodes.push(node);
      }
    }
    for (var i2 = 0; i2 < nodes.length; i2++) {
      var n = nodes[i2];
      node = heap.insert(n.key, n.value);
      values[node.key] = node;
    }
  };
  Spa2.prototype.swap = function(i2, j) {
    var nodei = this._values[i2];
    var nodej = this._values[j];
    if (!nodei && nodej) {
      nodei = this._heap.insert(i2, nodej.value);
      this._heap.remove(nodej);
      this._values[i2] = nodei;
      this._values[j] = void 0;
    } else if (nodei && !nodej) {
      nodej = this._heap.insert(j, nodei.value);
      this._heap.remove(nodei);
      this._values[j] = nodej;
      this._values[i2] = void 0;
    } else if (nodei && nodej) {
      var v = nodei.value;
      nodei.value = nodej.value;
      nodej.value = v;
    }
  };
  return Spa2;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/utils/bignumber/constants.js
var createBigNumberE = memoize(function(BigNumber2) {
  return new BigNumber2(1).exp();
}, {
  hasher
});
var createBigNumberPhi = memoize(function(BigNumber2) {
  return new BigNumber2(1).plus(new BigNumber2(5).sqrt()).div(2);
}, {
  hasher
});
var createBigNumberPi = memoize(function(BigNumber2) {
  return BigNumber2.acos(-1);
}, {
  hasher
});
var createBigNumberTau = memoize(function(BigNumber2) {
  return createBigNumberPi(BigNumber2).times(2);
}, {
  hasher
});
function hasher(args) {
  return args[0].precision;
}

// node_modules/mathjs/lib/esm/type/unit/Unit.js
function ownKeys2(e3, r) {
  var t = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e3);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e3, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e3) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys2(Object(t), true).forEach(function(r2) {
      _defineProperty(e3, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t)) : ownKeys2(Object(t)).forEach(function(r2) {
      Object.defineProperty(e3, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e3;
}
var name161 = "Unit";
var dependencies162 = ["?on", "config", "addScalar", "subtractScalar", "multiplyScalar", "divideScalar", "pow", "abs", "fix", "round", "equal", "isNumeric", "format", "number", "Complex", "BigNumber", "Fraction"];
var createUnitClass = /* @__PURE__ */ factory(name161, dependencies162, (_ref) => {
  var {
    on,
    config: config5,
    addScalar: addScalar2,
    subtractScalar: subtractScalar2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    pow: pow3,
    abs: abs3,
    fix: fix2,
    round: round3,
    equal: equal2,
    isNumeric: isNumeric2,
    format: format5,
    number: _number,
    Complex: Complex3,
    BigNumber: _BigNumber,
    Fraction: _Fraction
  } = _ref;
  var toNumber = _number;
  function Unit2(value, valuelessUnit) {
    if (!(this instanceof Unit2)) {
      throw new Error("Constructor must be called with the new operator");
    }
    if (!(value === null || value === void 0 || isNumeric2(value) || isComplex(value))) {
      throw new TypeError("First parameter in Unit constructor must be number, BigNumber, Fraction, Complex, or undefined");
    }
    this.fixPrefix = false;
    this.skipAutomaticSimplification = true;
    if (valuelessUnit === void 0) {
      this.units = [];
      this.dimensions = BASE_DIMENSIONS.map((x) => 0);
    } else if (typeof valuelessUnit === "string") {
      var u = Unit2.parse(valuelessUnit);
      this.units = u.units;
      this.dimensions = u.dimensions;
    } else if (isUnit(valuelessUnit) && valuelessUnit.value === null) {
      this.fixPrefix = valuelessUnit.fixPrefix;
      this.skipAutomaticSimplification = valuelessUnit.skipAutomaticSimplification;
      this.dimensions = valuelessUnit.dimensions.slice(0);
      this.units = valuelessUnit.units.map((u2) => _extends({}, u2));
    } else {
      throw new TypeError("Second parameter in Unit constructor must be a string or valueless Unit");
    }
    this.value = this._normalize(value);
  }
  Object.defineProperty(Unit2, "name", {
    value: "Unit"
  });
  Unit2.prototype.constructor = Unit2;
  Unit2.prototype.type = "Unit";
  Unit2.prototype.isUnit = true;
  var text, index2, c;
  function skipWhitespace() {
    while (c === " " || c === "	") {
      next();
    }
  }
  function isDigitDot(c2) {
    return c2 >= "0" && c2 <= "9" || c2 === ".";
  }
  function isDigit(c2) {
    return c2 >= "0" && c2 <= "9";
  }
  function next() {
    index2++;
    c = text.charAt(index2);
  }
  function revert(oldIndex) {
    index2 = oldIndex;
    c = text.charAt(index2);
  }
  function parseNumber() {
    var number2 = "";
    var oldIndex = index2;
    if (c === "+") {
      next();
    } else if (c === "-") {
      number2 += c;
      next();
    }
    if (!isDigitDot(c)) {
      revert(oldIndex);
      return null;
    }
    if (c === ".") {
      number2 += c;
      next();
      if (!isDigit(c)) {
        revert(oldIndex);
        return null;
      }
    } else {
      while (isDigit(c)) {
        number2 += c;
        next();
      }
      if (c === ".") {
        number2 += c;
        next();
      }
    }
    while (isDigit(c)) {
      number2 += c;
      next();
    }
    if (c === "E" || c === "e") {
      var tentativeNumber = "";
      var tentativeIndex = index2;
      tentativeNumber += c;
      next();
      if (c === "+" || c === "-") {
        tentativeNumber += c;
        next();
      }
      if (!isDigit(c)) {
        revert(tentativeIndex);
        return number2;
      }
      number2 = number2 + tentativeNumber;
      while (isDigit(c)) {
        number2 += c;
        next();
      }
    }
    return number2;
  }
  function parseUnit() {
    var unitName = "";
    while (isDigit(c) || Unit2.isValidAlpha(c)) {
      unitName += c;
      next();
    }
    var firstC = unitName.charAt(0);
    if (Unit2.isValidAlpha(firstC)) {
      return unitName;
    } else {
      return null;
    }
  }
  function parseCharacter(toFind) {
    if (c === toFind) {
      next();
      return toFind;
    } else {
      return null;
    }
  }
  Unit2.parse = function(str, options2) {
    options2 = options2 || {};
    text = str;
    index2 = -1;
    c = "";
    if (typeof text !== "string") {
      throw new TypeError("Invalid argument in Unit.parse, string expected");
    }
    var unit3 = new Unit2();
    unit3.units = [];
    var powerMultiplierCurrent = 1;
    var expectingUnit = false;
    next();
    skipWhitespace();
    var valueStr = parseNumber();
    var value = null;
    if (valueStr) {
      if (config5.number === "BigNumber") {
        value = new _BigNumber(valueStr);
      } else if (config5.number === "Fraction") {
        try {
          value = new _Fraction(valueStr);
        } catch (err) {
          value = parseFloat(valueStr);
        }
      } else {
        value = parseFloat(valueStr);
      }
      skipWhitespace();
      if (parseCharacter("*")) {
        powerMultiplierCurrent = 1;
        expectingUnit = true;
      } else if (parseCharacter("/")) {
        powerMultiplierCurrent = -1;
        expectingUnit = true;
      }
    }
    var powerMultiplierStack = [];
    var powerMultiplierStackProduct = 1;
    while (true) {
      skipWhitespace();
      while (c === "(") {
        powerMultiplierStack.push(powerMultiplierCurrent);
        powerMultiplierStackProduct *= powerMultiplierCurrent;
        powerMultiplierCurrent = 1;
        next();
        skipWhitespace();
      }
      var uStr = void 0;
      if (c) {
        var oldC = c;
        uStr = parseUnit();
        if (uStr === null) {
          throw new SyntaxError('Unexpected "' + oldC + '" in "' + text + '" at index ' + index2.toString());
        }
      } else {
        break;
      }
      var res = _findUnit(uStr);
      if (res === null) {
        throw new SyntaxError('Unit "' + uStr + '" not found.');
      }
      var power = powerMultiplierCurrent * powerMultiplierStackProduct;
      skipWhitespace();
      if (parseCharacter("^")) {
        skipWhitespace();
        var p = parseNumber();
        if (p === null) {
          throw new SyntaxError('In "' + str + '", "^" must be followed by a floating-point number');
        }
        power *= p;
      }
      unit3.units.push({
        unit: res.unit,
        prefix: res.prefix,
        power
      });
      for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
        unit3.dimensions[i2] += (res.unit.dimensions[i2] || 0) * power;
      }
      skipWhitespace();
      while (c === ")") {
        if (powerMultiplierStack.length === 0) {
          throw new SyntaxError('Unmatched ")" in "' + text + '" at index ' + index2.toString());
        }
        powerMultiplierStackProduct /= powerMultiplierStack.pop();
        next();
        skipWhitespace();
      }
      expectingUnit = false;
      if (parseCharacter("*")) {
        powerMultiplierCurrent = 1;
        expectingUnit = true;
      } else if (parseCharacter("/")) {
        powerMultiplierCurrent = -1;
        expectingUnit = true;
      } else {
        powerMultiplierCurrent = 1;
      }
      if (res.unit.base) {
        var baseDim = res.unit.base.key;
        UNIT_SYSTEMS.auto[baseDim] = {
          unit: res.unit,
          prefix: res.prefix
        };
      }
    }
    skipWhitespace();
    if (c) {
      throw new SyntaxError('Could not parse: "' + str + '"');
    }
    if (expectingUnit) {
      throw new SyntaxError('Trailing characters: "' + str + '"');
    }
    if (powerMultiplierStack.length !== 0) {
      throw new SyntaxError('Unmatched "(" in "' + text + '"');
    }
    if (unit3.units.length === 0 && !options2.allowNoUnits) {
      throw new SyntaxError('"' + str + '" contains no units');
    }
    unit3.value = value !== void 0 ? unit3._normalize(value) : null;
    return unit3;
  };
  Unit2.prototype.clone = function() {
    var unit3 = new Unit2();
    unit3.fixPrefix = this.fixPrefix;
    unit3.skipAutomaticSimplification = this.skipAutomaticSimplification;
    unit3.value = clone(this.value);
    unit3.dimensions = this.dimensions.slice(0);
    unit3.units = [];
    for (var i2 = 0; i2 < this.units.length; i2++) {
      unit3.units[i2] = {};
      for (var p in this.units[i2]) {
        if (hasOwnProperty(this.units[i2], p)) {
          unit3.units[i2][p] = this.units[i2][p];
        }
      }
    }
    return unit3;
  };
  Unit2.prototype.valueType = function() {
    return typeOf(this.value);
  };
  Unit2.prototype._isDerived = function() {
    if (this.units.length === 0) {
      return false;
    }
    return this.units.length > 1 || Math.abs(this.units[0].power - 1) > 1e-15;
  };
  Unit2.prototype._normalize = function(value) {
    if (value === null || value === void 0 || this.units.length === 0) {
      return value;
    }
    var res = value;
    var convert = Unit2._getNumberConverter(typeOf(value));
    for (var i2 = 0; i2 < this.units.length; i2++) {
      var unitValue = convert(this.units[i2].unit.value);
      var unitPrefixValue = convert(this.units[i2].prefix.value);
      var unitPower = convert(this.units[i2].power);
      res = multiplyScalar2(res, pow3(multiplyScalar2(unitValue, unitPrefixValue), unitPower));
    }
    return res;
  };
  Unit2.prototype._denormalize = function(value, prefixValue) {
    if (value === null || value === void 0 || this.units.length === 0) {
      return value;
    }
    var res = value;
    var convert = Unit2._getNumberConverter(typeOf(value));
    for (var i2 = 0; i2 < this.units.length; i2++) {
      var unitValue = convert(this.units[i2].unit.value);
      var unitPrefixValue = convert(this.units[i2].prefix.value);
      var unitPower = convert(this.units[i2].power);
      res = divideScalar2(res, pow3(multiplyScalar2(unitValue, unitPrefixValue), unitPower));
    }
    return res;
  };
  var _findUnit = memoize((str) => {
    if (hasOwnProperty(UNITS, str)) {
      var unit3 = UNITS[str];
      var prefix = unit3.prefixes[""];
      return {
        unit: unit3,
        prefix
      };
    }
    for (var _name in UNITS) {
      if (hasOwnProperty(UNITS, _name)) {
        if (endsWith(str, _name)) {
          var _unit = UNITS[_name];
          var prefixLen = str.length - _name.length;
          var prefixName = str.substring(0, prefixLen);
          var _prefix = hasOwnProperty(_unit.prefixes, prefixName) ? _unit.prefixes[prefixName] : void 0;
          if (_prefix !== void 0) {
            return {
              unit: _unit,
              prefix: _prefix
            };
          }
        }
      }
    }
    return null;
  }, {
    hasher: (args) => args[0],
    limit: 100
  });
  Unit2.isValuelessUnit = function(name314) {
    return _findUnit(name314) !== null;
  };
  Unit2.prototype.hasBase = function(base) {
    if (typeof base === "string") {
      base = BASE_UNITS[base];
    }
    if (!base) {
      return false;
    }
    for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
      if (Math.abs((this.dimensions[i2] || 0) - (base.dimensions[i2] || 0)) > 1e-12) {
        return false;
      }
    }
    return true;
  };
  Unit2.prototype.equalBase = function(other) {
    for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
      if (Math.abs((this.dimensions[i2] || 0) - (other.dimensions[i2] || 0)) > 1e-12) {
        return false;
      }
    }
    return true;
  };
  Unit2.prototype.equals = function(other) {
    return this.equalBase(other) && equal2(this.value, other.value);
  };
  Unit2.prototype.multiply = function(_other) {
    var res = this.clone();
    var other = isUnit(_other) ? _other : new Unit2(_other);
    for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
      res.dimensions[i2] = (this.dimensions[i2] || 0) + (other.dimensions[i2] || 0);
    }
    for (var _i = 0; _i < other.units.length; _i++) {
      var inverted = _objectSpread2({}, other.units[_i]);
      res.units.push(inverted);
    }
    if (this.value !== null || other.value !== null) {
      var valThis = this.value === null ? this._normalize(1) : this.value;
      var valOther = other.value === null ? other._normalize(1) : other.value;
      res.value = multiplyScalar2(valThis, valOther);
    } else {
      res.value = null;
    }
    if (isUnit(_other)) {
      res.skipAutomaticSimplification = false;
    }
    return getNumericIfUnitless(res);
  };
  Unit2.prototype.divideInto = function(numerator) {
    return new Unit2(numerator).divide(this);
  };
  Unit2.prototype.divide = function(_other) {
    var res = this.clone();
    var other = isUnit(_other) ? _other : new Unit2(_other);
    for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
      res.dimensions[i2] = (this.dimensions[i2] || 0) - (other.dimensions[i2] || 0);
    }
    for (var _i2 = 0; _i2 < other.units.length; _i2++) {
      var inverted = _objectSpread2(_objectSpread2({}, other.units[_i2]), {}, {
        power: -other.units[_i2].power
      });
      res.units.push(inverted);
    }
    if (this.value !== null || other.value !== null) {
      var valThis = this.value === null ? this._normalize(1) : this.value;
      var valOther = other.value === null ? other._normalize(1) : other.value;
      res.value = divideScalar2(valThis, valOther);
    } else {
      res.value = null;
    }
    if (isUnit(_other)) {
      res.skipAutomaticSimplification = false;
    }
    return getNumericIfUnitless(res);
  };
  Unit2.prototype.pow = function(p) {
    var res = this.clone();
    for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
      res.dimensions[i2] = (this.dimensions[i2] || 0) * p;
    }
    for (var _i3 = 0; _i3 < res.units.length; _i3++) {
      res.units[_i3].power *= p;
    }
    if (res.value !== null) {
      res.value = pow3(res.value, p);
    } else {
      res.value = null;
    }
    res.skipAutomaticSimplification = false;
    return getNumericIfUnitless(res);
  };
  function getNumericIfUnitless(unit3) {
    if (unit3.equalBase(BASE_UNITS.NONE) && unit3.value !== null && !config5.predictable) {
      return unit3.value;
    } else {
      return unit3;
    }
  }
  Unit2.prototype.abs = function() {
    var ret = this.clone();
    if (ret.value !== null) {
      if (ret._isDerived() || ret.units.length === 0 || ret.units[0].unit.offset === 0) {
        ret.value = abs3(ret.value);
      } else {
        var convert = ret._numberConverter();
        var unitValue = convert(ret.units[0].unit.value);
        var nominalOffset = convert(ret.units[0].unit.offset);
        var unitOffset = multiplyScalar2(unitValue, nominalOffset);
        ret.value = subtractScalar2(abs3(addScalar2(ret.value, unitOffset)), unitOffset);
      }
    }
    for (var i2 in ret.units) {
      if (ret.units[i2].unit.name === "VA" || ret.units[i2].unit.name === "VAR") {
        ret.units[i2].unit = UNITS.W;
      }
    }
    return ret;
  };
  Unit2.prototype.to = function(valuelessUnit) {
    var value = this.value === null ? this._normalize(1) : this.value;
    var other;
    if (typeof valuelessUnit === "string") {
      other = Unit2.parse(valuelessUnit);
    } else if (isUnit(valuelessUnit)) {
      other = valuelessUnit.clone();
    } else {
      throw new Error("String or Unit expected as parameter");
    }
    if (!this.equalBase(other)) {
      throw new Error("Units do not match ('".concat(other.toString(), "' != '").concat(this.toString(), "')"));
    }
    if (other.value !== null) {
      throw new Error("Cannot convert to a unit with a value");
    }
    if (this.value === null || this._isDerived() || this.units.length === 0 || other.units.length === 0 || this.units[0].unit.offset === other.units[0].unit.offset) {
      other.value = clone(value);
    } else {
      var convert = Unit2._getNumberConverter(typeOf(value));
      var thisUnitValue = this.units[0].unit.value;
      var thisNominalOffset = this.units[0].unit.offset;
      var thisUnitOffset = multiplyScalar2(thisUnitValue, thisNominalOffset);
      var otherUnitValue = other.units[0].unit.value;
      var otherNominalOffset = other.units[0].unit.offset;
      var otherUnitOffset = multiplyScalar2(otherUnitValue, otherNominalOffset);
      other.value = addScalar2(value, convert(subtractScalar2(thisUnitOffset, otherUnitOffset)));
    }
    other.fixPrefix = true;
    other.skipAutomaticSimplification = true;
    return other;
  };
  Unit2.prototype.toNumber = function(valuelessUnit) {
    return toNumber(this.toNumeric(valuelessUnit));
  };
  Unit2.prototype.toNumeric = function(valuelessUnit) {
    var other;
    if (valuelessUnit) {
      other = this.to(valuelessUnit);
    } else {
      other = this.clone();
    }
    if (other._isDerived() || other.units.length === 0) {
      return other._denormalize(other.value);
    } else {
      return other._denormalize(other.value, other.units[0].prefix.value);
    }
  };
  Unit2.prototype.toString = function() {
    return this.format();
  };
  Unit2.prototype.toJSON = function() {
    return {
      mathjs: "Unit",
      value: this._denormalize(this.value),
      unit: this.units.length > 0 ? this.formatUnits() : null,
      fixPrefix: this.fixPrefix
    };
  };
  Unit2.fromJSON = function(json) {
    var _json$unit;
    var unit3 = new Unit2(json.value, (_json$unit = json.unit) !== null && _json$unit !== void 0 ? _json$unit : void 0);
    unit3.fixPrefix = json.fixPrefix || false;
    return unit3;
  };
  Unit2.prototype.valueOf = Unit2.prototype.toString;
  Unit2.prototype.simplify = function() {
    var ret = this.clone();
    var proposedUnitList = [];
    var matchingBase;
    for (var key2 in currentUnitSystem) {
      if (hasOwnProperty(currentUnitSystem, key2)) {
        if (ret.hasBase(BASE_UNITS[key2])) {
          matchingBase = key2;
          break;
        }
      }
    }
    if (matchingBase === "NONE") {
      ret.units = [];
    } else {
      var matchingUnit;
      if (matchingBase) {
        if (hasOwnProperty(currentUnitSystem, matchingBase)) {
          matchingUnit = currentUnitSystem[matchingBase];
        }
      }
      if (matchingUnit) {
        ret.units = [{
          unit: matchingUnit.unit,
          prefix: matchingUnit.prefix,
          power: 1
        }];
      } else {
        var missingBaseDim = false;
        for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
          var baseDim = BASE_DIMENSIONS[i2];
          if (Math.abs(ret.dimensions[i2] || 0) > 1e-12) {
            if (hasOwnProperty(currentUnitSystem, baseDim)) {
              proposedUnitList.push({
                unit: currentUnitSystem[baseDim].unit,
                prefix: currentUnitSystem[baseDim].prefix,
                power: ret.dimensions[i2] || 0
              });
            } else {
              missingBaseDim = true;
            }
          }
        }
        if (proposedUnitList.length < ret.units.length && !missingBaseDim) {
          ret.units = proposedUnitList;
        }
      }
    }
    return ret;
  };
  Unit2.prototype.toSI = function() {
    var ret = this.clone();
    var proposedUnitList = [];
    for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
      var baseDim = BASE_DIMENSIONS[i2];
      if (Math.abs(ret.dimensions[i2] || 0) > 1e-12) {
        if (hasOwnProperty(UNIT_SYSTEMS.si, baseDim)) {
          proposedUnitList.push({
            unit: UNIT_SYSTEMS.si[baseDim].unit,
            prefix: UNIT_SYSTEMS.si[baseDim].prefix,
            power: ret.dimensions[i2] || 0
          });
        } else {
          throw new Error("Cannot express custom unit " + baseDim + " in SI units");
        }
      }
    }
    ret.units = proposedUnitList;
    ret.fixPrefix = true;
    ret.skipAutomaticSimplification = true;
    if (this.value !== null) {
      ret.value = null;
      return this.to(ret);
    }
    return ret;
  };
  Unit2.prototype.formatUnits = function() {
    var strNum = "";
    var strDen = "";
    var nNum = 0;
    var nDen = 0;
    for (var i2 = 0; i2 < this.units.length; i2++) {
      if (this.units[i2].power > 0) {
        nNum++;
        strNum += " " + this.units[i2].prefix.name + this.units[i2].unit.name;
        if (Math.abs(this.units[i2].power - 1) > 1e-15) {
          strNum += "^" + this.units[i2].power;
        }
      } else if (this.units[i2].power < 0) {
        nDen++;
      }
    }
    if (nDen > 0) {
      for (var _i4 = 0; _i4 < this.units.length; _i4++) {
        if (this.units[_i4].power < 0) {
          if (nNum > 0) {
            strDen += " " + this.units[_i4].prefix.name + this.units[_i4].unit.name;
            if (Math.abs(this.units[_i4].power + 1) > 1e-15) {
              strDen += "^" + -this.units[_i4].power;
            }
          } else {
            strDen += " " + this.units[_i4].prefix.name + this.units[_i4].unit.name;
            strDen += "^" + this.units[_i4].power;
          }
        }
      }
    }
    strNum = strNum.substr(1);
    strDen = strDen.substr(1);
    if (nNum > 1 && nDen > 0) {
      strNum = "(" + strNum + ")";
    }
    if (nDen > 1 && nNum > 0) {
      strDen = "(" + strDen + ")";
    }
    var str = strNum;
    if (nNum > 0 && nDen > 0) {
      str += " / ";
    }
    str += strDen;
    return str;
  };
  Unit2.prototype.format = function(options2) {
    var simp = this.skipAutomaticSimplification || this.value === null ? this.clone() : this.simplify();
    var isImaginary = false;
    if (typeof simp.value !== "undefined" && simp.value !== null && isComplex(simp.value)) {
      isImaginary = Math.abs(simp.value.re) < 1e-14;
    }
    for (var i2 in simp.units) {
      if (hasOwnProperty(simp.units, i2)) {
        if (simp.units[i2].unit) {
          if (simp.units[i2].unit.name === "VA" && isImaginary) {
            simp.units[i2].unit = UNITS.VAR;
          } else if (simp.units[i2].unit.name === "VAR" && !isImaginary) {
            simp.units[i2].unit = UNITS.VA;
          }
        }
      }
    }
    if (simp.units.length === 1 && !simp.fixPrefix) {
      if (Math.abs(simp.units[0].power - Math.round(simp.units[0].power)) < 1e-14) {
        simp.units[0].prefix = simp._bestPrefix();
      }
    }
    var value = simp._denormalize(simp.value);
    var str = simp.value !== null ? format5(value, options2 || {}) : "";
    var unitStr = simp.formatUnits();
    if (simp.value && isComplex(simp.value)) {
      str = "(" + str + ")";
    }
    if (unitStr.length > 0 && str.length > 0) {
      str += " ";
    }
    str += unitStr;
    return str;
  };
  Unit2.prototype._bestPrefix = function() {
    if (this.units.length !== 1) {
      throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
    }
    if (Math.abs(this.units[0].power - Math.round(this.units[0].power)) >= 1e-14) {
      throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
    }
    var absValue = this.value !== null ? abs3(this.value) : 0;
    var absUnitValue = abs3(this.units[0].unit.value);
    var bestPrefix = this.units[0].prefix;
    if (absValue === 0) {
      return bestPrefix;
    }
    var power = this.units[0].power;
    var bestDiff = Math.log(absValue / Math.pow(bestPrefix.value * absUnitValue, power)) / Math.LN10 - 1.2;
    if (bestDiff > -2.200001 && bestDiff < 1.800001)
      return bestPrefix;
    bestDiff = Math.abs(bestDiff);
    var prefixes = this.units[0].unit.prefixes;
    for (var p in prefixes) {
      if (hasOwnProperty(prefixes, p)) {
        var prefix = prefixes[p];
        if (prefix.scientific) {
          var diff2 = Math.abs(Math.log(absValue / Math.pow(prefix.value * absUnitValue, power)) / Math.LN10 - 1.2);
          if (diff2 < bestDiff || diff2 === bestDiff && prefix.name.length < bestPrefix.name.length) {
            bestPrefix = prefix;
            bestDiff = diff2;
          }
        }
      }
    }
    return bestPrefix;
  };
  Unit2.prototype.splitUnit = function(parts) {
    var x = this.clone();
    var ret = [];
    for (var i2 = 0; i2 < parts.length; i2++) {
      x = x.to(parts[i2]);
      if (i2 === parts.length - 1)
        break;
      var xNumeric = x.toNumeric();
      var xRounded = round3(xNumeric);
      var xFixed = void 0;
      var isNearlyEqual = equal2(xRounded, xNumeric);
      if (isNearlyEqual) {
        xFixed = xRounded;
      } else {
        xFixed = fix2(x.toNumeric());
      }
      var y = new Unit2(xFixed, parts[i2].toString());
      ret.push(y);
      x = subtractScalar2(x, y);
    }
    var testSum = 0;
    for (var _i5 = 0; _i5 < ret.length; _i5++) {
      testSum = addScalar2(testSum, ret[_i5].value);
    }
    if (equal2(testSum, this.value)) {
      x.value = 0;
    }
    ret.push(x);
    return ret;
  };
  var PREFIXES = {
    NONE: {
      "": {
        name: "",
        value: 1,
        scientific: true
      }
    },
    SHORT: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      da: {
        name: "da",
        value: 10,
        scientific: false
      },
      h: {
        name: "h",
        value: 100,
        scientific: false
      },
      k: {
        name: "k",
        value: 1e3,
        scientific: true
      },
      M: {
        name: "M",
        value: 1e6,
        scientific: true
      },
      G: {
        name: "G",
        value: 1e9,
        scientific: true
      },
      T: {
        name: "T",
        value: 1e12,
        scientific: true
      },
      P: {
        name: "P",
        value: 1e15,
        scientific: true
      },
      E: {
        name: "E",
        value: 1e18,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1e21,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1e24,
        scientific: true
      },
      R: {
        name: "R",
        value: 1e27,
        scientific: true
      },
      Q: {
        name: "Q",
        value: 1e30,
        scientific: true
      },
      d: {
        name: "d",
        value: 0.1,
        scientific: false
      },
      c: {
        name: "c",
        value: 0.01,
        scientific: false
      },
      m: {
        name: "m",
        value: 1e-3,
        scientific: true
      },
      u: {
        name: "u",
        value: 1e-6,
        scientific: true
      },
      n: {
        name: "n",
        value: 1e-9,
        scientific: true
      },
      p: {
        name: "p",
        value: 1e-12,
        scientific: true
      },
      f: {
        name: "f",
        value: 1e-15,
        scientific: true
      },
      a: {
        name: "a",
        value: 1e-18,
        scientific: true
      },
      z: {
        name: "z",
        value: 1e-21,
        scientific: true
      },
      y: {
        name: "y",
        value: 1e-24,
        scientific: true
      },
      r: {
        name: "r",
        value: 1e-27,
        scientific: true
      },
      q: {
        name: "q",
        value: 1e-30,
        scientific: true
      }
    },
    LONG: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      deca: {
        name: "deca",
        value: 10,
        scientific: false
      },
      hecto: {
        name: "hecto",
        value: 100,
        scientific: false
      },
      kilo: {
        name: "kilo",
        value: 1e3,
        scientific: true
      },
      mega: {
        name: "mega",
        value: 1e6,
        scientific: true
      },
      giga: {
        name: "giga",
        value: 1e9,
        scientific: true
      },
      tera: {
        name: "tera",
        value: 1e12,
        scientific: true
      },
      peta: {
        name: "peta",
        value: 1e15,
        scientific: true
      },
      exa: {
        name: "exa",
        value: 1e18,
        scientific: true
      },
      zetta: {
        name: "zetta",
        value: 1e21,
        scientific: true
      },
      yotta: {
        name: "yotta",
        value: 1e24,
        scientific: true
      },
      ronna: {
        name: "ronna",
        value: 1e27,
        scientific: true
      },
      quetta: {
        name: "quetta",
        value: 1e30,
        scientific: true
      },
      deci: {
        name: "deci",
        value: 0.1,
        scientific: false
      },
      centi: {
        name: "centi",
        value: 0.01,
        scientific: false
      },
      milli: {
        name: "milli",
        value: 1e-3,
        scientific: true
      },
      micro: {
        name: "micro",
        value: 1e-6,
        scientific: true
      },
      nano: {
        name: "nano",
        value: 1e-9,
        scientific: true
      },
      pico: {
        name: "pico",
        value: 1e-12,
        scientific: true
      },
      femto: {
        name: "femto",
        value: 1e-15,
        scientific: true
      },
      atto: {
        name: "atto",
        value: 1e-18,
        scientific: true
      },
      zepto: {
        name: "zepto",
        value: 1e-21,
        scientific: true
      },
      yocto: {
        name: "yocto",
        value: 1e-24,
        scientific: true
      },
      ronto: {
        name: "ronto",
        value: 1e-27,
        scientific: true
      },
      quecto: {
        name: "quecto",
        value: 1e-30,
        scientific: true
      }
    },
    SQUARED: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      da: {
        name: "da",
        value: 100,
        scientific: false
      },
      h: {
        name: "h",
        value: 1e4,
        scientific: false
      },
      k: {
        name: "k",
        value: 1e6,
        scientific: true
      },
      M: {
        name: "M",
        value: 1e12,
        scientific: true
      },
      G: {
        name: "G",
        value: 1e18,
        scientific: true
      },
      T: {
        name: "T",
        value: 1e24,
        scientific: true
      },
      P: {
        name: "P",
        value: 1e30,
        scientific: true
      },
      E: {
        name: "E",
        value: 1e36,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1e42,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1e48,
        scientific: true
      },
      R: {
        name: "R",
        value: 1e54,
        scientific: true
      },
      Q: {
        name: "Q",
        value: 1e60,
        scientific: true
      },
      d: {
        name: "d",
        value: 0.01,
        scientific: false
      },
      c: {
        name: "c",
        value: 1e-4,
        scientific: false
      },
      m: {
        name: "m",
        value: 1e-6,
        scientific: true
      },
      u: {
        name: "u",
        value: 1e-12,
        scientific: true
      },
      n: {
        name: "n",
        value: 1e-18,
        scientific: true
      },
      p: {
        name: "p",
        value: 1e-24,
        scientific: true
      },
      f: {
        name: "f",
        value: 1e-30,
        scientific: true
      },
      a: {
        name: "a",
        value: 1e-36,
        scientific: true
      },
      z: {
        name: "z",
        value: 1e-42,
        scientific: true
      },
      y: {
        name: "y",
        value: 1e-48,
        scientific: true
      },
      r: {
        name: "r",
        value: 1e-54,
        scientific: true
      },
      q: {
        name: "q",
        value: 1e-60,
        scientific: true
      }
    },
    CUBIC: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      da: {
        name: "da",
        value: 1e3,
        scientific: false
      },
      h: {
        name: "h",
        value: 1e6,
        scientific: false
      },
      k: {
        name: "k",
        value: 1e9,
        scientific: true
      },
      M: {
        name: "M",
        value: 1e18,
        scientific: true
      },
      G: {
        name: "G",
        value: 1e27,
        scientific: true
      },
      T: {
        name: "T",
        value: 1e36,
        scientific: true
      },
      P: {
        name: "P",
        value: 1e45,
        scientific: true
      },
      E: {
        name: "E",
        value: 1e54,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1e63,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1e72,
        scientific: true
      },
      R: {
        name: "R",
        value: 1e81,
        scientific: true
      },
      Q: {
        name: "Q",
        value: 1e90,
        scientific: true
      },
      d: {
        name: "d",
        value: 1e-3,
        scientific: false
      },
      c: {
        name: "c",
        value: 1e-6,
        scientific: false
      },
      m: {
        name: "m",
        value: 1e-9,
        scientific: true
      },
      u: {
        name: "u",
        value: 1e-18,
        scientific: true
      },
      n: {
        name: "n",
        value: 1e-27,
        scientific: true
      },
      p: {
        name: "p",
        value: 1e-36,
        scientific: true
      },
      f: {
        name: "f",
        value: 1e-45,
        scientific: true
      },
      a: {
        name: "a",
        value: 1e-54,
        scientific: true
      },
      z: {
        name: "z",
        value: 1e-63,
        scientific: true
      },
      y: {
        name: "y",
        value: 1e-72,
        scientific: true
      },
      r: {
        name: "r",
        value: 1e-81,
        scientific: true
      },
      q: {
        name: "q",
        value: 1e-90,
        scientific: true
      }
    },
    BINARY_SHORT_SI: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      k: {
        name: "k",
        value: 1e3,
        scientific: true
      },
      M: {
        name: "M",
        value: 1e6,
        scientific: true
      },
      G: {
        name: "G",
        value: 1e9,
        scientific: true
      },
      T: {
        name: "T",
        value: 1e12,
        scientific: true
      },
      P: {
        name: "P",
        value: 1e15,
        scientific: true
      },
      E: {
        name: "E",
        value: 1e18,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1e21,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1e24,
        scientific: true
      }
    },
    BINARY_SHORT_IEC: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      Ki: {
        name: "Ki",
        value: 1024,
        scientific: true
      },
      Mi: {
        name: "Mi",
        value: Math.pow(1024, 2),
        scientific: true
      },
      Gi: {
        name: "Gi",
        value: Math.pow(1024, 3),
        scientific: true
      },
      Ti: {
        name: "Ti",
        value: Math.pow(1024, 4),
        scientific: true
      },
      Pi: {
        name: "Pi",
        value: Math.pow(1024, 5),
        scientific: true
      },
      Ei: {
        name: "Ei",
        value: Math.pow(1024, 6),
        scientific: true
      },
      Zi: {
        name: "Zi",
        value: Math.pow(1024, 7),
        scientific: true
      },
      Yi: {
        name: "Yi",
        value: Math.pow(1024, 8),
        scientific: true
      }
    },
    BINARY_LONG_SI: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      kilo: {
        name: "kilo",
        value: 1e3,
        scientific: true
      },
      mega: {
        name: "mega",
        value: 1e6,
        scientific: true
      },
      giga: {
        name: "giga",
        value: 1e9,
        scientific: true
      },
      tera: {
        name: "tera",
        value: 1e12,
        scientific: true
      },
      peta: {
        name: "peta",
        value: 1e15,
        scientific: true
      },
      exa: {
        name: "exa",
        value: 1e18,
        scientific: true
      },
      zetta: {
        name: "zetta",
        value: 1e21,
        scientific: true
      },
      yotta: {
        name: "yotta",
        value: 1e24,
        scientific: true
      }
    },
    BINARY_LONG_IEC: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      kibi: {
        name: "kibi",
        value: 1024,
        scientific: true
      },
      mebi: {
        name: "mebi",
        value: Math.pow(1024, 2),
        scientific: true
      },
      gibi: {
        name: "gibi",
        value: Math.pow(1024, 3),
        scientific: true
      },
      tebi: {
        name: "tebi",
        value: Math.pow(1024, 4),
        scientific: true
      },
      pebi: {
        name: "pebi",
        value: Math.pow(1024, 5),
        scientific: true
      },
      exi: {
        name: "exi",
        value: Math.pow(1024, 6),
        scientific: true
      },
      zebi: {
        name: "zebi",
        value: Math.pow(1024, 7),
        scientific: true
      },
      yobi: {
        name: "yobi",
        value: Math.pow(1024, 8),
        scientific: true
      }
    },
    BTU: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      MM: {
        name: "MM",
        value: 1e6,
        scientific: true
      }
    }
  };
  PREFIXES.SHORTLONG = _extends({}, PREFIXES.SHORT, PREFIXES.LONG);
  PREFIXES.BINARY_SHORT = _extends({}, PREFIXES.BINARY_SHORT_SI, PREFIXES.BINARY_SHORT_IEC);
  PREFIXES.BINARY_LONG = _extends({}, PREFIXES.BINARY_LONG_SI, PREFIXES.BINARY_LONG_IEC);
  var BASE_DIMENSIONS = ["MASS", "LENGTH", "TIME", "CURRENT", "TEMPERATURE", "LUMINOUS_INTENSITY", "AMOUNT_OF_SUBSTANCE", "ANGLE", "BIT"];
  var BASE_UNITS = {
    NONE: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 0]
    },
    MASS: {
      dimensions: [1, 0, 0, 0, 0, 0, 0, 0, 0]
    },
    LENGTH: {
      dimensions: [0, 1, 0, 0, 0, 0, 0, 0, 0]
    },
    TIME: {
      dimensions: [0, 0, 1, 0, 0, 0, 0, 0, 0]
    },
    CURRENT: {
      dimensions: [0, 0, 0, 1, 0, 0, 0, 0, 0]
    },
    TEMPERATURE: {
      dimensions: [0, 0, 0, 0, 1, 0, 0, 0, 0]
    },
    LUMINOUS_INTENSITY: {
      dimensions: [0, 0, 0, 0, 0, 1, 0, 0, 0]
    },
    AMOUNT_OF_SUBSTANCE: {
      dimensions: [0, 0, 0, 0, 0, 0, 1, 0, 0]
    },
    FORCE: {
      dimensions: [1, 1, -2, 0, 0, 0, 0, 0, 0]
    },
    SURFACE: {
      dimensions: [0, 2, 0, 0, 0, 0, 0, 0, 0]
    },
    VOLUME: {
      dimensions: [0, 3, 0, 0, 0, 0, 0, 0, 0]
    },
    ENERGY: {
      dimensions: [1, 2, -2, 0, 0, 0, 0, 0, 0]
    },
    POWER: {
      dimensions: [1, 2, -3, 0, 0, 0, 0, 0, 0]
    },
    PRESSURE: {
      dimensions: [1, -1, -2, 0, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CHARGE: {
      dimensions: [0, 0, 1, 1, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CAPACITANCE: {
      dimensions: [-1, -2, 4, 2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_POTENTIAL: {
      dimensions: [1, 2, -3, -1, 0, 0, 0, 0, 0]
    },
    ELECTRIC_RESISTANCE: {
      dimensions: [1, 2, -3, -2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_INDUCTANCE: {
      dimensions: [1, 2, -2, -2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CONDUCTANCE: {
      dimensions: [-1, -2, 3, 2, 0, 0, 0, 0, 0]
    },
    MAGNETIC_FLUX: {
      dimensions: [1, 2, -2, -1, 0, 0, 0, 0, 0]
    },
    MAGNETIC_FLUX_DENSITY: {
      dimensions: [1, 0, -2, -1, 0, 0, 0, 0, 0]
    },
    FREQUENCY: {
      dimensions: [0, 0, -1, 0, 0, 0, 0, 0, 0]
    },
    ANGLE: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 1, 0]
    },
    BIT: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 1]
    }
  };
  for (var key in BASE_UNITS) {
    if (hasOwnProperty(BASE_UNITS, key)) {
      BASE_UNITS[key].key = key;
    }
  }
  var BASE_UNIT_NONE = {};
  var UNIT_NONE = {
    name: "",
    base: BASE_UNIT_NONE,
    value: 1,
    offset: 0,
    dimensions: BASE_DIMENSIONS.map((x) => 0)
  };
  var UNITS = {
    // length
    meter: {
      name: "meter",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    inch: {
      name: "inch",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.0254,
      offset: 0
    },
    foot: {
      name: "foot",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.3048,
      offset: 0
    },
    yard: {
      name: "yard",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.9144,
      offset: 0
    },
    mile: {
      name: "mile",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 1609.344,
      offset: 0
    },
    link: {
      name: "link",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.201168,
      offset: 0
    },
    rod: {
      name: "rod",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 5.0292,
      offset: 0
    },
    chain: {
      name: "chain",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 20.1168,
      offset: 0
    },
    angstrom: {
      name: "angstrom",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 1e-10,
      offset: 0
    },
    m: {
      name: "m",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    in: {
      name: "in",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.0254,
      offset: 0
    },
    ft: {
      name: "ft",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.3048,
      offset: 0
    },
    yd: {
      name: "yd",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.9144,
      offset: 0
    },
    mi: {
      name: "mi",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 1609.344,
      offset: 0
    },
    li: {
      name: "li",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.201168,
      offset: 0
    },
    rd: {
      name: "rd",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 5.02921,
      offset: 0
    },
    ch: {
      name: "ch",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 20.1168,
      offset: 0
    },
    mil: {
      name: "mil",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 254e-7,
      offset: 0
    },
    // 1/1000 inch
    // Surface
    m2: {
      name: "m2",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.SQUARED,
      value: 1,
      offset: 0
    },
    sqin: {
      name: "sqin",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 64516e-8,
      offset: 0
    },
    // 645.16 mm2
    sqft: {
      name: "sqft",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 0.09290304,
      offset: 0
    },
    // 0.09290304 m2
    sqyd: {
      name: "sqyd",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 0.83612736,
      offset: 0
    },
    // 0.83612736 m2
    sqmi: {
      name: "sqmi",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 2589988110336e-6,
      offset: 0
    },
    // 2.589988110336 km2
    sqrd: {
      name: "sqrd",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 25.29295,
      offset: 0
    },
    // 25.29295 m2
    sqch: {
      name: "sqch",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 404.6873,
      offset: 0
    },
    // 404.6873 m2
    sqmil: {
      name: "sqmil",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 64516e-14,
      offset: 0
    },
    // 6.4516 * 10^-10 m2
    acre: {
      name: "acre",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 4046.86,
      offset: 0
    },
    // 4046.86 m2
    hectare: {
      name: "hectare",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 1e4,
      offset: 0
    },
    // 10000 m2
    // Volume
    m3: {
      name: "m3",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.CUBIC,
      value: 1,
      offset: 0
    },
    L: {
      name: "L",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.SHORT,
      value: 1e-3,
      offset: 0
    },
    // litre
    l: {
      name: "l",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.SHORT,
      value: 1e-3,
      offset: 0
    },
    // litre
    litre: {
      name: "litre",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.LONG,
      value: 1e-3,
      offset: 0
    },
    cuin: {
      name: "cuin",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 16387064e-12,
      offset: 0
    },
    // 1.6387064e-5 m3
    cuft: {
      name: "cuft",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.028316846592,
      offset: 0
    },
    // 28.316 846 592 L
    cuyd: {
      name: "cuyd",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.764554857984,
      offset: 0
    },
    // 764.554 857 984 L
    teaspoon: {
      name: "teaspoon",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 5e-6,
      offset: 0
    },
    // 5 mL
    tablespoon: {
      name: "tablespoon",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 15e-6,
      offset: 0
    },
    // 15 mL
    // {name: 'cup', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.000240, offset: 0}, // 240 mL  // not possible, we have already another cup
    drop: {
      name: "drop",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 5e-8,
      offset: 0
    },
    // 0.05 mL = 5e-8 m3
    gtt: {
      name: "gtt",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 5e-8,
      offset: 0
    },
    // 0.05 mL = 5e-8 m3
    // Liquid volume
    minim: {
      name: "minim",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 61611519921875e-21,
      offset: 0
    },
    // 1/61440 gallons
    fluiddram: {
      name: "fluiddram",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 36966911953125e-19,
      offset: 0
    },
    // 1/1024 gallons
    fluidounce: {
      name: "fluidounce",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 295735295625e-16,
      offset: 0
    },
    // 1/128 gallons
    gill: {
      name: "gill",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 11829411825e-14,
      offset: 0
    },
    // 1/32 gallons
    cc: {
      name: "cc",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 1e-6,
      offset: 0
    },
    // 1e-6 L
    cup: {
      name: "cup",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 2365882365e-13,
      offset: 0
    },
    // 1/16 gallons
    pint: {
      name: "pint",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 473176473e-12,
      offset: 0
    },
    // 1/8 gallons
    quart: {
      name: "quart",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 946352946e-12,
      offset: 0
    },
    // 1/4 gallons
    gallon: {
      name: "gallon",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.003785411784,
      offset: 0
    },
    // 3.785411784 L
    beerbarrel: {
      name: "beerbarrel",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.117347765304,
      offset: 0
    },
    // 31 gallons
    oilbarrel: {
      name: "oilbarrel",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.158987294928,
      offset: 0
    },
    // 42 gallons
    hogshead: {
      name: "hogshead",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.238480942392,
      offset: 0
    },
    // 63 gallons
    // Mass
    g: {
      name: "g",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.SHORT,
      value: 1e-3,
      offset: 0
    },
    gram: {
      name: "gram",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.LONG,
      value: 1e-3,
      offset: 0
    },
    ton: {
      name: "ton",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.SHORT,
      value: 907.18474,
      offset: 0
    },
    t: {
      name: "t",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.SHORT,
      value: 1e3,
      offset: 0
    },
    tonne: {
      name: "tonne",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.LONG,
      value: 1e3,
      offset: 0
    },
    grain: {
      name: "grain",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 6479891e-11,
      offset: 0
    },
    dram: {
      name: "dram",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.0017718451953125,
      offset: 0
    },
    ounce: {
      name: "ounce",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.028349523125,
      offset: 0
    },
    poundmass: {
      name: "poundmass",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.45359237,
      offset: 0
    },
    hundredweight: {
      name: "hundredweight",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 45.359237,
      offset: 0
    },
    stick: {
      name: "stick",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.115,
      offset: 0
    },
    stone: {
      name: "stone",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 6.35029318,
      offset: 0
    },
    gr: {
      name: "gr",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 6479891e-11,
      offset: 0
    },
    dr: {
      name: "dr",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.0017718451953125,
      offset: 0
    },
    oz: {
      name: "oz",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.028349523125,
      offset: 0
    },
    lbm: {
      name: "lbm",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.45359237,
      offset: 0
    },
    cwt: {
      name: "cwt",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 45.359237,
      offset: 0
    },
    // Time
    s: {
      name: "s",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    min: {
      name: "min",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 60,
      offset: 0
    },
    h: {
      name: "h",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 3600,
      offset: 0
    },
    second: {
      name: "second",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    sec: {
      name: "sec",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    minute: {
      name: "minute",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 60,
      offset: 0
    },
    hour: {
      name: "hour",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 3600,
      offset: 0
    },
    day: {
      name: "day",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 86400,
      offset: 0
    },
    week: {
      name: "week",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 7 * 86400,
      offset: 0
    },
    month: {
      name: "month",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 2629800,
      // 1/12th of Julian year
      offset: 0
    },
    year: {
      name: "year",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 31557600,
      // Julian year
      offset: 0
    },
    decade: {
      name: "decade",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 315576e3,
      // Julian decade
      offset: 0
    },
    century: {
      name: "century",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 315576e4,
      // Julian century
      offset: 0
    },
    millennium: {
      name: "millennium",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 315576e5,
      // Julian millennium
      offset: 0
    },
    // Frequency
    hertz: {
      name: "Hertz",
      base: BASE_UNITS.FREQUENCY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0,
      reciprocal: true
    },
    Hz: {
      name: "Hz",
      base: BASE_UNITS.FREQUENCY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0,
      reciprocal: true
    },
    // Angle
    rad: {
      name: "rad",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    radian: {
      name: "radian",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    // deg = rad / (2*pi) * 360 = rad / 0.017453292519943295769236907684888
    deg: {
      name: "deg",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.SHORT,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    degree: {
      name: "degree",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.LONG,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // grad = rad / (2*pi) * 400  = rad / 0.015707963267948966192313216916399
    grad: {
      name: "grad",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.SHORT,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    gradian: {
      name: "gradian",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.LONG,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // cycle = rad / (2*pi) = rad / 6.2831853071795864769252867665793
    cycle: {
      name: "cycle",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // arcsec = rad / (3600 * (360 / 2 * pi)) = rad / 0.0000048481368110953599358991410235795
    arcsec: {
      name: "arcsec",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // arcmin = rad / (60 * (360 / 2 * pi)) = rad / 0.00029088820866572159615394846141477
    arcmin: {
      name: "arcmin",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // Electric current
    A: {
      name: "A",
      base: BASE_UNITS.CURRENT,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    ampere: {
      name: "ampere",
      base: BASE_UNITS.CURRENT,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    // Temperature
    // K(C) = °C + 273.15
    // K(F) = (°F + 459.67) * (5 / 9)
    // K(R) = °R * (5 / 9)
    K: {
      name: "K",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    degC: {
      name: "degC",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 273.15
    },
    degF: {
      name: "degF",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.SHORT,
      value: new _Fraction(5, 9),
      offset: 459.67
    },
    degR: {
      name: "degR",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.SHORT,
      value: new _Fraction(5, 9),
      offset: 0
    },
    kelvin: {
      name: "kelvin",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    celsius: {
      name: "celsius",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 273.15
    },
    fahrenheit: {
      name: "fahrenheit",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.LONG,
      value: new _Fraction(5, 9),
      offset: 459.67
    },
    rankine: {
      name: "rankine",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.LONG,
      value: new _Fraction(5, 9),
      offset: 0
    },
    // amount of substance
    mol: {
      name: "mol",
      base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    mole: {
      name: "mole",
      base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    // luminous intensity
    cd: {
      name: "cd",
      base: BASE_UNITS.LUMINOUS_INTENSITY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    candela: {
      name: "candela",
      base: BASE_UNITS.LUMINOUS_INTENSITY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    // TODO: units STERADIAN
    // {name: 'sr', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
    // {name: 'steradian', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
    // Force
    N: {
      name: "N",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    newton: {
      name: "newton",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    dyn: {
      name: "dyn",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.SHORT,
      value: 1e-5,
      offset: 0
    },
    dyne: {
      name: "dyne",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.LONG,
      value: 1e-5,
      offset: 0
    },
    lbf: {
      name: "lbf",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.NONE,
      value: 4.4482216152605,
      offset: 0
    },
    poundforce: {
      name: "poundforce",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.NONE,
      value: 4.4482216152605,
      offset: 0
    },
    kip: {
      name: "kip",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.LONG,
      value: 4448.2216,
      offset: 0
    },
    kilogramforce: {
      name: "kilogramforce",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.NONE,
      value: 9.80665,
      offset: 0
    },
    // Energy
    J: {
      name: "J",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    joule: {
      name: "joule",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    erg: {
      name: "erg",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORTLONG,
      // Both kiloerg and kerg are acceptable
      value: 1e-7,
      offset: 0
    },
    Wh: {
      name: "Wh",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 3600,
      offset: 0
    },
    BTU: {
      name: "BTU",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.BTU,
      value: 1055.05585262,
      offset: 0
    },
    eV: {
      name: "eV",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 1602176565e-28,
      offset: 0
    },
    electronvolt: {
      name: "electronvolt",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.LONG,
      value: 1602176565e-28,
      offset: 0
    },
    // Power
    W: {
      name: "W",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    watt: {
      name: "watt",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    hp: {
      name: "hp",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.NONE,
      value: 745.6998715386,
      offset: 0
    },
    // Electrical power units
    VAR: {
      name: "VAR",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.SHORT,
      value: Complex3.I,
      offset: 0
    },
    VA: {
      name: "VA",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Pressure
    Pa: {
      name: "Pa",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    psi: {
      name: "psi",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 6894.75729276459,
      offset: 0
    },
    atm: {
      name: "atm",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 101325,
      offset: 0
    },
    bar: {
      name: "bar",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.SHORTLONG,
      value: 1e5,
      offset: 0
    },
    torr: {
      name: "torr",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 133.322,
      offset: 0
    },
    mmHg: {
      name: "mmHg",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 133.322,
      offset: 0
    },
    mmH2O: {
      name: "mmH2O",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 9.80665,
      offset: 0
    },
    cmH2O: {
      name: "cmH2O",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 98.0665,
      offset: 0
    },
    // Electric charge
    coulomb: {
      name: "coulomb",
      base: BASE_UNITS.ELECTRIC_CHARGE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    C: {
      name: "C",
      base: BASE_UNITS.ELECTRIC_CHARGE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Electric capacitance
    farad: {
      name: "farad",
      base: BASE_UNITS.ELECTRIC_CAPACITANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    F: {
      name: "F",
      base: BASE_UNITS.ELECTRIC_CAPACITANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Electric potential
    volt: {
      name: "volt",
      base: BASE_UNITS.ELECTRIC_POTENTIAL,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    V: {
      name: "V",
      base: BASE_UNITS.ELECTRIC_POTENTIAL,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Electric resistance
    ohm: {
      name: "ohm",
      base: BASE_UNITS.ELECTRIC_RESISTANCE,
      prefixes: PREFIXES.SHORTLONG,
      // Both Mohm and megaohm are acceptable
      value: 1,
      offset: 0
    },
    /*
     * Unicode breaks in browsers if charset is not specified
    Ω: {
      name: 'Ω',
      base: BASE_UNITS.ELECTRIC_RESISTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    */
    // Electric inductance
    henry: {
      name: "henry",
      base: BASE_UNITS.ELECTRIC_INDUCTANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    H: {
      name: "H",
      base: BASE_UNITS.ELECTRIC_INDUCTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Electric conductance
    siemens: {
      name: "siemens",
      base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    S: {
      name: "S",
      base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Magnetic flux
    weber: {
      name: "weber",
      base: BASE_UNITS.MAGNETIC_FLUX,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    Wb: {
      name: "Wb",
      base: BASE_UNITS.MAGNETIC_FLUX,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Magnetic flux density
    tesla: {
      name: "tesla",
      base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    T: {
      name: "T",
      base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Binary
    b: {
      name: "b",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_SHORT,
      value: 1,
      offset: 0
    },
    bits: {
      name: "bits",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_LONG,
      value: 1,
      offset: 0
    },
    B: {
      name: "B",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_SHORT,
      value: 8,
      offset: 0
    },
    bytes: {
      name: "bytes",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_LONG,
      value: 8,
      offset: 0
    }
  };
  var ALIASES = {
    meters: "meter",
    inches: "inch",
    feet: "foot",
    yards: "yard",
    miles: "mile",
    links: "link",
    rods: "rod",
    chains: "chain",
    angstroms: "angstrom",
    lt: "l",
    litres: "litre",
    liter: "litre",
    liters: "litre",
    teaspoons: "teaspoon",
    tablespoons: "tablespoon",
    minims: "minim",
    fldr: "fluiddram",
    fluiddrams: "fluiddram",
    floz: "fluidounce",
    fluidounces: "fluidounce",
    gi: "gill",
    gills: "gill",
    cp: "cup",
    cups: "cup",
    pt: "pint",
    pints: "pint",
    qt: "quart",
    quarts: "quart",
    gal: "gallon",
    gallons: "gallon",
    bbl: "beerbarrel",
    beerbarrels: "beerbarrel",
    obl: "oilbarrel",
    oilbarrels: "oilbarrel",
    hogsheads: "hogshead",
    gtts: "gtt",
    grams: "gram",
    tons: "ton",
    tonnes: "tonne",
    grains: "grain",
    drams: "dram",
    ounces: "ounce",
    poundmasses: "poundmass",
    hundredweights: "hundredweight",
    sticks: "stick",
    lb: "lbm",
    lbs: "lbm",
    kips: "kip",
    kgf: "kilogramforce",
    acres: "acre",
    hectares: "hectare",
    sqfeet: "sqft",
    sqyard: "sqyd",
    sqmile: "sqmi",
    sqmiles: "sqmi",
    mmhg: "mmHg",
    mmh2o: "mmH2O",
    cmh2o: "cmH2O",
    seconds: "second",
    secs: "second",
    minutes: "minute",
    mins: "minute",
    hours: "hour",
    hr: "hour",
    hrs: "hour",
    days: "day",
    weeks: "week",
    months: "month",
    years: "year",
    decades: "decade",
    centuries: "century",
    millennia: "millennium",
    hertz: "hertz",
    radians: "radian",
    degrees: "degree",
    gradians: "gradian",
    cycles: "cycle",
    arcsecond: "arcsec",
    arcseconds: "arcsec",
    arcminute: "arcmin",
    arcminutes: "arcmin",
    BTUs: "BTU",
    watts: "watt",
    joules: "joule",
    amperes: "ampere",
    amps: "ampere",
    amp: "ampere",
    coulombs: "coulomb",
    volts: "volt",
    ohms: "ohm",
    farads: "farad",
    webers: "weber",
    teslas: "tesla",
    electronvolts: "electronvolt",
    moles: "mole",
    bit: "bits",
    byte: "bytes"
  };
  function calculateAngleValues(config6) {
    if (config6.number === "BigNumber") {
      var pi3 = createBigNumberPi(_BigNumber);
      UNITS.rad.value = new _BigNumber(1);
      UNITS.deg.value = pi3.div(180);
      UNITS.grad.value = pi3.div(200);
      UNITS.cycle.value = pi3.times(2);
      UNITS.arcsec.value = pi3.div(648e3);
      UNITS.arcmin.value = pi3.div(10800);
    } else {
      UNITS.rad.value = 1;
      UNITS.deg.value = Math.PI / 180;
      UNITS.grad.value = Math.PI / 200;
      UNITS.cycle.value = Math.PI * 2;
      UNITS.arcsec.value = Math.PI / 648e3;
      UNITS.arcmin.value = Math.PI / 10800;
    }
    UNITS.radian.value = UNITS.rad.value;
    UNITS.degree.value = UNITS.deg.value;
    UNITS.gradian.value = UNITS.grad.value;
  }
  calculateAngleValues(config5);
  if (on) {
    on("config", function(curr, prev) {
      if (curr.number !== prev.number) {
        calculateAngleValues(curr);
      }
    });
  }
  var UNIT_SYSTEMS = {
    si: {
      // Base units
      NONE: {
        unit: UNIT_NONE,
        prefix: PREFIXES.NONE[""]
      },
      LENGTH: {
        unit: UNITS.m,
        prefix: PREFIXES.SHORT[""]
      },
      MASS: {
        unit: UNITS.g,
        prefix: PREFIXES.SHORT.k
      },
      TIME: {
        unit: UNITS.s,
        prefix: PREFIXES.SHORT[""]
      },
      CURRENT: {
        unit: UNITS.A,
        prefix: PREFIXES.SHORT[""]
      },
      TEMPERATURE: {
        unit: UNITS.K,
        prefix: PREFIXES.SHORT[""]
      },
      LUMINOUS_INTENSITY: {
        unit: UNITS.cd,
        prefix: PREFIXES.SHORT[""]
      },
      AMOUNT_OF_SUBSTANCE: {
        unit: UNITS.mol,
        prefix: PREFIXES.SHORT[""]
      },
      ANGLE: {
        unit: UNITS.rad,
        prefix: PREFIXES.SHORT[""]
      },
      BIT: {
        unit: UNITS.bits,
        prefix: PREFIXES.SHORT[""]
      },
      // Derived units
      FORCE: {
        unit: UNITS.N,
        prefix: PREFIXES.SHORT[""]
      },
      ENERGY: {
        unit: UNITS.J,
        prefix: PREFIXES.SHORT[""]
      },
      POWER: {
        unit: UNITS.W,
        prefix: PREFIXES.SHORT[""]
      },
      PRESSURE: {
        unit: UNITS.Pa,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_CHARGE: {
        unit: UNITS.C,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_CAPACITANCE: {
        unit: UNITS.F,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_POTENTIAL: {
        unit: UNITS.V,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_RESISTANCE: {
        unit: UNITS.ohm,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_INDUCTANCE: {
        unit: UNITS.H,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_CONDUCTANCE: {
        unit: UNITS.S,
        prefix: PREFIXES.SHORT[""]
      },
      MAGNETIC_FLUX: {
        unit: UNITS.Wb,
        prefix: PREFIXES.SHORT[""]
      },
      MAGNETIC_FLUX_DENSITY: {
        unit: UNITS.T,
        prefix: PREFIXES.SHORT[""]
      },
      FREQUENCY: {
        unit: UNITS.Hz,
        prefix: PREFIXES.SHORT[""]
      }
    }
  };
  UNIT_SYSTEMS.cgs = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
  UNIT_SYSTEMS.cgs.LENGTH = {
    unit: UNITS.m,
    prefix: PREFIXES.SHORT.c
  };
  UNIT_SYSTEMS.cgs.MASS = {
    unit: UNITS.g,
    prefix: PREFIXES.SHORT[""]
  };
  UNIT_SYSTEMS.cgs.FORCE = {
    unit: UNITS.dyn,
    prefix: PREFIXES.SHORT[""]
  };
  UNIT_SYSTEMS.cgs.ENERGY = {
    unit: UNITS.erg,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
  UNIT_SYSTEMS.us.LENGTH = {
    unit: UNITS.ft,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.MASS = {
    unit: UNITS.lbm,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.TEMPERATURE = {
    unit: UNITS.degF,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.FORCE = {
    unit: UNITS.lbf,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.ENERGY = {
    unit: UNITS.BTU,
    prefix: PREFIXES.BTU[""]
  };
  UNIT_SYSTEMS.us.POWER = {
    unit: UNITS.hp,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.PRESSURE = {
    unit: UNITS.psi,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.auto = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
  var currentUnitSystem = UNIT_SYSTEMS.auto;
  Unit2.setUnitSystem = function(name314) {
    if (hasOwnProperty(UNIT_SYSTEMS, name314)) {
      currentUnitSystem = UNIT_SYSTEMS[name314];
    } else {
      throw new Error("Unit system " + name314 + " does not exist. Choices are: " + Object.keys(UNIT_SYSTEMS).join(", "));
    }
  };
  Unit2.getUnitSystem = function() {
    for (var _key in UNIT_SYSTEMS) {
      if (hasOwnProperty(UNIT_SYSTEMS, _key)) {
        if (UNIT_SYSTEMS[_key] === currentUnitSystem) {
          return _key;
        }
      }
    }
  };
  Unit2.typeConverters = {
    BigNumber: function BigNumber2(x) {
      if (x !== null && x !== void 0 && x.isFraction)
        return new _BigNumber(x.n).div(x.d).times(x.s);
      return new _BigNumber(x + "");
    },
    Fraction: function Fraction3(x) {
      return new _Fraction(x);
    },
    Complex: function Complex4(x) {
      return x;
    },
    number: function number2(x) {
      if (x !== null && x !== void 0 && x.isFraction)
        return _number(x);
      return x;
    }
  };
  Unit2.prototype._numberConverter = function() {
    var convert = Unit2.typeConverters[this.valueType()];
    if (convert) {
      return convert;
    }
    throw new TypeError('Unsupported Unit value type "' + this.valueType() + '"');
  };
  Unit2._getNumberConverter = function(type) {
    if (!Unit2.typeConverters[type]) {
      throw new TypeError('Unsupported type "' + type + '"');
    }
    return Unit2.typeConverters[type];
  };
  for (var _key2 in UNITS) {
    if (hasOwnProperty(UNITS, _key2)) {
      var unit2 = UNITS[_key2];
      unit2.dimensions = unit2.base.dimensions;
    }
  }
  for (var _name2 in ALIASES) {
    if (hasOwnProperty(ALIASES, _name2)) {
      var _unit2 = UNITS[ALIASES[_name2]];
      var alias = {};
      for (var _key3 in _unit2) {
        if (hasOwnProperty(_unit2, _key3)) {
          alias[_key3] = _unit2[_key3];
        }
      }
      alias.name = _name2;
      UNITS[_name2] = alias;
    }
  }
  Unit2.isValidAlpha = function isValidAlpha(c2) {
    return /^[a-zA-Z]$/.test(c2);
  };
  function assertUnitNameIsValid(name314) {
    for (var i2 = 0; i2 < name314.length; i2++) {
      c = name314.charAt(i2);
      if (i2 === 0 && !Unit2.isValidAlpha(c)) {
        throw new Error('Invalid unit name (must begin with alpha character): "' + name314 + '"');
      }
      if (i2 > 0 && !(Unit2.isValidAlpha(c) || isDigit(c))) {
        throw new Error('Invalid unit name (only alphanumeric characters are allowed): "' + name314 + '"');
      }
    }
  }
  Unit2.createUnit = function(obj, options2) {
    if (typeof obj !== "object") {
      throw new TypeError("createUnit expects first parameter to be of type 'Object'");
    }
    if (options2 && options2.override) {
      for (var _key4 in obj) {
        if (hasOwnProperty(obj, _key4)) {
          Unit2.deleteUnit(_key4);
        }
        if (obj[_key4].aliases) {
          for (var i2 = 0; i2 < obj[_key4].aliases.length; i2++) {
            Unit2.deleteUnit(obj[_key4].aliases[i2]);
          }
        }
      }
    }
    var lastUnit;
    for (var _key5 in obj) {
      if (hasOwnProperty(obj, _key5)) {
        lastUnit = Unit2.createUnitSingle(_key5, obj[_key5]);
      }
    }
    return lastUnit;
  };
  Unit2.createUnitSingle = function(name314, obj) {
    if (typeof obj === "undefined" || obj === null) {
      obj = {};
    }
    if (typeof name314 !== "string") {
      throw new TypeError("createUnitSingle expects first parameter to be of type 'string'");
    }
    if (hasOwnProperty(UNITS, name314)) {
      throw new Error('Cannot create unit "' + name314 + '": a unit with that name already exists');
    }
    assertUnitNameIsValid(name314);
    var defUnit = null;
    var aliases = [];
    var offset = 0;
    var definition;
    var prefixes;
    var baseName;
    if (obj && obj.type === "Unit") {
      defUnit = obj.clone();
    } else if (typeof obj === "string") {
      if (obj !== "") {
        definition = obj;
      }
    } else if (typeof obj === "object") {
      definition = obj.definition;
      prefixes = obj.prefixes;
      offset = obj.offset;
      baseName = obj.baseName;
      if (obj.aliases) {
        aliases = obj.aliases.valueOf();
      }
    } else {
      throw new TypeError('Cannot create unit "' + name314 + '" from "' + obj.toString() + '": expecting "string" or "Unit" or "Object"');
    }
    if (aliases) {
      for (var i2 = 0; i2 < aliases.length; i2++) {
        if (hasOwnProperty(UNITS, aliases[i2])) {
          throw new Error('Cannot create alias "' + aliases[i2] + '": a unit with that name already exists');
        }
      }
    }
    if (definition && typeof definition === "string" && !defUnit) {
      try {
        defUnit = Unit2.parse(definition, {
          allowNoUnits: true
        });
      } catch (ex) {
        ex.message = 'Could not create unit "' + name314 + '" from "' + definition + '": ' + ex.message;
        throw ex;
      }
    } else if (definition && definition.type === "Unit") {
      defUnit = definition.clone();
    }
    aliases = aliases || [];
    offset = offset || 0;
    if (prefixes && prefixes.toUpperCase) {
      prefixes = PREFIXES[prefixes.toUpperCase()] || PREFIXES.NONE;
    } else {
      prefixes = PREFIXES.NONE;
    }
    var newUnit = {};
    if (!defUnit) {
      baseName = baseName || name314 + "_STUFF";
      if (BASE_DIMENSIONS.indexOf(baseName) >= 0) {
        throw new Error('Cannot create new base unit "' + name314 + '": a base unit with that name already exists (and cannot be overridden)');
      }
      BASE_DIMENSIONS.push(baseName);
      for (var b in BASE_UNITS) {
        if (hasOwnProperty(BASE_UNITS, b)) {
          BASE_UNITS[b].dimensions[BASE_DIMENSIONS.length - 1] = 0;
        }
      }
      var newBaseUnit = {
        dimensions: []
      };
      for (var _i6 = 0; _i6 < BASE_DIMENSIONS.length; _i6++) {
        newBaseUnit.dimensions[_i6] = 0;
      }
      newBaseUnit.dimensions[BASE_DIMENSIONS.length - 1] = 1;
      newBaseUnit.key = baseName;
      BASE_UNITS[baseName] = newBaseUnit;
      newUnit = {
        name: name314,
        value: 1,
        dimensions: BASE_UNITS[baseName].dimensions.slice(0),
        prefixes,
        offset,
        base: BASE_UNITS[baseName]
      };
      currentUnitSystem[baseName] = {
        unit: newUnit,
        prefix: PREFIXES.NONE[""]
      };
    } else {
      newUnit = {
        name: name314,
        value: defUnit.value,
        dimensions: defUnit.dimensions.slice(0),
        prefixes,
        offset
      };
      var anyMatch = false;
      for (var _i7 in BASE_UNITS) {
        if (hasOwnProperty(BASE_UNITS, _i7)) {
          var match = true;
          for (var j = 0; j < BASE_DIMENSIONS.length; j++) {
            if (Math.abs((newUnit.dimensions[j] || 0) - (BASE_UNITS[_i7].dimensions[j] || 0)) > 1e-12) {
              match = false;
              break;
            }
          }
          if (match) {
            anyMatch = true;
            newUnit.base = BASE_UNITS[_i7];
            break;
          }
        }
      }
      if (!anyMatch) {
        baseName = baseName || name314 + "_STUFF";
        var _newBaseUnit = {
          dimensions: defUnit.dimensions.slice(0)
        };
        _newBaseUnit.key = baseName;
        BASE_UNITS[baseName] = _newBaseUnit;
        currentUnitSystem[baseName] = {
          unit: newUnit,
          prefix: PREFIXES.NONE[""]
        };
        newUnit.base = BASE_UNITS[baseName];
      }
    }
    Unit2.UNITS[name314] = newUnit;
    for (var _i8 = 0; _i8 < aliases.length; _i8++) {
      var aliasName = aliases[_i8];
      var _alias = {};
      for (var _key6 in newUnit) {
        if (hasOwnProperty(newUnit, _key6)) {
          _alias[_key6] = newUnit[_key6];
        }
      }
      _alias.name = aliasName;
      Unit2.UNITS[aliasName] = _alias;
    }
    delete _findUnit.cache;
    return new Unit2(null, name314);
  };
  Unit2.deleteUnit = function(name314) {
    delete Unit2.UNITS[name314];
    delete _findUnit.cache;
  };
  Unit2.PREFIXES = PREFIXES;
  Unit2.BASE_DIMENSIONS = BASE_DIMENSIONS;
  Unit2.BASE_UNITS = BASE_UNITS;
  Unit2.UNIT_SYSTEMS = UNIT_SYSTEMS;
  Unit2.UNITS = UNITS;
  return Unit2;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/unit/function/unit.js
var name162 = "unit";
var dependencies163 = ["typed", "Unit"];
var createUnitFunction = /* @__PURE__ */ factory(name162, dependencies163, (_ref) => {
  var {
    typed: typed3,
    Unit: Unit2
  } = _ref;
  return typed3(name162, {
    Unit: function Unit3(x) {
      return x.clone();
    },
    string: function string2(x) {
      if (Unit2.isValuelessUnit(x)) {
        return new Unit2(null, x);
      }
      return Unit2.parse(x, {
        allowNoUnits: true
      });
    },
    "number | BigNumber | Fraction | Complex, string | Unit": function numberBigNumberFractionComplexStringUnit(value, unit2) {
      return new Unit2(value, unit2);
    },
    "number | BigNumber | Fraction": function numberBigNumberFraction(value) {
      return new Unit2(value);
    },
    "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});

// node_modules/mathjs/lib/esm/type/matrix/function/sparse.js
var name163 = "sparse";
var dependencies164 = ["typed", "SparseMatrix"];
var createSparse = /* @__PURE__ */ factory(name163, dependencies164, (_ref) => {
  var {
    typed: typed3,
    SparseMatrix: SparseMatrix2
  } = _ref;
  return typed3(name163, {
    "": function _() {
      return new SparseMatrix2([]);
    },
    string: function string2(datatype) {
      return new SparseMatrix2([], datatype);
    },
    "Array | Matrix": function ArrayMatrix(data) {
      return new SparseMatrix2(data);
    },
    "Array | Matrix, string": function ArrayMatrixString(data, datatype) {
      return new SparseMatrix2(data, datatype);
    }
  });
});

// node_modules/mathjs/lib/esm/type/unit/function/createUnit.js
var name164 = "createUnit";
var dependencies165 = ["typed", "Unit"];
var createCreateUnit = /* @__PURE__ */ factory(name164, dependencies165, (_ref) => {
  var {
    typed: typed3,
    Unit: Unit2
  } = _ref;
  return typed3(name164, {
    // General function signature. First parameter is an object where each property is the definition of a new unit. The object keys are the unit names and the values are the definitions. The values can be objects, strings, or Units. If a property is an empty object or an empty string, a new base unit is created. The second parameter is the options.
    "Object, Object": function ObjectObject(obj, options2) {
      return Unit2.createUnit(obj, options2);
    },
    // Same as above but without the options.
    Object: function Object2(obj) {
      return Unit2.createUnit(obj, {});
    },
    // Shortcut method for creating one unit.
    "string, Unit | string | Object, Object": function stringUnitStringObjectObject(name314, def, options2) {
      var obj = {};
      obj[name314] = def;
      return Unit2.createUnit(obj, options2);
    },
    // Same as above but without the options.
    "string, Unit | string | Object": function stringUnitStringObject(name314, def) {
      var obj = {};
      obj[name314] = def;
      return Unit2.createUnit(obj, {});
    },
    // Without a definition, creates a base unit.
    string: function string2(name314) {
      var obj = {};
      obj[name314] = {};
      return Unit2.createUnit(obj, {});
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/acos.js
var name165 = "acos";
var dependencies166 = ["typed", "config", "Complex"];
var createAcos = /* @__PURE__ */ factory(name165, dependencies166, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    Complex: Complex3
  } = _ref;
  return typed3(name165, {
    number: function number2(x) {
      if (x >= -1 && x <= 1 || config5.predictable) {
        return Math.acos(x);
      } else {
        return new Complex3(x, 0).acos();
      }
    },
    Complex: function Complex4(x) {
      return x.acos();
    },
    BigNumber: function BigNumber2(x) {
      return x.acos();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/acosh.js
var name166 = "acosh";
var dependencies167 = ["typed", "config", "Complex"];
var createAcosh = /* @__PURE__ */ factory(name166, dependencies167, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    Complex: Complex3
  } = _ref;
  return typed3(name166, {
    number: function number2(x) {
      if (x >= 1 || config5.predictable) {
        return acoshNumber(x);
      }
      if (x <= -1) {
        return new Complex3(Math.log(Math.sqrt(x * x - 1) - x), Math.PI);
      }
      return new Complex3(x, 0).acosh();
    },
    Complex: function Complex4(x) {
      return x.acosh();
    },
    BigNumber: function BigNumber2(x) {
      return x.acosh();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/acot.js
var name167 = "acot";
var dependencies168 = ["typed", "BigNumber"];
var createAcot = /* @__PURE__ */ factory(name167, dependencies168, (_ref) => {
  var {
    typed: typed3,
    BigNumber: _BigNumber
  } = _ref;
  return typed3(name167, {
    number: acotNumber,
    Complex: function Complex3(x) {
      return x.acot();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(1).div(x).atan();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/acoth.js
var name168 = "acoth";
var dependencies169 = ["typed", "config", "Complex", "BigNumber"];
var createAcoth = /* @__PURE__ */ factory(name168, dependencies169, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    Complex: Complex3,
    BigNumber: _BigNumber
  } = _ref;
  return typed3(name168, {
    number: function number2(x) {
      if (x >= 1 || x <= -1 || config5.predictable) {
        return acothNumber(x);
      }
      return new Complex3(x, 0).acoth();
    },
    Complex: function Complex4(x) {
      return x.acoth();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(1).div(x).atanh();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/acsc.js
var name169 = "acsc";
var dependencies170 = ["typed", "config", "Complex", "BigNumber"];
var createAcsc = /* @__PURE__ */ factory(name169, dependencies170, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    Complex: Complex3,
    BigNumber: _BigNumber
  } = _ref;
  return typed3(name169, {
    number: function number2(x) {
      if (x <= -1 || x >= 1 || config5.predictable) {
        return acscNumber(x);
      }
      return new Complex3(x, 0).acsc();
    },
    Complex: function Complex4(x) {
      return x.acsc();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(1).div(x).asin();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/acsch.js
var name170 = "acsch";
var dependencies171 = ["typed", "BigNumber"];
var createAcsch = /* @__PURE__ */ factory(name170, dependencies171, (_ref) => {
  var {
    typed: typed3,
    BigNumber: _BigNumber
  } = _ref;
  return typed3(name170, {
    number: acschNumber,
    Complex: function Complex3(x) {
      return x.acsch();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(1).div(x).asinh();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/asec.js
var name171 = "asec";
var dependencies172 = ["typed", "config", "Complex", "BigNumber"];
var createAsec = /* @__PURE__ */ factory(name171, dependencies172, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    Complex: Complex3,
    BigNumber: _BigNumber
  } = _ref;
  return typed3(name171, {
    number: function number2(x) {
      if (x <= -1 || x >= 1 || config5.predictable) {
        return asecNumber(x);
      }
      return new Complex3(x, 0).asec();
    },
    Complex: function Complex4(x) {
      return x.asec();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(1).div(x).acos();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/asech.js
var name172 = "asech";
var dependencies173 = ["typed", "config", "Complex", "BigNumber"];
var createAsech = /* @__PURE__ */ factory(name172, dependencies173, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    Complex: Complex3,
    BigNumber: _BigNumber
  } = _ref;
  return typed3(name172, {
    number: function number2(x) {
      if (x <= 1 && x >= -1 || config5.predictable) {
        var xInv = 1 / x;
        if (xInv > 0 || config5.predictable) {
          return asechNumber(x);
        }
        var ret = Math.sqrt(xInv * xInv - 1);
        return new Complex3(Math.log(ret - xInv), Math.PI);
      }
      return new Complex3(x, 0).asech();
    },
    Complex: function Complex4(x) {
      return x.asech();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(1).div(x).acosh();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/asin.js
var name173 = "asin";
var dependencies174 = ["typed", "config", "Complex"];
var createAsin = /* @__PURE__ */ factory(name173, dependencies174, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    Complex: Complex3
  } = _ref;
  return typed3(name173, {
    number: function number2(x) {
      if (x >= -1 && x <= 1 || config5.predictable) {
        return Math.asin(x);
      } else {
        return new Complex3(x, 0).asin();
      }
    },
    Complex: function Complex4(x) {
      return x.asin();
    },
    BigNumber: function BigNumber2(x) {
      return x.asin();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/asinh.js
var name174 = "asinh";
var dependencies175 = ["typed"];
var createAsinh = /* @__PURE__ */ factory(name174, dependencies175, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3("asinh", {
    number: asinhNumber,
    Complex: function Complex3(x) {
      return x.asinh();
    },
    BigNumber: function BigNumber2(x) {
      return x.asinh();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/atan.js
var name175 = "atan";
var dependencies176 = ["typed"];
var createAtan = /* @__PURE__ */ factory(name175, dependencies176, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3("atan", {
    number: function number2(x) {
      return Math.atan(x);
    },
    Complex: function Complex3(x) {
      return x.atan();
    },
    BigNumber: function BigNumber2(x) {
      return x.atan();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/atan2.js
var name176 = "atan2";
var dependencies177 = ["typed", "matrix", "equalScalar", "BigNumber", "DenseMatrix", "concat"];
var createAtan2 = /* @__PURE__ */ factory(name176, dependencies177, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    equalScalar: equalScalar2,
    BigNumber: BigNumber2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed3
  });
  var matAlgo09xS0Sf = createMatAlgo09xS0Sf({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix: matrix2,
    concat: concat3
  });
  return typed3(name176, {
    "number, number": Math.atan2,
    // Complex numbers doesn't seem to have a reasonable implementation of
    // atan2(). Even Matlab removed the support, after they only calculated
    // the atan only on base of the real part of the numbers and ignored
    // the imaginary.
    "BigNumber, BigNumber": (y, x) => BigNumber2.atan2(y, x)
  }, matrixAlgorithmSuite({
    scalar: "number | BigNumber",
    SS: matAlgo09xS0Sf,
    DS: matAlgo03xDSf,
    SD: matAlgo02xDS0,
    Ss: matAlgo11xS0s,
    sS: matAlgo12xSfs
  }));
});

// node_modules/mathjs/lib/esm/function/trigonometry/atanh.js
var name177 = "atanh";
var dependencies178 = ["typed", "config", "Complex"];
var createAtanh = /* @__PURE__ */ factory(name177, dependencies178, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    Complex: Complex3
  } = _ref;
  return typed3(name177, {
    number: function number2(x) {
      if (x <= 1 && x >= -1 || config5.predictable) {
        return atanhNumber(x);
      }
      return new Complex3(x, 0).atanh();
    },
    Complex: function Complex4(x) {
      return x.atanh();
    },
    BigNumber: function BigNumber2(x) {
      return x.atanh();
    }
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/trigUnit.js
var createTrigUnit = /* @__PURE__ */ factory("trigUnit", ["typed"], (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return {
    Unit: typed3.referToSelf((self2) => (x) => {
      if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
        throw new TypeError("Unit in function cot is no angle");
      }
      return typed3.find(self2, x.valueType())(x.value);
    })
  };
});

// node_modules/mathjs/lib/esm/function/trigonometry/cos.js
var name178 = "cos";
var dependencies179 = ["typed"];
var createCos = /* @__PURE__ */ factory(name178, dependencies179, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed3
  });
  return typed3(name178, {
    number: Math.cos,
    "Complex | BigNumber": (x) => x.cos()
  }, trigUnit);
});

// node_modules/mathjs/lib/esm/function/trigonometry/cosh.js
var name179 = "cosh";
var dependencies180 = ["typed"];
var createCosh = /* @__PURE__ */ factory(name179, dependencies180, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name179, {
    number: cosh,
    "Complex | BigNumber": (x) => x.cosh()
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/cot.js
var name180 = "cot";
var dependencies181 = ["typed", "BigNumber"];
var createCot = /* @__PURE__ */ factory(name180, dependencies181, (_ref) => {
  var {
    typed: typed3,
    BigNumber: _BigNumber
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed3
  });
  return typed3(name180, {
    number: cotNumber,
    Complex: (x) => x.cot(),
    BigNumber: (x) => new _BigNumber(1).div(x.tan())
  }, trigUnit);
});

// node_modules/mathjs/lib/esm/function/trigonometry/coth.js
var name181 = "coth";
var dependencies182 = ["typed", "BigNumber"];
var createCoth = /* @__PURE__ */ factory(name181, dependencies182, (_ref) => {
  var {
    typed: typed3,
    BigNumber: _BigNumber
  } = _ref;
  return typed3(name181, {
    number: cothNumber,
    Complex: (x) => x.coth(),
    BigNumber: (x) => new _BigNumber(1).div(x.tanh())
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/csc.js
var name182 = "csc";
var dependencies183 = ["typed", "BigNumber"];
var createCsc = /* @__PURE__ */ factory(name182, dependencies183, (_ref) => {
  var {
    typed: typed3,
    BigNumber: _BigNumber
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed3
  });
  return typed3(name182, {
    number: cscNumber,
    Complex: (x) => x.csc(),
    BigNumber: (x) => new _BigNumber(1).div(x.sin())
  }, trigUnit);
});

// node_modules/mathjs/lib/esm/function/trigonometry/csch.js
var name183 = "csch";
var dependencies184 = ["typed", "BigNumber"];
var createCsch = /* @__PURE__ */ factory(name183, dependencies184, (_ref) => {
  var {
    typed: typed3,
    BigNumber: _BigNumber
  } = _ref;
  return typed3(name183, {
    number: cschNumber,
    Complex: (x) => x.csch(),
    BigNumber: (x) => new _BigNumber(1).div(x.sinh())
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/sec.js
var name184 = "sec";
var dependencies185 = ["typed", "BigNumber"];
var createSec = /* @__PURE__ */ factory(name184, dependencies185, (_ref) => {
  var {
    typed: typed3,
    BigNumber: _BigNumber
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed3
  });
  return typed3(name184, {
    number: secNumber,
    Complex: (x) => x.sec(),
    BigNumber: (x) => new _BigNumber(1).div(x.cos())
  }, trigUnit);
});

// node_modules/mathjs/lib/esm/function/trigonometry/sech.js
var name185 = "sech";
var dependencies186 = ["typed", "BigNumber"];
var createSech = /* @__PURE__ */ factory(name185, dependencies186, (_ref) => {
  var {
    typed: typed3,
    BigNumber: _BigNumber
  } = _ref;
  return typed3(name185, {
    number: sechNumber,
    Complex: (x) => x.sech(),
    BigNumber: (x) => new _BigNumber(1).div(x.cosh())
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/sin.js
var name186 = "sin";
var dependencies187 = ["typed"];
var createSin = /* @__PURE__ */ factory(name186, dependencies187, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed3
  });
  return typed3(name186, {
    number: Math.sin,
    "Complex | BigNumber": (x) => x.sin()
  }, trigUnit);
});

// node_modules/mathjs/lib/esm/function/trigonometry/sinh.js
var name187 = "sinh";
var dependencies188 = ["typed"];
var createSinh = /* @__PURE__ */ factory(name187, dependencies188, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name187, {
    number: sinhNumber,
    "Complex | BigNumber": (x) => x.sinh()
  });
});

// node_modules/mathjs/lib/esm/function/trigonometry/tan.js
var name188 = "tan";
var dependencies189 = ["typed"];
var createTan = /* @__PURE__ */ factory(name188, dependencies189, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed3
  });
  return typed3(name188, {
    number: Math.tan,
    "Complex | BigNumber": (x) => x.tan()
  }, trigUnit);
});

// node_modules/mathjs/lib/esm/function/trigonometry/tanh.js
var name189 = "tanh";
var dependencies190 = ["typed"];
var createTanh = /* @__PURE__ */ factory(name189, dependencies190, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3("tanh", {
    number: tanh,
    "Complex | BigNumber": (x) => x.tanh()
  });
});

// node_modules/mathjs/lib/esm/function/set/setCartesian.js
var name190 = "setCartesian";
var dependencies191 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetCartesian = /* @__PURE__ */ factory(name190, dependencies191, (_ref) => {
  var {
    typed: typed3,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return typed3(name190, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      var result = [];
      if (subset2(size2(a1), new Index2(0)) !== 0 && subset2(size2(a2), new Index2(0)) !== 0) {
        var b1 = flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2);
        var b2 = flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural2);
        result = [];
        for (var i2 = 0; i2 < b1.length; i2++) {
          for (var j = 0; j < b2.length; j++) {
            result.push([b1[i2], b2[j]]);
          }
        }
      }
      if (Array.isArray(a1) && Array.isArray(a2)) {
        return result;
      }
      return new DenseMatrix2(result);
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setDifference.js
var name191 = "setDifference";
var dependencies192 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetDifference = /* @__PURE__ */ factory(name191, dependencies192, (_ref) => {
  var {
    typed: typed3,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return typed3(name191, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      var result;
      if (subset2(size2(a1), new Index2(0)) === 0) {
        result = [];
      } else if (subset2(size2(a2), new Index2(0)) === 0) {
        return flatten(a1.toArray());
      } else {
        var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2));
        var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural2));
        result = [];
        var inb2;
        for (var i2 = 0; i2 < b1.length; i2++) {
          inb2 = false;
          for (var j = 0; j < b2.length; j++) {
            if (compareNatural2(b1[i2].value, b2[j].value) === 0 && b1[i2].identifier === b2[j].identifier) {
              inb2 = true;
              break;
            }
          }
          if (!inb2) {
            result.push(b1[i2]);
          }
        }
      }
      if (Array.isArray(a1) && Array.isArray(a2)) {
        return generalize(result);
      }
      return new DenseMatrix2(generalize(result));
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setDistinct.js
var name192 = "setDistinct";
var dependencies193 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetDistinct = /* @__PURE__ */ factory(name192, dependencies193, (_ref) => {
  var {
    typed: typed3,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return typed3(name192, {
    "Array | Matrix": function ArrayMatrix(a) {
      var result;
      if (subset2(size2(a), new Index2(0)) === 0) {
        result = [];
      } else {
        var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural2);
        result = [];
        result.push(b[0]);
        for (var i2 = 1; i2 < b.length; i2++) {
          if (compareNatural2(b[i2], b[i2 - 1]) !== 0) {
            result.push(b[i2]);
          }
        }
      }
      if (Array.isArray(a)) {
        return result;
      }
      return new DenseMatrix2(result);
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setIntersect.js
var name193 = "setIntersect";
var dependencies194 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetIntersect = /* @__PURE__ */ factory(name193, dependencies194, (_ref) => {
  var {
    typed: typed3,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return typed3(name193, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      var result;
      if (subset2(size2(a1), new Index2(0)) === 0 || subset2(size2(a2), new Index2(0)) === 0) {
        result = [];
      } else {
        var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2));
        var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural2));
        result = [];
        for (var i2 = 0; i2 < b1.length; i2++) {
          for (var j = 0; j < b2.length; j++) {
            if (compareNatural2(b1[i2].value, b2[j].value) === 0 && b1[i2].identifier === b2[j].identifier) {
              result.push(b1[i2]);
              break;
            }
          }
        }
      }
      if (Array.isArray(a1) && Array.isArray(a2)) {
        return generalize(result);
      }
      return new DenseMatrix2(generalize(result));
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setIsSubset.js
var name194 = "setIsSubset";
var dependencies195 = ["typed", "size", "subset", "compareNatural", "Index"];
var createSetIsSubset = /* @__PURE__ */ factory(name194, dependencies195, (_ref) => {
  var {
    typed: typed3,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2
  } = _ref;
  return typed3(name194, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      if (subset2(size2(a1), new Index2(0)) === 0) {
        return true;
      } else if (subset2(size2(a2), new Index2(0)) === 0) {
        return false;
      }
      var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2));
      var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural2));
      var inb2;
      for (var i2 = 0; i2 < b1.length; i2++) {
        inb2 = false;
        for (var j = 0; j < b2.length; j++) {
          if (compareNatural2(b1[i2].value, b2[j].value) === 0 && b1[i2].identifier === b2[j].identifier) {
            inb2 = true;
            break;
          }
        }
        if (inb2 === false) {
          return false;
        }
      }
      return true;
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setMultiplicity.js
var name195 = "setMultiplicity";
var dependencies196 = ["typed", "size", "subset", "compareNatural", "Index"];
var createSetMultiplicity = /* @__PURE__ */ factory(name195, dependencies196, (_ref) => {
  var {
    typed: typed3,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2
  } = _ref;
  return typed3(name195, {
    "number | BigNumber | Fraction | Complex, Array | Matrix": function numberBigNumberFractionComplexArrayMatrix(e3, a) {
      if (subset2(size2(a), new Index2(0)) === 0) {
        return 0;
      }
      var b = flatten(Array.isArray(a) ? a : a.toArray());
      var count2 = 0;
      for (var i2 = 0; i2 < b.length; i2++) {
        if (compareNatural2(b[i2], e3) === 0) {
          count2++;
        }
      }
      return count2;
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setPowerset.js
var name196 = "setPowerset";
var dependencies197 = ["typed", "size", "subset", "compareNatural", "Index"];
var createSetPowerset = /* @__PURE__ */ factory(name196, dependencies197, (_ref) => {
  var {
    typed: typed3,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2
  } = _ref;
  return typed3(name196, {
    "Array | Matrix": function ArrayMatrix(a) {
      if (subset2(size2(a), new Index2(0)) === 0) {
        return [];
      }
      var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural2);
      var result = [];
      var number2 = 0;
      while (number2.toString(2).length <= b.length) {
        result.push(_subset(b, number2.toString(2).split("").reverse()));
        number2++;
      }
      return _sort(result);
    }
  });
  function _subset(array, bitarray) {
    var result = [];
    for (var i2 = 0; i2 < bitarray.length; i2++) {
      if (bitarray[i2] === "1") {
        result.push(array[i2]);
      }
    }
    return result;
  }
  function _sort(array) {
    var temp = [];
    for (var i2 = array.length - 1; i2 > 0; i2--) {
      for (var j = 0; j < i2; j++) {
        if (array[j].length > array[j + 1].length) {
          temp = array[j];
          array[j] = array[j + 1];
          array[j + 1] = temp;
        }
      }
    }
    return array;
  }
});

// node_modules/mathjs/lib/esm/function/set/setSize.js
var name197 = "setSize";
var dependencies198 = ["typed", "compareNatural"];
var createSetSize = /* @__PURE__ */ factory(name197, dependencies198, (_ref) => {
  var {
    typed: typed3,
    compareNatural: compareNatural2
  } = _ref;
  return typed3(name197, {
    "Array | Matrix": function ArrayMatrix(a) {
      return Array.isArray(a) ? flatten(a).length : flatten(a.toArray()).length;
    },
    "Array | Matrix, boolean": function ArrayMatrixBoolean(a, unique) {
      if (unique === false || a.length === 0) {
        return Array.isArray(a) ? flatten(a).length : flatten(a.toArray()).length;
      } else {
        var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural2);
        var count2 = 1;
        for (var i2 = 1; i2 < b.length; i2++) {
          if (compareNatural2(b[i2], b[i2 - 1]) !== 0) {
            count2++;
          }
        }
        return count2;
      }
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setSymDifference.js
var name198 = "setSymDifference";
var dependencies199 = ["typed", "size", "concat", "subset", "setDifference", "Index"];
var createSetSymDifference = /* @__PURE__ */ factory(name198, dependencies199, (_ref) => {
  var {
    typed: typed3,
    size: size2,
    concat: concat3,
    subset: subset2,
    setDifference: setDifference2,
    Index: Index2
  } = _ref;
  return typed3(name198, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      if (subset2(size2(a1), new Index2(0)) === 0) {
        return flatten(a2);
      } else if (subset2(size2(a2), new Index2(0)) === 0) {
        return flatten(a1);
      }
      var b1 = flatten(a1);
      var b2 = flatten(a2);
      return concat3(setDifference2(b1, b2), setDifference2(b2, b1));
    }
  });
});

// node_modules/mathjs/lib/esm/function/set/setUnion.js
var name199 = "setUnion";
var dependencies200 = ["typed", "size", "concat", "subset", "setIntersect", "setSymDifference", "Index"];
var createSetUnion = /* @__PURE__ */ factory(name199, dependencies200, (_ref) => {
  var {
    typed: typed3,
    size: size2,
    concat: concat3,
    subset: subset2,
    setIntersect: setIntersect2,
    setSymDifference: setSymDifference2,
    Index: Index2
  } = _ref;
  return typed3(name199, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      if (subset2(size2(a1), new Index2(0)) === 0) {
        return flatten(a2);
      } else if (subset2(size2(a2), new Index2(0)) === 0) {
        return flatten(a1);
      }
      var b1 = flatten(a1);
      var b2 = flatten(a2);
      return concat3(setSymDifference2(b1, b2), setIntersect2(b1, b2));
    }
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/add.js
var name200 = "add";
var dependencies201 = ["typed", "matrix", "addScalar", "equalScalar", "DenseMatrix", "SparseMatrix", "concat"];
var createAdd = /* @__PURE__ */ factory(name200, dependencies201, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    addScalar: addScalar2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2,
    concat: concat3
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed3
  });
  var matAlgo04xSidSid = createMatAlgo04xSidSid({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed3,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed3,
    matrix: matrix2,
    concat: concat3
  });
  return typed3(name200, {
    "any, any": addScalar2,
    "any, any, ...any": typed3.referToSelf((self2) => (x, y, rest) => {
      var result = self2(x, y);
      for (var i2 = 0; i2 < rest.length; i2++) {
        result = self2(result, rest[i2]);
      }
      return result;
    })
  }, matrixAlgorithmSuite({
    elop: addScalar2,
    DS: matAlgo01xDSid,
    SS: matAlgo04xSidSid,
    Ss: matAlgo10xSids
  }));
});

// node_modules/mathjs/lib/esm/function/arithmetic/hypot.js
var name201 = "hypot";
var dependencies202 = ["typed", "abs", "addScalar", "divideScalar", "multiplyScalar", "sqrt", "smaller", "isPositive"];
var createHypot = /* @__PURE__ */ factory(name201, dependencies202, (_ref) => {
  var {
    typed: typed3,
    abs: abs3,
    addScalar: addScalar2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    sqrt: sqrt3,
    smaller: smaller2,
    isPositive: isPositive2
  } = _ref;
  return typed3(name201, {
    "... number | BigNumber": _hypot,
    Array: _hypot,
    Matrix: (M) => _hypot(flatten(M.toArray()))
  });
  function _hypot(args) {
    var result = 0;
    var largest = 0;
    for (var i2 = 0; i2 < args.length; i2++) {
      if (isComplex(args[i2])) {
        throw new TypeError("Unexpected type of argument to hypot");
      }
      var value = abs3(args[i2]);
      if (smaller2(largest, value)) {
        result = multiplyScalar2(result, multiplyScalar2(divideScalar2(largest, value), divideScalar2(largest, value)));
        result = addScalar2(result, 1);
        largest = value;
      } else {
        result = addScalar2(result, isPositive2(value) ? multiplyScalar2(divideScalar2(value, largest), divideScalar2(value, largest)) : value);
      }
    }
    return multiplyScalar2(largest, sqrt3(result));
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/norm.js
var name202 = "norm";
var dependencies203 = ["typed", "abs", "add", "pow", "conj", "sqrt", "multiply", "equalScalar", "larger", "smaller", "matrix", "ctranspose", "eigs"];
var createNorm = /* @__PURE__ */ factory(name202, dependencies203, (_ref) => {
  var {
    typed: typed3,
    abs: abs3,
    add: add3,
    pow: pow3,
    conj: conj2,
    sqrt: sqrt3,
    multiply: multiply2,
    equalScalar: equalScalar2,
    larger: larger2,
    smaller: smaller2,
    matrix: matrix2,
    ctranspose: ctranspose2,
    eigs: eigs2
  } = _ref;
  return typed3(name202, {
    number: Math.abs,
    Complex: function Complex3(x) {
      return x.abs();
    },
    BigNumber: function BigNumber2(x) {
      return x.abs();
    },
    boolean: function boolean2(x) {
      return Math.abs(x);
    },
    Array: function Array2(x) {
      return _norm(matrix2(x), 2);
    },
    Matrix: function Matrix2(x) {
      return _norm(x, 2);
    },
    "Array, number | BigNumber | string": function ArrayNumberBigNumberString(x, p) {
      return _norm(matrix2(x), p);
    },
    "Matrix, number | BigNumber | string": function MatrixNumberBigNumberString(x, p) {
      return _norm(x, p);
    }
  });
  function _vectorNormPlusInfinity(x) {
    var pinf = 0;
    x.forEach(function(value) {
      var v = abs3(value);
      if (larger2(v, pinf)) {
        pinf = v;
      }
    }, true);
    return pinf;
  }
  function _vectorNormMinusInfinity(x) {
    var ninf;
    x.forEach(function(value) {
      var v = abs3(value);
      if (!ninf || smaller2(v, ninf)) {
        ninf = v;
      }
    }, true);
    return ninf || 0;
  }
  function _vectorNorm(x, p) {
    if (p === Number.POSITIVE_INFINITY || p === "inf") {
      return _vectorNormPlusInfinity(x);
    }
    if (p === Number.NEGATIVE_INFINITY || p === "-inf") {
      return _vectorNormMinusInfinity(x);
    }
    if (p === "fro") {
      return _norm(x, 2);
    }
    if (typeof p === "number" && !isNaN(p)) {
      if (!equalScalar2(p, 0)) {
        var n = 0;
        x.forEach(function(value) {
          n = add3(pow3(abs3(value), p), n);
        }, true);
        return pow3(n, 1 / p);
      }
      return Number.POSITIVE_INFINITY;
    }
    throw new Error("Unsupported parameter value");
  }
  function _matrixNormFrobenius(x) {
    var fro = 0;
    x.forEach(function(value, index2) {
      fro = add3(fro, multiply2(value, conj2(value)));
    });
    return abs3(sqrt3(fro));
  }
  function _matrixNormOne(x) {
    var c = [];
    var maxc = 0;
    x.forEach(function(value, index2) {
      var j = index2[1];
      var cj = add3(c[j] || 0, abs3(value));
      if (larger2(cj, maxc)) {
        maxc = cj;
      }
      c[j] = cj;
    }, true);
    return maxc;
  }
  function _matrixNormTwo(x) {
    var sizeX = x.size();
    if (sizeX[0] !== sizeX[1]) {
      throw new RangeError("Invalid matrix dimensions");
    }
    var tx = ctranspose2(x);
    var squaredX = multiply2(tx, x);
    var eigenVals = eigs2(squaredX).values.toArray();
    var rho = eigenVals[eigenVals.length - 1];
    return abs3(sqrt3(rho));
  }
  function _matrixNormInfinity(x) {
    var r = [];
    var maxr = 0;
    x.forEach(function(value, index2) {
      var i2 = index2[0];
      var ri = add3(r[i2] || 0, abs3(value));
      if (larger2(ri, maxr)) {
        maxr = ri;
      }
      r[i2] = ri;
    }, true);
    return maxr;
  }
  function _matrixNorm(x, p) {
    if (p === 1) {
      return _matrixNormOne(x);
    }
    if (p === Number.POSITIVE_INFINITY || p === "inf") {
      return _matrixNormInfinity(x);
    }
    if (p === "fro") {
      return _matrixNormFrobenius(x);
    }
    if (p === 2) {
      return _matrixNormTwo(x);
    }
    throw new Error("Unsupported parameter value " + p);
  }
  function _norm(x, p) {
    var sizeX = x.size();
    if (sizeX.length === 1) {
      return _vectorNorm(x, p);
    }
    if (sizeX.length === 2) {
      if (sizeX[0] && sizeX[1]) {
        return _matrixNorm(x, p);
      } else {
        throw new RangeError("Invalid matrix dimensions");
      }
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/dot.js
var name203 = "dot";
var dependencies204 = ["typed", "addScalar", "multiplyScalar", "conj", "size"];
var createDot = /* @__PURE__ */ factory(name203, dependencies204, (_ref) => {
  var {
    typed: typed3,
    addScalar: addScalar2,
    multiplyScalar: multiplyScalar2,
    conj: conj2,
    size: size2
  } = _ref;
  return typed3(name203, {
    "Array | DenseMatrix, Array | DenseMatrix": _denseDot,
    "SparseMatrix, SparseMatrix": _sparseDot
  });
  function _validateDim(x, y) {
    var xSize = _size(x);
    var ySize = _size(y);
    var xLen, yLen;
    if (xSize.length === 1) {
      xLen = xSize[0];
    } else if (xSize.length === 2 && xSize[1] === 1) {
      xLen = xSize[0];
    } else {
      throw new RangeError("Expected a column vector, instead got a matrix of size (" + xSize.join(", ") + ")");
    }
    if (ySize.length === 1) {
      yLen = ySize[0];
    } else if (ySize.length === 2 && ySize[1] === 1) {
      yLen = ySize[0];
    } else {
      throw new RangeError("Expected a column vector, instead got a matrix of size (" + ySize.join(", ") + ")");
    }
    if (xLen !== yLen)
      throw new RangeError("Vectors must have equal length (" + xLen + " != " + yLen + ")");
    if (xLen === 0)
      throw new RangeError("Cannot calculate the dot product of empty vectors");
    return xLen;
  }
  function _denseDot(a, b) {
    var N = _validateDim(a, b);
    var adata = isMatrix(a) ? a._data : a;
    var adt = isMatrix(a) ? a._datatype || a.getDataType() : void 0;
    var bdata = isMatrix(b) ? b._data : b;
    var bdt = isMatrix(b) ? b._datatype || b.getDataType() : void 0;
    var aIsColumn = _size(a).length === 2;
    var bIsColumn = _size(b).length === 2;
    var add3 = addScalar2;
    var mul2 = multiplyScalar2;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
      var dt = adt;
      add3 = typed3.find(addScalar2, [dt, dt]);
      mul2 = typed3.find(multiplyScalar2, [dt, dt]);
    }
    if (!aIsColumn && !bIsColumn) {
      var c = mul2(conj2(adata[0]), bdata[0]);
      for (var i2 = 1; i2 < N; i2++) {
        c = add3(c, mul2(conj2(adata[i2]), bdata[i2]));
      }
      return c;
    }
    if (!aIsColumn && bIsColumn) {
      var _c = mul2(conj2(adata[0]), bdata[0][0]);
      for (var _i = 1; _i < N; _i++) {
        _c = add3(_c, mul2(conj2(adata[_i]), bdata[_i][0]));
      }
      return _c;
    }
    if (aIsColumn && !bIsColumn) {
      var _c2 = mul2(conj2(adata[0][0]), bdata[0]);
      for (var _i2 = 1; _i2 < N; _i2++) {
        _c2 = add3(_c2, mul2(conj2(adata[_i2][0]), bdata[_i2]));
      }
      return _c2;
    }
    if (aIsColumn && bIsColumn) {
      var _c3 = mul2(conj2(adata[0][0]), bdata[0][0]);
      for (var _i3 = 1; _i3 < N; _i3++) {
        _c3 = add3(_c3, mul2(conj2(adata[_i3][0]), bdata[_i3][0]));
      }
      return _c3;
    }
  }
  function _sparseDot(x, y) {
    _validateDim(x, y);
    var xindex = x._index;
    var xvalues = x._values;
    var yindex = y._index;
    var yvalues = y._values;
    var c = 0;
    var add3 = addScalar2;
    var mul2 = multiplyScalar2;
    var i2 = 0;
    var j = 0;
    while (i2 < xindex.length && j < yindex.length) {
      var I = xindex[i2];
      var J = yindex[j];
      if (I < J) {
        i2++;
        continue;
      }
      if (I > J) {
        j++;
        continue;
      }
      if (I === J) {
        c = add3(c, mul2(xvalues[i2], yvalues[j]));
        i2++;
        j++;
      }
    }
    return c;
  }
  function _size(x) {
    return isMatrix(x) ? x.size() : size2(x);
  }
});

// node_modules/mathjs/lib/esm/function/matrix/trace.js
var name204 = "trace";
var dependencies205 = ["typed", "matrix", "add"];
var createTrace = /* @__PURE__ */ factory(name204, dependencies205, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    add: add3
  } = _ref;
  return typed3("trace", {
    Array: function _arrayTrace(x) {
      return _denseTrace(matrix2(x));
    },
    SparseMatrix: _sparseTrace,
    DenseMatrix: _denseTrace,
    any: clone
  });
  function _denseTrace(m) {
    var size2 = m._size;
    var data = m._data;
    switch (size2.length) {
      case 1:
        if (size2[0] === 1) {
          return clone(data[0]);
        }
        throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
      case 2: {
        var rows = size2[0];
        var cols = size2[1];
        if (rows === cols) {
          var sum3 = 0;
          for (var i2 = 0; i2 < rows; i2++) {
            sum3 = add3(sum3, data[i2][i2]);
          }
          return sum3;
        } else {
          throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
        }
      }
      default:
        throw new RangeError("Matrix must be two dimensional (size: " + format3(size2) + ")");
    }
  }
  function _sparseTrace(m) {
    var values = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    var size2 = m._size;
    var rows = size2[0];
    var columns = size2[1];
    if (rows === columns) {
      var sum3 = 0;
      if (values.length > 0) {
        for (var j = 0; j < columns; j++) {
          var k0 = ptr[j];
          var k1 = ptr[j + 1];
          for (var k = k0; k < k1; k++) {
            var i2 = index2[k];
            if (i2 === j) {
              sum3 = add3(sum3, values[k]);
              break;
            }
            if (i2 > j) {
              break;
            }
          }
        }
      }
      return sum3;
    }
    throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
  }
});

// node_modules/mathjs/lib/esm/type/matrix/function/index.js
var name205 = "index";
var dependencies206 = ["typed", "Index"];
var createIndex = /* @__PURE__ */ factory(name205, dependencies206, (_ref) => {
  var {
    typed: typed3,
    Index: Index2
  } = _ref;
  return typed3(name205, {
    "...number | string | BigNumber | Range | Array | Matrix": function numberStringBigNumberRangeArrayMatrix(args) {
      var ranges = args.map(function(arg2) {
        if (isBigNumber(arg2)) {
          return arg2.toNumber();
        } else if (isArray(arg2) || isMatrix(arg2)) {
          return arg2.map(function(elem) {
            return isBigNumber(elem) ? elem.toNumber() : elem;
          });
        } else {
          return arg2;
        }
      });
      var res = new Index2();
      Index2.apply(res, ranges);
      return res;
    }
  });
});

// node_modules/mathjs/lib/esm/expression/keywords.js
var keywords = /* @__PURE__ */ new Set(["end"]);

// node_modules/mathjs/lib/esm/expression/node/Node.js
var name206 = "Node";
var dependencies207 = ["mathWithTransform"];
var createNode = /* @__PURE__ */ factory(name206, dependencies207, (_ref) => {
  var {
    mathWithTransform: mathWithTransform2
  } = _ref;
  function _validateScope(scope) {
    for (var symbol of [...keywords]) {
      if (scope.has(symbol)) {
        throw new Error('Scope contains an illegal symbol, "' + symbol + '" is a reserved keyword');
      }
    }
  }
  class Node2 {
    get type() {
      return "Node";
    }
    get isNode() {
      return true;
    }
    /**
     * Evaluate the node
     * @param {Object} [scope]  Scope to read/write variables
     * @return {*}              Returns the result
     */
    evaluate(scope) {
      return this.compile().evaluate(scope);
    }
    /**
     * Compile the node into an optimized, evauatable JavaScript function
     * @return {{evaluate: function([Object])}} object
     *                Returns an object with a function 'evaluate',
     *                which can be invoked as expr.evaluate([scope: Object]),
     *                where scope is an optional object with
     *                variables.
     */
    compile() {
      var expr = this._compile(mathWithTransform2, {});
      var args = {};
      var context = null;
      function evaluate2(scope) {
        var s = createMap(scope);
        _validateScope(s);
        return expr(s, args, context);
      }
      return {
        evaluate: evaluate2
      };
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math2, argNames) {
      throw new Error("Method _compile must be implemented by type " + this.type);
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      throw new Error("Cannot run forEach on a Node interface");
    }
    /**
     * Create a new Node whose children are the results of calling the
     * provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {OperatorNode} Returns a transformed copy of the node
     */
    map(callback) {
      throw new Error("Cannot run map on a Node interface");
    }
    /**
     * Validate whether an object is a Node, for use with map
     * @param {Node} node
     * @returns {Node} Returns the input if it's a node, else throws an Error
     * @protected
     */
    _ifNode(node) {
      if (!isNode(node)) {
        throw new TypeError("Callback function must return a Node");
      }
      return node;
    }
    /**
     * Recursively traverse all nodes in a node tree. Executes given callback for
     * this node and each of its child nodes.
     * @param {function(node: Node, path: string, parent: Node)} callback
     *          A callback called for every node in the node tree.
     */
    traverse(callback) {
      callback(this, null, null);
      function _traverse(node, callback2) {
        node.forEach(function(child, path, parent) {
          callback2(child, path, parent);
          _traverse(child, callback2);
        });
      }
      _traverse(this, callback);
    }
    /**
     * Recursively transform a node tree via a transform function.
     *
     * For example, to replace all nodes of type SymbolNode having name 'x' with
     * a ConstantNode with value 2:
     *
     *     const res = Node.transform(function (node, path, parent) {
     *       if (node && node.isSymbolNode) && (node.name === 'x')) {
     *         return new ConstantNode(2)
     *       }
     *       else {
     *         return node
     *       }
     *     })
     *
     * @param {function(node: Node, path: string, parent: Node) : Node} callback
     *          A mapping function accepting a node, and returning
     *          a replacement for the node or the original node. The "signature"
     *          of the callback must be:
     *          callback(node: Node, index: string, parent: Node) : Node
     * @return {Node} Returns the original node or its replacement
     */
    transform(callback) {
      function _transform(child, path, parent) {
        var replacement = callback(child, path, parent);
        if (replacement !== child) {
          return replacement;
        }
        return child.map(_transform);
      }
      return _transform(this, null, null);
    }
    /**
     * Find any node in the node tree matching given filter function. For
     * example, to find all nodes of type SymbolNode having name 'x':
     *
     *     const results = Node.filter(function (node) {
     *       return (node && node.isSymbolNode) && (node.name === 'x')
     *     })
     *
     * @param {function(node: Node, path: string, parent: Node) : Node} callback
     *            A test function returning true when a node matches, and false
     *            otherwise. Function signature:
     *            callback(node: Node, index: string, parent: Node) : boolean
     * @return {Node[]} nodes
     *            An array with nodes matching given filter criteria
     */
    filter(callback) {
      var nodes = [];
      this.traverse(function(node, path, parent) {
        if (callback(node, path, parent)) {
          nodes.push(node);
        }
      });
      return nodes;
    }
    /**
     * Create a shallow clone of this node
     * @return {Node}
     */
    clone() {
      throw new Error("Cannot clone a Node interface");
    }
    /**
     * Create a deep clone of this node
     * @return {Node}
     */
    cloneDeep() {
      return this.map(function(node) {
        return node.cloneDeep();
      });
    }
    /**
     * Deep compare this node with another node.
     * @param {Node} other
     * @return {boolean} Returns true when both nodes are of the same type and
     *                   contain the same values (as do their childs)
     */
    equals(other) {
      return other ? this.type === other.type && deepStrictEqual(this, other) : false;
    }
    /**
     * Get string representation. (wrapper function)
     *
     * This function can get an object of the following form:
     * {
     *    handler: //This can be a callback function of the form
     *             // "function callback(node, options)"or
     *             // a map that maps function names (used in FunctionNodes)
     *             // to callbacks
     *    parenthesis: "keep" //the parenthesis option (This is optional)
     * }
     *
     * @param {Object} [options]
     * @return {string}
     */
    toString(options2) {
      var customString = this._getCustomString(options2);
      if (typeof customString !== "undefined") {
        return customString;
      }
      return this._toString(options2);
    }
    /**
     * Internal function to generate the string output.
     * This has to be implemented by every Node
     *
     * @throws {Error}
     */
    _toString() {
      throw new Error("_toString not implemented for " + this.type);
    }
    /**
     * Get a JSON representation of the node
     * Both .toJSON() and the static .fromJSON(json) should be implemented by all
     * implementations of Node
     * @returns {Object}
     */
    toJSON() {
      throw new Error("Cannot serialize object: toJSON not implemented by " + this.type);
    }
    /**
     * Get HTML representation. (wrapper function)
     *
     * This function can get an object of the following form:
     * {
     *    handler: //This can be a callback function of the form
     *             // "function callback(node, options)" or
     *             // a map that maps function names (used in FunctionNodes)
     *             // to callbacks
     *    parenthesis: "keep" //the parenthesis option (This is optional)
     * }
     *
     * @param {Object} [options]
     * @return {string}
     */
    toHTML(options2) {
      var customString = this._getCustomString(options2);
      if (typeof customString !== "undefined") {
        return customString;
      }
      return this._toHTML(options2);
    }
    /**
     * Internal function to generate the HTML output.
     * This has to be implemented by every Node
     *
     * @throws {Error}
     */
    _toHTML() {
      throw new Error("_toHTML not implemented for " + this.type);
    }
    /**
     * Get LaTeX representation. (wrapper function)
     *
     * This function can get an object of the following form:
     * {
     *    handler: //This can be a callback function of the form
     *             // "function callback(node, options)"or
     *             // a map that maps function names (used in FunctionNodes)
     *             // to callbacks
     *    parenthesis: "keep" //the parenthesis option (This is optional)
     * }
     *
     * @param {Object} [options]
     * @return {string}
     */
    toTex(options2) {
      var customString = this._getCustomString(options2);
      if (typeof customString !== "undefined") {
        return customString;
      }
      return this._toTex(options2);
    }
    /**
     * Internal function to generate the LaTeX output.
     * This has to be implemented by every Node
     *
     * @param {Object} [options]
     * @throws {Error}
     */
    _toTex(options2) {
      throw new Error("_toTex not implemented for " + this.type);
    }
    /**
     * Helper used by `to...` functions.
     */
    _getCustomString(options2) {
      if (options2 && typeof options2 === "object") {
        switch (typeof options2.handler) {
          case "object":
          case "undefined":
            return;
          case "function":
            return options2.handler(this, options2);
          default:
            throw new TypeError("Object or function expected as callback");
        }
      }
    }
    /**
     * Get identifier.
     * @return {string}
     */
    getIdentifier() {
      return this.type;
    }
    /**
     * Get the content of the current Node.
     * @return {Node} node
     **/
    getContent() {
      return this;
    }
  }
  return Node2;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/expression/transform/utils/errorTransform.js
function errorTransform(err) {
  if (err && err.isIndexError) {
    return new IndexError(err.index + 1, err.min + 1, err.max !== void 0 ? err.max + 1 : void 0);
  }
  return err;
}

// node_modules/mathjs/lib/esm/expression/node/utils/access.js
function accessFactory(_ref) {
  var {
    subset: subset2
  } = _ref;
  return function access(object, index2) {
    try {
      if (Array.isArray(object)) {
        return subset2(object, index2);
      } else if (object && typeof object.subset === "function") {
        return object.subset(index2);
      } else if (typeof object === "string") {
        return subset2(object, index2);
      } else if (typeof object === "object") {
        if (!index2.isObjectProperty()) {
          throw new TypeError("Cannot apply a numeric index as object property");
        }
        return getSafeProperty(object, index2.getObjectProperty());
      } else {
        throw new TypeError("Cannot apply index: unsupported type of object");
      }
    } catch (err) {
      throw errorTransform(err);
    }
  };
}

// node_modules/mathjs/lib/esm/expression/node/AccessorNode.js
var name207 = "AccessorNode";
var dependencies208 = ["subset", "Node"];
var createAccessorNode = /* @__PURE__ */ factory(name207, dependencies208, (_ref) => {
  var {
    subset: subset2,
    Node: Node2
  } = _ref;
  var access = accessFactory({
    subset: subset2
  });
  function needParenthesis(node) {
    return !(isAccessorNode(node) || isArrayNode(node) || isConstantNode(node) || isFunctionNode(node) || isObjectNode(node) || isParenthesisNode(node) || isSymbolNode(node));
  }
  class AccessorNode2 extends Node2 {
    /**
     * @constructor AccessorNode
     * @extends {Node}
     * Access an object property or get a matrix subset
     *
     * @param {Node} object                 The object from which to retrieve
     *                                      a property or subset.
     * @param {IndexNode} index             IndexNode containing ranges
     */
    constructor(object, index2) {
      super();
      if (!isNode(object)) {
        throw new TypeError('Node expected for parameter "object"');
      }
      if (!isIndexNode(index2)) {
        throw new TypeError('IndexNode expected for parameter "index"');
      }
      this.object = object;
      this.index = index2;
    }
    // readonly property name
    get name() {
      if (this.index) {
        return this.index.isObjectProperty() ? this.index.getObjectProperty() : "";
      } else {
        return this.object.name || "";
      }
    }
    get type() {
      return name207;
    }
    get isAccessorNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math2, argNames) {
      var evalObject = this.object._compile(math2, argNames);
      var evalIndex = this.index._compile(math2, argNames);
      if (this.index.isObjectProperty()) {
        var prop = this.index.getObjectProperty();
        return function evalAccessorNode(scope, args, context) {
          return getSafeProperty(evalObject(scope, args, context), prop);
        };
      } else {
        return function evalAccessorNode(scope, args, context) {
          var object = evalObject(scope, args, context);
          var index2 = evalIndex(scope, args, object);
          return access(object, index2);
        };
      }
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      callback(this.object, "object", this);
      callback(this.index, "index", this);
    }
    /**
     * Create a new AccessorNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {AccessorNode} Returns a transformed copy of the node
     */
    map(callback) {
      return new AccessorNode2(this._ifNode(callback(this.object, "object", this)), this._ifNode(callback(this.index, "index", this)));
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {AccessorNode}
     */
    clone() {
      return new AccessorNode2(this.object, this.index);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string}
     */
    _toString(options2) {
      var object = this.object.toString(options2);
      if (needParenthesis(this.object)) {
        object = "(" + object + ")";
      }
      return object + this.index.toString(options2);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string}
     */
    _toHTML(options2) {
      var object = this.object.toHTML(options2);
      if (needParenthesis(this.object)) {
        object = '<span class="math-parenthesis math-round-parenthesis">(</span>' + object + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      return object + this.index.toHTML(options2);
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string}
     */
    _toTex(options2) {
      var object = this.object.toTex(options2);
      if (needParenthesis(this.object)) {
        object = "\\left(' + object + '\\right)";
      }
      return object + this.index.toTex(options2);
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name207,
        object: this.object,
        index: this.index
      };
    }
    /**
     * Instantiate an AccessorNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "AccessorNode", object: ..., index: ...}`,
     *     where mathjs is optional
     * @returns {AccessorNode}
     */
    static fromJSON(json) {
      return new AccessorNode2(json.object, json.index);
    }
  }
  _defineProperty(AccessorNode2, "name", name207);
  return AccessorNode2;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/expression/node/ArrayNode.js
var name208 = "ArrayNode";
var dependencies209 = ["Node"];
var createArrayNode = /* @__PURE__ */ factory(name208, dependencies209, (_ref) => {
  var {
    Node: Node2
  } = _ref;
  class ArrayNode2 extends Node2 {
    /**
     * @constructor ArrayNode
     * @extends {Node}
     * Holds an 1-dimensional array with items
     * @param {Node[]} [items]   1 dimensional array with items
     */
    constructor(items) {
      super();
      this.items = items || [];
      if (!Array.isArray(this.items) || !this.items.every(isNode)) {
        throw new TypeError("Array containing Nodes expected");
      }
    }
    get type() {
      return name208;
    }
    get isArrayNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math2, argNames) {
      var evalItems = map(this.items, function(item) {
        return item._compile(math2, argNames);
      });
      var asMatrix = math2.config.matrix !== "Array";
      if (asMatrix) {
        var matrix2 = math2.matrix;
        return function evalArrayNode(scope, args, context) {
          return matrix2(map(evalItems, function(evalItem) {
            return evalItem(scope, args, context);
          }));
        };
      } else {
        return function evalArrayNode(scope, args, context) {
          return map(evalItems, function(evalItem) {
            return evalItem(scope, args, context);
          });
        };
      }
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      for (var i2 = 0; i2 < this.items.length; i2++) {
        var node = this.items[i2];
        callback(node, "items[" + i2 + "]", this);
      }
    }
    /**
     * Create a new ArrayNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {ArrayNode} Returns a transformed copy of the node
     */
    map(callback) {
      var items = [];
      for (var i2 = 0; i2 < this.items.length; i2++) {
        items[i2] = this._ifNode(callback(this.items[i2], "items[" + i2 + "]", this));
      }
      return new ArrayNode2(items);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {ArrayNode}
     */
    clone() {
      return new ArrayNode2(this.items.slice(0));
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toString(options2) {
      var items = this.items.map(function(node) {
        return node.toString(options2);
      });
      return "[" + items.join(", ") + "]";
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name208,
        items: this.items
      };
    }
    /**
     * Instantiate an ArrayNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "ArrayNode", items: [...]}`,
     *                       where mathjs is optional
     * @returns {ArrayNode}
     */
    static fromJSON(json) {
      return new ArrayNode2(json.items);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toHTML(options2) {
      var items = this.items.map(function(node) {
        return node.toHTML(options2);
      });
      return '<span class="math-parenthesis math-square-parenthesis">[</span>' + items.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(options2) {
      function itemsToTex(items, nested) {
        var mixedItems = items.some(isArrayNode) && !items.every(isArrayNode);
        var itemsFormRow = nested || mixedItems;
        var itemSep = itemsFormRow ? "&" : "\\\\";
        var itemsTex = items.map(function(node) {
          if (node.items) {
            return itemsToTex(node.items, !nested);
          } else {
            return node.toTex(options2);
          }
        }).join(itemSep);
        return mixedItems || !itemsFormRow || itemsFormRow && !nested ? "\\begin{bmatrix}" + itemsTex + "\\end{bmatrix}" : itemsTex;
      }
      return itemsToTex(this.items, false);
    }
  }
  _defineProperty(ArrayNode2, "name", name208);
  return ArrayNode2;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/expression/node/utils/assign.js
function assignFactory(_ref) {
  var {
    subset: subset2,
    matrix: matrix2
  } = _ref;
  return function assign2(object, index2, value) {
    try {
      if (Array.isArray(object)) {
        var result = matrix2(object).subset(index2, value).valueOf();
        result.forEach((item, index3) => {
          object[index3] = item;
        });
        return object;
      } else if (object && typeof object.subset === "function") {
        return object.subset(index2, value);
      } else if (typeof object === "string") {
        return subset2(object, index2, value);
      } else if (typeof object === "object") {
        if (!index2.isObjectProperty()) {
          throw TypeError("Cannot apply a numeric index as object property");
        }
        setSafeProperty(object, index2.getObjectProperty(), value);
        return object;
      } else {
        throw new TypeError("Cannot apply index: unsupported type of object");
      }
    } catch (err) {
      throw errorTransform(err);
    }
  };
}

// node_modules/mathjs/lib/esm/expression/operators.js
var properties = [{
  // assignment
  AssignmentNode: {},
  FunctionAssignmentNode: {}
}, {
  // conditional expression
  ConditionalNode: {
    latexLeftParens: false,
    latexRightParens: false,
    latexParens: false
    // conditionals don't need parentheses in LaTeX because
    // they are 2 dimensional
  }
}, {
  // logical or
  "OperatorNode:or": {
    op: "or",
    associativity: "left",
    associativeWith: []
  }
}, {
  // logical xor
  "OperatorNode:xor": {
    op: "xor",
    associativity: "left",
    associativeWith: []
  }
}, {
  // logical and
  "OperatorNode:and": {
    op: "and",
    associativity: "left",
    associativeWith: []
  }
}, {
  // bitwise or
  "OperatorNode:bitOr": {
    op: "|",
    associativity: "left",
    associativeWith: []
  }
}, {
  // bitwise xor
  "OperatorNode:bitXor": {
    op: "^|",
    associativity: "left",
    associativeWith: []
  }
}, {
  // bitwise and
  "OperatorNode:bitAnd": {
    op: "&",
    associativity: "left",
    associativeWith: []
  }
}, {
  // relational operators
  "OperatorNode:equal": {
    op: "==",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:unequal": {
    op: "!=",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:smaller": {
    op: "<",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:larger": {
    op: ">",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:smallerEq": {
    op: "<=",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:largerEq": {
    op: ">=",
    associativity: "left",
    associativeWith: []
  },
  RelationalNode: {
    associativity: "left",
    associativeWith: []
  }
}, {
  // bitshift operators
  "OperatorNode:leftShift": {
    op: "<<",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:rightArithShift": {
    op: ">>",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:rightLogShift": {
    op: ">>>",
    associativity: "left",
    associativeWith: []
  }
}, {
  // unit conversion
  "OperatorNode:to": {
    op: "to",
    associativity: "left",
    associativeWith: []
  }
}, {
  // range
  RangeNode: {}
}, {
  // addition, subtraction
  "OperatorNode:add": {
    op: "+",
    associativity: "left",
    associativeWith: ["OperatorNode:add", "OperatorNode:subtract"]
  },
  "OperatorNode:subtract": {
    op: "-",
    associativity: "left",
    associativeWith: []
  }
}, {
  // multiply, divide, modulus
  "OperatorNode:multiply": {
    op: "*",
    associativity: "left",
    associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "Operator:dotMultiply", "Operator:dotDivide"]
  },
  "OperatorNode:divide": {
    op: "/",
    associativity: "left",
    associativeWith: [],
    latexLeftParens: false,
    latexRightParens: false,
    latexParens: false
    // fractions don't require parentheses because
    // they're 2 dimensional, so parens aren't needed
    // in LaTeX
  },
  "OperatorNode:dotMultiply": {
    op: ".*",
    associativity: "left",
    associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "OperatorNode:dotMultiply", "OperatorNode:doDivide"]
  },
  "OperatorNode:dotDivide": {
    op: "./",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:mod": {
    op: "mod",
    associativity: "left",
    associativeWith: []
  }
}, {
  // Repeat multiplication for implicit multiplication
  "OperatorNode:multiply": {
    associativity: "left",
    associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "Operator:dotMultiply", "Operator:dotDivide"]
  }
}, {
  // unary prefix operators
  "OperatorNode:unaryPlus": {
    op: "+",
    associativity: "right"
  },
  "OperatorNode:unaryMinus": {
    op: "-",
    associativity: "right"
  },
  "OperatorNode:bitNot": {
    op: "~",
    associativity: "right"
  },
  "OperatorNode:not": {
    op: "not",
    associativity: "right"
  }
}, {
  // exponentiation
  "OperatorNode:pow": {
    op: "^",
    associativity: "right",
    associativeWith: [],
    latexRightParens: false
    // the exponent doesn't need parentheses in
    // LaTeX because it's 2 dimensional
    // (it's on top)
  },
  "OperatorNode:dotPow": {
    op: ".^",
    associativity: "right",
    associativeWith: []
  }
}, {
  // factorial
  "OperatorNode:factorial": {
    op: "!",
    associativity: "left"
  }
}, {
  // matrix transpose
  "OperatorNode:ctranspose": {
    op: "'",
    associativity: "left"
  }
}];
function unwrapParen(_node, parenthesis) {
  if (!parenthesis || parenthesis !== "auto")
    return _node;
  var node = _node;
  while (isParenthesisNode(node))
    node = node.content;
  return node;
}
function getPrecedence(_node, parenthesis, implicit, parent) {
  var node = _node;
  if (parenthesis !== "keep") {
    node = _node.getContent();
  }
  var identifier = node.getIdentifier();
  var precedence = null;
  for (var i2 = 0; i2 < properties.length; i2++) {
    if (identifier in properties[i2]) {
      precedence = i2;
      break;
    }
  }
  if (identifier === "OperatorNode:multiply" && node.implicit && implicit !== "show") {
    var leftArg = unwrapParen(node.args[0], parenthesis);
    if (!(isConstantNode(leftArg) && parent && parent.getIdentifier() === "OperatorNode:divide" && rule2Node(unwrapParen(parent.args[0], parenthesis))) && !(leftArg.getIdentifier() === "OperatorNode:divide" && rule2Node(unwrapParen(leftArg.args[0], parenthesis)) && isConstantNode(unwrapParen(leftArg.args[1])))) {
      precedence += 1;
    }
  }
  return precedence;
}
function getAssociativity(_node, parenthesis) {
  var node = _node;
  if (parenthesis !== "keep") {
    node = _node.getContent();
  }
  var identifier = node.getIdentifier();
  var index2 = getPrecedence(node, parenthesis);
  if (index2 === null) {
    return null;
  }
  var property = properties[index2][identifier];
  if (hasOwnProperty(property, "associativity")) {
    if (property.associativity === "left") {
      return "left";
    }
    if (property.associativity === "right") {
      return "right";
    }
    throw Error("'" + identifier + "' has the invalid associativity '" + property.associativity + "'.");
  }
  return null;
}
function isAssociativeWith(nodeA, nodeB, parenthesis) {
  var a = parenthesis !== "keep" ? nodeA.getContent() : nodeA;
  var b = parenthesis !== "keep" ? nodeA.getContent() : nodeB;
  var identifierA = a.getIdentifier();
  var identifierB = b.getIdentifier();
  var index2 = getPrecedence(a, parenthesis);
  if (index2 === null) {
    return null;
  }
  var property = properties[index2][identifierA];
  if (hasOwnProperty(property, "associativeWith") && property.associativeWith instanceof Array) {
    for (var i2 = 0; i2 < property.associativeWith.length; i2++) {
      if (property.associativeWith[i2] === identifierB) {
        return true;
      }
    }
    return false;
  }
  return null;
}
function getOperator(fn) {
  var identifier = "OperatorNode:" + fn;
  for (var group of properties) {
    if (identifier in group) {
      return group[identifier].op;
    }
  }
  return null;
}

// node_modules/mathjs/lib/esm/expression/node/AssignmentNode.js
var name209 = "AssignmentNode";
var dependencies210 = [
  "subset",
  "?matrix",
  // FIXME: should not be needed at all, should be handled by subset
  "Node"
];
var createAssignmentNode = /* @__PURE__ */ factory(name209, dependencies210, (_ref) => {
  var {
    subset: subset2,
    matrix: matrix2,
    Node: Node2
  } = _ref;
  var access = accessFactory({
    subset: subset2
  });
  var assign2 = assignFactory({
    subset: subset2,
    matrix: matrix2
  });
  function needParenthesis(node, parenthesis, implicit) {
    if (!parenthesis) {
      parenthesis = "keep";
    }
    var precedence = getPrecedence(node, parenthesis, implicit);
    var exprPrecedence = getPrecedence(node.value, parenthesis, implicit);
    return parenthesis === "all" || exprPrecedence !== null && exprPrecedence <= precedence;
  }
  class AssignmentNode2 extends Node2 {
    /**
     * @constructor AssignmentNode
     * @extends {Node}
     *
     * Define a symbol, like `a=3.2`, update a property like `a.b=3.2`, or
     * replace a subset of a matrix like `A[2,2]=42`.
     *
     * Syntax:
     *
     *     new AssignmentNode(symbol, value)
     *     new AssignmentNode(object, index, value)
     *
     * Usage:
     *
     *    new AssignmentNode(new SymbolNode('a'), new ConstantNode(2))  // a=2
     *    new AssignmentNode(new SymbolNode('a'),
     *                       new IndexNode('b'),
     *                       new ConstantNode(2))   // a.b=2
     *    new AssignmentNode(new SymbolNode('a'),
     *                       new IndexNode(1, 2),
     *                       new ConstantNode(3))  // a[1,2]=3
     *
     * @param {SymbolNode | AccessorNode} object
     *     Object on which to assign a value
     * @param {IndexNode} [index=null]
     *     Index, property name or matrix index. Optional. If not provided
     *     and `object` is a SymbolNode, the property is assigned to the
     *     global scope.
     * @param {Node} value
     *     The value to be assigned
     */
    constructor(object, index2, value) {
      super();
      this.object = object;
      this.index = value ? index2 : null;
      this.value = value || index2;
      if (!isSymbolNode(object) && !isAccessorNode(object)) {
        throw new TypeError('SymbolNode or AccessorNode expected as "object"');
      }
      if (isSymbolNode(object) && object.name === "end") {
        throw new Error('Cannot assign to symbol "end"');
      }
      if (this.index && !isIndexNode(this.index)) {
        throw new TypeError('IndexNode expected as "index"');
      }
      if (!isNode(this.value)) {
        throw new TypeError('Node expected as "value"');
      }
    }
    // class name for typing purposes:
    // readonly property name
    get name() {
      if (this.index) {
        return this.index.isObjectProperty() ? this.index.getObjectProperty() : "";
      } else {
        return this.object.name || "";
      }
    }
    get type() {
      return name209;
    }
    get isAssignmentNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math2, argNames) {
      var evalObject = this.object._compile(math2, argNames);
      var evalIndex = this.index ? this.index._compile(math2, argNames) : null;
      var evalValue = this.value._compile(math2, argNames);
      var name314 = this.object.name;
      if (!this.index) {
        if (!isSymbolNode(this.object)) {
          throw new TypeError("SymbolNode expected as object");
        }
        return function evalAssignmentNode(scope, args, context) {
          var value = evalValue(scope, args, context);
          scope.set(name314, value);
          return value;
        };
      } else if (this.index.isObjectProperty()) {
        var prop = this.index.getObjectProperty();
        return function evalAssignmentNode(scope, args, context) {
          var object = evalObject(scope, args, context);
          var value = evalValue(scope, args, context);
          setSafeProperty(object, prop, value);
          return value;
        };
      } else if (isSymbolNode(this.object)) {
        return function evalAssignmentNode(scope, args, context) {
          var childObject = evalObject(scope, args, context);
          var value = evalValue(scope, args, context);
          var index2 = evalIndex(scope, args, childObject);
          scope.set(name314, assign2(childObject, index2, value));
          return value;
        };
      } else {
        var evalParentObject = this.object.object._compile(math2, argNames);
        if (this.object.index.isObjectProperty()) {
          var parentProp = this.object.index.getObjectProperty();
          return function evalAssignmentNode(scope, args, context) {
            var parent = evalParentObject(scope, args, context);
            var childObject = getSafeProperty(parent, parentProp);
            var index2 = evalIndex(scope, args, childObject);
            var value = evalValue(scope, args, context);
            setSafeProperty(parent, parentProp, assign2(childObject, index2, value));
            return value;
          };
        } else {
          var evalParentIndex = this.object.index._compile(math2, argNames);
          return function evalAssignmentNode(scope, args, context) {
            var parent = evalParentObject(scope, args, context);
            var parentIndex = evalParentIndex(scope, args, parent);
            var childObject = access(parent, parentIndex);
            var index2 = evalIndex(scope, args, childObject);
            var value = evalValue(scope, args, context);
            assign2(parent, parentIndex, assign2(childObject, index2, value));
            return value;
          };
        }
      }
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      callback(this.object, "object", this);
      if (this.index) {
        callback(this.index, "index", this);
      }
      callback(this.value, "value", this);
    }
    /**
     * Create a new AssignmentNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {AssignmentNode} Returns a transformed copy of the node
     */
    map(callback) {
      var object = this._ifNode(callback(this.object, "object", this));
      var index2 = this.index ? this._ifNode(callback(this.index, "index", this)) : null;
      var value = this._ifNode(callback(this.value, "value", this));
      return new AssignmentNode2(object, index2, value);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {AssignmentNode}
     */
    clone() {
      return new AssignmentNode2(this.object, this.index, this.value);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string}
     */
    _toString(options2) {
      var object = this.object.toString(options2);
      var index2 = this.index ? this.index.toString(options2) : "";
      var value = this.value.toString(options2);
      if (needParenthesis(this, options2 && options2.parenthesis, options2 && options2.implicit)) {
        value = "(" + value + ")";
      }
      return object + index2 + " = " + value;
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name209,
        object: this.object,
        index: this.index,
        value: this.value
      };
    }
    /**
     * Instantiate an AssignmentNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "AssignmentNode", object: ..., index: ..., value: ...}`,
     *     where mathjs is optional
     * @returns {AssignmentNode}
     */
    static fromJSON(json) {
      return new AssignmentNode2(json.object, json.index, json.value);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string}
     */
    _toHTML(options2) {
      var object = this.object.toHTML(options2);
      var index2 = this.index ? this.index.toHTML(options2) : "";
      var value = this.value.toHTML(options2);
      if (needParenthesis(this, options2 && options2.parenthesis, options2 && options2.implicit)) {
        value = '<span class="math-paranthesis math-round-parenthesis">(</span>' + value + '<span class="math-paranthesis math-round-parenthesis">)</span>';
      }
      return object + index2 + '<span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' + value;
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string}
     */
    _toTex(options2) {
      var object = this.object.toTex(options2);
      var index2 = this.index ? this.index.toTex(options2) : "";
      var value = this.value.toTex(options2);
      if (needParenthesis(this, options2 && options2.parenthesis, options2 && options2.implicit)) {
        value = "\\left(".concat(value, "\\right)");
      }
      return object + index2 + "=" + value;
    }
  }
  _defineProperty(AssignmentNode2, "name", name209);
  return AssignmentNode2;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/expression/node/BlockNode.js
var name210 = "BlockNode";
var dependencies211 = ["ResultSet", "Node"];
var createBlockNode = /* @__PURE__ */ factory(name210, dependencies211, (_ref) => {
  var {
    ResultSet: ResultSet2,
    Node: Node2
  } = _ref;
  class BlockNode2 extends Node2 {
    /**
     * @constructor BlockNode
     * @extends {Node}
     * Holds a set with blocks
     * @param {Array.<{node: Node} | {node: Node, visible: boolean}>} blocks
     *            An array with blocks, where a block is constructed as an
     *            Object with properties block, which is a Node, and visible,
     *            which is a boolean. The property visible is optional and
     *            is true by default
     */
    constructor(blocks) {
      super();
      if (!Array.isArray(blocks))
        throw new Error("Array expected");
      this.blocks = blocks.map(function(block2) {
        var node = block2 && block2.node;
        var visible = block2 && block2.visible !== void 0 ? block2.visible : true;
        if (!isNode(node))
          throw new TypeError('Property "node" must be a Node');
        if (typeof visible !== "boolean") {
          throw new TypeError('Property "visible" must be a boolean');
        }
        return {
          node,
          visible
        };
      });
    }
    get type() {
      return name210;
    }
    get isBlockNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math2, argNames) {
      var evalBlocks = map(this.blocks, function(block2) {
        return {
          evaluate: block2.node._compile(math2, argNames),
          visible: block2.visible
        };
      });
      return function evalBlockNodes(scope, args, context) {
        var results = [];
        forEach(evalBlocks, function evalBlockNode(block2) {
          var result = block2.evaluate(scope, args, context);
          if (block2.visible) {
            results.push(result);
          }
        });
        return new ResultSet2(results);
      };
    }
    /**
     * Execute a callback for each of the child blocks of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      for (var i2 = 0; i2 < this.blocks.length; i2++) {
        callback(this.blocks[i2].node, "blocks[" + i2 + "].node", this);
      }
    }
    /**
     * Create a new BlockNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {BlockNode} Returns a transformed copy of the node
     */
    map(callback) {
      var blocks = [];
      for (var i2 = 0; i2 < this.blocks.length; i2++) {
        var block2 = this.blocks[i2];
        var node = this._ifNode(callback(block2.node, "blocks[" + i2 + "].node", this));
        blocks[i2] = {
          node,
          visible: block2.visible
        };
      }
      return new BlockNode2(blocks);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {BlockNode}
     */
    clone() {
      var blocks = this.blocks.map(function(block2) {
        return {
          node: block2.node,
          visible: block2.visible
        };
      });
      return new BlockNode2(blocks);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toString(options2) {
      return this.blocks.map(function(param) {
        return param.node.toString(options2) + (param.visible ? "" : ";");
      }).join("\n");
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name210,
        blocks: this.blocks
      };
    }
    /**
     * Instantiate an BlockNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "BlockNode", blocks: [{node: ..., visible: false}, ...]}`,
     *     where mathjs is optional
     * @returns {BlockNode}
     */
    static fromJSON(json) {
      return new BlockNode2(json.blocks);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toHTML(options2) {
      return this.blocks.map(function(param) {
        return param.node.toHTML(options2) + (param.visible ? "" : '<span class="math-separator">;</span>');
      }).join('<span class="math-separator"><br /></span>');
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(options2) {
      return this.blocks.map(function(param) {
        return param.node.toTex(options2) + (param.visible ? "" : ";");
      }).join("\\;\\;\n");
    }
  }
  _defineProperty(BlockNode2, "name", name210);
  return BlockNode2;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/expression/node/ConditionalNode.js
var name211 = "ConditionalNode";
var dependencies212 = ["Node"];
var createConditionalNode = /* @__PURE__ */ factory(name211, dependencies212, (_ref) => {
  var {
    Node: Node2
  } = _ref;
  function testCondition(condition) {
    if (typeof condition === "number" || typeof condition === "boolean" || typeof condition === "string") {
      return !!condition;
    }
    if (condition) {
      if (isBigNumber(condition)) {
        return !condition.isZero();
      }
      if (isComplex(condition)) {
        return !!(condition.re || condition.im);
      }
      if (isUnit(condition)) {
        return !!condition.value;
      }
    }
    if (condition === null || condition === void 0) {
      return false;
    }
    throw new TypeError('Unsupported type of condition "' + typeOf(condition) + '"');
  }
  class ConditionalNode2 extends Node2 {
    /**
     * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'
     *
     * @param {Node} condition   Condition, must result in a boolean
     * @param {Node} trueExpr    Expression evaluated when condition is true
     * @param {Node} falseExpr   Expression evaluated when condition is true
     *
     * @constructor ConditionalNode
     * @extends {Node}
     */
    constructor(condition, trueExpr, falseExpr) {
      super();
      if (!isNode(condition)) {
        throw new TypeError("Parameter condition must be a Node");
      }
      if (!isNode(trueExpr)) {
        throw new TypeError("Parameter trueExpr must be a Node");
      }
      if (!isNode(falseExpr)) {
        throw new TypeError("Parameter falseExpr must be a Node");
      }
      this.condition = condition;
      this.trueExpr = trueExpr;
      this.falseExpr = falseExpr;
    }
    get type() {
      return name211;
    }
    get isConditionalNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math2, argNames) {
      var evalCondition = this.condition._compile(math2, argNames);
      var evalTrueExpr = this.trueExpr._compile(math2, argNames);
      var evalFalseExpr = this.falseExpr._compile(math2, argNames);
      return function evalConditionalNode(scope, args, context) {
        return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      callback(this.condition, "condition", this);
      callback(this.trueExpr, "trueExpr", this);
      callback(this.falseExpr, "falseExpr", this);
    }
    /**
     * Create a new ConditionalNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {ConditionalNode} Returns a transformed copy of the node
     */
    map(callback) {
      return new ConditionalNode2(this._ifNode(callback(this.condition, "condition", this)), this._ifNode(callback(this.trueExpr, "trueExpr", this)), this._ifNode(callback(this.falseExpr, "falseExpr", this)));
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {ConditionalNode}
     */
    clone() {
      return new ConditionalNode2(this.condition, this.trueExpr, this.falseExpr);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */
    _toString(options2) {
      var parenthesis = options2 && options2.parenthesis ? options2.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis, options2 && options2.implicit);
      var condition = this.condition.toString(options2);
      var conditionPrecedence = getPrecedence(this.condition, parenthesis, options2 && options2.implicit);
      if (parenthesis === "all" || this.condition.type === "OperatorNode" || conditionPrecedence !== null && conditionPrecedence <= precedence) {
        condition = "(" + condition + ")";
      }
      var trueExpr = this.trueExpr.toString(options2);
      var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options2 && options2.implicit);
      if (parenthesis === "all" || this.trueExpr.type === "OperatorNode" || truePrecedence !== null && truePrecedence <= precedence) {
        trueExpr = "(" + trueExpr + ")";
      }
      var falseExpr = this.falseExpr.toString(options2);
      var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options2 && options2.implicit);
      if (parenthesis === "all" || this.falseExpr.type === "OperatorNode" || falsePrecedence !== null && falsePrecedence <= precedence) {
        falseExpr = "(" + falseExpr + ")";
      }
      return condition + " ? " + trueExpr + " : " + falseExpr;
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name211,
        condition: this.condition,
        trueExpr: this.trueExpr,
        falseExpr: this.falseExpr
      };
    }
    /**
     * Instantiate an ConditionalNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     ```
     *     {"mathjs": "ConditionalNode",
     *      "condition": ...,
     *      "trueExpr": ...,
     *      "falseExpr": ...}
     *     ```
     *     where mathjs is optional
     * @returns {ConditionalNode}
     */
    static fromJSON(json) {
      return new ConditionalNode2(json.condition, json.trueExpr, json.falseExpr);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(options2) {
      var parenthesis = options2 && options2.parenthesis ? options2.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis, options2 && options2.implicit);
      var condition = this.condition.toHTML(options2);
      var conditionPrecedence = getPrecedence(this.condition, parenthesis, options2 && options2.implicit);
      if (parenthesis === "all" || this.condition.type === "OperatorNode" || conditionPrecedence !== null && conditionPrecedence <= precedence) {
        condition = '<span class="math-parenthesis math-round-parenthesis">(</span>' + condition + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      var trueExpr = this.trueExpr.toHTML(options2);
      var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options2 && options2.implicit);
      if (parenthesis === "all" || this.trueExpr.type === "OperatorNode" || truePrecedence !== null && truePrecedence <= precedence) {
        trueExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + trueExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      var falseExpr = this.falseExpr.toHTML(options2);
      var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options2 && options2.implicit);
      if (parenthesis === "all" || this.falseExpr.type === "OperatorNode" || falsePrecedence !== null && falsePrecedence <= precedence) {
        falseExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + falseExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      return condition + '<span class="math-operator math-conditional-operator">?</span>' + trueExpr + '<span class="math-operator math-conditional-operator">:</span>' + falseExpr;
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(options2) {
      return "\\begin{cases} {" + this.trueExpr.toTex(options2) + "}, &\\quad{\\text{if }\\;" + this.condition.toTex(options2) + "}\\\\{" + this.falseExpr.toTex(options2) + "}, &\\quad{\\text{otherwise}}\\end{cases}";
    }
  }
  _defineProperty(ConditionalNode2, "name", name211);
  return ConditionalNode2;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/utils/latex.js
var import_escape_latex = __toESM(require_dist(), 1);
var latexSymbols = {
  // GREEK LETTERS
  Alpha: "A",
  alpha: "\\alpha",
  Beta: "B",
  beta: "\\beta",
  Gamma: "\\Gamma",
  gamma: "\\gamma",
  Delta: "\\Delta",
  delta: "\\delta",
  Epsilon: "E",
  epsilon: "\\epsilon",
  varepsilon: "\\varepsilon",
  Zeta: "Z",
  zeta: "\\zeta",
  Eta: "H",
  eta: "\\eta",
  Theta: "\\Theta",
  theta: "\\theta",
  vartheta: "\\vartheta",
  Iota: "I",
  iota: "\\iota",
  Kappa: "K",
  kappa: "\\kappa",
  varkappa: "\\varkappa",
  Lambda: "\\Lambda",
  lambda: "\\lambda",
  Mu: "M",
  mu: "\\mu",
  Nu: "N",
  nu: "\\nu",
  Xi: "\\Xi",
  xi: "\\xi",
  Omicron: "O",
  omicron: "o",
  Pi: "\\Pi",
  pi: "\\pi",
  varpi: "\\varpi",
  Rho: "P",
  rho: "\\rho",
  varrho: "\\varrho",
  Sigma: "\\Sigma",
  sigma: "\\sigma",
  varsigma: "\\varsigma",
  Tau: "T",
  tau: "\\tau",
  Upsilon: "\\Upsilon",
  upsilon: "\\upsilon",
  Phi: "\\Phi",
  phi: "\\phi",
  varphi: "\\varphi",
  Chi: "X",
  chi: "\\chi",
  Psi: "\\Psi",
  psi: "\\psi",
  Omega: "\\Omega",
  omega: "\\omega",
  // logic
  true: "\\mathrm{True}",
  false: "\\mathrm{False}",
  // other
  i: "i",
  // TODO use \i ??
  inf: "\\infty",
  Inf: "\\infty",
  infinity: "\\infty",
  Infinity: "\\infty",
  oo: "\\infty",
  lim: "\\lim",
  undefined: "\\mathbf{?}"
};
var latexOperators = {
  transpose: "^\\top",
  ctranspose: "^H",
  factorial: "!",
  pow: "^",
  dotPow: ".^\\wedge",
  // TODO find ideal solution
  unaryPlus: "+",
  unaryMinus: "-",
  bitNot: "\\~",
  // TODO find ideal solution
  not: "\\neg",
  multiply: "\\cdot",
  divide: "\\frac",
  // TODO how to handle that properly?
  dotMultiply: ".\\cdot",
  // TODO find ideal solution
  dotDivide: ".:",
  // TODO find ideal solution
  mod: "\\mod",
  add: "+",
  subtract: "-",
  to: "\\rightarrow",
  leftShift: "<<",
  rightArithShift: ">>",
  rightLogShift: ">>>",
  equal: "=",
  unequal: "\\neq",
  smaller: "<",
  larger: ">",
  smallerEq: "\\leq",
  largerEq: "\\geq",
  bitAnd: "\\&",
  bitXor: "\\underline{|}",
  bitOr: "|",
  and: "\\wedge",
  xor: "\\veebar",
  or: "\\vee"
};
var latexFunctions = {
  // arithmetic
  abs: {
    1: "\\left|${args[0]}\\right|"
  },
  add: {
    2: "\\left(${args[0]}".concat(latexOperators.add, "${args[1]}\\right)")
  },
  cbrt: {
    1: "\\sqrt[3]{${args[0]}}"
  },
  ceil: {
    1: "\\left\\lceil${args[0]}\\right\\rceil"
  },
  cube: {
    1: "\\left(${args[0]}\\right)^3"
  },
  divide: {
    2: "\\frac{${args[0]}}{${args[1]}}"
  },
  dotDivide: {
    2: "\\left(${args[0]}".concat(latexOperators.dotDivide, "${args[1]}\\right)")
  },
  dotMultiply: {
    2: "\\left(${args[0]}".concat(latexOperators.dotMultiply, "${args[1]}\\right)")
  },
  dotPow: {
    2: "\\left(${args[0]}".concat(latexOperators.dotPow, "${args[1]}\\right)")
  },
  exp: {
    1: "\\exp\\left(${args[0]}\\right)"
  },
  expm1: "\\left(e".concat(latexOperators.pow, "{${args[0]}}-1\\right)"),
  fix: {
    1: "\\mathrm{${name}}\\left(${args[0]}\\right)"
  },
  floor: {
    1: "\\left\\lfloor${args[0]}\\right\\rfloor"
  },
  gcd: "\\gcd\\left(${args}\\right)",
  hypot: "\\hypot\\left(${args}\\right)",
  log: {
    1: "\\ln\\left(${args[0]}\\right)",
    2: "\\log_{${args[1]}}\\left(${args[0]}\\right)"
  },
  log10: {
    1: "\\log_{10}\\left(${args[0]}\\right)"
  },
  log1p: {
    1: "\\ln\\left(${args[0]}+1\\right)",
    2: "\\log_{${args[1]}}\\left(${args[0]}+1\\right)"
  },
  log2: "\\log_{2}\\left(${args[0]}\\right)",
  mod: {
    2: "\\left(${args[0]}".concat(latexOperators.mod, "${args[1]}\\right)")
  },
  multiply: {
    2: "\\left(${args[0]}".concat(latexOperators.multiply, "${args[1]}\\right)")
  },
  norm: {
    1: "\\left\\|${args[0]}\\right\\|",
    2: void 0
    // use default template
  },
  nthRoot: {
    2: "\\sqrt[${args[1]}]{${args[0]}}"
  },
  nthRoots: {
    2: "\\{y : $y^{args[1]} = {${args[0]}}\\}"
  },
  pow: {
    2: "\\left(${args[0]}\\right)".concat(latexOperators.pow, "{${args[1]}}")
  },
  round: {
    1: "\\left\\lfloor${args[0]}\\right\\rceil",
    2: void 0
    // use default template
  },
  sign: {
    1: "\\mathrm{${name}}\\left(${args[0]}\\right)"
  },
  sqrt: {
    1: "\\sqrt{${args[0]}}"
  },
  square: {
    1: "\\left(${args[0]}\\right)^2"
  },
  subtract: {
    2: "\\left(${args[0]}".concat(latexOperators.subtract, "${args[1]}\\right)")
  },
  unaryMinus: {
    1: "".concat(latexOperators.unaryMinus, "\\left(${args[0]}\\right)")
  },
  unaryPlus: {
    1: "".concat(latexOperators.unaryPlus, "\\left(${args[0]}\\right)")
  },
  // bitwise
  bitAnd: {
    2: "\\left(${args[0]}".concat(latexOperators.bitAnd, "${args[1]}\\right)")
  },
  bitNot: {
    1: latexOperators.bitNot + "\\left(${args[0]}\\right)"
  },
  bitOr: {
    2: "\\left(${args[0]}".concat(latexOperators.bitOr, "${args[1]}\\right)")
  },
  bitXor: {
    2: "\\left(${args[0]}".concat(latexOperators.bitXor, "${args[1]}\\right)")
  },
  leftShift: {
    2: "\\left(${args[0]}".concat(latexOperators.leftShift, "${args[1]}\\right)")
  },
  rightArithShift: {
    2: "\\left(${args[0]}".concat(latexOperators.rightArithShift, "${args[1]}\\right)")
  },
  rightLogShift: {
    2: "\\left(${args[0]}".concat(latexOperators.rightLogShift, "${args[1]}\\right)")
  },
  // combinatorics
  bellNumbers: {
    1: "\\mathrm{B}_{${args[0]}}"
  },
  catalan: {
    1: "\\mathrm{C}_{${args[0]}}"
  },
  stirlingS2: {
    2: "\\mathrm{S}\\left(${args}\\right)"
  },
  // complex
  arg: {
    1: "\\arg\\left(${args[0]}\\right)"
  },
  conj: {
    1: "\\left(${args[0]}\\right)^*"
  },
  im: {
    1: "\\Im\\left\\lbrace${args[0]}\\right\\rbrace"
  },
  re: {
    1: "\\Re\\left\\lbrace${args[0]}\\right\\rbrace"
  },
  // logical
  and: {
    2: "\\left(${args[0]}".concat(latexOperators.and, "${args[1]}\\right)")
  },
  not: {
    1: latexOperators.not + "\\left(${args[0]}\\right)"
  },
  or: {
    2: "\\left(${args[0]}".concat(latexOperators.or, "${args[1]}\\right)")
  },
  xor: {
    2: "\\left(${args[0]}".concat(latexOperators.xor, "${args[1]}\\right)")
  },
  // matrix
  cross: {
    2: "\\left(${args[0]}\\right)\\times\\left(${args[1]}\\right)"
  },
  ctranspose: {
    1: "\\left(${args[0]}\\right)".concat(latexOperators.ctranspose)
  },
  det: {
    1: "\\det\\left(${args[0]}\\right)"
  },
  dot: {
    2: "\\left(${args[0]}\\cdot${args[1]}\\right)"
  },
  expm: {
    1: "\\exp\\left(${args[0]}\\right)"
  },
  inv: {
    1: "\\left(${args[0]}\\right)^{-1}"
  },
  pinv: {
    1: "\\left(${args[0]}\\right)^{+}"
  },
  sqrtm: {
    1: "{${args[0]}}".concat(latexOperators.pow, "{\\frac{1}{2}}")
  },
  trace: {
    1: "\\mathrm{tr}\\left(${args[0]}\\right)"
  },
  transpose: {
    1: "\\left(${args[0]}\\right)".concat(latexOperators.transpose)
  },
  // probability
  combinations: {
    2: "\\binom{${args[0]}}{${args[1]}}"
  },
  combinationsWithRep: {
    2: "\\left(\\!\\!{\\binom{${args[0]}}{${args[1]}}}\\!\\!\\right)"
  },
  factorial: {
    1: "\\left(${args[0]}\\right)".concat(latexOperators.factorial)
  },
  gamma: {
    1: "\\Gamma\\left(${args[0]}\\right)"
  },
  lgamma: {
    1: "\\ln\\Gamma\\left(${args[0]}\\right)"
  },
  // relational
  equal: {
    2: "\\left(${args[0]}".concat(latexOperators.equal, "${args[1]}\\right)")
  },
  larger: {
    2: "\\left(${args[0]}".concat(latexOperators.larger, "${args[1]}\\right)")
  },
  largerEq: {
    2: "\\left(${args[0]}".concat(latexOperators.largerEq, "${args[1]}\\right)")
  },
  smaller: {
    2: "\\left(${args[0]}".concat(latexOperators.smaller, "${args[1]}\\right)")
  },
  smallerEq: {
    2: "\\left(${args[0]}".concat(latexOperators.smallerEq, "${args[1]}\\right)")
  },
  unequal: {
    2: "\\left(${args[0]}".concat(latexOperators.unequal, "${args[1]}\\right)")
  },
  // special
  erf: {
    1: "erf\\left(${args[0]}\\right)"
  },
  // statistics
  max: "\\max\\left(${args}\\right)",
  min: "\\min\\left(${args}\\right)",
  variance: "\\mathrm{Var}\\left(${args}\\right)",
  // trigonometry
  acos: {
    1: "\\cos^{-1}\\left(${args[0]}\\right)"
  },
  acosh: {
    1: "\\cosh^{-1}\\left(${args[0]}\\right)"
  },
  acot: {
    1: "\\cot^{-1}\\left(${args[0]}\\right)"
  },
  acoth: {
    1: "\\coth^{-1}\\left(${args[0]}\\right)"
  },
  acsc: {
    1: "\\csc^{-1}\\left(${args[0]}\\right)"
  },
  acsch: {
    1: "\\mathrm{csch}^{-1}\\left(${args[0]}\\right)"
  },
  asec: {
    1: "\\sec^{-1}\\left(${args[0]}\\right)"
  },
  asech: {
    1: "\\mathrm{sech}^{-1}\\left(${args[0]}\\right)"
  },
  asin: {
    1: "\\sin^{-1}\\left(${args[0]}\\right)"
  },
  asinh: {
    1: "\\sinh^{-1}\\left(${args[0]}\\right)"
  },
  atan: {
    1: "\\tan^{-1}\\left(${args[0]}\\right)"
  },
  atan2: {
    2: "\\mathrm{atan2}\\left(${args}\\right)"
  },
  atanh: {
    1: "\\tanh^{-1}\\left(${args[0]}\\right)"
  },
  cos: {
    1: "\\cos\\left(${args[0]}\\right)"
  },
  cosh: {
    1: "\\cosh\\left(${args[0]}\\right)"
  },
  cot: {
    1: "\\cot\\left(${args[0]}\\right)"
  },
  coth: {
    1: "\\coth\\left(${args[0]}\\right)"
  },
  csc: {
    1: "\\csc\\left(${args[0]}\\right)"
  },
  csch: {
    1: "\\mathrm{csch}\\left(${args[0]}\\right)"
  },
  sec: {
    1: "\\sec\\left(${args[0]}\\right)"
  },
  sech: {
    1: "\\mathrm{sech}\\left(${args[0]}\\right)"
  },
  sin: {
    1: "\\sin\\left(${args[0]}\\right)"
  },
  sinh: {
    1: "\\sinh\\left(${args[0]}\\right)"
  },
  tan: {
    1: "\\tan\\left(${args[0]}\\right)"
  },
  tanh: {
    1: "\\tanh\\left(${args[0]}\\right)"
  },
  // unit
  to: {
    2: "\\left(${args[0]}".concat(latexOperators.to, "${args[1]}\\right)")
  },
  // utils
  numeric: function numeric(node, options2) {
    return node.args[0].toTex();
  },
  // type
  number: {
    0: "0",
    1: "\\left(${args[0]}\\right)",
    2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
  },
  string: {
    0: '\\mathtt{""}',
    1: "\\mathrm{string}\\left(${args[0]}\\right)"
  },
  bignumber: {
    0: "0",
    1: "\\left(${args[0]}\\right)"
  },
  bigint: {
    0: "0",
    1: "\\left(${args[0]}\\right)"
  },
  complex: {
    0: "0",
    1: "\\left(${args[0]}\\right)",
    2: "\\left(\\left(${args[0]}\\right)+".concat(latexSymbols.i, "\\cdot\\left(${args[1]}\\right)\\right)")
  },
  matrix: {
    0: "\\begin{bmatrix}\\end{bmatrix}",
    1: "\\left(${args[0]}\\right)",
    2: "\\left(${args[0]}\\right)"
  },
  sparse: {
    0: "\\begin{bsparse}\\end{bsparse}",
    1: "\\left(${args[0]}\\right)"
  },
  unit: {
    1: "\\left(${args[0]}\\right)",
    2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
  }
};
var defaultTemplate = "\\mathrm{${name}}\\left(${args}\\right)";
var latexUnits = {
  deg: "^\\circ"
};
function escapeLatex(string2) {
  return (0, import_escape_latex.default)(string2, {
    preserveFormatting: true
  });
}
function toSymbol(name314, isUnit2) {
  isUnit2 = typeof isUnit2 === "undefined" ? false : isUnit2;
  if (isUnit2) {
    if (hasOwnProperty(latexUnits, name314)) {
      return latexUnits[name314];
    }
    return "\\mathrm{" + escapeLatex(name314) + "}";
  }
  if (hasOwnProperty(latexSymbols, name314)) {
    return latexSymbols[name314];
  }
  return escapeLatex(name314);
}

// node_modules/mathjs/lib/esm/expression/node/ConstantNode.js
var name212 = "ConstantNode";
var dependencies213 = ["Node"];
var createConstantNode = /* @__PURE__ */ factory(name212, dependencies213, (_ref) => {
  var {
    Node: Node2
  } = _ref;
  class ConstantNode2 extends Node2 {
    /**
     * A ConstantNode holds a constant value like a number or string.
     *
     * Usage:
     *
     *     new ConstantNode(2.3)
     *     new ConstantNode('hello')
     *
     * @param {*} value    Value can be any type (number, BigNumber, bigint, string, ...)
     * @constructor ConstantNode
     * @extends {Node}
     */
    constructor(value) {
      super();
      this.value = value;
    }
    get type() {
      return name212;
    }
    get isConstantNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math2, argNames) {
      var value = this.value;
      return function evalConstantNode() {
        return value;
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
    }
    /**
     * Create a new ConstantNode with children produced by the given callback.
     * Trivial because there are no children.
     * @param {function(child: Node, path: string, parent: Node) : Node} callback
     * @returns {ConstantNode} Returns a clone of the node
     */
    map(callback) {
      return this.clone();
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {ConstantNode}
     */
    clone() {
      return new ConstantNode2(this.value);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */
    _toString(options2) {
      return format3(this.value, options2);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(options2) {
      var value = this._toString(options2);
      switch (typeOf(this.value)) {
        case "number":
        case "bigint":
        case "BigNumber":
        case "Fraction":
          return '<span class="math-number">' + value + "</span>";
        case "string":
          return '<span class="math-string">' + value + "</span>";
        case "boolean":
          return '<span class="math-boolean">' + value + "</span>";
        case "null":
          return '<span class="math-null-symbol">' + value + "</span>";
        case "undefined":
          return '<span class="math-undefined">' + value + "</span>";
        default:
          return '<span class="math-symbol">' + value + "</span>";
      }
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name212,
        value: this.value
      };
    }
    /**
     * Instantiate a ConstantNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "SymbolNode", value: 2.3}`,
     *                       where mathjs is optional
     * @returns {ConstantNode}
     */
    static fromJSON(json) {
      return new ConstantNode2(json.value);
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(options2) {
      var value = this._toString(options2);
      var type = typeOf(this.value);
      switch (type) {
        case "string":
          return "\\mathtt{" + escapeLatex(value) + "}";
        case "number":
        case "BigNumber": {
          var finite = type === "BigNumber" ? this.value.isFinite() : isFinite(this.value);
          if (!finite) {
            return this.value.valueOf() < 0 ? "-\\infty" : "\\infty";
          }
          var index2 = value.toLowerCase().indexOf("e");
          if (index2 !== -1) {
            return value.substring(0, index2) + "\\cdot10^{" + value.substring(index2 + 1) + "}";
          }
          return value;
        }
        case "bigint": {
          return value.toString();
        }
        case "Fraction":
          return this.value.toLatex();
        default:
          return value;
      }
    }
  }
  _defineProperty(ConstantNode2, "name", name212);
  return ConstantNode2;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/expression/node/FunctionAssignmentNode.js
var name213 = "FunctionAssignmentNode";
var dependencies214 = ["typed", "Node"];
var createFunctionAssignmentNode = /* @__PURE__ */ factory(name213, dependencies214, (_ref) => {
  var {
    typed: typed3,
    Node: Node2
  } = _ref;
  function needParenthesis(node, parenthesis, implicit) {
    var precedence = getPrecedence(node, parenthesis, implicit);
    var exprPrecedence = getPrecedence(node.expr, parenthesis, implicit);
    return parenthesis === "all" || exprPrecedence !== null && exprPrecedence <= precedence;
  }
  class FunctionAssignmentNode2 extends Node2 {
    /**
     * @constructor FunctionAssignmentNode
     * @extends {Node}
     * Function assignment
     *
     * @param {string} name           Function name
     * @param {string[] | Array.<{name: string, type: string}>} params
     *                                Array with function parameter names, or an
     *                                array with objects containing the name
     *                                and type of the parameter
     * @param {Node} expr             The function expression
     */
    constructor(name314, params, expr) {
      super();
      if (typeof name314 !== "string") {
        throw new TypeError('String expected for parameter "name"');
      }
      if (!Array.isArray(params)) {
        throw new TypeError('Array containing strings or objects expected for parameter "params"');
      }
      if (!isNode(expr)) {
        throw new TypeError('Node expected for parameter "expr"');
      }
      if (keywords.has(name314)) {
        throw new Error('Illegal function name, "' + name314 + '" is a reserved keyword');
      }
      var paramNames = /* @__PURE__ */ new Set();
      for (var param of params) {
        var _name = typeof param === "string" ? param : param.name;
        if (paramNames.has(_name)) {
          throw new Error('Duplicate parameter name "'.concat(_name, '"'));
        } else {
          paramNames.add(_name);
        }
      }
      this.name = name314;
      this.params = params.map(function(param2) {
        return param2 && param2.name || param2;
      });
      this.types = params.map(function(param2) {
        return param2 && param2.type || "any";
      });
      this.expr = expr;
    }
    get type() {
      return name213;
    }
    get isFunctionAssignmentNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math2, argNames) {
      var childArgNames = Object.create(argNames);
      forEach(this.params, function(param) {
        childArgNames[param] = true;
      });
      var evalExpr = this.expr._compile(math2, childArgNames);
      var name314 = this.name;
      var params = this.params;
      var signature = join(this.types, ",");
      var syntax = name314 + "(" + join(this.params, ", ") + ")";
      return function evalFunctionAssignmentNode(scope, args, context) {
        var signatures = {};
        signatures[signature] = function() {
          var childArgs = Object.create(args);
          for (var i2 = 0; i2 < params.length; i2++) {
            childArgs[params[i2]] = arguments[i2];
          }
          return evalExpr(scope, childArgs, context);
        };
        var fn = typed3(name314, signatures);
        fn.syntax = syntax;
        scope.set(name314, fn);
        return fn;
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      callback(this.expr, "expr", this);
    }
    /**
     * Create a new FunctionAssignmentNode whose children are the results of
     * calling the provided callback function for each child of the original
     * node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {FunctionAssignmentNode} Returns a transformed copy of the node
     */
    map(callback) {
      var expr = this._ifNode(callback(this.expr, "expr", this));
      return new FunctionAssignmentNode2(this.name, this.params.slice(0), expr);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {FunctionAssignmentNode}
     */
    clone() {
      return new FunctionAssignmentNode2(this.name, this.params.slice(0), this.expr);
    }
    /**
     * get string representation
     * @param {Object} options
     * @return {string} str
     */
    _toString(options2) {
      var parenthesis = options2 && options2.parenthesis ? options2.parenthesis : "keep";
      var expr = this.expr.toString(options2);
      if (needParenthesis(this, parenthesis, options2 && options2.implicit)) {
        expr = "(" + expr + ")";
      }
      return this.name + "(" + this.params.join(", ") + ") = " + expr;
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      var types = this.types;
      return {
        mathjs: name213,
        name: this.name,
        params: this.params.map(function(param, index2) {
          return {
            name: param,
            type: types[index2]
          };
        }),
        expr: this.expr
      };
    }
    /**
     * Instantiate an FunctionAssignmentNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     ```
     *     {"mathjs": "FunctionAssignmentNode",
     *      name: ..., params: ..., expr: ...}
     *     ```
     *     where mathjs is optional
     * @returns {FunctionAssignmentNode}
     */
    static fromJSON(json) {
      return new FunctionAssignmentNode2(json.name, json.params, json.expr);
    }
    /**
     * get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(options2) {
      var parenthesis = options2 && options2.parenthesis ? options2.parenthesis : "keep";
      var params = [];
      for (var i2 = 0; i2 < this.params.length; i2++) {
        params.push('<span class="math-symbol math-parameter">' + escape(this.params[i2]) + "</span>");
      }
      var expr = this.expr.toHTML(options2);
      if (needParenthesis(this, parenthesis, options2 && options2.implicit)) {
        expr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + expr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      return '<span class="math-function">' + escape(this.name) + '</span><span class="math-parenthesis math-round-parenthesis">(</span>' + params.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-round-parenthesis">)</span><span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' + expr;
    }
    /**
     * get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(options2) {
      var parenthesis = options2 && options2.parenthesis ? options2.parenthesis : "keep";
      var expr = this.expr.toTex(options2);
      if (needParenthesis(this, parenthesis, options2 && options2.implicit)) {
        expr = "\\left(".concat(expr, "\\right)");
      }
      return "\\mathrm{" + this.name + "}\\left(" + this.params.map(toSymbol).join(",") + "\\right)=" + expr;
    }
  }
  _defineProperty(FunctionAssignmentNode2, "name", name213);
  return FunctionAssignmentNode2;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/expression/node/IndexNode.js
var name214 = "IndexNode";
var dependencies215 = ["Node", "size"];
var createIndexNode = /* @__PURE__ */ factory(name214, dependencies215, (_ref) => {
  var {
    Node: Node2,
    size: size2
  } = _ref;
  class IndexNode2 extends Node2 {
    /**
     * @constructor IndexNode
     * @extends Node
     *
     * Describes a subset of a matrix or an object property.
     * Cannot be used on its own, needs to be used within an AccessorNode or
     * AssignmentNode.
     *
     * @param {Node[]} dimensions
     * @param {boolean} [dotNotation=false]
     *     Optional property describing whether this index was written using dot
     *     notation like `a.b`, or using bracket notation like `a["b"]`
     *     (which is the default). This property is used for string conversion.
     */
    constructor(dimensions, dotNotation) {
      super();
      this.dimensions = dimensions;
      this.dotNotation = dotNotation || false;
      if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {
        throw new TypeError('Array containing Nodes expected for parameter "dimensions"');
      }
      if (this.dotNotation && !this.isObjectProperty()) {
        throw new Error("dotNotation only applicable for object properties");
      }
    }
    get type() {
      return name214;
    }
    get isIndexNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math2, argNames) {
      var evalDimensions = map(this.dimensions, function(dimension, i2) {
        var needsEnd = dimension.filter((node) => node.isSymbolNode && node.name === "end").length > 0;
        if (needsEnd) {
          var childArgNames = Object.create(argNames);
          childArgNames.end = true;
          var _evalDimension = dimension._compile(math2, childArgNames);
          return function evalDimension(scope, args, context) {
            if (!isMatrix(context) && !isArray(context) && !isString(context)) {
              throw new TypeError('Cannot resolve "end": context must be a Matrix, Array, or string but is ' + typeOf(context));
            }
            var s = size2(context).valueOf();
            var childArgs = Object.create(args);
            childArgs.end = s[i2];
            return _evalDimension(scope, childArgs, context);
          };
        } else {
          return dimension._compile(math2, argNames);
        }
      });
      var index2 = getSafeProperty(math2, "index");
      return function evalIndexNode(scope, args, context) {
        var dimensions = map(evalDimensions, function(evalDimension) {
          return evalDimension(scope, args, context);
        });
        return index2(...dimensions);
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      for (var i2 = 0; i2 < this.dimensions.length; i2++) {
        callback(this.dimensions[i2], "dimensions[" + i2 + "]", this);
      }
    }
    /**
     * Create a new IndexNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {IndexNode} Returns a transformed copy of the node
     */
    map(callback) {
      var dimensions = [];
      for (var i2 = 0; i2 < this.dimensions.length; i2++) {
        dimensions[i2] = this._ifNode(callback(this.dimensions[i2], "dimensions[" + i2 + "]", this));
      }
      return new IndexNode2(dimensions, this.dotNotation);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {IndexNode}
     */
    clone() {
      return new IndexNode2(this.dimensions.slice(0), this.dotNotation);
    }
    /**
     * Test whether this IndexNode contains a single property name
     * @return {boolean}
     */
    isObjectProperty() {
      return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === "string";
    }
    /**
     * Returns the property name if IndexNode contains a property.
     * If not, returns null.
     * @return {string | null}
     */
    getObjectProperty() {
      return this.isObjectProperty() ? this.dimensions[0].value : null;
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */
    _toString(options2) {
      return this.dotNotation ? "." + this.getObjectProperty() : "[" + this.dimensions.join(", ") + "]";
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name214,
        dimensions: this.dimensions,
        dotNotation: this.dotNotation
      };
    }
    /**
     * Instantiate an IndexNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "IndexNode", dimensions: [...], dotNotation: false}`,
     *     where mathjs is optional
     * @returns {IndexNode}
     */
    static fromJSON(json) {
      return new IndexNode2(json.dimensions, json.dotNotation);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(options2) {
      var dimensions = [];
      for (var i2 = 0; i2 < this.dimensions.length; i2++) {
        dimensions[i2] = this.dimensions[i2].toHTML();
      }
      if (this.dotNotation) {
        return '<span class="math-operator math-accessor-operator">.</span><span class="math-symbol math-property">' + escape(this.getObjectProperty()) + "</span>";
      } else {
        return '<span class="math-parenthesis math-square-parenthesis">[</span>' + dimensions.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
      }
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(options2) {
      var dimensions = this.dimensions.map(function(range2) {
        return range2.toTex(options2);
      });
      return this.dotNotation ? "." + this.getObjectProperty() : "_{" + dimensions.join(",") + "}";
    }
  }
  _defineProperty(IndexNode2, "name", name214);
  return IndexNode2;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/expression/node/ObjectNode.js
var name215 = "ObjectNode";
var dependencies216 = ["Node"];
var createObjectNode = /* @__PURE__ */ factory(name215, dependencies216, (_ref) => {
  var {
    Node: Node2
  } = _ref;
  class ObjectNode2 extends Node2 {
    /**
     * @constructor ObjectNode
     * @extends {Node}
     * Holds an object with keys/values
     * @param {Object.<string, Node>} [properties]   object with key/value pairs
     */
    constructor(properties2) {
      super();
      this.properties = properties2 || {};
      if (properties2) {
        if (!(typeof properties2 === "object") || !Object.keys(properties2).every(function(key) {
          return isNode(properties2[key]);
        })) {
          throw new TypeError("Object containing Nodes expected");
        }
      }
    }
    get type() {
      return name215;
    }
    get isObjectNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math2, argNames) {
      var evalEntries = {};
      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          var stringifiedKey = stringify(key);
          var parsedKey = JSON.parse(stringifiedKey);
          var prop = getSafeProperty(this.properties, key);
          evalEntries[parsedKey] = prop._compile(math2, argNames);
        }
      }
      return function evalObjectNode(scope, args, context) {
        var obj = {};
        for (var _key in evalEntries) {
          if (hasOwnProperty(evalEntries, _key)) {
            obj[_key] = evalEntries[_key](scope, args, context);
          }
        }
        return obj;
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          callback(this.properties[key], "properties[" + stringify(key) + "]", this);
        }
      }
    }
    /**
     * Create a new ObjectNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {ObjectNode} Returns a transformed copy of the node
     */
    map(callback) {
      var properties2 = {};
      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          properties2[key] = this._ifNode(callback(this.properties[key], "properties[" + stringify(key) + "]", this));
        }
      }
      return new ObjectNode2(properties2);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {ObjectNode}
     */
    clone() {
      var properties2 = {};
      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          properties2[key] = this.properties[key];
        }
      }
      return new ObjectNode2(properties2);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toString(options2) {
      var entries = [];
      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          entries.push(stringify(key) + ": " + this.properties[key].toString(options2));
        }
      }
      return "{" + entries.join(", ") + "}";
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name215,
        properties: this.properties
      };
    }
    /**
     * Instantiate an OperatorNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "ObjectNode", "properties": {...}}`,
     *                       where mathjs is optional
     * @returns {ObjectNode}
     */
    static fromJSON(json) {
      return new ObjectNode2(json.properties);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toHTML(options2) {
      var entries = [];
      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          entries.push('<span class="math-symbol math-property">' + escape(key) + '</span><span class="math-operator math-assignment-operator math-property-assignment-operator math-binary-operator">:</span>' + this.properties[key].toHTML(options2));
        }
      }
      return '<span class="math-parenthesis math-curly-parenthesis">{</span>' + entries.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-curly-parenthesis">}</span>';
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(options2) {
      var entries = [];
      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          entries.push("\\mathbf{" + key + ":} & " + this.properties[key].toTex(options2) + "\\\\");
        }
      }
      var tex = "\\left\\{\\begin{array}{ll}" + entries.join("\n") + "\\end{array}\\right\\}";
      return tex;
    }
  }
  _defineProperty(ObjectNode2, "name", name215);
  return ObjectNode2;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/utils/scope.js
function createSubScope(parentScope, args) {
  return new PartitionedMap(parentScope, new ObjectWrappingMap(args), new Set(Object.keys(args)));
}

// node_modules/mathjs/lib/esm/expression/node/OperatorNode.js
var name216 = "OperatorNode";
var dependencies217 = ["Node"];
var createOperatorNode = /* @__PURE__ */ factory(name216, dependencies217, (_ref) => {
  var {
    Node: Node2
  } = _ref;
  function startsWithConstant(expr, parenthesis) {
    var curNode = expr;
    if (parenthesis === "auto") {
      while (isParenthesisNode(curNode))
        curNode = curNode.content;
    }
    if (isConstantNode(curNode))
      return true;
    if (isOperatorNode(curNode)) {
      return startsWithConstant(curNode.args[0], parenthesis);
    }
    return false;
  }
  function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {
    var precedence = getPrecedence(root, parenthesis, implicit);
    var associativity = getAssociativity(root, parenthesis);
    if (parenthesis === "all" || args.length > 2 && root.getIdentifier() !== "OperatorNode:add" && root.getIdentifier() !== "OperatorNode:multiply") {
      return args.map(function(arg2) {
        switch (arg2.getContent().type) {
          case "ArrayNode":
          case "ConstantNode":
          case "SymbolNode":
          case "ParenthesisNode":
            return false;
          default:
            return true;
        }
      });
    }
    var result;
    switch (args.length) {
      case 0:
        result = [];
        break;
      case 1:
        {
          var operandPrecedence = getPrecedence(args[0], parenthesis, implicit, root);
          if (latex && operandPrecedence !== null) {
            var operandIdentifier;
            var rootIdentifier;
            if (parenthesis === "keep") {
              operandIdentifier = args[0].getIdentifier();
              rootIdentifier = root.getIdentifier();
            } else {
              operandIdentifier = args[0].getContent().getIdentifier();
              rootIdentifier = root.getContent().getIdentifier();
            }
            if (properties[precedence][rootIdentifier].latexLeftParens === false) {
              result = [false];
              break;
            }
            if (properties[operandPrecedence][operandIdentifier].latexParens === false) {
              result = [false];
              break;
            }
          }
          if (operandPrecedence === null) {
            result = [false];
            break;
          }
          if (operandPrecedence <= precedence) {
            result = [true];
            break;
          }
          result = [false];
        }
        break;
      case 2:
        {
          var lhsParens;
          var lhsPrecedence = getPrecedence(args[0], parenthesis, implicit, root);
          var assocWithLhs = isAssociativeWith(root, args[0], parenthesis);
          if (lhsPrecedence === null) {
            lhsParens = false;
          } else if (lhsPrecedence === precedence && associativity === "right" && !assocWithLhs) {
            lhsParens = true;
          } else if (lhsPrecedence < precedence) {
            lhsParens = true;
          } else {
            lhsParens = false;
          }
          var rhsParens;
          var rhsPrecedence = getPrecedence(args[1], parenthesis, implicit, root);
          var assocWithRhs = isAssociativeWith(root, args[1], parenthesis);
          if (rhsPrecedence === null) {
            rhsParens = false;
          } else if (rhsPrecedence === precedence && associativity === "left" && !assocWithRhs) {
            rhsParens = true;
          } else if (rhsPrecedence < precedence) {
            rhsParens = true;
          } else {
            rhsParens = false;
          }
          if (latex) {
            var _rootIdentifier;
            var lhsIdentifier;
            var rhsIdentifier;
            if (parenthesis === "keep") {
              _rootIdentifier = root.getIdentifier();
              lhsIdentifier = root.args[0].getIdentifier();
              rhsIdentifier = root.args[1].getIdentifier();
            } else {
              _rootIdentifier = root.getContent().getIdentifier();
              lhsIdentifier = root.args[0].getContent().getIdentifier();
              rhsIdentifier = root.args[1].getContent().getIdentifier();
            }
            if (lhsPrecedence !== null) {
              if (properties[precedence][_rootIdentifier].latexLeftParens === false) {
                lhsParens = false;
              }
              if (properties[lhsPrecedence][lhsIdentifier].latexParens === false) {
                lhsParens = false;
              }
            }
            if (rhsPrecedence !== null) {
              if (properties[precedence][_rootIdentifier].latexRightParens === false) {
                rhsParens = false;
              }
              if (properties[rhsPrecedence][rhsIdentifier].latexParens === false) {
                rhsParens = false;
              }
            }
          }
          result = [lhsParens, rhsParens];
        }
        break;
      default:
        if (root.getIdentifier() === "OperatorNode:add" || root.getIdentifier() === "OperatorNode:multiply") {
          result = args.map(function(arg2) {
            var argPrecedence = getPrecedence(arg2, parenthesis, implicit, root);
            var assocWithArg = isAssociativeWith(root, arg2, parenthesis);
            var argAssociativity = getAssociativity(arg2, parenthesis);
            if (argPrecedence === null) {
              return false;
            } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {
              return true;
            } else if (argPrecedence < precedence) {
              return true;
            }
            return false;
          });
        }
        break;
    }
    if (args.length >= 2 && root.getIdentifier() === "OperatorNode:multiply" && root.implicit && parenthesis !== "all" && implicit === "hide") {
      for (var i2 = 1; i2 < result.length; ++i2) {
        if (startsWithConstant(args[i2], parenthesis) && !result[i2 - 1] && (parenthesis !== "keep" || !isParenthesisNode(args[i2 - 1]))) {
          result[i2] = true;
        }
      }
    }
    return result;
  }
  class OperatorNode2 extends Node2 {
    /**
     * @constructor OperatorNode
     * @extends {Node}
     * An operator with two arguments, like 2+3
     *
     * @param {string} op           Operator name, for example '+'
     * @param {string} fn           Function name, for example 'add'
     * @param {Node[]} args         Operator arguments
     * @param {boolean} [implicit]  Is this an implicit multiplication?
     * @param {boolean} [isPercentage] Is this an percentage Operation?
     */
    constructor(op, fn, args, implicit, isPercentage) {
      super();
      if (typeof op !== "string") {
        throw new TypeError('string expected for parameter "op"');
      }
      if (typeof fn !== "string") {
        throw new TypeError('string expected for parameter "fn"');
      }
      if (!Array.isArray(args) || !args.every(isNode)) {
        throw new TypeError('Array containing Nodes expected for parameter "args"');
      }
      this.implicit = implicit === true;
      this.isPercentage = isPercentage === true;
      this.op = op;
      this.fn = fn;
      this.args = args || [];
    }
    get type() {
      return name216;
    }
    get isOperatorNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math2, argNames) {
      if (typeof this.fn !== "string" || !isSafeMethod(math2, this.fn)) {
        if (!math2[this.fn]) {
          throw new Error("Function " + this.fn + ' missing in provided namespace "math"');
        } else {
          throw new Error('No access to function "' + this.fn + '"');
        }
      }
      var fn = getSafeProperty(math2, this.fn);
      var evalArgs = map(this.args, function(arg2) {
        return arg2._compile(math2, argNames);
      });
      if (typeof fn === "function" && fn.rawArgs === true) {
        var rawArgs = this.args;
        return function evalOperatorNode(scope, args, context) {
          return fn(rawArgs, math2, createSubScope(scope, args));
        };
      } else if (evalArgs.length === 1) {
        var evalArg0 = evalArgs[0];
        return function evalOperatorNode(scope, args, context) {
          return fn(evalArg0(scope, args, context));
        };
      } else if (evalArgs.length === 2) {
        var _evalArg = evalArgs[0];
        var evalArg1 = evalArgs[1];
        return function evalOperatorNode(scope, args, context) {
          return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));
        };
      } else {
        return function evalOperatorNode(scope, args, context) {
          return fn.apply(null, map(evalArgs, function(evalArg) {
            return evalArg(scope, args, context);
          }));
        };
      }
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      for (var i2 = 0; i2 < this.args.length; i2++) {
        callback(this.args[i2], "args[" + i2 + "]", this);
      }
    }
    /**
     * Create a new OperatorNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {OperatorNode} Returns a transformed copy of the node
     */
    map(callback) {
      var args = [];
      for (var i2 = 0; i2 < this.args.length; i2++) {
        args[i2] = this._ifNode(callback(this.args[i2], "args[" + i2 + "]", this));
      }
      return new OperatorNode2(this.op, this.fn, args, this.implicit, this.isPercentage);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {OperatorNode}
     */
    clone() {
      return new OperatorNode2(this.op, this.fn, this.args.slice(0), this.implicit, this.isPercentage);
    }
    /**
     * Check whether this is an unary OperatorNode:
     * has exactly one argument, like `-a`.
     * @return {boolean}
     *     Returns true when an unary operator node, false otherwise.
     */
    isUnary() {
      return this.args.length === 1;
    }
    /**
     * Check whether this is a binary OperatorNode:
     * has exactly two arguments, like `a + b`.
     * @return {boolean}
     *     Returns true when a binary operator node, false otherwise.
     */
    isBinary() {
      return this.args.length === 2;
    }
    /**
     * Get string representation.
     * @param {Object} options
     * @return {string} str
     */
    _toString(options2) {
      var parenthesis = options2 && options2.parenthesis ? options2.parenthesis : "keep";
      var implicit = options2 && options2.implicit ? options2.implicit : "hide";
      var args = this.args;
      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);
      if (args.length === 1) {
        var assoc = getAssociativity(this, parenthesis);
        var operand = args[0].toString(options2);
        if (parens[0]) {
          operand = "(" + operand + ")";
        }
        var opIsNamed = /[a-zA-Z]+/.test(this.op);
        if (assoc === "right") {
          return this.op + (opIsNamed ? " " : "") + operand;
        } else if (assoc === "left") {
          return operand + (opIsNamed ? " " : "") + this.op;
        }
        return operand + this.op;
      } else if (args.length === 2) {
        var lhs = args[0].toString(options2);
        var rhs = args[1].toString(options2);
        if (parens[0]) {
          lhs = "(" + lhs + ")";
        }
        if (parens[1]) {
          rhs = "(" + rhs + ")";
        }
        if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
          return lhs + " " + rhs;
        }
        return lhs + " " + this.op + " " + rhs;
      } else if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
        var stringifiedArgs = args.map(function(arg2, index2) {
          arg2 = arg2.toString(options2);
          if (parens[index2]) {
            arg2 = "(" + arg2 + ")";
          }
          return arg2;
        });
        if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
          return stringifiedArgs.join(" ");
        }
        return stringifiedArgs.join(" " + this.op + " ");
      } else {
        return this.fn + "(" + this.args.join(", ") + ")";
      }
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name216,
        op: this.op,
        fn: this.fn,
        args: this.args,
        implicit: this.implicit,
        isPercentage: this.isPercentage
      };
    }
    /**
     * Instantiate an OperatorNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     ```
     *     {"mathjs": "OperatorNode",
     *      "op": "+", "fn": "add", "args": [...],
     *      "implicit": false,
     *      "isPercentage":false}
     *     ```
     *     where mathjs is optional
     * @returns {OperatorNode}
     */
    static fromJSON(json) {
      return new OperatorNode2(json.op, json.fn, json.args, json.implicit, json.isPercentage);
    }
    /**
     * Get HTML representation.
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(options2) {
      var parenthesis = options2 && options2.parenthesis ? options2.parenthesis : "keep";
      var implicit = options2 && options2.implicit ? options2.implicit : "hide";
      var args = this.args;
      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);
      if (args.length === 1) {
        var assoc = getAssociativity(this, parenthesis);
        var operand = args[0].toHTML(options2);
        if (parens[0]) {
          operand = '<span class="math-parenthesis math-round-parenthesis">(</span>' + operand + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        if (assoc === "right") {
          return '<span class="math-operator math-unary-operator math-lefthand-unary-operator">' + escape(this.op) + "</span>" + operand;
        } else {
          return operand + '<span class="math-operator math-unary-operator math-righthand-unary-operator">' + escape(this.op) + "</span>";
        }
      } else if (args.length === 2) {
        var lhs = args[0].toHTML(options2);
        var rhs = args[1].toHTML(options2);
        if (parens[0]) {
          lhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + lhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        if (parens[1]) {
          rhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + rhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
          return lhs + '<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>' + rhs;
        }
        return lhs + '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(this.op) + "</span>" + rhs;
      } else {
        var stringifiedArgs = args.map(function(arg2, index2) {
          arg2 = arg2.toHTML(options2);
          if (parens[index2]) {
            arg2 = '<span class="math-parenthesis math-round-parenthesis">(</span>' + arg2 + '<span class="math-parenthesis math-round-parenthesis">)</span>';
          }
          return arg2;
        });
        if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
          if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
            return stringifiedArgs.join('<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>');
          }
          return stringifiedArgs.join('<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(this.op) + "</span>");
        } else {
          return '<span class="math-function">' + escape(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + stringifiedArgs.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
        }
      }
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(options2) {
      var parenthesis = options2 && options2.parenthesis ? options2.parenthesis : "keep";
      var implicit = options2 && options2.implicit ? options2.implicit : "hide";
      var args = this.args;
      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);
      var op = latexOperators[this.fn];
      op = typeof op === "undefined" ? this.op : op;
      if (args.length === 1) {
        var assoc = getAssociativity(this, parenthesis);
        var operand = args[0].toTex(options2);
        if (parens[0]) {
          operand = "\\left(".concat(operand, "\\right)");
        }
        if (assoc === "right") {
          return op + operand;
        } else if (assoc === "left") {
          return operand + op;
        }
        return operand + op;
      } else if (args.length === 2) {
        var lhs = args[0];
        var lhsTex = lhs.toTex(options2);
        if (parens[0]) {
          lhsTex = "\\left(".concat(lhsTex, "\\right)");
        }
        var rhs = args[1];
        var rhsTex = rhs.toTex(options2);
        if (parens[1]) {
          rhsTex = "\\left(".concat(rhsTex, "\\right)");
        }
        var lhsIdentifier;
        if (parenthesis === "keep") {
          lhsIdentifier = lhs.getIdentifier();
        } else {
          lhsIdentifier = lhs.getContent().getIdentifier();
        }
        switch (this.getIdentifier()) {
          case "OperatorNode:divide":
            return op + "{" + lhsTex + "}{" + rhsTex + "}";
          case "OperatorNode:pow":
            lhsTex = "{" + lhsTex + "}";
            rhsTex = "{" + rhsTex + "}";
            switch (lhsIdentifier) {
              case "ConditionalNode":
              case "OperatorNode:divide":
                lhsTex = "\\left(".concat(lhsTex, "\\right)");
            }
            break;
          case "OperatorNode:multiply":
            if (this.implicit && implicit === "hide") {
              return lhsTex + "~" + rhsTex;
            }
        }
        return lhsTex + op + rhsTex;
      } else if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
        var texifiedArgs = args.map(function(arg2, index2) {
          arg2 = arg2.toTex(options2);
          if (parens[index2]) {
            arg2 = "\\left(".concat(arg2, "\\right)");
          }
          return arg2;
        });
        if (this.getIdentifier() === "OperatorNode:multiply" && this.implicit && implicit === "hide") {
          return texifiedArgs.join("~");
        }
        return texifiedArgs.join(op);
      } else {
        return "\\mathrm{" + this.fn + "}\\left(" + args.map(function(arg2) {
          return arg2.toTex(options2);
        }).join(",") + "\\right)";
      }
    }
    /**
     * Get identifier.
     * @return {string}
     */
    getIdentifier() {
      return this.type + ":" + this.fn;
    }
  }
  _defineProperty(OperatorNode2, "name", name216);
  return OperatorNode2;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/expression/node/ParenthesisNode.js
var name217 = "ParenthesisNode";
var dependencies218 = ["Node"];
var createParenthesisNode = /* @__PURE__ */ factory(name217, dependencies218, (_ref) => {
  var {
    Node: Node2
  } = _ref;
  class ParenthesisNode2 extends Node2 {
    /**
     * @constructor ParenthesisNode
     * @extends {Node}
     * A parenthesis node describes manual parenthesis from the user input
     * @param {Node} content
     * @extends {Node}
     */
    constructor(content) {
      super();
      if (!isNode(content)) {
        throw new TypeError('Node expected for parameter "content"');
      }
      this.content = content;
    }
    get type() {
      return name217;
    }
    get isParenthesisNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math2, argNames) {
      return this.content._compile(math2, argNames);
    }
    /**
     * Get the content of the current Node.
     * @return {Node} content
     * @override
     **/
    getContent() {
      return this.content.getContent();
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      callback(this.content, "content", this);
    }
    /**
     * Create a new ParenthesisNode whose child is the result of calling
     * the provided callback function on the child of this node.
     * @param {function(child: Node, path: string, parent: Node) : Node} callback
     * @returns {ParenthesisNode} Returns a clone of the node
     */
    map(callback) {
      var content = callback(this.content, "content", this);
      return new ParenthesisNode2(content);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {ParenthesisNode}
     */
    clone() {
      return new ParenthesisNode2(this.content);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toString(options2) {
      if (!options2 || options2 && !options2.parenthesis || options2 && options2.parenthesis === "keep") {
        return "(" + this.content.toString(options2) + ")";
      }
      return this.content.toString(options2);
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name217,
        content: this.content
      };
    }
    /**
     * Instantiate an ParenthesisNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "ParenthesisNode", "content": ...}`,
     *                       where mathjs is optional
     * @returns {ParenthesisNode}
     */
    static fromJSON(json) {
      return new ParenthesisNode2(json.content);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toHTML(options2) {
      if (!options2 || options2 && !options2.parenthesis || options2 && options2.parenthesis === "keep") {
        return '<span class="math-parenthesis math-round-parenthesis">(</span>' + this.content.toHTML(options2) + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      return this.content.toHTML(options2);
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toTex(options2) {
      if (!options2 || options2 && !options2.parenthesis || options2 && options2.parenthesis === "keep") {
        return "\\left(".concat(this.content.toTex(options2), "\\right)");
      }
      return this.content.toTex(options2);
    }
  }
  _defineProperty(ParenthesisNode2, "name", name217);
  return ParenthesisNode2;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/expression/node/RangeNode.js
var name218 = "RangeNode";
var dependencies219 = ["Node"];
var createRangeNode = /* @__PURE__ */ factory(name218, dependencies219, (_ref) => {
  var {
    Node: Node2
  } = _ref;
  function calculateNecessaryParentheses(node, parenthesis, implicit) {
    var precedence = getPrecedence(node, parenthesis, implicit);
    var parens = {};
    var startPrecedence = getPrecedence(node.start, parenthesis, implicit);
    parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === "all";
    if (node.step) {
      var stepPrecedence = getPrecedence(node.step, parenthesis, implicit);
      parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === "all";
    }
    var endPrecedence = getPrecedence(node.end, parenthesis, implicit);
    parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === "all";
    return parens;
  }
  class RangeNode2 extends Node2 {
    /**
     * @constructor RangeNode
     * @extends {Node}
     * create a range
     * @param {Node} start  included lower-bound
     * @param {Node} end    included upper-bound
     * @param {Node} [step] optional step
     */
    constructor(start, end, step) {
      super();
      if (!isNode(start))
        throw new TypeError("Node expected");
      if (!isNode(end))
        throw new TypeError("Node expected");
      if (step && !isNode(step))
        throw new TypeError("Node expected");
      if (arguments.length > 3)
        throw new Error("Too many arguments");
      this.start = start;
      this.end = end;
      this.step = step || null;
    }
    get type() {
      return name218;
    }
    get isRangeNode() {
      return true;
    }
    /**
     * Check whether the RangeNode needs the `end` symbol to be defined.
     * This end is the size of the Matrix in current dimension.
     * @return {boolean}
     */
    needsEnd() {
      var endSymbols = this.filter(function(node) {
        return isSymbolNode(node) && node.name === "end";
      });
      return endSymbols.length > 0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math2, argNames) {
      var range2 = math2.range;
      var evalStart = this.start._compile(math2, argNames);
      var evalEnd = this.end._compile(math2, argNames);
      if (this.step) {
        var evalStep = this.step._compile(math2, argNames);
        return function evalRangeNode(scope, args, context) {
          return range2(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));
        };
      } else {
        return function evalRangeNode(scope, args, context) {
          return range2(evalStart(scope, args, context), evalEnd(scope, args, context));
        };
      }
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      callback(this.start, "start", this);
      callback(this.end, "end", this);
      if (this.step) {
        callback(this.step, "step", this);
      }
    }
    /**
     * Create a new RangeNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {RangeNode} Returns a transformed copy of the node
     */
    map(callback) {
      return new RangeNode2(this._ifNode(callback(this.start, "start", this)), this._ifNode(callback(this.end, "end", this)), this.step && this._ifNode(callback(this.step, "step", this)));
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {RangeNode}
     */
    clone() {
      return new RangeNode2(this.start, this.end, this.step && this.step);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */
    _toString(options2) {
      var parenthesis = options2 && options2.parenthesis ? options2.parenthesis : "keep";
      var parens = calculateNecessaryParentheses(this, parenthesis, options2 && options2.implicit);
      var str;
      var start = this.start.toString(options2);
      if (parens.start) {
        start = "(" + start + ")";
      }
      str = start;
      if (this.step) {
        var step = this.step.toString(options2);
        if (parens.step) {
          step = "(" + step + ")";
        }
        str += ":" + step;
      }
      var end = this.end.toString(options2);
      if (parens.end) {
        end = "(" + end + ")";
      }
      str += ":" + end;
      return str;
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name218,
        start: this.start,
        end: this.end,
        step: this.step
      };
    }
    /**
     * Instantiate an RangeNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "RangeNode", "start": ..., "end": ..., "step": ...}`,
     *     where mathjs is optional
     * @returns {RangeNode}
     */
    static fromJSON(json) {
      return new RangeNode2(json.start, json.end, json.step);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(options2) {
      var parenthesis = options2 && options2.parenthesis ? options2.parenthesis : "keep";
      var parens = calculateNecessaryParentheses(this, parenthesis, options2 && options2.implicit);
      var str;
      var start = this.start.toHTML(options2);
      if (parens.start) {
        start = '<span class="math-parenthesis math-round-parenthesis">(</span>' + start + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      str = start;
      if (this.step) {
        var step = this.step.toHTML(options2);
        if (parens.step) {
          step = '<span class="math-parenthesis math-round-parenthesis">(</span>' + step + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        str += '<span class="math-operator math-range-operator">:</span>' + step;
      }
      var end = this.end.toHTML(options2);
      if (parens.end) {
        end = '<span class="math-parenthesis math-round-parenthesis">(</span>' + end + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      str += '<span class="math-operator math-range-operator">:</span>' + end;
      return str;
    }
    /**
     * Get LaTeX representation
     * @params {Object} options
     * @return {string} str
     */
    _toTex(options2) {
      var parenthesis = options2 && options2.parenthesis ? options2.parenthesis : "keep";
      var parens = calculateNecessaryParentheses(this, parenthesis, options2 && options2.implicit);
      var str = this.start.toTex(options2);
      if (parens.start) {
        str = "\\left(".concat(str, "\\right)");
      }
      if (this.step) {
        var step = this.step.toTex(options2);
        if (parens.step) {
          step = "\\left(".concat(step, "\\right)");
        }
        str += ":" + step;
      }
      var end = this.end.toTex(options2);
      if (parens.end) {
        end = "\\left(".concat(end, "\\right)");
      }
      str += ":" + end;
      return str;
    }
  }
  _defineProperty(RangeNode2, "name", name218);
  return RangeNode2;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/expression/node/RelationalNode.js
var name219 = "RelationalNode";
var dependencies220 = ["Node"];
var createRelationalNode = /* @__PURE__ */ factory(name219, dependencies220, (_ref) => {
  var {
    Node: Node2
  } = _ref;
  var operatorMap = {
    equal: "==",
    unequal: "!=",
    smaller: "<",
    larger: ">",
    smallerEq: "<=",
    largerEq: ">="
  };
  class RelationalNode2 extends Node2 {
    /**
     * A node representing a chained conditional expression, such as 'x > y > z'
     *
     * @param {String[]} conditionals
     *     An array of conditional operators used to compare the parameters
     * @param {Node[]} params
     *     The parameters that will be compared
     *
     * @constructor RelationalNode
     * @extends {Node}
     */
    constructor(conditionals, params) {
      super();
      if (!Array.isArray(conditionals)) {
        throw new TypeError("Parameter conditionals must be an array");
      }
      if (!Array.isArray(params)) {
        throw new TypeError("Parameter params must be an array");
      }
      if (conditionals.length !== params.length - 1) {
        throw new TypeError("Parameter params must contain exactly one more element than parameter conditionals");
      }
      this.conditionals = conditionals;
      this.params = params;
    }
    get type() {
      return name219;
    }
    get isRelationalNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math2, argNames) {
      var self2 = this;
      var compiled = this.params.map((p) => p._compile(math2, argNames));
      return function evalRelationalNode(scope, args, context) {
        var evalLhs;
        var evalRhs = compiled[0](scope, args, context);
        for (var i2 = 0; i2 < self2.conditionals.length; i2++) {
          evalLhs = evalRhs;
          evalRhs = compiled[i2 + 1](scope, args, context);
          var condFn = getSafeProperty(math2, self2.conditionals[i2]);
          if (!condFn(evalLhs, evalRhs)) {
            return false;
          }
        }
        return true;
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      this.params.forEach((n, i2) => callback(n, "params[" + i2 + "]", this), this);
    }
    /**
     * Create a new RelationalNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {RelationalNode} Returns a transformed copy of the node
     */
    map(callback) {
      return new RelationalNode2(this.conditionals.slice(), this.params.map((n, i2) => this._ifNode(callback(n, "params[" + i2 + "]", this)), this));
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {RelationalNode}
     */
    clone() {
      return new RelationalNode2(this.conditionals, this.params);
    }
    /**
     * Get string representation.
     * @param {Object} options
     * @return {string} str
     */
    _toString(options2) {
      var parenthesis = options2 && options2.parenthesis ? options2.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis, options2 && options2.implicit);
      var paramStrings = this.params.map(function(p, index2) {
        var paramPrecedence = getPrecedence(p, parenthesis, options2 && options2.implicit);
        return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? "(" + p.toString(options2) + ")" : p.toString(options2);
      });
      var ret = paramStrings[0];
      for (var i2 = 0; i2 < this.conditionals.length; i2++) {
        ret += " " + operatorMap[this.conditionals[i2]];
        ret += " " + paramStrings[i2 + 1];
      }
      return ret;
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name219,
        conditionals: this.conditionals,
        params: this.params
      };
    }
    /**
     * Instantiate a RelationalNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "RelationalNode", "conditionals": ..., "params": ...}`,
     *     where mathjs is optional
     * @returns {RelationalNode}
     */
    static fromJSON(json) {
      return new RelationalNode2(json.conditionals, json.params);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(options2) {
      var parenthesis = options2 && options2.parenthesis ? options2.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis, options2 && options2.implicit);
      var paramStrings = this.params.map(function(p, index2) {
        var paramPrecedence = getPrecedence(p, parenthesis, options2 && options2.implicit);
        return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? '<span class="math-parenthesis math-round-parenthesis">(</span>' + p.toHTML(options2) + '<span class="math-parenthesis math-round-parenthesis">)</span>' : p.toHTML(options2);
      });
      var ret = paramStrings[0];
      for (var i2 = 0; i2 < this.conditionals.length; i2++) {
        ret += '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(operatorMap[this.conditionals[i2]]) + "</span>" + paramStrings[i2 + 1];
      }
      return ret;
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(options2) {
      var parenthesis = options2 && options2.parenthesis ? options2.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis, options2 && options2.implicit);
      var paramStrings = this.params.map(function(p, index2) {
        var paramPrecedence = getPrecedence(p, parenthesis, options2 && options2.implicit);
        return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? "\\left(" + p.toTex(options2) + "\right)" : p.toTex(options2);
      });
      var ret = paramStrings[0];
      for (var i2 = 0; i2 < this.conditionals.length; i2++) {
        ret += latexOperators[this.conditionals[i2]] + paramStrings[i2 + 1];
      }
      return ret;
    }
  }
  _defineProperty(RelationalNode2, "name", name219);
  return RelationalNode2;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/expression/node/SymbolNode.js
var name220 = "SymbolNode";
var dependencies221 = ["math", "?Unit", "Node"];
var createSymbolNode = /* @__PURE__ */ factory(name220, dependencies221, (_ref) => {
  var {
    math: math2,
    Unit: Unit2,
    Node: Node2
  } = _ref;
  function isValuelessUnit(name314) {
    return Unit2 ? Unit2.isValuelessUnit(name314) : false;
  }
  class SymbolNode2 extends Node2 {
    /**
     * @constructor SymbolNode
     * @extends {Node}
     * A symbol node can hold and resolve a symbol
     * @param {string} name
     * @extends {Node}
     */
    constructor(name314) {
      super();
      if (typeof name314 !== "string") {
        throw new TypeError('String expected for parameter "name"');
      }
      this.name = name314;
    }
    get type() {
      return "SymbolNode";
    }
    get isSymbolNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math3, argNames) {
      var name314 = this.name;
      if (argNames[name314] === true) {
        return function(scope, args, context) {
          return getSafeProperty(args, name314);
        };
      } else if (name314 in math3) {
        return function(scope, args, context) {
          return scope.has(name314) ? scope.get(name314) : getSafeProperty(math3, name314);
        };
      } else {
        var isUnit2 = isValuelessUnit(name314);
        return function(scope, args, context) {
          return scope.has(name314) ? scope.get(name314) : isUnit2 ? new Unit2(null, name314) : SymbolNode2.onUndefinedSymbol(name314);
        };
      }
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
    }
    /**
     * Create a new SymbolNode with children produced by the given callback.
     * Trivial since a SymbolNode has no children
     * @param {function(child: Node, path: string, parent: Node) : Node} callback
     * @returns {SymbolNode} Returns a clone of the node
     */
    map(callback) {
      return this.clone();
    }
    /**
     * Throws an error 'Undefined symbol {name}'
     * @param {string} name
     */
    static onUndefinedSymbol(name314) {
      throw new Error("Undefined symbol " + name314);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {SymbolNode}
     */
    clone() {
      return new SymbolNode2(this.name);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toString(options2) {
      return this.name;
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toHTML(options2) {
      var name314 = escape(this.name);
      if (name314 === "true" || name314 === "false") {
        return '<span class="math-symbol math-boolean">' + name314 + "</span>";
      } else if (name314 === "i") {
        return '<span class="math-symbol math-imaginary-symbol">' + name314 + "</span>";
      } else if (name314 === "Infinity") {
        return '<span class="math-symbol math-infinity-symbol">' + name314 + "</span>";
      } else if (name314 === "NaN") {
        return '<span class="math-symbol math-nan-symbol">' + name314 + "</span>";
      } else if (name314 === "null") {
        return '<span class="math-symbol math-null-symbol">' + name314 + "</span>";
      } else if (name314 === "undefined") {
        return '<span class="math-symbol math-undefined-symbol">' + name314 + "</span>";
      }
      return '<span class="math-symbol">' + name314 + "</span>";
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: "SymbolNode",
        name: this.name
      };
    }
    /**
     * Instantiate a SymbolNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "SymbolNode", name: "x"}`,
     *                       where mathjs is optional
     * @returns {SymbolNode}
     */
    static fromJSON(json) {
      return new SymbolNode2(json.name);
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toTex(options2) {
      var isUnit2 = false;
      if (typeof math2[this.name] === "undefined" && isValuelessUnit(this.name)) {
        isUnit2 = true;
      }
      var symbol = toSymbol(this.name, isUnit2);
      if (symbol[0] === "\\") {
        return symbol;
      }
      return " " + symbol;
    }
  }
  return SymbolNode2;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/expression/node/FunctionNode.js
var name221 = "FunctionNode";
var dependencies222 = ["math", "Node", "SymbolNode"];
var createFunctionNode = /* @__PURE__ */ factory(name221, dependencies222, (_ref) => {
  var _FunctionNode;
  var {
    math: math2,
    Node: Node2,
    SymbolNode: SymbolNode2
  } = _ref;
  var strin = (entity) => format3(entity, {
    truncate: 78
  });
  function expandTemplate(template, node, options2) {
    var latex = "";
    var regex = /\$(?:\{([a-z_][a-z_0-9]*)(?:\[([0-9]+)\])?\}|\$)/gi;
    var inputPos = 0;
    var match;
    while ((match = regex.exec(template)) !== null) {
      latex += template.substring(inputPos, match.index);
      inputPos = match.index;
      if (match[0] === "$$") {
        latex += "$";
        inputPos++;
      } else {
        inputPos += match[0].length;
        var property = node[match[1]];
        if (!property) {
          throw new ReferenceError("Template: Property " + match[1] + " does not exist.");
        }
        if (match[2] === void 0) {
          switch (typeof property) {
            case "string":
              latex += property;
              break;
            case "object":
              if (isNode(property)) {
                latex += property.toTex(options2);
              } else if (Array.isArray(property)) {
                latex += property.map(function(arg2, index2) {
                  if (isNode(arg2)) {
                    return arg2.toTex(options2);
                  }
                  throw new TypeError("Template: " + match[1] + "[" + index2 + "] is not a Node.");
                }).join(",");
              } else {
                throw new TypeError("Template: " + match[1] + " has to be a Node, String or array of Nodes");
              }
              break;
            default:
              throw new TypeError("Template: " + match[1] + " has to be a Node, String or array of Nodes");
          }
        } else {
          if (isNode(property[match[2]] && property[match[2]])) {
            latex += property[match[2]].toTex(options2);
          } else {
            throw new TypeError("Template: " + match[1] + "[" + match[2] + "] is not a Node.");
          }
        }
      }
    }
    latex += template.slice(inputPos);
    return latex;
  }
  class FunctionNode2 extends Node2 {
    /**
     * @constructor FunctionNode
     * @extends {./Node}
     * invoke a list with arguments on a node
     * @param {./Node | string} fn
     *     Item resolving to a function on which to invoke
     *     the arguments, typically a SymboNode or AccessorNode
     * @param {./Node[]} args
     */
    constructor(fn, args) {
      super();
      if (typeof fn === "string") {
        fn = new SymbolNode2(fn);
      }
      if (!isNode(fn))
        throw new TypeError('Node expected as parameter "fn"');
      if (!Array.isArray(args) || !args.every(isNode)) {
        throw new TypeError('Array containing Nodes expected for parameter "args"');
      }
      this.fn = fn;
      this.args = args || [];
    }
    // readonly property name
    get name() {
      return this.fn.name || "";
    }
    get type() {
      return name221;
    }
    get isFunctionNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math3, argNames) {
      var evalArgs = this.args.map((arg2) => arg2._compile(math3, argNames));
      if (isSymbolNode(this.fn)) {
        var _name = this.fn.name;
        if (!argNames[_name]) {
          var fn = _name in math3 ? getSafeProperty(math3, _name) : void 0;
          var isRaw = typeof fn === "function" && fn.rawArgs === true;
          var resolveFn = (scope) => {
            var value;
            if (scope.has(_name)) {
              value = scope.get(_name);
            } else if (_name in math3) {
              value = getSafeProperty(math3, _name);
            } else {
              return FunctionNode2.onUndefinedFunction(_name);
            }
            if (typeof value === "function") {
              return value;
            }
            throw new TypeError("'".concat(_name, "' is not a function; its value is:\n  ").concat(strin(value)));
          };
          if (isRaw) {
            var rawArgs = this.args;
            return function evalFunctionNode(scope, args, context) {
              var fn2 = resolveFn(scope);
              return fn2(rawArgs, math3, createSubScope(scope, args));
            };
          } else {
            switch (evalArgs.length) {
              case 0:
                return function evalFunctionNode(scope, args, context) {
                  var fn2 = resolveFn(scope);
                  return fn2();
                };
              case 1:
                return function evalFunctionNode(scope, args, context) {
                  var fn2 = resolveFn(scope);
                  var evalArg0 = evalArgs[0];
                  return fn2(evalArg0(scope, args, context));
                };
              case 2:
                return function evalFunctionNode(scope, args, context) {
                  var fn2 = resolveFn(scope);
                  var evalArg0 = evalArgs[0];
                  var evalArg1 = evalArgs[1];
                  return fn2(evalArg0(scope, args, context), evalArg1(scope, args, context));
                };
              default:
                return function evalFunctionNode(scope, args, context) {
                  var fn2 = resolveFn(scope);
                  var values = evalArgs.map((evalArg) => evalArg(scope, args, context));
                  return fn2(...values);
                };
            }
          }
        } else {
          var _rawArgs = this.args;
          return function evalFunctionNode(scope, args, context) {
            var fn2 = getSafeProperty(args, _name);
            if (typeof fn2 !== "function") {
              throw new TypeError("Argument '".concat(_name, "' was not a function; received: ").concat(strin(fn2)));
            }
            if (fn2.rawArgs) {
              return fn2(_rawArgs, math3, createSubScope(scope, args));
            } else {
              var values = evalArgs.map((evalArg) => evalArg(scope, args, context));
              return fn2.apply(fn2, values);
            }
          };
        }
      } else if (isAccessorNode(this.fn) && isIndexNode(this.fn.index) && this.fn.index.isObjectProperty()) {
        var evalObject = this.fn.object._compile(math3, argNames);
        var prop = this.fn.index.getObjectProperty();
        var _rawArgs2 = this.args;
        return function evalFunctionNode(scope, args, context) {
          var object = evalObject(scope, args, context);
          var fn2 = getSafeMethod(object, prop);
          if (fn2 !== null && fn2 !== void 0 && fn2.rawArgs) {
            return fn2(_rawArgs2, math3, createSubScope(scope, args));
          } else {
            var values = evalArgs.map((evalArg) => evalArg(scope, args, context));
            return fn2.apply(object, values);
          }
        };
      } else {
        var fnExpr = this.fn.toString();
        var evalFn = this.fn._compile(math3, argNames);
        var _rawArgs3 = this.args;
        return function evalFunctionNode(scope, args, context) {
          var fn2 = evalFn(scope, args, context);
          if (typeof fn2 !== "function") {
            throw new TypeError("Expression '".concat(fnExpr, "' did not evaluate to a function; value is:") + "\n  ".concat(strin(fn2)));
          }
          if (fn2.rawArgs) {
            return fn2(_rawArgs3, math3, createSubScope(scope, args));
          } else {
            var values = evalArgs.map((evalArg) => evalArg(scope, args, context));
            return fn2.apply(fn2, values);
          }
        };
      }
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      callback(this.fn, "fn", this);
      for (var i2 = 0; i2 < this.args.length; i2++) {
        callback(this.args[i2], "args[" + i2 + "]", this);
      }
    }
    /**
     * Create a new FunctionNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {FunctionNode} Returns a transformed copy of the node
     */
    map(callback) {
      var fn = this._ifNode(callback(this.fn, "fn", this));
      var args = [];
      for (var i2 = 0; i2 < this.args.length; i2++) {
        args[i2] = this._ifNode(callback(this.args[i2], "args[" + i2 + "]", this));
      }
      return new FunctionNode2(fn, args);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {FunctionNode}
     */
    clone() {
      return new FunctionNode2(this.fn, this.args.slice(0));
    }
    /**
     * Throws an error 'Undefined function {name}'
     * @param {string} name
     */
    /**
     * Get string representation. (wrapper function)
     * This overrides parts of Node's toString function.
     * If callback is an object containing callbacks, it
     * calls the correct callback for the current node,
     * otherwise it falls back to calling Node's toString
     * function.
     *
     * @param {Object} options
     * @return {string} str
     * @override
     */
    toString(options2) {
      var customString;
      var name314 = this.fn.toString(options2);
      if (options2 && typeof options2.handler === "object" && hasOwnProperty(options2.handler, name314)) {
        customString = options2.handler[name314](this, options2);
      }
      if (typeof customString !== "undefined") {
        return customString;
      }
      return super.toString(options2);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */
    _toString(options2) {
      var args = this.args.map(function(arg2) {
        return arg2.toString(options2);
      });
      var fn = isFunctionAssignmentNode(this.fn) ? "(" + this.fn.toString(options2) + ")" : this.fn.toString(options2);
      return fn + "(" + args.join(", ") + ")";
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name221,
        fn: this.fn,
        args: this.args
      };
    }
    /**
     * Instantiate an AssignmentNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "FunctionNode", fn: ..., args: ...}`,
     *                       where mathjs is optional
     * @returns {FunctionNode}
     */
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(options2) {
      var args = this.args.map(function(arg2) {
        return arg2.toHTML(options2);
      });
      return '<span class="math-function">' + escape(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + args.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
    }
    /**
     * Get LaTeX representation. (wrapper function)
     * This overrides parts of Node's toTex function.
     * If callback is an object containing callbacks, it
     * calls the correct callback for the current node,
     * otherwise it falls back to calling Node's toTex
     * function.
     *
     * @param {Object} options
     * @return {string}
     */
    toTex(options2) {
      var customTex;
      if (options2 && typeof options2.handler === "object" && hasOwnProperty(options2.handler, this.name)) {
        customTex = options2.handler[this.name](this, options2);
      }
      if (typeof customTex !== "undefined") {
        return customTex;
      }
      return super.toTex(options2);
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(options2) {
      var args = this.args.map(function(arg2) {
        return arg2.toTex(options2);
      });
      var latexConverter;
      if (latexFunctions[this.name]) {
        latexConverter = latexFunctions[this.name];
      }
      if (math2[this.name] && (typeof math2[this.name].toTex === "function" || typeof math2[this.name].toTex === "object" || typeof math2[this.name].toTex === "string")) {
        latexConverter = math2[this.name].toTex;
      }
      var customToTex;
      switch (typeof latexConverter) {
        case "function":
          customToTex = latexConverter(this, options2);
          break;
        case "string":
          customToTex = expandTemplate(latexConverter, this, options2);
          break;
        case "object":
          switch (typeof latexConverter[args.length]) {
            case "function":
              customToTex = latexConverter[args.length](this, options2);
              break;
            case "string":
              customToTex = expandTemplate(latexConverter[args.length], this, options2);
              break;
          }
      }
      if (typeof customToTex !== "undefined") {
        return customToTex;
      }
      return expandTemplate(defaultTemplate, this, options2);
    }
    /**
     * Get identifier.
     * @return {string}
     */
    getIdentifier() {
      return this.type + ":" + this.name;
    }
  }
  _FunctionNode = FunctionNode2;
  _defineProperty(FunctionNode2, "name", name221);
  _defineProperty(FunctionNode2, "onUndefinedFunction", function(name314) {
    throw new Error("Undefined function " + name314);
  });
  _defineProperty(FunctionNode2, "fromJSON", function(json) {
    return new _FunctionNode(json.fn, json.args);
  });
  return FunctionNode2;
}, {
  isClass: true,
  isNode: true
});

// node_modules/mathjs/lib/esm/expression/parse.js
var name222 = "parse";
var dependencies223 = ["typed", "numeric", "config", "AccessorNode", "ArrayNode", "AssignmentNode", "BlockNode", "ConditionalNode", "ConstantNode", "FunctionAssignmentNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "RangeNode", "RelationalNode", "SymbolNode"];
var createParse = /* @__PURE__ */ factory(name222, dependencies223, (_ref) => {
  var {
    typed: typed3,
    numeric: numeric3,
    config: config5,
    AccessorNode: AccessorNode2,
    ArrayNode: ArrayNode2,
    AssignmentNode: AssignmentNode2,
    BlockNode: BlockNode2,
    ConditionalNode: ConditionalNode2,
    ConstantNode: ConstantNode2,
    FunctionAssignmentNode: FunctionAssignmentNode2,
    FunctionNode: FunctionNode2,
    IndexNode: IndexNode2,
    ObjectNode: ObjectNode2,
    OperatorNode: OperatorNode2,
    ParenthesisNode: ParenthesisNode2,
    RangeNode: RangeNode2,
    RelationalNode: RelationalNode2,
    SymbolNode: SymbolNode2
  } = _ref;
  var parse4 = typed3(name222, {
    string: function string2(expression) {
      return parseStart(expression, {});
    },
    "Array | Matrix": function ArrayMatrix(expressions) {
      return parseMultiple(expressions, {});
    },
    "string, Object": function stringObject(expression, options2) {
      var extraNodes = options2.nodes !== void 0 ? options2.nodes : {};
      return parseStart(expression, extraNodes);
    },
    "Array | Matrix, Object": parseMultiple
  });
  function parseMultiple(expressions) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var extraNodes = options2.nodes !== void 0 ? options2.nodes : {};
    return deepMap(expressions, function(elem) {
      if (typeof elem !== "string")
        throw new TypeError("String expected");
      return parseStart(elem, extraNodes);
    });
  }
  var TOKENTYPE = {
    NULL: 0,
    DELIMITER: 1,
    NUMBER: 2,
    SYMBOL: 3,
    UNKNOWN: 4
  };
  var DELIMITERS = {
    ",": true,
    "(": true,
    ")": true,
    "[": true,
    "]": true,
    "{": true,
    "}": true,
    '"': true,
    "'": true,
    ";": true,
    "+": true,
    "-": true,
    "*": true,
    ".*": true,
    "/": true,
    "./": true,
    "%": true,
    "^": true,
    ".^": true,
    "~": true,
    "!": true,
    "&": true,
    "|": true,
    "^|": true,
    "=": true,
    ":": true,
    "?": true,
    "==": true,
    "!=": true,
    "<": true,
    ">": true,
    "<=": true,
    ">=": true,
    "<<": true,
    ">>": true,
    ">>>": true
  };
  var NAMED_DELIMITERS = {
    mod: true,
    to: true,
    in: true,
    and: true,
    xor: true,
    or: true,
    not: true
  };
  var CONSTANTS = {
    true: true,
    false: false,
    null: null,
    undefined: void 0
  };
  var NUMERIC_CONSTANTS = ["NaN", "Infinity"];
  var ESCAPE_CHARACTERS = {
    '"': '"',
    "'": "'",
    "\\": "\\",
    "/": "/",
    b: "\b",
    f: "\f",
    n: "\n",
    r: "\r",
    t: "	"
    // note that \u is handled separately in parseStringToken()
  };
  function initialState() {
    return {
      extraNodes: {},
      // current extra nodes, must be careful not to mutate
      expression: "",
      // current expression
      comment: "",
      // last parsed comment
      index: 0,
      // current index in expr
      token: "",
      // current token
      tokenType: TOKENTYPE.NULL,
      // type of the token
      nestingLevel: 0,
      // level of nesting inside parameters, used to ignore newline characters
      conditionalLevel: null
      // when a conditional is being parsed, the level of the conditional is stored here
    };
  }
  function currentString(state, length) {
    return state.expression.substr(state.index, length);
  }
  function currentCharacter(state) {
    return currentString(state, 1);
  }
  function next(state) {
    state.index++;
  }
  function prevCharacter(state) {
    return state.expression.charAt(state.index - 1);
  }
  function nextCharacter(state) {
    return state.expression.charAt(state.index + 1);
  }
  function getToken(state) {
    state.tokenType = TOKENTYPE.NULL;
    state.token = "";
    state.comment = "";
    while (true) {
      if (currentCharacter(state) === "#") {
        while (currentCharacter(state) !== "\n" && currentCharacter(state) !== "") {
          state.comment += currentCharacter(state);
          next(state);
        }
      }
      if (parse4.isWhitespace(currentCharacter(state), state.nestingLevel)) {
        next(state);
      } else {
        break;
      }
    }
    if (currentCharacter(state) === "") {
      state.tokenType = TOKENTYPE.DELIMITER;
      return;
    }
    if (currentCharacter(state) === "\n" && !state.nestingLevel) {
      state.tokenType = TOKENTYPE.DELIMITER;
      state.token = currentCharacter(state);
      next(state);
      return;
    }
    var c1 = currentCharacter(state);
    var c2 = currentString(state, 2);
    var c3 = currentString(state, 3);
    if (c3.length === 3 && DELIMITERS[c3]) {
      state.tokenType = TOKENTYPE.DELIMITER;
      state.token = c3;
      next(state);
      next(state);
      next(state);
      return;
    }
    if (c2.length === 2 && DELIMITERS[c2]) {
      state.tokenType = TOKENTYPE.DELIMITER;
      state.token = c2;
      next(state);
      next(state);
      return;
    }
    if (DELIMITERS[c1]) {
      state.tokenType = TOKENTYPE.DELIMITER;
      state.token = c1;
      next(state);
      return;
    }
    if (parse4.isDigitDot(c1)) {
      state.tokenType = TOKENTYPE.NUMBER;
      var _c = currentString(state, 2);
      if (_c === "0b" || _c === "0o" || _c === "0x") {
        state.token += currentCharacter(state);
        next(state);
        state.token += currentCharacter(state);
        next(state);
        while (parse4.isHexDigit(currentCharacter(state))) {
          state.token += currentCharacter(state);
          next(state);
        }
        if (currentCharacter(state) === ".") {
          state.token += ".";
          next(state);
          while (parse4.isHexDigit(currentCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }
        } else if (currentCharacter(state) === "i") {
          state.token += "i";
          next(state);
          while (parse4.isDigit(currentCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }
        }
        return;
      }
      if (currentCharacter(state) === ".") {
        state.token += currentCharacter(state);
        next(state);
        if (!parse4.isDigit(currentCharacter(state))) {
          state.tokenType = TOKENTYPE.DELIMITER;
          return;
        }
      } else {
        while (parse4.isDigit(currentCharacter(state))) {
          state.token += currentCharacter(state);
          next(state);
        }
        if (parse4.isDecimalMark(currentCharacter(state), nextCharacter(state))) {
          state.token += currentCharacter(state);
          next(state);
        }
      }
      while (parse4.isDigit(currentCharacter(state))) {
        state.token += currentCharacter(state);
        next(state);
      }
      if (currentCharacter(state) === "E" || currentCharacter(state) === "e") {
        if (parse4.isDigit(nextCharacter(state)) || nextCharacter(state) === "-" || nextCharacter(state) === "+") {
          state.token += currentCharacter(state);
          next(state);
          if (currentCharacter(state) === "+" || currentCharacter(state) === "-") {
            state.token += currentCharacter(state);
            next(state);
          }
          if (!parse4.isDigit(currentCharacter(state))) {
            throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
          }
          while (parse4.isDigit(currentCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }
          if (parse4.isDecimalMark(currentCharacter(state), nextCharacter(state))) {
            throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
          }
        } else if (nextCharacter(state) === ".") {
          next(state);
          throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
        }
      }
      return;
    }
    if (parse4.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state))) {
      while (parse4.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse4.isDigit(currentCharacter(state))) {
        state.token += currentCharacter(state);
        next(state);
      }
      if (hasOwnProperty(NAMED_DELIMITERS, state.token)) {
        state.tokenType = TOKENTYPE.DELIMITER;
      } else {
        state.tokenType = TOKENTYPE.SYMBOL;
      }
      return;
    }
    state.tokenType = TOKENTYPE.UNKNOWN;
    while (currentCharacter(state) !== "") {
      state.token += currentCharacter(state);
      next(state);
    }
    throw createSyntaxError(state, 'Syntax error in part "' + state.token + '"');
  }
  function getTokenSkipNewline(state) {
    do {
      getToken(state);
    } while (state.token === "\n");
  }
  function openParams(state) {
    state.nestingLevel++;
  }
  function closeParams(state) {
    state.nestingLevel--;
  }
  parse4.isAlpha = function isAlpha(c, cPrev, cNext) {
    return parse4.isValidLatinOrGreek(c) || parse4.isValidMathSymbol(c, cNext) || parse4.isValidMathSymbol(cPrev, c);
  };
  parse4.isValidLatinOrGreek = function isValidLatinOrGreek(c) {
    return /^[a-zA-Z_$\u00C0-\u02AF\u0370-\u03FF\u2100-\u214F]$/.test(c);
  };
  parse4.isValidMathSymbol = function isValidMathSymbol(high, low) {
    return /^[\uD835]$/.test(high) && /^[\uDC00-\uDFFF]$/.test(low) && /^[^\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]$/.test(low);
  };
  parse4.isWhitespace = function isWhitespace(c, nestingLevel) {
    return c === " " || c === "	" || c === "\n" && nestingLevel > 0;
  };
  parse4.isDecimalMark = function isDecimalMark(c, cNext) {
    return c === "." && cNext !== "/" && cNext !== "*" && cNext !== "^";
  };
  parse4.isDigitDot = function isDigitDot(c) {
    return c >= "0" && c <= "9" || c === ".";
  };
  parse4.isDigit = function isDigit(c) {
    return c >= "0" && c <= "9";
  };
  parse4.isHexDigit = function isHexDigit(c) {
    return c >= "0" && c <= "9" || c >= "a" && c <= "f" || c >= "A" && c <= "F";
  };
  function parseStart(expression, extraNodes) {
    var state = initialState();
    _extends(state, {
      expression,
      extraNodes
    });
    getToken(state);
    var node = parseBlock(state);
    if (state.token !== "") {
      if (state.tokenType === TOKENTYPE.DELIMITER) {
        throw createError(state, "Unexpected operator " + state.token);
      } else {
        throw createSyntaxError(state, 'Unexpected part "' + state.token + '"');
      }
    }
    return node;
  }
  function parseBlock(state) {
    var node;
    var blocks = [];
    var visible;
    if (state.token !== "" && state.token !== "\n" && state.token !== ";") {
      node = parseAssignment(state);
      if (state.comment) {
        node.comment = state.comment;
      }
    }
    while (state.token === "\n" || state.token === ";") {
      if (blocks.length === 0 && node) {
        visible = state.token !== ";";
        blocks.push({
          node,
          visible
        });
      }
      getToken(state);
      if (state.token !== "\n" && state.token !== ";" && state.token !== "") {
        node = parseAssignment(state);
        if (state.comment) {
          node.comment = state.comment;
        }
        visible = state.token !== ";";
        blocks.push({
          node,
          visible
        });
      }
    }
    if (blocks.length > 0) {
      return new BlockNode2(blocks);
    } else {
      if (!node) {
        node = new ConstantNode2(void 0);
        if (state.comment) {
          node.comment = state.comment;
        }
      }
      return node;
    }
  }
  function parseAssignment(state) {
    var name314, args, value, valid;
    var node = parseConditional(state);
    if (state.token === "=") {
      if (isSymbolNode(node)) {
        name314 = node.name;
        getTokenSkipNewline(state);
        value = parseAssignment(state);
        return new AssignmentNode2(new SymbolNode2(name314), value);
      } else if (isAccessorNode(node)) {
        getTokenSkipNewline(state);
        value = parseAssignment(state);
        return new AssignmentNode2(node.object, node.index, value);
      } else if (isFunctionNode(node) && isSymbolNode(node.fn)) {
        valid = true;
        args = [];
        name314 = node.name;
        node.args.forEach(function(arg2, index2) {
          if (isSymbolNode(arg2)) {
            args[index2] = arg2.name;
          } else {
            valid = false;
          }
        });
        if (valid) {
          getTokenSkipNewline(state);
          value = parseAssignment(state);
          return new FunctionAssignmentNode2(name314, args, value);
        }
      }
      throw createSyntaxError(state, "Invalid left hand side of assignment operator =");
    }
    return node;
  }
  function parseConditional(state) {
    var node = parseLogicalOr(state);
    while (state.token === "?") {
      var prev = state.conditionalLevel;
      state.conditionalLevel = state.nestingLevel;
      getTokenSkipNewline(state);
      var condition = node;
      var trueExpr = parseAssignment(state);
      if (state.token !== ":")
        throw createSyntaxError(state, "False part of conditional expression expected");
      state.conditionalLevel = null;
      getTokenSkipNewline(state);
      var falseExpr = parseAssignment(state);
      node = new ConditionalNode2(condition, trueExpr, falseExpr);
      state.conditionalLevel = prev;
    }
    return node;
  }
  function parseLogicalOr(state) {
    var node = parseLogicalXor(state);
    while (state.token === "or") {
      getTokenSkipNewline(state);
      node = new OperatorNode2("or", "or", [node, parseLogicalXor(state)]);
    }
    return node;
  }
  function parseLogicalXor(state) {
    var node = parseLogicalAnd(state);
    while (state.token === "xor") {
      getTokenSkipNewline(state);
      node = new OperatorNode2("xor", "xor", [node, parseLogicalAnd(state)]);
    }
    return node;
  }
  function parseLogicalAnd(state) {
    var node = parseBitwiseOr(state);
    while (state.token === "and") {
      getTokenSkipNewline(state);
      node = new OperatorNode2("and", "and", [node, parseBitwiseOr(state)]);
    }
    return node;
  }
  function parseBitwiseOr(state) {
    var node = parseBitwiseXor(state);
    while (state.token === "|") {
      getTokenSkipNewline(state);
      node = new OperatorNode2("|", "bitOr", [node, parseBitwiseXor(state)]);
    }
    return node;
  }
  function parseBitwiseXor(state) {
    var node = parseBitwiseAnd(state);
    while (state.token === "^|") {
      getTokenSkipNewline(state);
      node = new OperatorNode2("^|", "bitXor", [node, parseBitwiseAnd(state)]);
    }
    return node;
  }
  function parseBitwiseAnd(state) {
    var node = parseRelational(state);
    while (state.token === "&") {
      getTokenSkipNewline(state);
      node = new OperatorNode2("&", "bitAnd", [node, parseRelational(state)]);
    }
    return node;
  }
  function parseRelational(state) {
    var params = [parseShift(state)];
    var conditionals = [];
    var operators = {
      "==": "equal",
      "!=": "unequal",
      "<": "smaller",
      ">": "larger",
      "<=": "smallerEq",
      ">=": "largerEq"
    };
    while (hasOwnProperty(operators, state.token)) {
      var cond = {
        name: state.token,
        fn: operators[state.token]
      };
      conditionals.push(cond);
      getTokenSkipNewline(state);
      params.push(parseShift(state));
    }
    if (params.length === 1) {
      return params[0];
    } else if (params.length === 2) {
      return new OperatorNode2(conditionals[0].name, conditionals[0].fn, params);
    } else {
      return new RelationalNode2(conditionals.map((c) => c.fn), params);
    }
  }
  function parseShift(state) {
    var node, name314, fn, params;
    node = parseConversion(state);
    var operators = {
      "<<": "leftShift",
      ">>": "rightArithShift",
      ">>>": "rightLogShift"
    };
    while (hasOwnProperty(operators, state.token)) {
      name314 = state.token;
      fn = operators[name314];
      getTokenSkipNewline(state);
      params = [node, parseConversion(state)];
      node = new OperatorNode2(name314, fn, params);
    }
    return node;
  }
  function parseConversion(state) {
    var node, name314, fn, params;
    node = parseRange(state);
    var operators = {
      to: "to",
      in: "to"
      // alias of 'to'
    };
    while (hasOwnProperty(operators, state.token)) {
      name314 = state.token;
      fn = operators[name314];
      getTokenSkipNewline(state);
      if (name314 === "in" && state.token === "") {
        node = new OperatorNode2("*", "multiply", [node, new SymbolNode2("in")], true);
      } else {
        params = [node, parseRange(state)];
        node = new OperatorNode2(name314, fn, params);
      }
    }
    return node;
  }
  function parseRange(state) {
    var node;
    var params = [];
    if (state.token === ":") {
      node = new ConstantNode2(1);
    } else {
      node = parseAddSubtract(state);
    }
    if (state.token === ":" && state.conditionalLevel !== state.nestingLevel) {
      params.push(node);
      while (state.token === ":" && params.length < 3) {
        getTokenSkipNewline(state);
        if (state.token === ")" || state.token === "]" || state.token === "," || state.token === "") {
          params.push(new SymbolNode2("end"));
        } else {
          params.push(parseAddSubtract(state));
        }
      }
      if (params.length === 3) {
        node = new RangeNode2(params[0], params[2], params[1]);
      } else {
        node = new RangeNode2(params[0], params[1]);
      }
    }
    return node;
  }
  function parseAddSubtract(state) {
    var node, name314, fn, params;
    node = parseMultiplyDivide(state);
    var operators = {
      "+": "add",
      "-": "subtract"
    };
    while (hasOwnProperty(operators, state.token)) {
      name314 = state.token;
      fn = operators[name314];
      getTokenSkipNewline(state);
      var rightNode = parseMultiplyDivide(state);
      if (rightNode.isPercentage) {
        params = [node, new OperatorNode2("*", "multiply", [node, rightNode])];
      } else {
        params = [node, rightNode];
      }
      node = new OperatorNode2(name314, fn, params);
    }
    return node;
  }
  function parseMultiplyDivide(state) {
    var node, last, name314, fn;
    node = parseImplicitMultiplication(state);
    last = node;
    var operators = {
      "*": "multiply",
      ".*": "dotMultiply",
      "/": "divide",
      "./": "dotDivide"
    };
    while (true) {
      if (hasOwnProperty(operators, state.token)) {
        name314 = state.token;
        fn = operators[name314];
        getTokenSkipNewline(state);
        last = parseImplicitMultiplication(state);
        node = new OperatorNode2(name314, fn, [node, last]);
      } else {
        break;
      }
    }
    return node;
  }
  function parseImplicitMultiplication(state) {
    var node, last;
    node = parseRule2(state);
    last = node;
    while (true) {
      if (state.tokenType === TOKENTYPE.SYMBOL || state.token === "in" && isConstantNode(node) || state.tokenType === TOKENTYPE.NUMBER && !isConstantNode(last) && (!isOperatorNode(last) || last.op === "!") || state.token === "(") {
        last = parseRule2(state);
        node = new OperatorNode2(
          "*",
          "multiply",
          [node, last],
          true
          /* implicit */
        );
      } else {
        break;
      }
    }
    return node;
  }
  function parseRule2(state) {
    var node = parseModulusPercentage(state);
    var last = node;
    var tokenStates = [];
    while (true) {
      if (state.token === "/" && rule2Node(last)) {
        tokenStates.push(_extends({}, state));
        getTokenSkipNewline(state);
        if (state.tokenType === TOKENTYPE.NUMBER) {
          tokenStates.push(_extends({}, state));
          getTokenSkipNewline(state);
          if (state.tokenType === TOKENTYPE.SYMBOL || state.token === "(") {
            _extends(state, tokenStates.pop());
            tokenStates.pop();
            last = parseModulusPercentage(state);
            node = new OperatorNode2("/", "divide", [node, last]);
          } else {
            tokenStates.pop();
            _extends(state, tokenStates.pop());
            break;
          }
        } else {
          _extends(state, tokenStates.pop());
          break;
        }
      } else {
        break;
      }
    }
    return node;
  }
  function parseModulusPercentage(state) {
    var node, name314, fn, params;
    node = parseUnary(state);
    var operators = {
      "%": "mod",
      mod: "mod"
    };
    while (hasOwnProperty(operators, state.token)) {
      name314 = state.token;
      fn = operators[name314];
      getTokenSkipNewline(state);
      if (name314 === "%" && state.tokenType === TOKENTYPE.DELIMITER && state.token !== "(") {
        node = new OperatorNode2("/", "divide", [node, new ConstantNode2(100)], false, true);
      } else {
        params = [node, parseUnary(state)];
        node = new OperatorNode2(name314, fn, params);
      }
    }
    return node;
  }
  function parseUnary(state) {
    var name314, params, fn;
    var operators = {
      "-": "unaryMinus",
      "+": "unaryPlus",
      "~": "bitNot",
      not: "not"
    };
    if (hasOwnProperty(operators, state.token)) {
      fn = operators[state.token];
      name314 = state.token;
      getTokenSkipNewline(state);
      params = [parseUnary(state)];
      return new OperatorNode2(name314, fn, params);
    }
    return parsePow(state);
  }
  function parsePow(state) {
    var node, name314, fn, params;
    node = parseLeftHandOperators(state);
    if (state.token === "^" || state.token === ".^") {
      name314 = state.token;
      fn = name314 === "^" ? "pow" : "dotPow";
      getTokenSkipNewline(state);
      params = [node, parseUnary(state)];
      node = new OperatorNode2(name314, fn, params);
    }
    return node;
  }
  function parseLeftHandOperators(state) {
    var node, name314, fn, params;
    node = parseCustomNodes(state);
    var operators = {
      "!": "factorial",
      "'": "ctranspose"
    };
    while (hasOwnProperty(operators, state.token)) {
      name314 = state.token;
      fn = operators[name314];
      getToken(state);
      params = [node];
      node = new OperatorNode2(name314, fn, params);
      node = parseAccessors(state, node);
    }
    return node;
  }
  function parseCustomNodes(state) {
    var params = [];
    if (state.tokenType === TOKENTYPE.SYMBOL && hasOwnProperty(state.extraNodes, state.token)) {
      var CustomNode = state.extraNodes[state.token];
      getToken(state);
      if (state.token === "(") {
        params = [];
        openParams(state);
        getToken(state);
        if (state.token !== ")") {
          params.push(parseAssignment(state));
          while (state.token === ",") {
            getToken(state);
            params.push(parseAssignment(state));
          }
        }
        if (state.token !== ")") {
          throw createSyntaxError(state, "Parenthesis ) expected");
        }
        closeParams(state);
        getToken(state);
      }
      return new CustomNode(params);
    }
    return parseSymbol(state);
  }
  function parseSymbol(state) {
    var node, name314;
    if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {
      name314 = state.token;
      getToken(state);
      if (hasOwnProperty(CONSTANTS, name314)) {
        node = new ConstantNode2(CONSTANTS[name314]);
      } else if (NUMERIC_CONSTANTS.includes(name314)) {
        node = new ConstantNode2(numeric3(name314, "number"));
      } else {
        node = new SymbolNode2(name314);
      }
      node = parseAccessors(state, node);
      return node;
    }
    return parseString(state);
  }
  function parseAccessors(state, node, types) {
    var params;
    while ((state.token === "(" || state.token === "[" || state.token === ".") && (!types || types.includes(state.token))) {
      params = [];
      if (state.token === "(") {
        if (isSymbolNode(node) || isAccessorNode(node)) {
          openParams(state);
          getToken(state);
          if (state.token !== ")") {
            params.push(parseAssignment(state));
            while (state.token === ",") {
              getToken(state);
              params.push(parseAssignment(state));
            }
          }
          if (state.token !== ")") {
            throw createSyntaxError(state, "Parenthesis ) expected");
          }
          closeParams(state);
          getToken(state);
          node = new FunctionNode2(node, params);
        } else {
          return node;
        }
      } else if (state.token === "[") {
        openParams(state);
        getToken(state);
        if (state.token !== "]") {
          params.push(parseAssignment(state));
          while (state.token === ",") {
            getToken(state);
            params.push(parseAssignment(state));
          }
        }
        if (state.token !== "]") {
          throw createSyntaxError(state, "Parenthesis ] expected");
        }
        closeParams(state);
        getToken(state);
        node = new AccessorNode2(node, new IndexNode2(params));
      } else {
        getToken(state);
        var isPropertyName = state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS;
        if (!isPropertyName) {
          throw createSyntaxError(state, "Property name expected after dot");
        }
        params.push(new ConstantNode2(state.token));
        getToken(state);
        var dotNotation = true;
        node = new AccessorNode2(node, new IndexNode2(params, dotNotation));
      }
    }
    return node;
  }
  function parseString(state) {
    var node, str;
    if (state.token === '"' || state.token === "'") {
      str = parseStringToken(state, state.token);
      node = new ConstantNode2(str);
      node = parseAccessors(state, node);
      return node;
    }
    return parseMatrix(state);
  }
  function parseStringToken(state, quote) {
    var str = "";
    while (currentCharacter(state) !== "" && currentCharacter(state) !== quote) {
      if (currentCharacter(state) === "\\") {
        next(state);
        var char = currentCharacter(state);
        var escapeChar = ESCAPE_CHARACTERS[char];
        if (escapeChar !== void 0) {
          str += escapeChar;
          state.index += 1;
        } else if (char === "u") {
          var unicode = state.expression.slice(state.index + 1, state.index + 5);
          if (/^[0-9A-Fa-f]{4}$/.test(unicode)) {
            str += String.fromCharCode(parseInt(unicode, 16));
            state.index += 5;
          } else {
            throw createSyntaxError(state, "Invalid unicode character \\u".concat(unicode));
          }
        } else {
          throw createSyntaxError(state, "Bad escape character \\".concat(char));
        }
      } else {
        str += currentCharacter(state);
        next(state);
      }
    }
    getToken(state);
    if (state.token !== quote) {
      throw createSyntaxError(state, "End of string ".concat(quote, " expected"));
    }
    getToken(state);
    return str;
  }
  function parseMatrix(state) {
    var array, params, rows, cols;
    if (state.token === "[") {
      openParams(state);
      getToken(state);
      if (state.token !== "]") {
        var row2 = parseRow(state);
        if (state.token === ";") {
          rows = 1;
          params = [row2];
          while (state.token === ";") {
            getToken(state);
            if (state.token !== "]") {
              params[rows] = parseRow(state);
              rows++;
            }
          }
          if (state.token !== "]") {
            throw createSyntaxError(state, "End of matrix ] expected");
          }
          closeParams(state);
          getToken(state);
          cols = params[0].items.length;
          for (var r = 1; r < rows; r++) {
            if (params[r].items.length !== cols) {
              throw createError(state, "Column dimensions mismatch (" + params[r].items.length + " !== " + cols + ")");
            }
          }
          array = new ArrayNode2(params);
        } else {
          if (state.token !== "]") {
            throw createSyntaxError(state, "End of matrix ] expected");
          }
          closeParams(state);
          getToken(state);
          array = row2;
        }
      } else {
        closeParams(state);
        getToken(state);
        array = new ArrayNode2([]);
      }
      return parseAccessors(state, array);
    }
    return parseObject(state);
  }
  function parseRow(state) {
    var params = [parseAssignment(state)];
    var len = 1;
    while (state.token === ",") {
      getToken(state);
      if (state.token !== "]" && state.token !== ";") {
        params[len] = parseAssignment(state);
        len++;
      }
    }
    return new ArrayNode2(params);
  }
  function parseObject(state) {
    if (state.token === "{") {
      openParams(state);
      var key;
      var properties2 = {};
      do {
        getToken(state);
        if (state.token !== "}") {
          if (state.token === '"' || state.token === "'") {
            key = parseStringToken(state, state.token);
          } else if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {
            key = state.token;
            getToken(state);
          } else {
            throw createSyntaxError(state, "Symbol or string expected as object key");
          }
          if (state.token !== ":") {
            throw createSyntaxError(state, "Colon : expected after object key");
          }
          getToken(state);
          properties2[key] = parseAssignment(state);
        }
      } while (state.token === ",");
      if (state.token !== "}") {
        throw createSyntaxError(state, "Comma , or bracket } expected after object value");
      }
      closeParams(state);
      getToken(state);
      var node = new ObjectNode2(properties2);
      node = parseAccessors(state, node);
      return node;
    }
    return parseNumber(state);
  }
  function parseNumber(state) {
    var numberStr;
    if (state.tokenType === TOKENTYPE.NUMBER) {
      numberStr = state.token;
      getToken(state);
      var numericType = safeNumberType(numberStr, config5);
      var value = numeric3(numberStr, numericType);
      return new ConstantNode2(value);
    }
    return parseParentheses(state);
  }
  function parseParentheses(state) {
    var node;
    if (state.token === "(") {
      openParams(state);
      getToken(state);
      node = parseAssignment(state);
      if (state.token !== ")") {
        throw createSyntaxError(state, "Parenthesis ) expected");
      }
      closeParams(state);
      getToken(state);
      node = new ParenthesisNode2(node);
      node = parseAccessors(state, node);
      return node;
    }
    return parseEnd(state);
  }
  function parseEnd(state) {
    if (state.token === "") {
      throw createSyntaxError(state, "Unexpected end of expression");
    } else {
      throw createSyntaxError(state, "Value expected");
    }
  }
  function col(state) {
    return state.index - state.token.length + 1;
  }
  function createSyntaxError(state, message) {
    var c = col(state);
    var error = new SyntaxError(message + " (char " + c + ")");
    error.char = c;
    return error;
  }
  function createError(state, message) {
    var c = col(state);
    var error = new SyntaxError(message + " (char " + c + ")");
    error.char = c;
    return error;
  }
  typed3.addConversion({
    from: "string",
    to: "Node",
    convert: parse4
  });
  return parse4;
});

// node_modules/mathjs/lib/esm/expression/function/compile.js
var name223 = "compile";
var dependencies224 = ["typed", "parse"];
var createCompile = /* @__PURE__ */ factory(name223, dependencies224, (_ref) => {
  var {
    typed: typed3,
    parse: parse4
  } = _ref;
  return typed3(name223, {
    string: function string2(expr) {
      return parse4(expr).compile();
    },
    "Array | Matrix": function ArrayMatrix(expr) {
      return deepMap(expr, function(entry) {
        return parse4(entry).compile();
      });
    }
  });
});

// node_modules/mathjs/lib/esm/expression/function/evaluate.js
var name224 = "evaluate";
var dependencies225 = ["typed", "parse"];
var createEvaluate = /* @__PURE__ */ factory(name224, dependencies225, (_ref) => {
  var {
    typed: typed3,
    parse: parse4
  } = _ref;
  return typed3(name224, {
    string: function string2(expr) {
      var scope = createEmptyMap();
      return parse4(expr).compile().evaluate(scope);
    },
    "string, Map | Object": function stringMapObject(expr, scope) {
      return parse4(expr).compile().evaluate(scope);
    },
    "Array | Matrix": function ArrayMatrix(expr) {
      var scope = createEmptyMap();
      return deepMap(expr, function(entry) {
        return parse4(entry).compile().evaluate(scope);
      });
    },
    "Array | Matrix, Map | Object": function ArrayMatrixMapObject(expr, scope) {
      return deepMap(expr, function(entry) {
        return parse4(entry).compile().evaluate(scope);
      });
    }
  });
});

// node_modules/mathjs/lib/esm/expression/Parser.js
var name225 = "Parser";
var dependencies226 = ["evaluate"];
var createParserClass = /* @__PURE__ */ factory(name225, dependencies226, (_ref) => {
  var {
    evaluate: evaluate2
  } = _ref;
  function Parser3() {
    if (!(this instanceof Parser3)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    Object.defineProperty(this, "scope", {
      value: createEmptyMap(),
      writable: false
    });
  }
  Parser3.prototype.type = "Parser";
  Parser3.prototype.isParser = true;
  Parser3.prototype.evaluate = function(expr) {
    return evaluate2(expr, this.scope);
  };
  Parser3.prototype.get = function(name314) {
    if (this.scope.has(name314)) {
      return this.scope.get(name314);
    }
  };
  Parser3.prototype.getAll = function() {
    return toObject(this.scope);
  };
  Parser3.prototype.getAllAsMap = function() {
    return this.scope;
  };
  Parser3.prototype.set = function(name314, value) {
    this.scope.set(name314, value);
    return value;
  };
  Parser3.prototype.remove = function(name314) {
    this.scope.delete(name314);
  };
  Parser3.prototype.clear = function() {
    this.scope.clear();
  };
  return Parser3;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/expression/function/parser.js
var name226 = "parser";
var dependencies227 = ["typed", "Parser"];
var createParser = /* @__PURE__ */ factory(name226, dependencies227, (_ref) => {
  var {
    typed: typed3,
    Parser: Parser3
  } = _ref;
  return typed3(name226, {
    "": function _() {
      return new Parser3();
    }
  });
});

// node_modules/mathjs/lib/esm/function/algebra/decomposition/lup.js
var name227 = "lup";
var dependencies228 = ["typed", "matrix", "abs", "addScalar", "divideScalar", "multiplyScalar", "subtractScalar", "larger", "equalScalar", "unaryMinus", "DenseMatrix", "SparseMatrix", "Spa"];
var createLup = /* @__PURE__ */ factory(name227, dependencies228, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    abs: abs3,
    addScalar: addScalar2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtractScalar: subtractScalar2,
    larger: larger2,
    equalScalar: equalScalar2,
    unaryMinus: unaryMinus2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2,
    Spa: Spa2
  } = _ref;
  return typed3(name227, {
    DenseMatrix: function DenseMatrix3(m) {
      return _denseLUP(m);
    },
    SparseMatrix: function SparseMatrix3(m) {
      return _sparseLUP(m);
    },
    Array: function Array2(a) {
      var m = matrix2(a);
      var r = _denseLUP(m);
      return {
        L: r.L.valueOf(),
        U: r.U.valueOf(),
        p: r.p
      };
    }
  });
  function _denseLUP(m) {
    var rows = m._size[0];
    var columns = m._size[1];
    var n = Math.min(rows, columns);
    var data = clone(m._data);
    var ldata = [];
    var lsize = [rows, n];
    var udata = [];
    var usize = [n, columns];
    var i2, j, k;
    var p = [];
    for (i2 = 0; i2 < rows; i2++) {
      p[i2] = i2;
    }
    for (j = 0; j < columns; j++) {
      if (j > 0) {
        for (i2 = 0; i2 < rows; i2++) {
          var min3 = Math.min(i2, j);
          var s = 0;
          for (k = 0; k < min3; k++) {
            s = addScalar2(s, multiplyScalar2(data[i2][k], data[k][j]));
          }
          data[i2][j] = subtractScalar2(data[i2][j], s);
        }
      }
      var pi3 = j;
      var pabsv = 0;
      var vjj = 0;
      for (i2 = j; i2 < rows; i2++) {
        var v = data[i2][j];
        var absv = abs3(v);
        if (larger2(absv, pabsv)) {
          pi3 = i2;
          pabsv = absv;
          vjj = v;
        }
      }
      if (j !== pi3) {
        p[j] = [p[pi3], p[pi3] = p[j]][0];
        DenseMatrix2._swapRows(j, pi3, data);
      }
      if (j < rows) {
        for (i2 = j + 1; i2 < rows; i2++) {
          var vij = data[i2][j];
          if (!equalScalar2(vij, 0)) {
            data[i2][j] = divideScalar2(data[i2][j], vjj);
          }
        }
      }
    }
    for (j = 0; j < columns; j++) {
      for (i2 = 0; i2 < rows; i2++) {
        if (j === 0) {
          if (i2 < columns) {
            udata[i2] = [];
          }
          ldata[i2] = [];
        }
        if (i2 < j) {
          if (i2 < columns) {
            udata[i2][j] = data[i2][j];
          }
          if (j < rows) {
            ldata[i2][j] = 0;
          }
          continue;
        }
        if (i2 === j) {
          if (i2 < columns) {
            udata[i2][j] = data[i2][j];
          }
          if (j < rows) {
            ldata[i2][j] = 1;
          }
          continue;
        }
        if (i2 < columns) {
          udata[i2][j] = 0;
        }
        if (j < rows) {
          ldata[i2][j] = data[i2][j];
        }
      }
    }
    var l = new DenseMatrix2({
      data: ldata,
      size: lsize
    });
    var u = new DenseMatrix2({
      data: udata,
      size: usize
    });
    var pv = [];
    for (i2 = 0, n = p.length; i2 < n; i2++) {
      pv[p[i2]] = i2;
    }
    return {
      L: l,
      U: u,
      p: pv,
      toString: function toString() {
        return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
      }
    };
  }
  function _sparseLUP(m) {
    var rows = m._size[0];
    var columns = m._size[1];
    var n = Math.min(rows, columns);
    var values = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    var lvalues = [];
    var lindex = [];
    var lptr = [];
    var lsize = [rows, n];
    var uvalues = [];
    var uindex = [];
    var uptr = [];
    var usize = [n, columns];
    var i2, j, k;
    var pvCo = [];
    var pvOc = [];
    for (i2 = 0; i2 < rows; i2++) {
      pvCo[i2] = i2;
      pvOc[i2] = i2;
    }
    var swapIndeces = function swapIndeces2(x, y) {
      var kx = pvOc[x];
      var ky = pvOc[y];
      pvCo[kx] = y;
      pvCo[ky] = x;
      pvOc[x] = ky;
      pvOc[y] = kx;
    };
    var _loop = function _loop2() {
      var spa = new Spa2();
      if (j < rows) {
        lptr.push(lvalues.length);
        lvalues.push(1);
        lindex.push(j);
      }
      uptr.push(uvalues.length);
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      for (k = k0; k < k1; k++) {
        i2 = index2[k];
        spa.set(pvCo[i2], values[k]);
      }
      if (j > 0) {
        spa.forEach(0, j - 1, function(k2, vkj) {
          SparseMatrix2._forEachRow(k2, lvalues, lindex, lptr, function(i3, vik) {
            if (i3 > k2) {
              spa.accumulate(i3, unaryMinus2(multiplyScalar2(vik, vkj)));
            }
          });
        });
      }
      var pi3 = j;
      var vjj = spa.get(j);
      var pabsv = abs3(vjj);
      spa.forEach(j + 1, rows - 1, function(x, v) {
        var absv = abs3(v);
        if (larger2(absv, pabsv)) {
          pi3 = x;
          pabsv = absv;
          vjj = v;
        }
      });
      if (j !== pi3) {
        SparseMatrix2._swapRows(j, pi3, lsize[1], lvalues, lindex, lptr);
        SparseMatrix2._swapRows(j, pi3, usize[1], uvalues, uindex, uptr);
        spa.swap(j, pi3);
        swapIndeces(j, pi3);
      }
      spa.forEach(0, rows - 1, function(x, v) {
        if (x <= j) {
          uvalues.push(v);
          uindex.push(x);
        } else {
          v = divideScalar2(v, vjj);
          if (!equalScalar2(v, 0)) {
            lvalues.push(v);
            lindex.push(x);
          }
        }
      });
    };
    for (j = 0; j < columns; j++) {
      _loop();
    }
    uptr.push(uvalues.length);
    lptr.push(lvalues.length);
    return {
      L: new SparseMatrix2({
        values: lvalues,
        index: lindex,
        ptr: lptr,
        size: lsize
      }),
      U: new SparseMatrix2({
        values: uvalues,
        index: uindex,
        ptr: uptr,
        size: usize
      }),
      p: pvCo,
      toString: function toString() {
        return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
      }
    };
  }
});

// node_modules/mathjs/lib/esm/function/algebra/decomposition/qr.js
var name228 = "qr";
var dependencies229 = ["typed", "matrix", "zeros", "identity", "isZero", "equal", "sign", "sqrt", "conj", "unaryMinus", "addScalar", "divideScalar", "multiplyScalar", "subtractScalar", "complex"];
var createQr = /* @__PURE__ */ factory(name228, dependencies229, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    zeros: zeros3,
    identity: identity2,
    isZero: isZero2,
    equal: equal2,
    sign: sign4,
    sqrt: sqrt3,
    conj: conj2,
    unaryMinus: unaryMinus2,
    addScalar: addScalar2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtractScalar: subtractScalar2,
    complex: complex2
  } = _ref;
  return _extends(typed3(name228, {
    DenseMatrix: function DenseMatrix2(m) {
      return _denseQR(m);
    },
    SparseMatrix: function SparseMatrix2(m) {
      return _sparseQR(m);
    },
    Array: function Array2(a) {
      var m = matrix2(a);
      var r = _denseQR(m);
      return {
        Q: r.Q.valueOf(),
        R: r.R.valueOf()
      };
    }
  }), {
    _denseQRimpl
  });
  function _denseQRimpl(m) {
    var rows = m._size[0];
    var cols = m._size[1];
    var Q2 = identity2([rows], "dense");
    var Qdata = Q2._data;
    var R = m.clone();
    var Rdata = R._data;
    var i2, j, k;
    var w = zeros3([rows], "");
    for (k = 0; k < Math.min(cols, rows); ++k) {
      var pivot = Rdata[k][k];
      var sgn = unaryMinus2(equal2(pivot, 0) ? 1 : sign4(pivot));
      var conjSgn = conj2(sgn);
      var alphaSquared = 0;
      for (i2 = k; i2 < rows; i2++) {
        alphaSquared = addScalar2(alphaSquared, multiplyScalar2(Rdata[i2][k], conj2(Rdata[i2][k])));
      }
      var alpha = multiplyScalar2(sgn, sqrt3(alphaSquared));
      if (!isZero2(alpha)) {
        var u1 = subtractScalar2(pivot, alpha);
        w[k] = 1;
        for (i2 = k + 1; i2 < rows; i2++) {
          w[i2] = divideScalar2(Rdata[i2][k], u1);
        }
        var tau3 = unaryMinus2(conj2(divideScalar2(u1, alpha)));
        var s = void 0;
        for (j = k; j < cols; j++) {
          s = 0;
          for (i2 = k; i2 < rows; i2++) {
            s = addScalar2(s, multiplyScalar2(conj2(w[i2]), Rdata[i2][j]));
          }
          s = multiplyScalar2(s, tau3);
          for (i2 = k; i2 < rows; i2++) {
            Rdata[i2][j] = multiplyScalar2(subtractScalar2(Rdata[i2][j], multiplyScalar2(w[i2], s)), conjSgn);
          }
        }
        for (i2 = 0; i2 < rows; i2++) {
          s = 0;
          for (j = k; j < rows; j++) {
            s = addScalar2(s, multiplyScalar2(Qdata[i2][j], w[j]));
          }
          s = multiplyScalar2(s, tau3);
          for (j = k; j < rows; ++j) {
            Qdata[i2][j] = divideScalar2(subtractScalar2(Qdata[i2][j], multiplyScalar2(s, conj2(w[j]))), conjSgn);
          }
        }
      }
    }
    return {
      Q: Q2,
      R,
      toString: function toString() {
        return "Q: " + this.Q.toString() + "\nR: " + this.R.toString();
      }
    };
  }
  function _denseQR(m) {
    var ret = _denseQRimpl(m);
    var Rdata = ret.R._data;
    if (m._data.length > 0) {
      var zero = Rdata[0][0].type === "Complex" ? complex2(0) : 0;
      for (var i2 = 0; i2 < Rdata.length; ++i2) {
        for (var j = 0; j < i2 && j < (Rdata[0] || []).length; ++j) {
          Rdata[i2][j] = zero;
        }
      }
    }
    return ret;
  }
  function _sparseQR(m) {
    throw new Error("qr not implemented for sparse matrices yet");
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csPermute.js
function csPermute(a, pinv2, q, values) {
  var avalues = a._values;
  var aindex = a._index;
  var aptr = a._ptr;
  var asize = a._size;
  var adt = a._datatype;
  var m = asize[0];
  var n = asize[1];
  var cvalues = values && a._values ? [] : null;
  var cindex = [];
  var cptr = [];
  var nz = 0;
  for (var k = 0; k < n; k++) {
    cptr[k] = nz;
    var j = q ? q[k] : k;
    for (var t0 = aptr[j], t1 = aptr[j + 1], t = t0; t < t1; t++) {
      var r = pinv2 ? pinv2[aindex[t]] : aindex[t];
      cindex[nz] = r;
      if (cvalues) {
        cvalues[nz] = avalues[t];
      }
      nz++;
    }
  }
  cptr[n] = nz;
  return a.createSparseMatrix({
    values: cvalues,
    index: cindex,
    ptr: cptr,
    size: [m, n],
    datatype: adt
  });
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csTdfs.js
function csTdfs(j, k, w, head, next, post, stack) {
  var top = 0;
  w[stack] = j;
  while (top >= 0) {
    var p = w[stack + top];
    var i2 = w[head + p];
    if (i2 === -1) {
      top--;
      post[k++] = p;
    } else {
      w[head + p] = w[next + i2];
      ++top;
      w[stack + top] = i2;
    }
  }
  return k;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csPost.js
function csPost(parent, n) {
  if (!parent) {
    return null;
  }
  var k = 0;
  var j;
  var post = [];
  var w = [];
  var head = 0;
  var next = n;
  var stack = 2 * n;
  for (j = 0; j < n; j++) {
    w[head + j] = -1;
  }
  for (j = n - 1; j >= 0; j--) {
    if (parent[j] === -1) {
      continue;
    }
    w[next + j] = w[head + parent[j]];
    w[head + parent[j]] = j;
  }
  for (j = 0; j < n; j++) {
    if (parent[j] !== -1) {
      continue;
    }
    k = csTdfs(j, k, w, head, next, post, stack);
  }
  return post;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csEtree.js
function csEtree(a, ata) {
  if (!a) {
    return null;
  }
  var aindex = a._index;
  var aptr = a._ptr;
  var asize = a._size;
  var m = asize[0];
  var n = asize[1];
  var parent = [];
  var w = [];
  var ancestor = 0;
  var prev = n;
  var i2, inext;
  if (ata) {
    for (i2 = 0; i2 < m; i2++) {
      w[prev + i2] = -1;
    }
  }
  for (var k = 0; k < n; k++) {
    parent[k] = -1;
    w[ancestor + k] = -1;
    for (var p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {
      var r = aindex[p];
      i2 = ata ? w[prev + r] : r;
      for (; i2 !== -1 && i2 < k; i2 = inext) {
        inext = w[ancestor + i2];
        w[ancestor + i2] = k;
        if (inext === -1) {
          parent[i2] = k;
        }
      }
      if (ata) {
        w[prev + r] = k;
      }
    }
  }
  return parent;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csFkeep.js
function csFkeep(a, callback, other) {
  var avalues = a._values;
  var aindex = a._index;
  var aptr = a._ptr;
  var asize = a._size;
  var n = asize[1];
  var nz = 0;
  for (var j = 0; j < n; j++) {
    var p = aptr[j];
    aptr[j] = nz;
    for (; p < aptr[j + 1]; p++) {
      if (callback(aindex[p], j, avalues ? avalues[p] : 1, other)) {
        aindex[nz] = aindex[p];
        if (avalues) {
          avalues[nz] = avalues[p];
        }
        nz++;
      }
    }
  }
  aptr[n] = nz;
  aindex.splice(nz, aindex.length - nz);
  if (avalues) {
    avalues.splice(nz, avalues.length - nz);
  }
  return nz;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csFlip.js
function csFlip(i2) {
  return -i2 - 2;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csAmd.js
var name229 = "csAmd";
var dependencies230 = ["add", "multiply", "transpose"];
var createCsAmd = /* @__PURE__ */ factory(name229, dependencies230, (_ref) => {
  var {
    add: add3,
    multiply: multiply2,
    transpose: transpose2
  } = _ref;
  return function csAmd(order, a) {
    if (!a || order <= 0 || order > 3) {
      return null;
    }
    var asize = a._size;
    var m = asize[0];
    var n = asize[1];
    var lemax = 0;
    var dense = Math.max(16, 10 * Math.sqrt(n));
    dense = Math.min(n - 2, dense);
    var cm = _createTargetMatrix(order, a, m, n, dense);
    csFkeep(cm, _diag, null);
    var cindex = cm._index;
    var cptr = cm._ptr;
    var cnz = cptr[n];
    var P4 = [];
    var W = [];
    var len = 0;
    var nv = n + 1;
    var next = 2 * (n + 1);
    var head = 3 * (n + 1);
    var elen = 4 * (n + 1);
    var degree = 5 * (n + 1);
    var w = 6 * (n + 1);
    var hhead = 7 * (n + 1);
    var last = P4;
    var mark = _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree);
    var nel = _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next);
    var mindeg = 0;
    var i2, j, k, k1, k2, e3, pj, ln2, nvi, pk, eln, p1, p2, pn, h, d;
    while (nel < n) {
      for (k = -1; mindeg < n && (k = W[head + mindeg]) === -1; mindeg++)
        ;
      if (W[next + k] !== -1) {
        last[W[next + k]] = -1;
      }
      W[head + mindeg] = W[next + k];
      var elenk = W[elen + k];
      var nvk = W[nv + k];
      nel += nvk;
      var dk = 0;
      W[nv + k] = -nvk;
      var p = cptr[k];
      var pk1 = elenk === 0 ? p : cnz;
      var pk2 = pk1;
      for (k1 = 1; k1 <= elenk + 1; k1++) {
        if (k1 > elenk) {
          e3 = k;
          pj = p;
          ln2 = W[len + k] - elenk;
        } else {
          e3 = cindex[p++];
          pj = cptr[e3];
          ln2 = W[len + e3];
        }
        for (k2 = 1; k2 <= ln2; k2++) {
          i2 = cindex[pj++];
          if ((nvi = W[nv + i2]) <= 0) {
            continue;
          }
          dk += nvi;
          W[nv + i2] = -nvi;
          cindex[pk2++] = i2;
          if (W[next + i2] !== -1) {
            last[W[next + i2]] = last[i2];
          }
          if (last[i2] !== -1) {
            W[next + last[i2]] = W[next + i2];
          } else {
            W[head + W[degree + i2]] = W[next + i2];
          }
        }
        if (e3 !== k) {
          cptr[e3] = csFlip(k);
          W[w + e3] = 0;
        }
      }
      if (elenk !== 0) {
        cnz = pk2;
      }
      W[degree + k] = dk;
      cptr[k] = pk1;
      W[len + k] = pk2 - pk1;
      W[elen + k] = -2;
      mark = _wclear(mark, lemax, W, w, n);
      for (pk = pk1; pk < pk2; pk++) {
        i2 = cindex[pk];
        if ((eln = W[elen + i2]) <= 0) {
          continue;
        }
        nvi = -W[nv + i2];
        var wnvi = mark - nvi;
        for (p = cptr[i2], p1 = cptr[i2] + eln - 1; p <= p1; p++) {
          e3 = cindex[p];
          if (W[w + e3] >= mark) {
            W[w + e3] -= nvi;
          } else if (W[w + e3] !== 0) {
            W[w + e3] = W[degree + e3] + wnvi;
          }
        }
      }
      for (pk = pk1; pk < pk2; pk++) {
        i2 = cindex[pk];
        p1 = cptr[i2];
        p2 = p1 + W[elen + i2] - 1;
        pn = p1;
        for (h = 0, d = 0, p = p1; p <= p2; p++) {
          e3 = cindex[p];
          if (W[w + e3] !== 0) {
            var dext = W[w + e3] - mark;
            if (dext > 0) {
              d += dext;
              cindex[pn++] = e3;
              h += e3;
            } else {
              cptr[e3] = csFlip(k);
              W[w + e3] = 0;
            }
          }
        }
        W[elen + i2] = pn - p1 + 1;
        var p3 = pn;
        var p4 = p1 + W[len + i2];
        for (p = p2 + 1; p < p4; p++) {
          j = cindex[p];
          var nvj = W[nv + j];
          if (nvj <= 0) {
            continue;
          }
          d += nvj;
          cindex[pn++] = j;
          h += j;
        }
        if (d === 0) {
          cptr[i2] = csFlip(k);
          nvi = -W[nv + i2];
          dk -= nvi;
          nvk += nvi;
          nel += nvi;
          W[nv + i2] = 0;
          W[elen + i2] = -1;
        } else {
          W[degree + i2] = Math.min(W[degree + i2], d);
          cindex[pn] = cindex[p3];
          cindex[p3] = cindex[p1];
          cindex[p1] = k;
          W[len + i2] = pn - p1 + 1;
          h = (h < 0 ? -h : h) % n;
          W[next + i2] = W[hhead + h];
          W[hhead + h] = i2;
          last[i2] = h;
        }
      }
      W[degree + k] = dk;
      lemax = Math.max(lemax, dk);
      mark = _wclear(mark + lemax, lemax, W, w, n);
      for (pk = pk1; pk < pk2; pk++) {
        i2 = cindex[pk];
        if (W[nv + i2] >= 0) {
          continue;
        }
        h = last[i2];
        i2 = W[hhead + h];
        W[hhead + h] = -1;
        for (; i2 !== -1 && W[next + i2] !== -1; i2 = W[next + i2], mark++) {
          ln2 = W[len + i2];
          eln = W[elen + i2];
          for (p = cptr[i2] + 1; p <= cptr[i2] + ln2 - 1; p++) {
            W[w + cindex[p]] = mark;
          }
          var jlast = i2;
          for (j = W[next + i2]; j !== -1; ) {
            var ok = W[len + j] === ln2 && W[elen + j] === eln;
            for (p = cptr[j] + 1; ok && p <= cptr[j] + ln2 - 1; p++) {
              if (W[w + cindex[p]] !== mark) {
                ok = 0;
              }
            }
            if (ok) {
              cptr[j] = csFlip(i2);
              W[nv + i2] += W[nv + j];
              W[nv + j] = 0;
              W[elen + j] = -1;
              j = W[next + j];
              W[next + jlast] = j;
            } else {
              jlast = j;
              j = W[next + j];
            }
          }
        }
      }
      for (p = pk1, pk = pk1; pk < pk2; pk++) {
        i2 = cindex[pk];
        if ((nvi = -W[nv + i2]) <= 0) {
          continue;
        }
        W[nv + i2] = nvi;
        d = W[degree + i2] + dk - nvi;
        d = Math.min(d, n - nel - nvi);
        if (W[head + d] !== -1) {
          last[W[head + d]] = i2;
        }
        W[next + i2] = W[head + d];
        last[i2] = -1;
        W[head + d] = i2;
        mindeg = Math.min(mindeg, d);
        W[degree + i2] = d;
        cindex[p++] = i2;
      }
      W[nv + k] = nvk;
      if ((W[len + k] = p - pk1) === 0) {
        cptr[k] = -1;
        W[w + k] = 0;
      }
      if (elenk !== 0) {
        cnz = p;
      }
    }
    for (i2 = 0; i2 < n; i2++) {
      cptr[i2] = csFlip(cptr[i2]);
    }
    for (j = 0; j <= n; j++) {
      W[head + j] = -1;
    }
    for (j = n; j >= 0; j--) {
      if (W[nv + j] > 0) {
        continue;
      }
      W[next + j] = W[head + cptr[j]];
      W[head + cptr[j]] = j;
    }
    for (e3 = n; e3 >= 0; e3--) {
      if (W[nv + e3] <= 0) {
        continue;
      }
      if (cptr[e3] !== -1) {
        W[next + e3] = W[head + cptr[e3]];
        W[head + cptr[e3]] = e3;
      }
    }
    for (k = 0, i2 = 0; i2 <= n; i2++) {
      if (cptr[i2] === -1) {
        k = csTdfs(i2, k, W, head, next, P4, w);
      }
    }
    P4.splice(P4.length - 1, 1);
    return P4;
  };
  function _createTargetMatrix(order, a, m, n, dense) {
    var at = transpose2(a);
    if (order === 1 && n === m) {
      return add3(a, at);
    }
    if (order === 2) {
      var tindex = at._index;
      var tptr = at._ptr;
      var p2 = 0;
      for (var j = 0; j < m; j++) {
        var p = tptr[j];
        tptr[j] = p2;
        if (tptr[j + 1] - p > dense) {
          continue;
        }
        for (var p1 = tptr[j + 1]; p < p1; p++) {
          tindex[p2++] = tindex[p];
        }
      }
      tptr[m] = p2;
      a = transpose2(at);
      return multiply2(at, a);
    }
    return multiply2(at, a);
  }
  function _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree) {
    for (var k = 0; k < n; k++) {
      W[len + k] = cptr[k + 1] - cptr[k];
    }
    W[len + n] = 0;
    for (var i2 = 0; i2 <= n; i2++) {
      W[head + i2] = -1;
      last[i2] = -1;
      W[next + i2] = -1;
      W[hhead + i2] = -1;
      W[nv + i2] = 1;
      W[w + i2] = 1;
      W[elen + i2] = 0;
      W[degree + i2] = W[len + i2];
    }
    var mark = _wclear(0, 0, W, w, n);
    W[elen + n] = -2;
    cptr[n] = -1;
    W[w + n] = 0;
    return mark;
  }
  function _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next) {
    var nel = 0;
    for (var i2 = 0; i2 < n; i2++) {
      var d = W[degree + i2];
      if (d === 0) {
        W[elen + i2] = -2;
        nel++;
        cptr[i2] = -1;
        W[w + i2] = 0;
      } else if (d > dense) {
        W[nv + i2] = 0;
        W[elen + i2] = -1;
        nel++;
        cptr[i2] = csFlip(n);
        W[nv + n]++;
      } else {
        var h = W[head + d];
        if (h !== -1) {
          last[h] = i2;
        }
        W[next + i2] = W[head + d];
        W[head + d] = i2;
      }
    }
    return nel;
  }
  function _wclear(mark, lemax, W, w, n) {
    if (mark < 2 || mark + lemax < 0) {
      for (var k = 0; k < n; k++) {
        if (W[w + k] !== 0) {
          W[w + k] = 1;
        }
      }
      mark = 2;
    }
    return mark;
  }
  function _diag(i2, j) {
    return i2 !== j;
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csLeaf.js
function csLeaf(i2, j, w, first, maxfirst, prevleaf, ancestor) {
  var s, sparent;
  var jleaf = 0;
  var q;
  if (i2 <= j || w[first + j] <= w[maxfirst + i2]) {
    return -1;
  }
  w[maxfirst + i2] = w[first + j];
  var jprev = w[prevleaf + i2];
  w[prevleaf + i2] = j;
  if (jprev === -1) {
    jleaf = 1;
    q = i2;
  } else {
    jleaf = 2;
    for (q = jprev; q !== w[ancestor + q]; q = w[ancestor + q])
      ;
    for (s = jprev; s !== q; s = sparent) {
      sparent = w[ancestor + s];
      w[ancestor + s] = q;
    }
  }
  return {
    jleaf,
    q
  };
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csCounts.js
var name230 = "csCounts";
var dependencies231 = ["transpose"];
var createCsCounts = /* @__PURE__ */ factory(name230, dependencies231, (_ref) => {
  var {
    transpose: transpose2
  } = _ref;
  return function(a, parent, post, ata) {
    if (!a || !parent || !post) {
      return null;
    }
    var asize = a._size;
    var m = asize[0];
    var n = asize[1];
    var i2, j, k, J, p, p0, p1;
    var s = 4 * n + (ata ? n + m + 1 : 0);
    var w = [];
    var ancestor = 0;
    var maxfirst = n;
    var prevleaf = 2 * n;
    var first = 3 * n;
    var head = 4 * n;
    var next = 5 * n + 1;
    for (k = 0; k < s; k++) {
      w[k] = -1;
    }
    var colcount = [];
    var at = transpose2(a);
    var tindex = at._index;
    var tptr = at._ptr;
    for (k = 0; k < n; k++) {
      j = post[k];
      colcount[j] = w[first + j] === -1 ? 1 : 0;
      for (; j !== -1 && w[first + j] === -1; j = parent[j]) {
        w[first + j] = k;
      }
    }
    if (ata) {
      for (k = 0; k < n; k++) {
        w[post[k]] = k;
      }
      for (i2 = 0; i2 < m; i2++) {
        for (k = n, p0 = tptr[i2], p1 = tptr[i2 + 1], p = p0; p < p1; p++) {
          k = Math.min(k, w[tindex[p]]);
        }
        w[next + i2] = w[head + k];
        w[head + k] = i2;
      }
    }
    for (i2 = 0; i2 < n; i2++) {
      w[ancestor + i2] = i2;
    }
    for (k = 0; k < n; k++) {
      j = post[k];
      if (parent[j] !== -1) {
        colcount[parent[j]]--;
      }
      for (J = ata ? w[head + k] : j; J !== -1; J = ata ? w[next + J] : -1) {
        for (p = tptr[J]; p < tptr[J + 1]; p++) {
          i2 = tindex[p];
          var r = csLeaf(i2, j, w, first, maxfirst, prevleaf, ancestor);
          if (r.jleaf >= 1) {
            colcount[j]++;
          }
          if (r.jleaf === 2) {
            colcount[r.q]--;
          }
        }
      }
      if (parent[j] !== -1) {
        w[ancestor + j] = parent[j];
      }
    }
    for (j = 0; j < n; j++) {
      if (parent[j] !== -1) {
        colcount[parent[j]] += colcount[j];
      }
    }
    return colcount;
  };
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csSqr.js
var name231 = "csSqr";
var dependencies232 = ["add", "multiply", "transpose"];
var createCsSqr = /* @__PURE__ */ factory(name231, dependencies232, (_ref) => {
  var {
    add: add3,
    multiply: multiply2,
    transpose: transpose2
  } = _ref;
  var csAmd = createCsAmd({
    add: add3,
    multiply: multiply2,
    transpose: transpose2
  });
  var csCounts = createCsCounts({
    transpose: transpose2
  });
  return function csSqr(order, a, qr2) {
    var aptr = a._ptr;
    var asize = a._size;
    var n = asize[1];
    var k;
    var s = {};
    s.q = csAmd(order, a);
    if (order && !s.q) {
      return null;
    }
    if (qr2) {
      var c = order ? csPermute(a, null, s.q, 0) : a;
      s.parent = csEtree(c, 1);
      var post = csPost(s.parent, n);
      s.cp = csCounts(c, s.parent, post, 1);
      if (c && s.parent && s.cp && _vcount(c, s)) {
        for (s.unz = 0, k = 0; k < n; k++) {
          s.unz += s.cp[k];
        }
      }
    } else {
      s.unz = 4 * aptr[n] + n;
      s.lnz = s.unz;
    }
    return s;
  };
  function _vcount(a, s) {
    var aptr = a._ptr;
    var aindex = a._index;
    var asize = a._size;
    var m = asize[0];
    var n = asize[1];
    s.pinv = [];
    s.leftmost = [];
    var parent = s.parent;
    var pinv2 = s.pinv;
    var leftmost = s.leftmost;
    var w = [];
    var next = 0;
    var head = m;
    var tail = m + n;
    var nque = m + 2 * n;
    var i2, k, p, p0, p1;
    for (k = 0; k < n; k++) {
      w[head + k] = -1;
      w[tail + k] = -1;
      w[nque + k] = 0;
    }
    for (i2 = 0; i2 < m; i2++) {
      leftmost[i2] = -1;
    }
    for (k = n - 1; k >= 0; k--) {
      for (p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {
        leftmost[aindex[p]] = k;
      }
    }
    for (i2 = m - 1; i2 >= 0; i2--) {
      pinv2[i2] = -1;
      k = leftmost[i2];
      if (k === -1) {
        continue;
      }
      if (w[nque + k]++ === 0) {
        w[tail + k] = i2;
      }
      w[next + i2] = w[head + k];
      w[head + k] = i2;
    }
    s.lnz = 0;
    s.m2 = m;
    for (k = 0; k < n; k++) {
      i2 = w[head + k];
      s.lnz++;
      if (i2 < 0) {
        i2 = s.m2++;
      }
      pinv2[i2] = k;
      if (--nque[k] <= 0) {
        continue;
      }
      s.lnz += w[nque + k];
      var pa = parent[k];
      if (pa !== -1) {
        if (w[nque + pa] === 0) {
          w[tail + pa] = w[tail + k];
        }
        w[next + w[tail + k]] = w[head + pa];
        w[head + pa] = w[next + i2];
        w[nque + pa] += w[nque + k];
      }
    }
    for (i2 = 0; i2 < m; i2++) {
      if (pinv2[i2] < 0) {
        pinv2[i2] = k++;
      }
    }
    return true;
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csMarked.js
function csMarked(w, j) {
  return w[j] < 0;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csMark.js
function csMark(w, j) {
  w[j] = csFlip(w[j]);
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csUnflip.js
function csUnflip(i2) {
  return i2 < 0 ? csFlip(i2) : i2;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csDfs.js
function csDfs(j, g, top, xi, pinv2) {
  var index2 = g._index;
  var ptr = g._ptr;
  var size2 = g._size;
  var n = size2[1];
  var i2, p, p2;
  var head = 0;
  xi[0] = j;
  while (head >= 0) {
    j = xi[head];
    var jnew = pinv2 ? pinv2[j] : j;
    if (!csMarked(ptr, j)) {
      csMark(ptr, j);
      xi[n + head] = jnew < 0 ? 0 : csUnflip(ptr[jnew]);
    }
    var done = 1;
    for (p = xi[n + head], p2 = jnew < 0 ? 0 : csUnflip(ptr[jnew + 1]); p < p2; p++) {
      i2 = index2[p];
      if (csMarked(ptr, i2)) {
        continue;
      }
      xi[n + head] = p;
      xi[++head] = i2;
      done = 0;
      break;
    }
    if (done) {
      head--;
      xi[--top] = j;
    }
  }
  return top;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csReach.js
function csReach(g, b, k, xi, pinv2) {
  var gptr = g._ptr;
  var gsize = g._size;
  var bindex = b._index;
  var bptr = b._ptr;
  var n = gsize[1];
  var p, p0, p1;
  var top = n;
  for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {
    var i2 = bindex[p];
    if (!csMarked(gptr, i2)) {
      top = csDfs(i2, g, top, xi, pinv2);
    }
  }
  for (p = top; p < n; p++) {
    csMark(gptr, xi[p]);
  }
  return top;
}

// node_modules/mathjs/lib/esm/function/algebra/sparse/csSpsolve.js
var name232 = "csSpsolve";
var dependencies233 = ["divideScalar", "multiply", "subtract"];
var createCsSpsolve = /* @__PURE__ */ factory(name232, dependencies233, (_ref) => {
  var {
    divideScalar: divideScalar2,
    multiply: multiply2,
    subtract: subtract2
  } = _ref;
  return function csSpsolve(g, b, k, xi, x, pinv2, lo) {
    var gvalues = g._values;
    var gindex = g._index;
    var gptr = g._ptr;
    var gsize = g._size;
    var n = gsize[1];
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var p, p0, p1, q;
    var top = csReach(g, b, k, xi, pinv2);
    for (p = top; p < n; p++) {
      x[xi[p]] = 0;
    }
    for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {
      x[bindex[p]] = bvalues[p];
    }
    for (var px = top; px < n; px++) {
      var j = xi[px];
      var J = pinv2 ? pinv2[j] : j;
      if (J < 0) {
        continue;
      }
      p0 = gptr[J];
      p1 = gptr[J + 1];
      x[j] = divideScalar2(x[j], gvalues[lo ? p0 : p1 - 1]);
      p = lo ? p0 + 1 : p0;
      q = lo ? p1 : p1 - 1;
      for (; p < q; p++) {
        var i2 = gindex[p];
        x[i2] = subtract2(x[i2], multiply2(gvalues[p], x[j]));
      }
    }
    return top;
  };
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csLu.js
var name233 = "csLu";
var dependencies234 = ["abs", "divideScalar", "multiply", "subtract", "larger", "largerEq", "SparseMatrix"];
var createCsLu = /* @__PURE__ */ factory(name233, dependencies234, (_ref) => {
  var {
    abs: abs3,
    divideScalar: divideScalar2,
    multiply: multiply2,
    subtract: subtract2,
    larger: larger2,
    largerEq: largerEq2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  var csSpsolve = createCsSpsolve({
    divideScalar: divideScalar2,
    multiply: multiply2,
    subtract: subtract2
  });
  return function csLu(m, s, tol) {
    if (!m) {
      return null;
    }
    var size2 = m._size;
    var n = size2[1];
    var q;
    var lnz = 100;
    var unz = 100;
    if (s) {
      q = s.q;
      lnz = s.lnz || lnz;
      unz = s.unz || unz;
    }
    var lvalues = [];
    var lindex = [];
    var lptr = [];
    var L = new SparseMatrix2({
      values: lvalues,
      index: lindex,
      ptr: lptr,
      size: [n, n]
    });
    var uvalues = [];
    var uindex = [];
    var uptr = [];
    var U = new SparseMatrix2({
      values: uvalues,
      index: uindex,
      ptr: uptr,
      size: [n, n]
    });
    var pinv2 = [];
    var i2, p;
    var x = [];
    var xi = [];
    for (i2 = 0; i2 < n; i2++) {
      x[i2] = 0;
      pinv2[i2] = -1;
      lptr[i2 + 1] = 0;
    }
    lnz = 0;
    unz = 0;
    for (var k = 0; k < n; k++) {
      lptr[k] = lnz;
      uptr[k] = unz;
      var col = q ? q[k] : k;
      var top = csSpsolve(L, m, col, xi, x, pinv2, 1);
      var ipiv = -1;
      var a = -1;
      for (p = top; p < n; p++) {
        i2 = xi[p];
        if (pinv2[i2] < 0) {
          var xabs = abs3(x[i2]);
          if (larger2(xabs, a)) {
            a = xabs;
            ipiv = i2;
          }
        } else {
          uindex[unz] = pinv2[i2];
          uvalues[unz++] = x[i2];
        }
      }
      if (ipiv === -1 || a <= 0) {
        return null;
      }
      if (pinv2[col] < 0 && largerEq2(abs3(x[col]), multiply2(a, tol))) {
        ipiv = col;
      }
      var pivot = x[ipiv];
      uindex[unz] = k;
      uvalues[unz++] = pivot;
      pinv2[ipiv] = k;
      lindex[lnz] = ipiv;
      lvalues[lnz++] = 1;
      for (p = top; p < n; p++) {
        i2 = xi[p];
        if (pinv2[i2] < 0) {
          lindex[lnz] = i2;
          lvalues[lnz++] = divideScalar2(x[i2], pivot);
        }
        x[i2] = 0;
      }
    }
    lptr[n] = lnz;
    uptr[n] = unz;
    for (p = 0; p < lnz; p++) {
      lindex[p] = pinv2[lindex[p]];
    }
    lvalues.splice(lnz, lvalues.length - lnz);
    lindex.splice(lnz, lindex.length - lnz);
    uvalues.splice(unz, uvalues.length - unz);
    uindex.splice(unz, uindex.length - unz);
    return {
      L,
      U,
      pinv: pinv2
    };
  };
});

// node_modules/mathjs/lib/esm/function/algebra/decomposition/slu.js
var name234 = "slu";
var dependencies235 = ["typed", "abs", "add", "multiply", "transpose", "divideScalar", "subtract", "larger", "largerEq", "SparseMatrix"];
var createSlu = /* @__PURE__ */ factory(name234, dependencies235, (_ref) => {
  var {
    typed: typed3,
    abs: abs3,
    add: add3,
    multiply: multiply2,
    transpose: transpose2,
    divideScalar: divideScalar2,
    subtract: subtract2,
    larger: larger2,
    largerEq: largerEq2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  var csSqr = createCsSqr({
    add: add3,
    multiply: multiply2,
    transpose: transpose2
  });
  var csLu = createCsLu({
    abs: abs3,
    divideScalar: divideScalar2,
    multiply: multiply2,
    subtract: subtract2,
    larger: larger2,
    largerEq: largerEq2,
    SparseMatrix: SparseMatrix2
  });
  return typed3(name234, {
    "SparseMatrix, number, number": function SparseMatrixNumberNumber(a, order, threshold) {
      if (!isInteger(order) || order < 0 || order > 3) {
        throw new Error("Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]");
      }
      if (threshold < 0 || threshold > 1) {
        throw new Error("Partial pivoting threshold must be a number from 0 to 1");
      }
      var s = csSqr(order, a, false);
      var f = csLu(a, s, threshold);
      return {
        L: f.L,
        U: f.U,
        p: f.pinv,
        q: s.q,
        toString: function toString() {
          return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\np: " + this.p.toString() + (this.q ? "\nq: " + this.q.toString() : "") + "\n";
        }
      };
    }
  });
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csIpvec.js
function csIpvec(p, b) {
  var k;
  var n = b.length;
  var x = [];
  if (p) {
    for (k = 0; k < n; k++) {
      x[p[k]] = b[k];
    }
  } else {
    for (k = 0; k < n; k++) {
      x[k] = b[k];
    }
  }
  return x;
}

// node_modules/mathjs/lib/esm/function/algebra/solver/lusolve.js
var name235 = "lusolve";
var dependencies236 = ["typed", "matrix", "lup", "slu", "usolve", "lsolve", "DenseMatrix"];
var createLusolve = /* @__PURE__ */ factory(name235, dependencies236, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    lup: lup2,
    slu: slu2,
    usolve: usolve2,
    lsolve: lsolve2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix: DenseMatrix2
  });
  return typed3(name235, {
    "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
      a = matrix2(a);
      var d = lup2(a);
      var x = _lusolve(d.L, d.U, d.p, null, b);
      return x.valueOf();
    },
    "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(a, b) {
      var d = lup2(a);
      return _lusolve(d.L, d.U, d.p, null, b);
    },
    "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(a, b) {
      var d = lup2(a);
      return _lusolve(d.L, d.U, d.p, null, b);
    },
    "SparseMatrix, Array | Matrix, number, number": function SparseMatrixArrayMatrixNumberNumber(a, b, order, threshold) {
      var d = slu2(a, order, threshold);
      return _lusolve(d.L, d.U, d.p, d.q, b);
    },
    "Object, Array | Matrix": function ObjectArrayMatrix(d, b) {
      return _lusolve(d.L, d.U, d.p, d.q, b);
    }
  });
  function _toMatrix(a) {
    if (isMatrix(a)) {
      return a;
    }
    if (isArray(a)) {
      return matrix2(a);
    }
    throw new TypeError("Invalid Matrix LU decomposition");
  }
  function _lusolve(l, u, p, q, b) {
    l = _toMatrix(l);
    u = _toMatrix(u);
    if (p) {
      b = solveValidation(l, b, true);
      b._data = csIpvec(p, b._data);
    }
    var y = lsolve2(l, b);
    var x = usolve2(u, y);
    if (q) {
      x._data = csIpvec(q, x._data);
    }
    return x;
  }
});

// node_modules/mathjs/lib/esm/function/algebra/polynomialRoot.js
var name236 = "polynomialRoot";
var dependencies237 = ["typed", "isZero", "equalScalar", "add", "subtract", "multiply", "divide", "sqrt", "unaryMinus", "cbrt", "typeOf", "im", "re"];
var createPolynomialRoot = /* @__PURE__ */ factory(name236, dependencies237, (_ref) => {
  var {
    typed: typed3,
    isZero: isZero2,
    equalScalar: equalScalar2,
    add: add3,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide3,
    sqrt: sqrt3,
    unaryMinus: unaryMinus2,
    cbrt: cbrt5,
    typeOf: typeOf3,
    im: im2,
    re: re2
  } = _ref;
  return typed3(name236, {
    "number|Complex, ...number|Complex": (constant, restCoeffs) => {
      var coeffs = [constant, ...restCoeffs];
      while (coeffs.length > 0 && isZero2(coeffs[coeffs.length - 1])) {
        coeffs.pop();
      }
      if (coeffs.length < 2) {
        throw new RangeError("Polynomial [".concat(constant, ", ").concat(restCoeffs, "] must have a non-zero non-constant coefficient"));
      }
      switch (coeffs.length) {
        case 2:
          return [unaryMinus2(divide3(coeffs[0], coeffs[1]))];
        case 3: {
          var [c, b, a] = coeffs;
          var denom = multiply2(2, a);
          var d1 = multiply2(b, b);
          var d2 = multiply2(4, a, c);
          if (equalScalar2(d1, d2))
            return [divide3(unaryMinus2(b), denom)];
          var discriminant = sqrt3(subtract2(d1, d2));
          return [divide3(subtract2(discriminant, b), denom), divide3(subtract2(unaryMinus2(discriminant), b), denom)];
        }
        case 4: {
          var [d, _c, _b, _a] = coeffs;
          var _denom = unaryMinus2(multiply2(3, _a));
          var D0_1 = multiply2(_b, _b);
          var D0_2 = multiply2(3, _a, _c);
          var D1_1 = add3(multiply2(2, _b, _b, _b), multiply2(27, _a, _a, d));
          var D1_2 = multiply2(9, _a, _b, _c);
          if (equalScalar2(D0_1, D0_2) && equalScalar2(D1_1, D1_2)) {
            return [divide3(_b, _denom)];
          }
          var Delta0 = subtract2(D0_1, D0_2);
          var Delta1 = subtract2(D1_1, D1_2);
          var discriminant1 = add3(multiply2(18, _a, _b, _c, d), multiply2(_b, _b, _c, _c));
          var discriminant2 = add3(multiply2(4, _b, _b, _b, d), multiply2(4, _a, _c, _c, _c), multiply2(27, _a, _a, d, d));
          if (equalScalar2(discriminant1, discriminant2)) {
            return [
              divide3(subtract2(multiply2(4, _a, _b, _c), add3(multiply2(9, _a, _a, d), multiply2(_b, _b, _b))), multiply2(_a, Delta0)),
              // simple root
              divide3(subtract2(multiply2(9, _a, d), multiply2(_b, _c)), multiply2(2, Delta0))
              // double root
            ];
          }
          var Ccubed;
          if (equalScalar2(D0_1, D0_2)) {
            Ccubed = Delta1;
          } else {
            Ccubed = divide3(add3(Delta1, sqrt3(subtract2(multiply2(Delta1, Delta1), multiply2(4, Delta0, Delta0, Delta0)))), 2);
          }
          var allRoots = true;
          var rawRoots = cbrt5(Ccubed, allRoots).toArray().map((C) => divide3(add3(_b, C, divide3(Delta0, C)), _denom));
          return rawRoots.map((r) => {
            if (typeOf3(r) === "Complex" && equalScalar2(re2(r), re2(r) + im2(r))) {
              return re2(r);
            }
            return r;
          });
        }
        default:
          throw new RangeError("only implemented for cubic or lower-order polynomials, not ".concat(coeffs));
      }
    }
  });
});

// node_modules/mathjs/lib/esm/expression/Help.js
var name237 = "Help";
var dependencies238 = ["evaluate"];
var createHelpClass = /* @__PURE__ */ factory(name237, dependencies238, (_ref) => {
  var {
    evaluate: evaluate2
  } = _ref;
  function Help2(doc) {
    if (!(this instanceof Help2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (!doc)
      throw new Error('Argument "doc" missing');
    this.doc = doc;
  }
  Help2.prototype.type = "Help";
  Help2.prototype.isHelp = true;
  Help2.prototype.toString = function() {
    var doc = this.doc || {};
    var desc = "\n";
    if (doc.name) {
      desc += "Name: " + doc.name + "\n\n";
    }
    if (doc.category) {
      desc += "Category: " + doc.category + "\n\n";
    }
    if (doc.description) {
      desc += "Description:\n    " + doc.description + "\n\n";
    }
    if (doc.syntax) {
      desc += "Syntax:\n    " + doc.syntax.join("\n    ") + "\n\n";
    }
    if (doc.examples) {
      desc += "Examples:\n";
      var configChanged = false;
      var originalConfig = evaluate2("config()");
      var scope = {
        config: (newConfig) => {
          configChanged = true;
          return evaluate2("config(newConfig)", {
            newConfig
          });
        }
      };
      for (var i2 = 0; i2 < doc.examples.length; i2++) {
        var expr = doc.examples[i2];
        desc += "    " + expr + "\n";
        var res = void 0;
        try {
          res = evaluate2(expr, scope);
        } catch (e3) {
          res = e3;
        }
        if (res !== void 0 && !isHelp(res)) {
          desc += "        " + format3(res, {
            precision: 14
          }) + "\n";
        }
      }
      desc += "\n";
      if (configChanged) {
        evaluate2("config(originalConfig)", {
          originalConfig
        });
      }
    }
    if (doc.mayThrow && doc.mayThrow.length) {
      desc += "Throws: " + doc.mayThrow.join(", ") + "\n\n";
    }
    if (doc.seealso && doc.seealso.length) {
      desc += "See also: " + doc.seealso.join(", ") + "\n";
    }
    return desc;
  };
  Help2.prototype.toJSON = function() {
    var obj = clone(this.doc);
    obj.mathjs = "Help";
    return obj;
  };
  Help2.fromJSON = function(json) {
    var doc = {};
    Object.keys(json).filter((prop) => prop !== "mathjs").forEach((prop) => {
      doc[prop] = json[prop];
    });
    return new Help2(doc);
  };
  Help2.prototype.valueOf = Help2.prototype.toString;
  return Help2;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/type/chain/Chain.js
var name238 = "Chain";
var dependencies239 = ["?on", "math", "typed"];
var createChainClass = /* @__PURE__ */ factory(name238, dependencies239, (_ref) => {
  var {
    on,
    math: math2,
    typed: typed3
  } = _ref;
  function Chain2(value) {
    if (!(this instanceof Chain2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (isChain(value)) {
      this.value = value.value;
    } else {
      this.value = value;
    }
  }
  Chain2.prototype.type = "Chain";
  Chain2.prototype.isChain = true;
  Chain2.prototype.done = function() {
    return this.value;
  };
  Chain2.prototype.valueOf = function() {
    return this.value;
  };
  Chain2.prototype.toString = function() {
    return format3(this.value);
  };
  Chain2.prototype.toJSON = function() {
    return {
      mathjs: "Chain",
      value: this.value
    };
  };
  Chain2.fromJSON = function(json) {
    return new Chain2(json.value);
  };
  function createProxy(name314, fn) {
    if (typeof fn === "function") {
      Chain2.prototype[name314] = chainify(fn);
    }
  }
  function createLazyProxy(name314, resolver) {
    lazy(Chain2.prototype, name314, function outerResolver() {
      var fn = resolver();
      if (typeof fn === "function") {
        return chainify(fn);
      }
      return void 0;
    });
  }
  function chainify(fn) {
    return function() {
      if (arguments.length === 0) {
        return new Chain2(fn(this.value));
      }
      var args = [this.value];
      for (var i2 = 0; i2 < arguments.length; i2++) {
        args[i2 + 1] = arguments[i2];
      }
      if (typed3.isTypedFunction(fn)) {
        var sigObject = typed3.resolve(fn, args);
        if (sigObject.params.length === 1) {
          throw new Error("chain function " + fn.name + " cannot match rest parameter between chain value and additional arguments.");
        }
        return new Chain2(sigObject.implementation.apply(fn, args));
      }
      return new Chain2(fn.apply(fn, args));
    };
  }
  Chain2.createProxy = function(arg0, arg1) {
    if (typeof arg0 === "string") {
      createProxy(arg0, arg1);
    } else {
      var _loop = function _loop2(_name2) {
        if (hasOwnProperty(arg0, _name2) && excludedNames[_name2] === void 0) {
          createLazyProxy(_name2, () => arg0[_name2]);
        }
      };
      for (var _name in arg0) {
        _loop(_name);
      }
    }
  };
  var excludedNames = {
    expression: true,
    docs: true,
    type: true,
    classes: true,
    json: true,
    error: true,
    isChain: true
    // conflicts with the property isChain of a Chain instance
  };
  Chain2.createProxy(math2);
  if (on) {
    on("import", function(name314, resolver, path) {
      if (!path) {
        createLazyProxy(name314, resolver);
      }
    });
  }
  return Chain2;
}, {
  isClass: true
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/e.js
var eDocs = {
  name: "e",
  category: "Constants",
  syntax: ["e"],
  description: "Euler's number, the base of the natural logarithm. Approximately equal to 2.71828",
  examples: ["e", "e ^ 2", "exp(2)", "log(e)"],
  seealso: ["exp"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/false.js
var falseDocs = {
  name: "false",
  category: "Constants",
  syntax: ["false"],
  description: "Boolean value false",
  examples: ["false"],
  seealso: ["true"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/i.js
var iDocs = {
  name: "i",
  category: "Constants",
  syntax: ["i"],
  description: "Imaginary unit, defined as i*i=-1. A complex number is described as a + b*i, where a is the real part, and b is the imaginary part.",
  examples: ["i", "i * i", "sqrt(-1)"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/Infinity.js
var InfinityDocs = {
  name: "Infinity",
  category: "Constants",
  syntax: ["Infinity"],
  description: "Infinity, a number which is larger than the maximum number that can be handled by a floating point number.",
  examples: ["Infinity", "1 / 0"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LN10.js
var LN10Docs = {
  name: "LN10",
  category: "Constants",
  syntax: ["LN10"],
  description: "Returns the natural logarithm of 10, approximately equal to 2.302",
  examples: ["LN10", "log(10)"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LN2.js
var LN2Docs = {
  name: "LN2",
  category: "Constants",
  syntax: ["LN2"],
  description: "Returns the natural logarithm of 2, approximately equal to 0.693",
  examples: ["LN2", "log(2)"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LOG10E.js
var LOG10EDocs = {
  name: "LOG10E",
  category: "Constants",
  syntax: ["LOG10E"],
  description: "Returns the base-10 logarithm of E, approximately equal to 0.434",
  examples: ["LOG10E", "log(e, 10)"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LOG2E.js
var LOG2EDocs = {
  name: "LOG2E",
  category: "Constants",
  syntax: ["LOG2E"],
  description: "Returns the base-2 logarithm of E, approximately equal to 1.442",
  examples: ["LOG2E", "log(e, 2)"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/NaN.js
var NaNDocs = {
  name: "NaN",
  category: "Constants",
  syntax: ["NaN"],
  description: "Not a number",
  examples: ["NaN", "0 / 0"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/null.js
var nullDocs = {
  name: "null",
  category: "Constants",
  syntax: ["null"],
  description: "Value null",
  examples: ["null"],
  seealso: ["true", "false"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/phi.js
var phiDocs = {
  name: "phi",
  category: "Constants",
  syntax: ["phi"],
  description: "Phi is the golden ratio. Two quantities are in the golden ratio if their ratio is the same as the ratio of their sum to the larger of the two quantities. Phi is defined as `(1 + sqrt(5)) / 2` and is approximately 1.618034...",
  examples: ["phi"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/pi.js
var piDocs = {
  name: "pi",
  category: "Constants",
  syntax: ["pi"],
  description: "The number pi is a mathematical constant that is the ratio of a circle's circumference to its diameter, and is approximately equal to 3.14159",
  examples: ["pi", "sin(pi/2)"],
  seealso: ["tau"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/SQRT1_2.js
var SQRT12Docs = {
  name: "SQRT1_2",
  category: "Constants",
  syntax: ["SQRT1_2"],
  description: "Returns the square root of 1/2, approximately equal to 0.707",
  examples: ["SQRT1_2", "sqrt(1/2)"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/SQRT2.js
var SQRT2Docs = {
  name: "SQRT2",
  category: "Constants",
  syntax: ["SQRT2"],
  description: "Returns the square root of 2, approximately equal to 1.414",
  examples: ["SQRT2", "sqrt(2)"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/tau.js
var tauDocs = {
  name: "tau",
  category: "Constants",
  syntax: ["tau"],
  description: "Tau is the ratio constant of a circle's circumference to radius, equal to 2 * pi, approximately 6.2832.",
  examples: ["tau", "2 * pi"],
  seealso: ["pi"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/true.js
var trueDocs = {
  name: "true",
  category: "Constants",
  syntax: ["true"],
  description: "Boolean value true",
  examples: ["true"],
  seealso: ["false"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/version.js
var versionDocs = {
  name: "version",
  category: "Constants",
  syntax: ["version"],
  description: "A string with the version number of math.js",
  examples: ["version"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/bignumber.js
var bignumberDocs = {
  name: "bignumber",
  category: "Construction",
  syntax: ["bignumber(x)"],
  description: "Create a big number from a number or string.",
  examples: ["0.1 + 0.2", "bignumber(0.1) + bignumber(0.2)", 'bignumber("7.2")', 'bignumber("7.2e500")', "bignumber([0.1, 0.2, 0.3])"],
  seealso: ["boolean", "bigint", "complex", "fraction", "index", "matrix", "string", "unit"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/bigint.js
var bigintDocs = {
  name: "bigint",
  category: "Construction",
  syntax: ["bigint(x)"],
  description: "Create a bigint, an integer with an arbitrary number of digits, from a number or string.",
  examples: ["123123123123123123 # a large number will lose digits", 'bigint("123123123123123123")', 'bignumber(["1", "3", "5"])'],
  seealso: ["boolean", "bignumber", "number", "complex", "fraction", "index", "matrix", "string", "unit"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/boolean.js
var booleanDocs = {
  name: "boolean",
  category: "Construction",
  syntax: ["x", "boolean(x)"],
  description: "Convert a string or number into a boolean.",
  examples: ["boolean(0)", "boolean(1)", "boolean(3)", 'boolean("true")', 'boolean("false")', "boolean([1, 0, 1, 1])"],
  seealso: ["bignumber", "complex", "index", "matrix", "number", "string", "unit"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/complex.js
var complexDocs = {
  name: "complex",
  category: "Construction",
  syntax: ["complex()", "complex(re, im)", "complex(string)"],
  description: "Create a complex number.",
  examples: ["complex()", "complex(2, 3)", 'complex("7 - 2i")'],
  seealso: ["bignumber", "boolean", "index", "matrix", "number", "string", "unit"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/createUnit.js
var createUnitDocs = {
  name: "createUnit",
  category: "Construction",
  syntax: ["createUnit(definitions)", "createUnit(name, definition)"],
  description: "Create a user-defined unit and register it with the Unit type.",
  examples: ['createUnit("foo")', 'createUnit("knot", {definition: "0.514444444 m/s", aliases: ["knots", "kt", "kts"]})', 'createUnit("mph", "1 mile/hour")'],
  seealso: ["unit", "splitUnit"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/fraction.js
var fractionDocs = {
  name: "fraction",
  category: "Construction",
  syntax: ["fraction(num)", "fraction(matrix)", "fraction(num,den)", "fraction({n: num, d: den})"],
  description: "Create a fraction from a number or from integer numerator and denominator.",
  examples: ["fraction(0.125)", "fraction(1, 3) + fraction(2, 5)", "fraction({n: 333, d: 53})", "fraction([sqrt(9), sqrt(10), sqrt(11)])"],
  seealso: ["bignumber", "boolean", "complex", "index", "matrix", "string", "unit"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/index.js
var indexDocs = {
  name: "index",
  category: "Construction",
  syntax: ["[start]", "[start:end]", "[start:step:end]", "[start1, start 2, ...]", "[start1:end1, start2:end2, ...]", "[start1:step1:end1, start2:step2:end2, ...]"],
  description: "Create an index to get or replace a subset of a matrix",
  examples: ["A = [1, 2, 3; 4, 5, 6]", "A[1, :]", "A[1, 2] = 50", "A[1:2, 1:2] = 1", "B = [1, 2, 3]", "B[B>1 and B<3]"],
  seealso: ["bignumber", "boolean", "complex", "matrix,", "number", "range", "string", "unit"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/matrix.js
var matrixDocs = {
  name: "matrix",
  category: "Construction",
  syntax: ["[]", "[a1, b1, ...; a2, b2, ...]", "matrix()", 'matrix("dense")', "matrix([...])"],
  description: "Create a matrix.",
  examples: ["[]", "[1, 2, 3]", "[1, 2, 3; 4, 5, 6]", "matrix()", "matrix([3, 4])", 'matrix([3, 4; 5, 6], "sparse")', 'matrix([3, 4; 5, 6], "sparse", "number")'],
  seealso: ["bignumber", "boolean", "complex", "index", "number", "string", "unit", "sparse"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/number.js
var numberDocs = {
  name: "number",
  category: "Construction",
  syntax: ["x", "number(x)", "number(unit, valuelessUnit)"],
  description: "Create a number or convert a string or boolean into a number.",
  examples: ["2", "2e3", "4.05", "number(2)", 'number("7.2")', "number(true)", "number([true, false, true, true])", 'number(unit("52cm"), "m")'],
  seealso: ["bignumber", "bigint", "boolean", "complex", "fraction", "index", "matrix", "string", "unit"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/sparse.js
var sparseDocs = {
  name: "sparse",
  category: "Construction",
  syntax: ["sparse()", "sparse([a1, b1, ...; a1, b2, ...])", 'sparse([a1, b1, ...; a1, b2, ...], "number")'],
  description: "Create a sparse matrix.",
  examples: ["sparse()", "sparse([3, 4; 5, 6])", 'sparse([3, 0; 5, 0], "number")'],
  seealso: ["bignumber", "boolean", "complex", "index", "number", "string", "unit", "matrix"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/splitUnit.js
var splitUnitDocs = {
  name: "splitUnit",
  category: "Construction",
  syntax: ["splitUnit(unit: Unit, parts: Unit[])"],
  description: "Split a unit in an array of units whose sum is equal to the original unit.",
  examples: ['splitUnit(1 m, ["feet", "inch"])'],
  seealso: ["unit", "createUnit"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/string.js
var stringDocs = {
  name: "string",
  category: "Construction",
  syntax: ['"text"', "string(x)"],
  description: "Create a string or convert a value to a string",
  examples: ['"Hello World!"', "string(4.2)", "string(3 + 2i)"],
  seealso: ["bignumber", "boolean", "complex", "index", "matrix", "number", "unit"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/unit.js
var unitDocs = {
  name: "unit",
  category: "Construction",
  syntax: ["value unit", "unit(value, unit)", "unit(string)"],
  description: "Create a unit.",
  examples: ["5.5 mm", "3 inch", 'unit(7.1, "kilogram")', 'unit("23 deg")'],
  seealso: ["bignumber", "boolean", "complex", "index", "matrix", "number", "string"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/core/config.js
var configDocs = {
  name: "config",
  category: "Core",
  syntax: ["config()", "config(options)"],
  description: "Get configuration or change configuration.",
  examples: ["config()", "1/3 + 1/4", 'config({number: "Fraction"})', "1/3 + 1/4"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/core/import.js
var importDocs = {
  name: "import",
  category: "Core",
  syntax: ["import(functions)", "import(functions, options)"],
  description: "Import functions or constants from an object.",
  examples: ["import({myFn: f(x)=x^2, myConstant: 32 })", "myFn(2)", "myConstant"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/core/typed.js
var typedDocs = {
  name: "typed",
  category: "Core",
  syntax: ["typed(signatures)", "typed(name, signatures)"],
  description: "Create a typed function.",
  examples: ['double = typed({ "number": f(x)=x+x, "string": f(x)=concat(x,x) })', "double(2)", 'double("hello")'],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/derivative.js
var derivativeDocs = {
  name: "derivative",
  category: "Algebra",
  syntax: ["derivative(expr, variable)", "derivative(expr, variable, {simplify: boolean})"],
  description: "Takes the derivative of an expression expressed in parser Nodes. The derivative will be taken over the supplied variable in the second parameter. If there are multiple variables in the expression, it will return a partial derivative.",
  examples: ['derivative("2x^3", "x")', 'derivative("2x^3", "x", {simplify: false})', 'derivative("2x^2 + 3x + 4", "x")', 'derivative("sin(2x)", "x")', 'f = parse("x^2 + x")', 'x = parse("x")', "df = derivative(f, x)", "df.evaluate({x: 3})"],
  seealso: ["simplify", "parse", "evaluate"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/leafCount.js
var leafCountDocs = {
  name: "leafCount",
  category: "Algebra",
  syntax: ["leafCount(expr)"],
  description: "Computes the number of leaves in the parse tree of the given expression",
  examples: ['leafCount("e^(i*pi)-1")', 'leafCount(parse("{a: 22/7, b: 10^(1/2)}"))'],
  seealso: ["simplify"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lsolve.js
var lsolveDocs = {
  name: "lsolve",
  category: "Algebra",
  syntax: ["x=lsolve(L, b)"],
  description: "Finds one solution of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
  examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
  seealso: ["lsolveAll", "lup", "lusolve", "usolve", "matrix", "sparse"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lsolveAll.js
var lsolveAllDocs = {
  name: "lsolveAll",
  category: "Algebra",
  syntax: ["x=lsolveAll(L, b)"],
  description: "Finds all solutions of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
  examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
  seealso: ["lsolve", "lup", "lusolve", "usolve", "matrix", "sparse"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lup.js
var lupDocs = {
  name: "lup",
  category: "Algebra",
  syntax: ["lup(m)"],
  description: "Calculate the Matrix LU decomposition with partial pivoting. Matrix A is decomposed in three matrices (L, U, P) where P * A = L * U",
  examples: ["lup([[2, 1], [1, 4]])", "lup(matrix([[2, 1], [1, 4]]))", "lup(sparse([[2, 1], [1, 4]]))"],
  seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "slu", "qr"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lusolve.js
var lusolveDocs = {
  name: "lusolve",
  category: "Algebra",
  syntax: ["x=lusolve(A, b)", "x=lusolve(lu, b)"],
  description: "Solves the linear system A * x = b where A is an [n x n] matrix and b is a [n] column vector.",
  examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lusolve(a, b)"],
  seealso: ["lup", "slu", "lsolve", "usolve", "matrix", "sparse"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/polynomialRoot.js
var polynomialRootDocs = {
  name: "polynomialRoot",
  category: "Algebra",
  syntax: ["x=polynomialRoot(-6, 3)", "x=polynomialRoot(4, -4, 1)", "x=polynomialRoot(-8, 12, -6, 1)"],
  description: "Finds the roots of a univariate polynomial given by its coefficients starting from constant, linear, and so on, increasing in degree.",
  examples: ["a = polynomialRoot(-6, 11, -6, 1)"],
  seealso: ["cbrt", "sqrt"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/qr.js
var qrDocs = {
  name: "qr",
  category: "Algebra",
  syntax: ["qr(A)"],
  description: "Calculates the Matrix QR decomposition. Matrix `A` is decomposed in two matrices (`Q`, `R`) where `Q` is an orthogonal matrix and `R` is an upper triangular matrix.",
  examples: ["qr([[1, -1,  4], [1,  4, -2], [1,  4,  2], [1,  -1, 0]])"],
  seealso: ["lup", "slu", "matrix"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/rationalize.js
var rationalizeDocs = {
  name: "rationalize",
  category: "Algebra",
  syntax: ["rationalize(expr)", "rationalize(expr, scope)", "rationalize(expr, scope, detailed)"],
  description: "Transform a rationalizable expression in a rational fraction. If rational fraction is one variable polynomial then converts the numerator and denominator in canonical form, with decreasing exponents, returning the coefficients of numerator.",
  examples: ['rationalize("2x/y - y/(x+1)")', 'rationalize("2x/y - y/(x+1)", true)'],
  seealso: ["simplify"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/resolve.js
var resolveDocs = {
  name: "resolve",
  category: "Algebra",
  syntax: ["resolve(node, scope)"],
  description: "Recursively substitute variables in an expression tree.",
  examples: ['resolve(parse("1 + x"), { x: 7 })', 'resolve(parse("size(text)"), { text: "Hello World" })', 'resolve(parse("x + y"), { x: parse("3z") })', 'resolve(parse("3x"), { x: parse("y+z"), z: parse("w^y") })'],
  seealso: ["simplify", "evaluate"],
  mayThrow: ["ReferenceError"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/simplify.js
var simplifyDocs = {
  name: "simplify",
  category: "Algebra",
  syntax: ["simplify(expr)", "simplify(expr, rules)"],
  description: "Simplify an expression tree.",
  examples: ['simplify("3 + 2 / 4")', 'simplify("2x + x")', 'f = parse("x * (x + 2 + x)")', "simplified = simplify(f)", "simplified.evaluate({x: 2})"],
  seealso: ["simplifyCore", "derivative", "evaluate", "parse", "rationalize", "resolve"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/simplifyConstant.js
var simplifyConstantDocs = {
  name: "simplifyConstant",
  category: "Algebra",
  syntax: ["simplifyConstant(expr)", "simplifyConstant(expr, options)"],
  description: "Replace constant subexpressions of node with their values.",
  examples: ['simplifyConstant("(3-3)*x")', 'simplifyConstant(parse("z-cos(tau/8)"))'],
  seealso: ["simplify", "simplifyCore", "evaluate"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/simplifyCore.js
var simplifyCoreDocs = {
  name: "simplifyCore",
  category: "Algebra",
  syntax: ["simplifyCore(node)"],
  description: "Perform simple one-pass simplifications on an expression tree.",
  examples: ['simplifyCore(parse("0*x"))', 'simplifyCore(parse("(x+0)*2"))'],
  seealso: ["simplify", "simplifyConstant", "evaluate"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/slu.js
var sluDocs = {
  name: "slu",
  category: "Algebra",
  syntax: ["slu(A, order, threshold)"],
  description: "Calculate the Matrix LU decomposition with full pivoting. Matrix A is decomposed in two matrices (L, U) and two permutation vectors (pinv, q) where P * A * Q = L * U",
  examples: ["slu(sparse([4.5, 0, 3.2, 0; 3.1, 2.9, 0, 0.9; 0, 1.7, 3, 0; 3.5, 0.4, 0, 1]), 1, 0.001)"],
  seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "lup", "qr"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/symbolicEqual.js
var symbolicEqualDocs = {
  name: "symbolicEqual",
  category: "Algebra",
  syntax: ["symbolicEqual(expr1, expr2)", "symbolicEqual(expr1, expr2, options)"],
  description: "Returns true if the difference of the expressions simplifies to 0",
  examples: ['symbolicEqual("x*y","y*x")', 'symbolicEqual("abs(x^2)", "x^2")', 'symbolicEqual("abs(x)", "x", {context: {abs: {trivial: true}}})'],
  seealso: ["simplify", "evaluate"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/usolve.js
var usolveDocs = {
  name: "usolve",
  category: "Algebra",
  syntax: ["x=usolve(U, b)"],
  description: "Finds one solution of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
  examples: ["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],
  seealso: ["usolveAll", "lup", "lusolve", "lsolve", "matrix", "sparse"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/usolveAll.js
var usolveAllDocs = {
  name: "usolveAll",
  category: "Algebra",
  syntax: ["x=usolve(U, b)"],
  description: "Finds all solutions of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
  examples: ["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],
  seealso: ["usolve", "lup", "lusolve", "lsolve", "matrix", "sparse"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/abs.js
var absDocs = {
  name: "abs",
  category: "Arithmetic",
  syntax: ["abs(x)"],
  description: "Compute the absolute value.",
  examples: ["abs(3.5)", "abs(-4.2)"],
  seealso: ["sign"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/add.js
var addDocs = {
  name: "add",
  category: "Operators",
  syntax: ["x + y", "add(x, y)"],
  description: "Add two values.",
  examples: ["a = 2.1 + 3.6", "a - 3.6", "3 + 2i", "3 cm + 2 inch", '"2.3" + "4"'],
  seealso: ["subtract"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/cbrt.js
var cbrtDocs = {
  name: "cbrt",
  category: "Arithmetic",
  syntax: ["cbrt(x)", "cbrt(x, allRoots)"],
  description: "Compute the cubic root value. If x = y * y * y, then y is the cubic root of x. When `x` is a number or complex number, an optional second argument `allRoots` can be provided to return all three cubic roots. If not provided, the principal root is returned",
  examples: ["cbrt(64)", "cube(4)", "cbrt(-8)", "cbrt(2 + 3i)", "cbrt(8i)", "cbrt(8i, true)", "cbrt(27 m^3)"],
  seealso: ["square", "sqrt", "cube", "multiply"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/ceil.js
var ceilDocs = {
  name: "ceil",
  category: "Arithmetic",
  syntax: ["ceil(x)"],
  description: "Round a value towards plus infinity. If x is complex, both real and imaginary part are rounded towards plus infinity.",
  examples: ["ceil(3.2)", "ceil(3.8)", "ceil(-4.2)"],
  seealso: ["floor", "fix", "round"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/cube.js
var cubeDocs = {
  name: "cube",
  category: "Arithmetic",
  syntax: ["cube(x)"],
  description: "Compute the cube of a value. The cube of x is x * x * x.",
  examples: ["cube(2)", "2^3", "2 * 2 * 2"],
  seealso: ["multiply", "square", "pow"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/divide.js
var divideDocs = {
  name: "divide",
  category: "Operators",
  syntax: ["x / y", "divide(x, y)"],
  description: "Divide two values.",
  examples: ["a = 2 / 3", "a * 3", "4.5 / 2", "3 + 4 / 2", "(3 + 4) / 2", "18 km / 4.5"],
  seealso: ["multiply"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotDivide.js
var dotDivideDocs = {
  name: "dotDivide",
  category: "Operators",
  syntax: ["x ./ y", "dotDivide(x, y)"],
  description: "Divide two values element wise.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a ./ b"],
  seealso: ["multiply", "dotMultiply", "divide"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotMultiply.js
var dotMultiplyDocs = {
  name: "dotMultiply",
  category: "Operators",
  syntax: ["x .* y", "dotMultiply(x, y)"],
  description: "Multiply two values element wise.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a .* b"],
  seealso: ["multiply", "divide", "dotDivide"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotPow.js
var dotPowDocs = {
  name: "dotPow",
  category: "Operators",
  syntax: ["x .^ y", "dotPow(x, y)"],
  description: "Calculates the power of x to y element wise.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "a .^ 2"],
  seealso: ["pow"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/exp.js
var expDocs = {
  name: "exp",
  category: "Arithmetic",
  syntax: ["exp(x)"],
  description: "Calculate the exponent of a value.",
  examples: ["exp(1.3)", "e ^ 1.3", "log(exp(1.3))", "x = 2.4", "(exp(i*x) == cos(x) + i*sin(x))   # Euler's formula"],
  seealso: ["expm", "expm1", "pow", "log"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/expm.js
var expmDocs = {
  name: "expm",
  category: "Arithmetic",
  syntax: ["exp(x)"],
  description: "Compute the matrix exponential, expm(A) = e^A. The matrix must be square. Not to be confused with exp(a), which performs element-wise exponentiation.",
  examples: ["expm([[0,2],[0,0]])"],
  seealso: ["exp"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/expm1.js
var expm1Docs = {
  name: "expm1",
  category: "Arithmetic",
  syntax: ["expm1(x)"],
  description: "Calculate the value of subtracting 1 from the exponential value.",
  examples: ["expm1(2)", "pow(e, 2) - 1", "log(expm1(2) + 1)"],
  seealso: ["exp", "pow", "log"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/fix.js
var fixDocs = {
  name: "fix",
  category: "Arithmetic",
  syntax: ["fix(x)"],
  description: "Round a value towards zero. If x is complex, both real and imaginary part are rounded towards zero.",
  examples: ["fix(3.2)", "fix(3.8)", "fix(-4.2)", "fix(-4.8)"],
  seealso: ["ceil", "floor", "round"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/floor.js
var floorDocs = {
  name: "floor",
  category: "Arithmetic",
  syntax: ["floor(x)"],
  description: "Round a value towards minus infinity.If x is complex, both real and imaginary part are rounded towards minus infinity.",
  examples: ["floor(3.2)", "floor(3.8)", "floor(-4.2)"],
  seealso: ["ceil", "fix", "round"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/gcd.js
var gcdDocs = {
  name: "gcd",
  category: "Arithmetic",
  syntax: ["gcd(a, b)", "gcd(a, b, c, ...)"],
  description: "Compute the greatest common divisor.",
  examples: ["gcd(8, 12)", "gcd(-4, 6)", "gcd(25, 15, -10)"],
  seealso: ["lcm", "xgcd"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/hypot.js
var hypotDocs = {
  name: "hypot",
  category: "Arithmetic",
  syntax: ["hypot(a, b, c, ...)", "hypot([a, b, c, ...])"],
  description: "Calculate the hypotenusa of a list with values. ",
  examples: ["hypot(3, 4)", "sqrt(3^2 + 4^2)", "hypot(-2)", "hypot([3, 4, 5])"],
  seealso: ["abs", "norm"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/invmod.js
var invmodDocs = {
  name: "invmod",
  category: "Arithmetic",
  syntax: ["invmod(a, b)"],
  description: "Calculate the (modular) multiplicative inverse of a modulo b. Solution to the equation ax \u2263 1 (mod b)",
  examples: ["invmod(8, 12)", "invmod(7, 13)", "invmod(15151, 15122)"],
  seealso: ["gcd", "xgcd"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/lcm.js
var lcmDocs = {
  name: "lcm",
  category: "Arithmetic",
  syntax: ["lcm(x, y)"],
  description: "Compute the least common multiple.",
  examples: ["lcm(4, 6)", "lcm(6, 21)", "lcm(6, 21, 5)"],
  seealso: ["gcd"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log.js
var logDocs = {
  name: "log",
  category: "Arithmetic",
  syntax: ["log(x)", "log(x, base)"],
  description: "Compute the logarithm of a value. If no base is provided, the natural logarithm of x is calculated. If base if provided, the logarithm is calculated for the specified base. log(x, base) is defined as log(x) / log(base).",
  examples: ["log(3.5)", "a = log(2.4)", "exp(a)", "10 ^ 4", "log(10000, 10)", "log(10000) / log(10)", "b = log(1024, 2)", "2 ^ b"],
  seealso: ["exp", "log1p", "log2", "log10"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log10.js
var log10Docs = {
  name: "log10",
  category: "Arithmetic",
  syntax: ["log10(x)"],
  description: "Compute the 10-base logarithm of a value.",
  examples: ["log10(0.00001)", "log10(10000)", "10 ^ 4", "log(10000) / log(10)", "log(10000, 10)"],
  seealso: ["exp", "log"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log1p.js
var log1pDocs = {
  name: "log1p",
  category: "Arithmetic",
  syntax: ["log1p(x)", "log1p(x, base)"],
  description: "Calculate the logarithm of a `value+1`",
  examples: ["log1p(2.5)", "exp(log1p(1.4))", "pow(10, 4)", "log1p(9999, 10)", "log1p(9999) / log(10)"],
  seealso: ["exp", "log", "log2", "log10"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log2.js
var log2Docs = {
  name: "log2",
  category: "Arithmetic",
  syntax: ["log2(x)"],
  description: "Calculate the 2-base of a value. This is the same as calculating `log(x, 2)`.",
  examples: ["log2(0.03125)", "log2(16)", "log2(16) / log2(2)", "pow(2, 4)"],
  seealso: ["exp", "log1p", "log", "log10"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/mod.js
var modDocs = {
  name: "mod",
  category: "Operators",
  syntax: ["x % y", "x mod y", "mod(x, y)"],
  description: "Calculates the modulus, the remainder of an integer division.",
  examples: ["7 % 3", "11 % 2", "10 mod 4", "isOdd(x) = x % 2", "isOdd(2)", "isOdd(3)"],
  seealso: ["divide"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/multiply.js
var multiplyDocs = {
  name: "multiply",
  category: "Operators",
  syntax: ["x * y", "multiply(x, y)"],
  description: "multiply two values.",
  examples: ["a = 2.1 * 3.4", "a / 3.4", "2 * 3 + 4", "2 * (3 + 4)", "3 * 2.1 km"],
  seealso: ["divide"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/norm.js
var normDocs = {
  name: "norm",
  category: "Arithmetic",
  syntax: ["norm(x)", "norm(x, p)"],
  description: "Calculate the norm of a number, vector or matrix.",
  examples: ["abs(-3.5)", "norm(-3.5)", "norm(3 - 4i)", "norm([1, 2, -3], Infinity)", "norm([1, 2, -3], -Infinity)", "norm([3, 4], 2)", "norm([[1, 2], [3, 4]], 1)", 'norm([[1, 2], [3, 4]], "inf")', 'norm([[1, 2], [3, 4]], "fro")']
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/nthRoot.js
var nthRootDocs = {
  name: "nthRoot",
  category: "Arithmetic",
  syntax: ["nthRoot(a)", "nthRoot(a, root)"],
  description: 'Calculate the nth root of a value. The principal nth root of a positive real number A, is the positive real solution of the equation "x^root = A".',
  examples: ["4 ^ 3", "nthRoot(64, 3)", "nthRoot(9, 2)", "sqrt(9)"],
  seealso: ["nthRoots", "pow", "sqrt"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/nthRoots.js
var nthRootsDocs = {
  name: "nthRoots",
  category: "Arithmetic",
  syntax: ["nthRoots(A)", "nthRoots(A, root)"],
  description: 'Calculate the nth roots of a value. An nth root of a positive real number A, is a positive real solution of the equation "x^root = A". This function returns an array of complex values.',
  examples: ["nthRoots(1)", "nthRoots(1, 3)"],
  seealso: ["sqrt", "pow", "nthRoot"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/pow.js
var powDocs = {
  name: "pow",
  category: "Operators",
  syntax: ["x ^ y", "pow(x, y)"],
  description: "Calculates the power of x to y, x^y.",
  examples: ["2^3", "2*2*2", "1 + e ^ (pi * i)", "pow([[1, 2], [4, 3]], 2)", "pow([[1, 2], [4, 3]], -1)"],
  seealso: ["multiply", "nthRoot", "nthRoots", "sqrt"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/round.js
var roundDocs = {
  name: "round",
  category: "Arithmetic",
  syntax: ["round(x)", "round(x, n)", "round(unit, valuelessUnit)", "round(unit, n, valuelessUnit)"],
  description: "round a value towards the nearest integer.If x is complex, both real and imaginary part are rounded towards the nearest integer. When n is specified, the value is rounded to n decimals.",
  examples: ["round(3.2)", "round(3.8)", "round(-4.2)", "round(-4.8)", "round(pi, 3)", "round(123.45678, 2)", "round(3.241cm, 2, cm)", "round([3.2, 3.8, -4.7])"],
  seealso: ["ceil", "floor", "fix"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sign.js
var signDocs = {
  name: "sign",
  category: "Arithmetic",
  syntax: ["sign(x)"],
  description: "Compute the sign of a value. The sign of a value x is 1 when x>1, -1 when x<0, and 0 when x=0.",
  examples: ["sign(3.5)", "sign(-4.2)", "sign(0)"],
  seealso: ["abs"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sqrt.js
var sqrtDocs = {
  name: "sqrt",
  category: "Arithmetic",
  syntax: ["sqrt(x)"],
  description: "Compute the square root value. If x = y * y, then y is the square root of x.",
  examples: ["sqrt(25)", "5 * 5", "sqrt(-1)"],
  seealso: ["square", "sqrtm", "multiply", "nthRoot", "nthRoots", "pow"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sqrtm.js
var sqrtmDocs = {
  name: "sqrtm",
  category: "Arithmetic",
  syntax: ["sqrtm(x)"],
  description: "Calculate the principal square root of a square matrix. The principal square root matrix `X` of another matrix `A` is such that `X * X = A`.",
  examples: ["sqrtm([[33, 24], [48, 57]])"],
  seealso: ["sqrt", "abs", "square", "multiply"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/sylvester.js
var sylvesterDocs = {
  name: "sylvester",
  category: "Algebra",
  syntax: ["sylvester(A,B,C)"],
  description: "Solves the real-valued Sylvester equation AX+XB=C for X",
  examples: ["sylvester([[-1, -2], [1, 1]], [[-2, 1], [-1, 2]], [[-3, 2], [3, 0]])", "A = [[-1, -2], [1, 1]]; B = [[2, -1], [1, -2]]; C = [[-3, 2], [3, 0]]", "sylvester(A, B, C)"],
  seealso: ["schur", "lyap"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/schur.js
var schurDocs = {
  name: "schur",
  category: "Algebra",
  syntax: ["schur(A)"],
  description: "Performs a real Schur decomposition of the real matrix A = UTU'",
  examples: ["schur([[1, 0], [-4, 3]])", "A = [[1, 0], [-4, 3]]", "schur(A)"],
  seealso: ["lyap", "sylvester"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lyap.js
var lyapDocs = {
  name: "lyap",
  category: "Algebra",
  syntax: ["lyap(A,Q)"],
  description: "Solves the Continuous-time Lyapunov equation AP+PA'+Q=0 for P",
  examples: ["lyap([[-2, 0], [1, -4]], [[3, 1], [1, 3]])", "A = [[-2, 0], [1, -4]]", "Q = [[3, 1], [1, 3]]", "lyap(A,Q)"],
  seealso: ["schur", "sylvester"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/square.js
var squareDocs = {
  name: "square",
  category: "Arithmetic",
  syntax: ["square(x)"],
  description: "Compute the square of a value. The square of x is x * x.",
  examples: ["square(3)", "sqrt(9)", "3^2", "3 * 3"],
  seealso: ["multiply", "pow", "sqrt", "cube"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/subtract.js
var subtractDocs = {
  name: "subtract",
  category: "Operators",
  syntax: ["x - y", "subtract(x, y)"],
  description: "subtract two values.",
  examples: ["a = 5.3 - 2", "a + 2", "2/3 - 1/6", "2 * 3 - 3", "2.1 km - 500m"],
  seealso: ["add"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/unaryMinus.js
var unaryMinusDocs = {
  name: "unaryMinus",
  category: "Operators",
  syntax: ["-x", "unaryMinus(x)"],
  description: "Inverse the sign of a value. Converts booleans and strings to numbers.",
  examples: ["-4.5", "-(-5.6)", '-"22"'],
  seealso: ["add", "subtract", "unaryPlus"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/unaryPlus.js
var unaryPlusDocs = {
  name: "unaryPlus",
  category: "Operators",
  syntax: ["+x", "unaryPlus(x)"],
  description: "Converts booleans and strings to numbers.",
  examples: ["+true", '+"2"'],
  seealso: ["add", "subtract", "unaryMinus"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/xgcd.js
var xgcdDocs = {
  name: "xgcd",
  category: "Arithmetic",
  syntax: ["xgcd(a, b)"],
  description: "Calculate the extended greatest common divisor for two values. The result is an array [d, x, y] with 3 entries, where d is the greatest common divisor, and d = x * a + y * b.",
  examples: ["xgcd(8, 12)", "gcd(8, 12)", "xgcd(36163, 21199)"],
  seealso: ["gcd", "lcm"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitAnd.js
var bitAndDocs = {
  name: "bitAnd",
  category: "Bitwise",
  syntax: ["x & y", "bitAnd(x, y)"],
  description: "Bitwise AND operation. Performs the logical AND operation on each pair of the corresponding bits of the two given values by multiplying them. If both bits in the compared position are 1, the bit in the resulting binary representation is 1, otherwise, the result is 0",
  examples: ["5 & 3", "bitAnd(53, 131)", "[1, 12, 31] & 42"],
  seealso: ["bitNot", "bitOr", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitNot.js
var bitNotDocs = {
  name: "bitNot",
  category: "Bitwise",
  syntax: ["~x", "bitNot(x)"],
  description: "Bitwise NOT operation. Performs a logical negation on each bit of the given value. Bits that are 0 become 1, and those that are 1 become 0.",
  examples: ["~1", "~2", "bitNot([2, -3, 4])"],
  seealso: ["bitAnd", "bitOr", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitOr.js
var bitOrDocs = {
  name: "bitOr",
  category: "Bitwise",
  syntax: ["x | y", "bitOr(x, y)"],
  description: "Bitwise OR operation. Performs the logical inclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if the first bit is 1 or the second bit is 1 or both bits are 1, otherwise, the result is 0.",
  examples: ["5 | 3", "bitOr([1, 2, 3], 4)"],
  seealso: ["bitAnd", "bitNot", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitXor.js
var bitXorDocs = {
  name: "bitXor",
  category: "Bitwise",
  syntax: ["bitXor(x, y)"],
  description: "Bitwise XOR operation, exclusive OR. Performs the logical exclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1.",
  examples: ["bitOr(1, 2)", "bitXor([2, 3, 4], 4)"],
  seealso: ["bitAnd", "bitNot", "bitOr", "leftShift", "rightArithShift", "rightLogShift"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/leftShift.js
var leftShiftDocs = {
  name: "leftShift",
  category: "Bitwise",
  syntax: ["x << y", "leftShift(x, y)"],
  description: "Bitwise left logical shift of a value x by y number of bits.",
  examples: ["4 << 1", "8 >> 1"],
  seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "rightArithShift", "rightLogShift"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/rightArithShift.js
var rightArithShiftDocs = {
  name: "rightArithShift",
  category: "Bitwise",
  syntax: ["x >> y", "rightArithShift(x, y)"],
  description: "Bitwise right arithmetic shift of a value x by y number of bits.",
  examples: ["8 >> 1", "4 << 1", "-12 >> 2"],
  seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "leftShift", "rightLogShift"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/rightLogShift.js
var rightLogShiftDocs = {
  name: "rightLogShift",
  category: "Bitwise",
  syntax: ["x >>> y", "rightLogShift(x, y)"],
  description: "Bitwise right logical shift of a value x by y number of bits.",
  examples: ["8 >>> 1", "4 << 1", "-12 >>> 2"],
  seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "leftShift", "rightArithShift"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/bellNumbers.js
var bellNumbersDocs = {
  name: "bellNumbers",
  category: "Combinatorics",
  syntax: ["bellNumbers(n)"],
  description: "The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S. `bellNumbers` only takes integer arguments. The following condition must be enforced: n >= 0.",
  examples: ["bellNumbers(3)", "bellNumbers(8)"],
  seealso: ["stirlingS2"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/catalan.js
var catalanDocs = {
  name: "catalan",
  category: "Combinatorics",
  syntax: ["catalan(n)"],
  description: "The Catalan Numbers enumerate combinatorial structures of many different types. catalan only takes integer arguments. The following condition must be enforced: n >= 0.",
  examples: ["catalan(3)", "catalan(8)"],
  seealso: ["bellNumbers"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/composition.js
var compositionDocs = {
  name: "composition",
  category: "Combinatorics",
  syntax: ["composition(n, k)"],
  description: "The composition counts of n into k parts. composition only takes integer arguments. The following condition must be enforced: k <= n.",
  examples: ["composition(5, 3)"],
  seealso: ["combinations"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/stirlingS2.js
var stirlingS2Docs = {
  name: "stirlingS2",
  category: "Combinatorics",
  syntax: ["stirlingS2(n, k)"],
  description: "he Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets. `stirlingS2` only takes integer arguments. The following condition must be enforced: k <= n. If n = k or k = 1, then s(n,k) = 1.",
  examples: ["stirlingS2(5, 3)"],
  seealso: ["bellNumbers"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/arg.js
var argDocs = {
  name: "arg",
  category: "Complex",
  syntax: ["arg(x)"],
  description: "Compute the argument of a complex value. If x = a+bi, the argument is computed as atan2(b, a).",
  examples: ["arg(2 + 2i)", "atan2(3, 2)", "arg(2 + 3i)"],
  seealso: ["re", "im", "conj", "abs"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/conj.js
var conjDocs = {
  name: "conj",
  category: "Complex",
  syntax: ["conj(x)"],
  description: "Compute the complex conjugate of a complex value. If x = a+bi, the complex conjugate is a-bi.",
  examples: ["conj(2 + 3i)", "conj(2 - 3i)", "conj(-5.2i)"],
  seealso: ["re", "im", "abs", "arg"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/im.js
var imDocs = {
  name: "im",
  category: "Complex",
  syntax: ["im(x)"],
  description: "Get the imaginary part of a complex number.",
  examples: ["im(2 + 3i)", "re(2 + 3i)", "im(-5.2i)", "im(2.4)"],
  seealso: ["re", "conj", "abs", "arg"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/re.js
var reDocs = {
  name: "re",
  category: "Complex",
  syntax: ["re(x)"],
  description: "Get the real part of a complex number.",
  examples: ["re(2 + 3i)", "im(2 + 3i)", "re(-5.2i)", "re(2.4)"],
  seealso: ["im", "conj", "abs", "arg"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/expression/evaluate.js
var evaluateDocs = {
  name: "evaluate",
  category: "Expression",
  syntax: ["evaluate(expression)", "evaluate(expression, scope)", "evaluate([expr1, expr2, expr3, ...])", "evaluate([expr1, expr2, expr3, ...], scope)"],
  description: "Evaluate an expression or an array with expressions.",
  examples: ['evaluate("2 + 3")', 'evaluate("sqrt(16)")', 'evaluate("2 inch to cm")', 'evaluate("sin(x * pi)", { "x": 1/2 })', 'evaluate(["width=2", "height=4","width*height"])'],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/expression/help.js
var helpDocs = {
  name: "help",
  category: "Expression",
  syntax: ["help(object)", "help(string)"],
  description: "Display documentation on a function or data type.",
  examples: ["help(sqrt)", 'help("complex")'],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/geometry/distance.js
var distanceDocs = {
  name: "distance",
  category: "Geometry",
  syntax: ["distance([x1, y1], [x2, y2])", "distance([[x1, y1], [x2, y2]])"],
  description: "Calculates the Euclidean distance between two points.",
  examples: ["distance([0,0], [4,4])", "distance([[0,0], [4,4]])"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/geometry/intersect.js
var intersectDocs = {
  name: "intersect",
  category: "Geometry",
  syntax: ["intersect(expr1, expr2, expr3, expr4)", "intersect(expr1, expr2, expr3)"],
  description: "Computes the intersection point of lines and/or planes.",
  examples: ["intersect([0, 0], [10, 10], [10, 0], [0, 10])", "intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6])"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/and.js
var andDocs = {
  name: "and",
  category: "Logical",
  syntax: ["x and y", "and(x, y)"],
  description: "Logical and. Test whether two values are both defined with a nonzero/nonempty value.",
  examples: ["true and false", "true and true", "2 and 4"],
  seealso: ["not", "or", "xor"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/not.js
var notDocs = {
  name: "not",
  category: "Logical",
  syntax: ["not x", "not(x)"],
  description: "Logical not. Flips the boolean value of given argument.",
  examples: ["not true", "not false", "not 2", "not 0"],
  seealso: ["and", "or", "xor"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/or.js
var orDocs = {
  name: "or",
  category: "Logical",
  syntax: ["x or y", "or(x, y)"],
  description: "Logical or. Test if at least one value is defined with a nonzero/nonempty value.",
  examples: ["true or false", "false or false", "0 or 4"],
  seealso: ["not", "and", "xor"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/xor.js
var xorDocs = {
  name: "xor",
  category: "Logical",
  syntax: ["x xor y", "xor(x, y)"],
  description: "Logical exclusive or, xor. Test whether one and only one value is defined with a nonzero/nonempty value.",
  examples: ["true xor false", "false xor false", "true xor true", "0 xor 4"],
  seealso: ["not", "and", "or"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/column.js
var columnDocs = {
  name: "column",
  category: "Matrix",
  syntax: ["column(x, index)"],
  description: "Return a column from a matrix or array.",
  examples: ["A = [[1, 2], [3, 4]]", "column(A, 1)", "column(A, 2)"],
  seealso: ["row", "matrixFromColumns"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/concat.js
var concatDocs = {
  name: "concat",
  category: "Matrix",
  syntax: ["concat(A, B, C, ...)", "concat(A, B, C, ..., dim)"],
  description: "Concatenate matrices. By default, the matrices are concatenated by the last dimension. The dimension on which to concatenate can be provided as last argument.",
  examples: ["A = [1, 2; 5, 6]", "B = [3, 4; 7, 8]", "concat(A, B)", "concat(A, B, 1)", "concat(A, B, 2)"],
  seealso: ["det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/count.js
var countDocs = {
  name: "count",
  category: "Matrix",
  syntax: ["count(x)"],
  description: "Count the number of elements of a matrix, array or string.",
  examples: ["a = [1, 2; 3, 4; 5, 6]", "count(a)", "size(a)", 'count("hello world")'],
  seealso: ["size"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/cross.js
var crossDocs = {
  name: "cross",
  category: "Matrix",
  syntax: ["cross(A, B)"],
  description: "Calculate the cross product for two vectors in three dimensional space.",
  examples: ["cross([1, 1, 0],  [0, 1, 1])", "cross([3, -3, 1], [4, 9, 2])", "cross([2, 3, 4],  [5, 6, 7])"],
  seealso: ["multiply", "dot"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ctranspose.js
var ctransposeDocs = {
  name: "ctranspose",
  category: "Matrix",
  syntax: ["x'", "ctranspose(x)"],
  description: "Complex Conjugate and Transpose a matrix",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "ctranspose(a)"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/det.js
var detDocs = {
  name: "det",
  category: "Matrix",
  syntax: ["det(x)"],
  description: "Calculate the determinant of a matrix",
  examples: ["det([1, 2; 3, 4])", "det([-2, 2, 3; -1, 1, 3; 2, 0, -1])"],
  seealso: ["concat", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/diag.js
var diagDocs = {
  name: "diag",
  category: "Matrix",
  syntax: ["diag(x)", "diag(x, k)"],
  description: "Create a diagonal matrix or retrieve the diagonal of a matrix. When x is a vector, a matrix with the vector values on the diagonal will be returned. When x is a matrix, a vector with the diagonal values of the matrix is returned. When k is provided, the k-th diagonal will be filled in or retrieved, if k is positive, the values are placed on the super diagonal. When k is negative, the values are placed on the sub diagonal.",
  examples: ["diag(1:3)", "diag(1:3, 1)", "a = [1, 2, 3; 4, 5, 6; 7, 8, 9]", "diag(a)"],
  seealso: ["concat", "det", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/diff.js
var diffDocs = {
  name: "diff",
  category: "Matrix",
  syntax: ["diff(arr)", "diff(arr, dim)"],
  description: ["Create a new matrix or array with the difference of the passed matrix or array.", "Dim parameter is optional and used to indicant the dimension of the array/matrix to apply the difference", "If no dimension parameter is passed it is assumed as dimension 0", "Dimension is zero-based in javascript and one-based in the parser", "Arrays must be 'rectangular' meaning arrays like [1, 2]", "If something is passed as a matrix it will be returned as a matrix but other than that all matrices are converted to arrays"],
  examples: ["A = [1, 2, 4, 7, 0]", "diff(A)", "diff(A, 1)", "B = [[1, 2], [3, 4]]", "diff(B)", "diff(B, 1)", "diff(B, 2)", "diff(B, bignumber(2))", "diff([[1, 2], matrix([3, 4])], 2)"],
  seealso: ["subtract", "partitionSelect"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/dot.js
var dotDocs = {
  name: "dot",
  category: "Matrix",
  syntax: ["dot(A, B)", "A * B"],
  description: "Calculate the dot product of two vectors. The dot product of A = [a1, a2, a3, ..., an] and B = [b1, b2, b3, ..., bn] is defined as dot(A, B) = a1 * b1 + a2 * b2 + a3 * b3 + ... + an * bn",
  examples: ["dot([2, 4, 1], [2, 2, 3])", "[2, 4, 1] * [2, 2, 3]"],
  seealso: ["multiply", "cross"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/eigs.js
var eigsDocs = {
  name: "eigs",
  category: "Matrix",
  syntax: ["eigs(x)"],
  description: "Calculate the eigenvalues and optionally eigenvectors of a square matrix",
  examples: ["eigs([[5, 2.3], [2.3, 1]])", "eigs([[1, 2, 3], [4, 5, 6], [7, 8, 9]], { precision: 1e-6, eigenvectors: false })"],
  seealso: ["inv"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/filter.js
var filterDocs = {
  name: "filter",
  category: "Matrix",
  syntax: ["filter(x, test)"],
  description: "Filter items in a matrix.",
  examples: ["isPositive(x) = x > 0", "filter([6, -2, -1, 4, 3], isPositive)", "filter([6, -2, 0, 1, 0], x != 0)"],
  seealso: ["sort", "map", "forEach"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/flatten.js
var flattenDocs = {
  name: "flatten",
  category: "Matrix",
  syntax: ["flatten(x)"],
  description: "Flatten a multi dimensional matrix into a single dimensional matrix.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "size(a)", "b = flatten(a)", "size(b)"],
  seealso: ["concat", "resize", "size", "squeeze"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/forEach.js
var forEachDocs = {
  name: "forEach",
  category: "Matrix",
  syntax: ["forEach(x, callback)"],
  description: "Iterates over all elements of a matrix/array, and executes the given callback function.",
  examples: ["numberOfPets = {}", "addPet(n) = numberOfPets[n] = (numberOfPets[n] ? numberOfPets[n]:0 ) + 1;", 'forEach(["Dog","Cat","Cat"], addPet)', "numberOfPets"],
  seealso: ["map", "sort", "filter"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/getMatrixDataType.js
var getMatrixDataTypeDocs = {
  name: "getMatrixDataType",
  category: "Matrix",
  syntax: ["getMatrixDataType(x)"],
  description: 'Find the data type of all elements in a matrix or array, for example "number" if all items are a number and "Complex" if all values are complex numbers. If a matrix contains more than one data type, it will return "mixed".',
  examples: ["getMatrixDataType([1, 2, 3])", "getMatrixDataType([[5 cm], [2 inch]])", 'getMatrixDataType([1, "text"])', "getMatrixDataType([1, bignumber(4)])"],
  seealso: ["matrix", "sparse", "typeOf"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/identity.js
var identityDocs = {
  name: "identity",
  category: "Matrix",
  syntax: ["identity(n)", "identity(m, n)", "identity([m, n])"],
  description: "Returns the identity matrix with size m-by-n. The matrix has ones on the diagonal and zeros elsewhere.",
  examples: ["identity(3)", "identity(3, 5)", "a = [1, 2, 3; 4, 5, 6]", "identity(size(a))"],
  seealso: ["concat", "det", "diag", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/inv.js
var invDocs = {
  name: "inv",
  category: "Matrix",
  syntax: ["inv(x)"],
  description: "Calculate the inverse of a matrix",
  examples: ["inv([1, 2; 3, 4])", "inv(4)", "1 / 4"],
  seealso: ["concat", "det", "diag", "identity", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/pinv.js
var pinvDocs = {
  name: "pinv",
  category: "Matrix",
  syntax: ["pinv(x)"],
  description: "Calculate the Moore\u2013Penrose inverse of a matrix",
  examples: ["pinv([1, 2; 3, 4])", "pinv([[1, 0], [0, 1], [0, 1]])", "pinv(4)"],
  seealso: ["inv"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/kron.js
var kronDocs = {
  name: "kron",
  category: "Matrix",
  syntax: ["kron(x, y)"],
  description: "Calculates the kronecker product of 2 matrices or vectors.",
  examples: ["kron([[1, 0], [0, 1]], [[1, 2], [3, 4]])", "kron([1,1], [2,3,4])"],
  seealso: ["multiply", "dot", "cross"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/map.js
var mapDocs = {
  name: "map",
  category: "Matrix",
  syntax: ["map(x, callback)"],
  description: "Create a new matrix or array with the results of the callback function executed on each entry of the matrix/array.",
  examples: ["map([1, 2, 3], square)"],
  seealso: ["filter", "forEach"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/matrixFromColumns.js
var matrixFromColumnsDocs = {
  name: "matrixFromColumns",
  category: "Matrix",
  syntax: ["matrixFromColumns(...arr)", "matrixFromColumns(row1, row2)", "matrixFromColumns(row1, row2, row3)"],
  description: "Create a dense matrix from vectors as individual columns.",
  examples: ["matrixFromColumns([1, 2, 3], [[4],[5],[6]])"],
  seealso: ["matrix", "matrixFromRows", "matrixFromFunction", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/matrixFromFunction.js
var matrixFromFunctionDocs = {
  name: "matrixFromFunction",
  category: "Matrix",
  syntax: ["matrixFromFunction(size, fn)", "matrixFromFunction(size, fn, format)", "matrixFromFunction(size, fn, format, datatype)", "matrixFromFunction(size, format, fn)", "matrixFromFunction(size, format, datatype, fn)"],
  description: "Create a matrix by evaluating a generating function at each index.",
  examples: ["f(I) = I[1] - I[2]", "matrixFromFunction([3,3], f)", "g(I) = I[1] - I[2] == 1 ? 4 : 0", 'matrixFromFunction([100, 100], "sparse", g)', "matrixFromFunction([5], random)"],
  seealso: ["matrix", "matrixFromRows", "matrixFromColumns", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/matrixFromRows.js
var matrixFromRowsDocs = {
  name: "matrixFromRows",
  category: "Matrix",
  syntax: ["matrixFromRows(...arr)", "matrixFromRows(row1, row2)", "matrixFromRows(row1, row2, row3)"],
  description: "Create a dense matrix from vectors as individual rows.",
  examples: ["matrixFromRows([1, 2, 3], [[4],[5],[6]])"],
  seealso: ["matrix", "matrixFromColumns", "matrixFromFunction", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ones.js
var onesDocs = {
  name: "ones",
  category: "Matrix",
  syntax: ["ones(m)", "ones(m, n)", "ones(m, n, p, ...)", "ones([m])", "ones([m, n])", "ones([m, n, p, ...])"],
  description: "Create a matrix containing ones.",
  examples: ["ones(3)", "ones(3, 5)", "ones([2,3]) * 4.5", "a = [1, 2, 3; 4, 5, 6]", "ones(size(a))"],
  seealso: ["concat", "det", "diag", "identity", "inv", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/partitionSelect.js
var partitionSelectDocs = {
  name: "partitionSelect",
  category: "Matrix",
  syntax: ["partitionSelect(x, k)", "partitionSelect(x, k, compare)"],
  description: "Partition-based selection of an array or 1D matrix. Will find the kth smallest value, and mutates the input array. Uses Quickselect.",
  examples: ["partitionSelect([5, 10, 1], 2)", 'partitionSelect(["C", "B", "A", "D"], 1, compareText)', "arr = [5, 2, 1]", "partitionSelect(arr, 0) # returns 1, arr is now: [1, 2, 5]", "arr", "partitionSelect(arr, 1, 'desc') # returns 2, arr is now: [5, 2, 1]", "arr"],
  seealso: ["sort"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/range.js
var rangeDocs = {
  name: "range",
  category: "Type",
  syntax: ["start:end", "start:step:end", "range(start, end)", "range(start, end, step)", "range(string)"],
  description: "Create a range. Lower bound of the range is included, upper bound is excluded.",
  examples: ["1:5", "3:-1:-3", "range(3, 7)", "range(0, 12, 2)", 'range("4:10")', "range(1m, 1m, 3m)", "a = [1, 2, 3, 4; 5, 6, 7, 8]", "a[1:2, 1:2]"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/reshape.js
var reshapeDocs = {
  name: "reshape",
  category: "Matrix",
  syntax: ["reshape(x, sizes)"],
  description: "Reshape a multi dimensional array to fit the specified dimensions.",
  examples: ["reshape([1, 2, 3, 4, 5, 6], [2, 3])", "reshape([[1, 2], [3, 4]], [1, 4])", "reshape([[1, 2], [3, 4]], [4])", "reshape([1, 2, 3, 4], [-1, 2])"],
  seealso: ["size", "squeeze", "resize"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/resize.js
var resizeDocs = {
  name: "resize",
  category: "Matrix",
  syntax: ["resize(x, size)", "resize(x, size, defaultValue)"],
  description: "Resize a matrix.",
  examples: ["resize([1,2,3,4,5], [3])", "resize([1,2,3], [5])", "resize([1,2,3], [5], -1)", "resize(2, [2, 3])", 'resize("hello", [8], "!")'],
  seealso: ["size", "subset", "squeeze", "reshape"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/rotate.js
var rotateDocs = {
  name: "rotate",
  category: "Matrix",
  syntax: ["rotate(w, theta)", "rotate(w, theta, v)"],
  description: "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
  examples: ["rotate([1, 0], pi / 2)", 'rotate(matrix([1, 0]), unit("35deg"))', 'rotate([1, 0, 0], unit("90deg"), [0, 0, 1])', 'rotate(matrix([1, 0, 0]), unit("90deg"), matrix([0, 0, 1]))'],
  seealso: ["matrix", "rotationMatrix"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/rotationMatrix.js
var rotationMatrixDocs = {
  name: "rotationMatrix",
  category: "Matrix",
  syntax: ["rotationMatrix(theta)", "rotationMatrix(theta, v)", "rotationMatrix(theta, v, format)"],
  description: "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
  examples: ["rotationMatrix(pi / 2)", 'rotationMatrix(unit("45deg"), [0, 0, 1])', 'rotationMatrix(1, matrix([0, 0, 1]), "sparse")'],
  seealso: ["cos", "sin"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/row.js
var rowDocs = {
  name: "row",
  category: "Matrix",
  syntax: ["row(x, index)"],
  description: "Return a row from a matrix or array.",
  examples: ["A = [[1, 2], [3, 4]]", "row(A, 1)", "row(A, 2)"],
  seealso: ["column", "matrixFromRows"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/size.js
var sizeDocs = {
  name: "size",
  category: "Matrix",
  syntax: ["size(x)"],
  description: "Calculate the size of a matrix.",
  examples: ["size(2.3)", 'size("hello world")', "a = [1, 2; 3, 4; 5, 6]", "size(a)", "size(1:6)"],
  seealso: ["concat", "count", "det", "diag", "identity", "inv", "ones", "range", "squeeze", "subset", "trace", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/sort.js
var sortDocs = {
  name: "sort",
  category: "Matrix",
  syntax: ["sort(x)", "sort(x, compare)"],
  description: 'Sort the items in a matrix. Compare can be a string "asc", "desc", "natural", or a custom sort function.',
  examples: ["sort([5, 10, 1])", 'sort(["C", "B", "A", "D"], "natural")', "sortByLength(a, b) = size(a)[1] - size(b)[1]", 'sort(["Langdon", "Tom", "Sara"], sortByLength)', 'sort(["10", "1", "2"], "natural")'],
  seealso: ["map", "filter", "forEach"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/squeeze.js
var squeezeDocs = {
  name: "squeeze",
  category: "Matrix",
  syntax: ["squeeze(x)"],
  description: "Remove inner and outer singleton dimensions from a matrix.",
  examples: ["a = zeros(3,2,1)", "size(squeeze(a))", "b = zeros(1,1,3)", "size(squeeze(b))"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "subset", "trace", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/subset.js
var subsetDocs = {
  name: "subset",
  category: "Matrix",
  syntax: ["value(index)", "value(index) = replacement", "subset(value, [index])", "subset(value, [index], replacement)"],
  description: "Get or set a subset of the entries of a matrix or characters of a string. Indexes are one-based. There should be one index specification for each dimension of the target. Each specification can be a single index, a list of indices, or a range in colon notation `l:u`. In a range, both the lower bound l and upper bound u are included; and if a bound is omitted it defaults to the most extreme valid value. The cartesian product of the indices specified in each dimension determines the target of the operation.",
  examples: ["d = [1, 2; 3, 4]", "e = []", "e[1, 1:2] = [5, 6]", "e[2, :] = [7, 8]", "f = d * e", "f[2, 1]", "f[:, 1]", "f[[1,2], [1,3]] = [9, 10; 11, 12]", "f"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "trace", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/trace.js
var traceDocs = {
  name: "trace",
  category: "Matrix",
  syntax: ["trace(A)"],
  description: "Calculate the trace of a matrix: the sum of the elements on the main diagonal of a square matrix.",
  examples: ["A = [1, 2, 3; -1, 2, 3; 2, 0, 3]", "trace(A)"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "transpose", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/transpose.js
var transposeDocs = {
  name: "transpose",
  category: "Matrix",
  syntax: ["x'", "transpose(x)"],
  description: "Transpose a matrix",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "transpose(a)"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "zeros"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/zeros.js
var zerosDocs = {
  name: "zeros",
  category: "Matrix",
  syntax: ["zeros(m)", "zeros(m, n)", "zeros(m, n, p, ...)", "zeros([m])", "zeros([m, n])", "zeros([m, n, p, ...])"],
  description: "Create a matrix containing zeros.",
  examples: ["zeros(3)", "zeros(3, 5)", "a = [1, 2, 3; 4, 5, 6]", "zeros(size(a))"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/fft.js
var fftDocs = {
  name: "fft",
  category: "Matrix",
  syntax: ["fft(x)"],
  description: "Calculate N-dimensional fourier transform",
  examples: ["fft([[1, 0], [1, 0]])"],
  seealso: ["ifft"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ifft.js
var ifftDocs = {
  name: "ifft",
  category: "Matrix",
  syntax: ["ifft(x)"],
  description: "Calculate N-dimensional inverse fourier transform",
  examples: ["ifft([[2, 2], [0, 0]])"],
  seealso: ["fft"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/combinations.js
var combinationsDocs = {
  name: "combinations",
  category: "Probability",
  syntax: ["combinations(n, k)"],
  description: "Compute the number of combinations of n items taken k at a time",
  examples: ["combinations(7, 5)"],
  seealso: ["combinationsWithRep", "permutations", "factorial"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/combinationsWithRep.js
var combinationsWithRepDocs = {
  name: "combinationsWithRep",
  category: "Probability",
  syntax: ["combinationsWithRep(n, k)"],
  description: "Compute the number of combinations of n items taken k at a time with replacements.",
  examples: ["combinationsWithRep(7, 5)"],
  seealso: ["combinations", "permutations", "factorial"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/factorial.js
var factorialDocs = {
  name: "factorial",
  category: "Probability",
  syntax: ["n!", "factorial(n)"],
  description: "Compute the factorial of a value",
  examples: ["5!", "5 * 4 * 3 * 2 * 1", "3!"],
  seealso: ["combinations", "combinationsWithRep", "permutations", "gamma"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/gamma.js
var gammaDocs = {
  name: "gamma",
  category: "Probability",
  syntax: ["gamma(n)"],
  description: "Compute the gamma function. For small values, the Lanczos approximation is used, and for large values the extended Stirling approximation.",
  examples: ["gamma(4)", "3!", "gamma(1/2)", "sqrt(pi)"],
  seealso: ["factorial"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/lgamma.js
var lgammaDocs = {
  name: "lgamma",
  category: "Probability",
  syntax: ["lgamma(n)"],
  description: "Logarithm of the gamma function for real, positive numbers and complex numbers, using Lanczos approximation for numbers and Stirling series for complex numbers.",
  examples: ["lgamma(4)", "lgamma(1/2)", "lgamma(i)", "lgamma(complex(1.1, 2))"],
  seealso: ["gamma"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/kldivergence.js
var kldivergenceDocs = {
  name: "kldivergence",
  category: "Probability",
  syntax: ["kldivergence(x, y)"],
  description: "Calculate the Kullback-Leibler (KL) divergence  between two distributions.",
  examples: ["kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/multinomial.js
var multinomialDocs = {
  name: "multinomial",
  category: "Probability",
  syntax: ["multinomial(A)"],
  description: "Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities. multinomial takes one array of integers as an argument. The following condition must be enforced: every ai > 0.",
  examples: ["multinomial([1, 2, 1])"],
  seealso: ["combinations", "factorial"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/permutations.js
var permutationsDocs = {
  name: "permutations",
  category: "Probability",
  syntax: ["permutations(n)", "permutations(n, k)"],
  description: "Compute the number of permutations of n items taken k at a time",
  examples: ["permutations(5)", "permutations(5, 3)"],
  seealso: ["combinations", "combinationsWithRep", "factorial"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/pickRandom.js
var pickRandomDocs = {
  name: "pickRandom",
  category: "Probability",
  syntax: ["pickRandom(array)", "pickRandom(array, number)", "pickRandom(array, weights)", "pickRandom(array, number, weights)", "pickRandom(array, weights, number)"],
  description: "Pick a random entry from a given array.",
  examples: ["pickRandom(0:10)", "pickRandom([1, 3, 1, 6])", "pickRandom([1, 3, 1, 6], 2)", "pickRandom([1, 3, 1, 6], [2, 3, 2, 1])", "pickRandom([1, 3, 1, 6], 2, [2, 3, 2, 1])", "pickRandom([1, 3, 1, 6], [2, 3, 2, 1], 2)"],
  seealso: ["random", "randomInt"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/random.js
var randomDocs = {
  name: "random",
  category: "Probability",
  syntax: ["random()", "random(max)", "random(min, max)", "random(size)", "random(size, max)", "random(size, min, max)"],
  description: "Return a random number.",
  examples: ["random()", "random(10, 20)", "random([2, 3])"],
  seealso: ["pickRandom", "randomInt"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/randomInt.js
var randomIntDocs = {
  name: "randomInt",
  category: "Probability",
  syntax: ["randomInt(max)", "randomInt(min, max)", "randomInt(size)", "randomInt(size, max)", "randomInt(size, min, max)"],
  description: "Return a random integer number",
  examples: ["randomInt(10, 20)", "randomInt([2, 3], 10)"],
  seealso: ["pickRandom", "random"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compare.js
var compareDocs = {
  name: "compare",
  category: "Relational",
  syntax: ["compare(x, y)"],
  description: "Compare two values. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
  examples: ["compare(2, 3)", "compare(3, 2)", "compare(2, 2)", "compare(5cm, 40mm)", "compare(2, [1, 2, 3])"],
  seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compareNatural", "compareText"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compareNatural.js
var compareNaturalDocs = {
  name: "compareNatural",
  category: "Relational",
  syntax: ["compareNatural(x, y)"],
  description: "Compare two values of any type in a deterministic, natural way. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
  examples: ["compareNatural(2, 3)", "compareNatural(3, 2)", "compareNatural(2, 2)", "compareNatural(5cm, 40mm)", 'compareNatural("2", "10")', "compareNatural(2 + 3i, 2 + 4i)", "compareNatural([1, 2, 4], [1, 2, 3])", "compareNatural([1, 5], [1, 2, 3])", "compareNatural([1, 2], [1, 2])", "compareNatural({a: 2}, {a: 4})"],
  seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compare", "compareText"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compareText.js
var compareTextDocs = {
  name: "compareText",
  category: "Relational",
  syntax: ["compareText(x, y)"],
  description: "Compare two strings lexically. Comparison is case sensitive. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
  examples: ['compareText("B", "A")', 'compareText("A", "B")', 'compareText("A", "A")', 'compareText("2", "10")', 'compare("2", "10")', "compare(2, 10)", 'compareNatural("2", "10")', 'compareText("B", ["A", "B", "C"])'],
  seealso: ["compare", "compareNatural"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/deepEqual.js
var deepEqualDocs = {
  name: "deepEqual",
  category: "Relational",
  syntax: ["deepEqual(x, y)"],
  description: "Check equality of two matrices element wise. Returns true if the size of both matrices is equal and when and each of the elements are equal.",
  examples: ["deepEqual([1,3,4], [1,3,4])", "deepEqual([1,3,4], [1,3])"],
  seealso: ["equal", "unequal", "smaller", "larger", "smallerEq", "largerEq", "compare"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/equal.js
var equalDocs = {
  name: "equal",
  category: "Relational",
  syntax: ["x == y", "equal(x, y)"],
  description: "Check equality of two values. Returns true if the values are equal, and false if not.",
  examples: ["2+2 == 3", "2+2 == 4", "a = 3.2", "b = 6-2.8", "a == b", "50cm == 0.5m"],
  seealso: ["unequal", "smaller", "larger", "smallerEq", "largerEq", "compare", "deepEqual", "equalText"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/equalText.js
var equalTextDocs = {
  name: "equalText",
  category: "Relational",
  syntax: ["equalText(x, y)"],
  description: "Check equality of two strings. Comparison is case sensitive. Returns true if the values are equal, and false if not.",
  examples: ['equalText("Hello", "Hello")', 'equalText("a", "A")', 'equal("2e3", "2000")', 'equalText("2e3", "2000")', 'equalText("B", ["A", "B", "C"])'],
  seealso: ["compare", "compareNatural", "compareText", "equal"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/larger.js
var largerDocs = {
  name: "larger",
  category: "Relational",
  syntax: ["x > y", "larger(x, y)"],
  description: "Check if value x is larger than y. Returns true if x is larger than y, and false if not.",
  examples: ["2 > 3", "5 > 2*2", "a = 3.3", "b = 6-2.8", "(a > b)", "(b < a)", "5 cm > 2 inch"],
  seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compare"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/largerEq.js
var largerEqDocs = {
  name: "largerEq",
  category: "Relational",
  syntax: ["x >= y", "largerEq(x, y)"],
  description: "Check if value x is larger or equal to y. Returns true if x is larger or equal to y, and false if not.",
  examples: ["2 >= 1+1", "2 > 1+1", "a = 3.2", "b = 6-2.8", "(a >= b)"],
  seealso: ["equal", "unequal", "smallerEq", "smaller", "compare"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/smaller.js
var smallerDocs = {
  name: "smaller",
  category: "Relational",
  syntax: ["x < y", "smaller(x, y)"],
  description: "Check if value x is smaller than value y. Returns true if x is smaller than y, and false if not.",
  examples: ["2 < 3", "5 < 2*2", "a = 3.3", "b = 6-2.8", "(a < b)", "5 cm < 2 inch"],
  seealso: ["equal", "unequal", "larger", "smallerEq", "largerEq", "compare"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/smallerEq.js
var smallerEqDocs = {
  name: "smallerEq",
  category: "Relational",
  syntax: ["x <= y", "smallerEq(x, y)"],
  description: "Check if value x is smaller or equal to value y. Returns true if x is smaller than y, and false if not.",
  examples: ["2 <= 1+1", "2 < 1+1", "a = 3.2", "b = 6-2.8", "(a <= b)"],
  seealso: ["equal", "unequal", "larger", "smaller", "largerEq", "compare"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/unequal.js
var unequalDocs = {
  name: "unequal",
  category: "Relational",
  syntax: ["x != y", "unequal(x, y)"],
  description: "Check unequality of two values. Returns true if the values are unequal, and false if they are equal.",
  examples: ["2+2 != 3", "2+2 != 4", "a = 3.2", "b = 6-2.8", "a != b", "50cm != 0.5m", "5 cm != 2 inch"],
  seealso: ["equal", "smaller", "larger", "smallerEq", "largerEq", "compare", "deepEqual"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setCartesian.js
var setCartesianDocs = {
  name: "setCartesian",
  category: "Set",
  syntax: ["setCartesian(set1, set2)"],
  description: "Create the cartesian product of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays and the values will be sorted in ascending order before the operation.",
  examples: ["setCartesian([1, 2], [3, 4])"],
  seealso: ["setUnion", "setIntersect", "setDifference", "setPowerset"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setDifference.js
var setDifferenceDocs = {
  name: "setDifference",
  category: "Set",
  syntax: ["setDifference(set1, set2)"],
  description: "Create the difference of two (multi)sets: every element of set1, that is not the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setDifference([1, 2, 3, 4], [3, 4, 5, 6])", "setDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setUnion", "setIntersect", "setSymDifference"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setDistinct.js
var setDistinctDocs = {
  name: "setDistinct",
  category: "Set",
  syntax: ["setDistinct(set)"],
  description: "Collect the distinct elements of a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
  examples: ["setDistinct([1, 1, 1, 2, 2, 3])"],
  seealso: ["setMultiplicity"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setIntersect.js
var setIntersectDocs = {
  name: "setIntersect",
  category: "Set",
  syntax: ["setIntersect(set1, set2)"],
  description: "Create the intersection of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setIntersect([1, 2, 3, 4], [3, 4, 5, 6])", "setIntersect([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setUnion", "setDifference"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setIsSubset.js
var setIsSubsetDocs = {
  name: "setIsSubset",
  category: "Set",
  syntax: ["setIsSubset(set1, set2)"],
  description: "Check whether a (multi)set is a subset of another (multi)set: every element of set1 is the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setIsSubset([1, 2], [3, 4, 5, 6])", "setIsSubset([3, 4], [3, 4, 5, 6])"],
  seealso: ["setUnion", "setIntersect", "setDifference"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setMultiplicity.js
var setMultiplicityDocs = {
  name: "setMultiplicity",
  category: "Set",
  syntax: ["setMultiplicity(element, set)"],
  description: "Count the multiplicity of an element in a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
  examples: ["setMultiplicity(1, [1, 2, 2, 4])", "setMultiplicity(2, [1, 2, 2, 4])"],
  seealso: ["setDistinct", "setSize"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setPowerset.js
var setPowersetDocs = {
  name: "setPowerset",
  category: "Set",
  syntax: ["setPowerset(set)"],
  description: "Create the powerset of a (multi)set: the powerset contains very possible subsets of a (multi)set. A multi-dimension array will be converted to a single-dimension array before the operation.",
  examples: ["setPowerset([1, 2, 3])"],
  seealso: ["setCartesian"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setSize.js
var setSizeDocs = {
  name: "setSize",
  category: "Set",
  syntax: ["setSize(set)", "setSize(set, unique)"],
  description: 'Count the number of elements of a (multi)set. When the second parameter "unique" is true, count only the unique values. A multi-dimension array will be converted to a single-dimension array before the operation.',
  examples: ["setSize([1, 2, 2, 4])", "setSize([1, 2, 2, 4], true)"],
  seealso: ["setUnion", "setIntersect", "setDifference"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setSymDifference.js
var setSymDifferenceDocs = {
  name: "setSymDifference",
  category: "Set",
  syntax: ["setSymDifference(set1, set2)"],
  description: "Create the symmetric difference of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setSymDifference([1, 2, 3, 4], [3, 4, 5, 6])", "setSymDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setUnion", "setIntersect", "setDifference"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setUnion.js
var setUnionDocs = {
  name: "setUnion",
  category: "Set",
  syntax: ["setUnion(set1, set2)"],
  description: "Create the union of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setUnion([1, 2, 3, 4], [3, 4, 5, 6])", "setUnion([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setIntersect", "setDifference"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/signal/zpk2tf.js
var zpk2tfDocs = {
  name: "zpk2tf",
  category: "Signal",
  syntax: ["zpk2tf(z, p, k)"],
  description: "Compute the transfer function of a zero-pole-gain model.",
  examples: ["zpk2tf([1, 2], [-1, -2], 1)", "zpk2tf([1, 2], [-1, -2])", "zpk2tf([1 - 3i, 2 + 2i], [-1, -2])"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/signal/freqz.js
var freqzDocs = {
  name: "freqz",
  category: "Signal",
  syntax: ["freqz(b, a)", "freqz(b, a, w)"],
  description: "Calculates the frequency response of a filter given its numerator and denominator coefficients.",
  examples: ["freqz([1, 2], [1, 2, 3])", "freqz([1, 2], [1, 2, 3], [0, 1])", "freqz([1, 2], [1, 2, 3], 512)"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/special/erf.js
var erfDocs = {
  name: "erf",
  category: "Special",
  syntax: ["erf(x)"],
  description: "Compute the erf function of a value using a rational Chebyshev approximations for different intervals of x",
  examples: ["erf(0.2)", "erf(-0.5)", "erf(4)"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/special/zeta.js
var zetaDocs = {
  name: "zeta",
  category: "Special",
  syntax: ["zeta(s)"],
  description: "Compute the Riemann Zeta Function using an infinite series and Riemanns Functional Equation for the entire complex plane",
  examples: ["zeta(0.2)", "zeta(-0.5)", "zeta(4)"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mad.js
var madDocs = {
  name: "mad",
  category: "Statistics",
  syntax: ["mad(a, b, c, ...)", "mad(A)"],
  description: "Compute the median absolute deviation of a matrix or a list with values. The median absolute deviation is defined as the median of the absolute deviations from the median.",
  examples: ["mad(10, 20, 30)", "mad([1, 2, 3])"],
  seealso: ["mean", "median", "std", "abs"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/max.js
var maxDocs = {
  name: "max",
  category: "Statistics",
  syntax: ["max(a, b, c, ...)", "max(A)", "max(A, dimension)"],
  description: "Compute the maximum value of a list of values.",
  examples: ["max(2, 3, 4, 1)", "max([2, 3, 4, 1])", "max([2, 5; 4, 3])", "max([2, 5; 4, 3], 1)", "max([2, 5; 4, 3], 2)", "max(2.7, 7.1, -4.5, 2.0, 4.1)", "min(2.7, 7.1, -4.5, 2.0, 4.1)"],
  seealso: ["mean", "median", "min", "prod", "std", "sum", "variance"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mean.js
var meanDocs = {
  name: "mean",
  category: "Statistics",
  syntax: ["mean(a, b, c, ...)", "mean(A)", "mean(A, dimension)"],
  description: "Compute the arithmetic mean of a list of values.",
  examples: ["mean(2, 3, 4, 1)", "mean([2, 3, 4, 1])", "mean([2, 5; 4, 3])", "mean([2, 5; 4, 3], 1)", "mean([2, 5; 4, 3], 2)", "mean([1.0, 2.7, 3.2, 4.0])"],
  seealso: ["max", "median", "min", "prod", "std", "sum", "variance"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/median.js
var medianDocs = {
  name: "median",
  category: "Statistics",
  syntax: ["median(a, b, c, ...)", "median(A)"],
  description: "Compute the median of all values. The values are sorted and the middle value is returned. In case of an even number of values, the average of the two middle values is returned.",
  examples: ["median(5, 2, 7)", "median([3, -1, 5, 7])"],
  seealso: ["max", "mean", "min", "prod", "std", "sum", "variance", "quantileSeq"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/min.js
var minDocs = {
  name: "min",
  category: "Statistics",
  syntax: ["min(a, b, c, ...)", "min(A)", "min(A, dimension)"],
  description: "Compute the minimum value of a list of values.",
  examples: ["min(2, 3, 4, 1)", "min([2, 3, 4, 1])", "min([2, 5; 4, 3])", "min([2, 5; 4, 3], 1)", "min([2, 5; 4, 3], 2)", "min(2.7, 7.1, -4.5, 2.0, 4.1)", "max(2.7, 7.1, -4.5, 2.0, 4.1)"],
  seealso: ["max", "mean", "median", "prod", "std", "sum", "variance"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mode.js
var modeDocs = {
  name: "mode",
  category: "Statistics",
  syntax: ["mode(a, b, c, ...)", "mode(A)", "mode(A, a, b, B, c, ...)"],
  description: "Computes the mode of all values as an array. In case mode being more than one, multiple values are returned in an array.",
  examples: ["mode(2, 1, 4, 3, 1)", "mode([1, 2.7, 3.2, 4, 2.7])", "mode(1, 4, 6, 1, 6)"],
  seealso: ["max", "mean", "min", "median", "prod", "std", "sum", "variance"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/prod.js
var prodDocs = {
  name: "prod",
  category: "Statistics",
  syntax: ["prod(a, b, c, ...)", "prod(A)"],
  description: "Compute the product of all values.",
  examples: ["prod(2, 3, 4)", "prod([2, 3, 4])", "prod([2, 5; 4, 3])"],
  seealso: ["max", "mean", "min", "median", "min", "std", "sum", "variance"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/quantileSeq.js
var quantileSeqDocs = {
  name: "quantileSeq",
  category: "Statistics",
  syntax: ["quantileSeq(A, prob[, sorted])", "quantileSeq(A, [prob1, prob2, ...][, sorted])", "quantileSeq(A, N[, sorted])"],
  description: "Compute the prob order quantile of a matrix or a list with values. The sequence is sorted and the middle value is returned. Supported types of sequence values are: Number, BigNumber, Unit Supported types of probablity are: Number, BigNumber. \n\nIn case of a (multi dimensional) array or matrix, the prob order quantile of all elements will be calculated.",
  examples: ["quantileSeq([3, -1, 5, 7], 0.5)", "quantileSeq([3, -1, 5, 7], [1/3, 2/3])", "quantileSeq([3, -1, 5, 7], 2)", "quantileSeq([-1, 3, 5, 7], 0.5, true)"],
  seealso: ["mean", "median", "min", "max", "prod", "std", "sum", "variance"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/std.js
var stdDocs = {
  name: "std",
  category: "Statistics",
  syntax: ["std(a, b, c, ...)", "std(A)", "std(A, dimension)", "std(A, normalization)", "std(A, dimension, normalization)"],
  description: 'Compute the standard deviation of all values, defined as std(A) = sqrt(variance(A)). Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
  examples: ["std(2, 4, 6)", "std([2, 4, 6, 8])", 'std([2, 4, 6, 8], "uncorrected")', 'std([2, 4, 6, 8], "biased")', "std([1, 2, 3; 4, 5, 6])"],
  seealso: ["max", "mean", "min", "median", "prod", "sum", "variance"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/cumsum.js
var cumSumDocs = {
  name: "cumsum",
  category: "Statistics",
  syntax: ["cumsum(a, b, c, ...)", "cumsum(A)"],
  description: "Compute the cumulative sum of all values.",
  examples: ["cumsum(2, 3, 4, 1)", "cumsum([2, 3, 4, 1])", "cumsum([1, 2; 3, 4])", "cumsum([1, 2; 3, 4], 1)", "cumsum([1, 2; 3, 4], 2)"],
  seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/sum.js
var sumDocs = {
  name: "sum",
  category: "Statistics",
  syntax: ["sum(a, b, c, ...)", "sum(A)", "sum(A, dimension)"],
  description: "Compute the sum of all values.",
  examples: ["sum(2, 3, 4, 1)", "sum([2, 3, 4, 1])", "sum([2, 5; 4, 3])"],
  seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/variance.js
var varianceDocs = {
  name: "variance",
  category: "Statistics",
  syntax: ["variance(a, b, c, ...)", "variance(A)", "variance(A, dimension)", "variance(A, normalization)", "variance(A, dimension, normalization)"],
  description: 'Compute the variance of all values. Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
  examples: ["variance(2, 4, 6)", "variance([2, 4, 6, 8])", 'variance([2, 4, 6, 8], "uncorrected")', 'variance([2, 4, 6, 8], "biased")', "variance([1, 2, 3; 4, 5, 6])"],
  seealso: ["max", "mean", "min", "median", "min", "prod", "std", "sum"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/corr.js
var corrDocs = {
  name: "corr",
  category: "Statistics",
  syntax: ["corr(A,B)"],
  description: "Compute the correlation coefficient of a two list with values, For matrices, the matrix correlation coefficient is calculated.",
  examples: ["corr([2, 4, 6, 8],[1, 2, 3, 6])", "corr(matrix([[1, 2.2, 3, 4.8, 5], [1, 2, 3, 4, 5]]), matrix([[4, 5.3, 6.6, 7, 8], [1, 2, 3, 4, 5]]))"],
  seealso: ["max", "mean", "min", "median", "min", "prod", "std", "sum"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acos.js
var acosDocs = {
  name: "acos",
  category: "Trigonometry",
  syntax: ["acos(x)"],
  description: "Compute the inverse cosine of a value in radians.",
  examples: ["acos(0.5)", "acos(cos(2.3))"],
  seealso: ["cos", "atan", "asin"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acosh.js
var acoshDocs = {
  name: "acosh",
  category: "Trigonometry",
  syntax: ["acosh(x)"],
  description: "Calculate the hyperbolic arccos of a value, defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.",
  examples: ["acosh(1.5)"],
  seealso: ["cosh", "asinh", "atanh"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acot.js
var acotDocs = {
  name: "acot",
  category: "Trigonometry",
  syntax: ["acot(x)"],
  description: "Calculate the inverse cotangent of a value.",
  examples: ["acot(0.5)", "acot(cot(0.5))", "acot(2)"],
  seealso: ["cot", "atan"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acoth.js
var acothDocs = {
  name: "acoth",
  category: "Trigonometry",
  syntax: ["acoth(x)"],
  description: "Calculate the hyperbolic arccotangent of a value, defined as `acoth(x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.",
  examples: ["acoth(2)", "acoth(0.5)"],
  seealso: ["acsch", "asech"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acsc.js
var acscDocs = {
  name: "acsc",
  category: "Trigonometry",
  syntax: ["acsc(x)"],
  description: "Calculate the inverse cotangent of a value.",
  examples: ["acsc(2)", "acsc(csc(0.5))", "acsc(0.5)"],
  seealso: ["csc", "asin", "asec"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acsch.js
var acschDocs = {
  name: "acsch",
  category: "Trigonometry",
  syntax: ["acsch(x)"],
  description: "Calculate the hyperbolic arccosecant of a value, defined as `acsch(x) = ln(1/x + sqrt(1/x^2 + 1))`.",
  examples: ["acsch(0.5)"],
  seealso: ["asech", "acoth"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asec.js
var asecDocs = {
  name: "asec",
  category: "Trigonometry",
  syntax: ["asec(x)"],
  description: "Calculate the inverse secant of a value.",
  examples: ["asec(0.5)", "asec(sec(0.5))", "asec(2)"],
  seealso: ["acos", "acot", "acsc"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asech.js
var asechDocs = {
  name: "asech",
  category: "Trigonometry",
  syntax: ["asech(x)"],
  description: "Calculate the inverse secant of a value.",
  examples: ["asech(0.5)"],
  seealso: ["acsch", "acoth"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asin.js
var asinDocs = {
  name: "asin",
  category: "Trigonometry",
  syntax: ["asin(x)"],
  description: "Compute the inverse sine of a value in radians.",
  examples: ["asin(0.5)", "asin(sin(0.5))"],
  seealso: ["sin", "acos", "atan"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asinh.js
var asinhDocs = {
  name: "asinh",
  category: "Trigonometry",
  syntax: ["asinh(x)"],
  description: "Calculate the hyperbolic arcsine of a value, defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.",
  examples: ["asinh(0.5)"],
  seealso: ["acosh", "atanh"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atan.js
var atanDocs = {
  name: "atan",
  category: "Trigonometry",
  syntax: ["atan(x)"],
  description: "Compute the inverse tangent of a value in radians.",
  examples: ["atan(0.5)", "atan(tan(0.5))"],
  seealso: ["tan", "acos", "asin"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atan2.js
var atan2Docs = {
  name: "atan2",
  category: "Trigonometry",
  syntax: ["atan2(y, x)"],
  description: "Computes the principal value of the arc tangent of y/x in radians.",
  examples: ["atan2(2, 2) / pi", "angle = 60 deg in rad", "x = cos(angle)", "y = sin(angle)", "atan2(y, x)"],
  seealso: ["sin", "cos", "tan"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atanh.js
var atanhDocs = {
  name: "atanh",
  category: "Trigonometry",
  syntax: ["atanh(x)"],
  description: "Calculate the hyperbolic arctangent of a value, defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.",
  examples: ["atanh(0.5)"],
  seealso: ["acosh", "asinh"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cos.js
var cosDocs = {
  name: "cos",
  category: "Trigonometry",
  syntax: ["cos(x)"],
  description: "Compute the cosine of x in radians.",
  examples: ["cos(2)", "cos(pi / 4) ^ 2", "cos(180 deg)", "cos(60 deg)", "sin(0.2)^2 + cos(0.2)^2"],
  seealso: ["acos", "sin", "tan"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cosh.js
var coshDocs = {
  name: "cosh",
  category: "Trigonometry",
  syntax: ["cosh(x)"],
  description: "Compute the hyperbolic cosine of x in radians.",
  examples: ["cosh(0.5)"],
  seealso: ["sinh", "tanh", "coth"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cot.js
var cotDocs = {
  name: "cot",
  category: "Trigonometry",
  syntax: ["cot(x)"],
  description: "Compute the cotangent of x in radians. Defined as 1/tan(x)",
  examples: ["cot(2)", "1 / tan(2)"],
  seealso: ["sec", "csc", "tan"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/coth.js
var cothDocs = {
  name: "coth",
  category: "Trigonometry",
  syntax: ["coth(x)"],
  description: "Compute the hyperbolic cotangent of x in radians.",
  examples: ["coth(2)", "1 / tanh(2)"],
  seealso: ["sech", "csch", "tanh"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/csc.js
var cscDocs = {
  name: "csc",
  category: "Trigonometry",
  syntax: ["csc(x)"],
  description: "Compute the cosecant of x in radians. Defined as 1/sin(x)",
  examples: ["csc(2)", "1 / sin(2)"],
  seealso: ["sec", "cot", "sin"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/csch.js
var cschDocs = {
  name: "csch",
  category: "Trigonometry",
  syntax: ["csch(x)"],
  description: "Compute the hyperbolic cosecant of x in radians. Defined as 1/sinh(x)",
  examples: ["csch(2)", "1 / sinh(2)"],
  seealso: ["sech", "coth", "sinh"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sec.js
var secDocs = {
  name: "sec",
  category: "Trigonometry",
  syntax: ["sec(x)"],
  description: "Compute the secant of x in radians. Defined as 1/cos(x)",
  examples: ["sec(2)", "1 / cos(2)"],
  seealso: ["cot", "csc", "cos"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sech.js
var sechDocs = {
  name: "sech",
  category: "Trigonometry",
  syntax: ["sech(x)"],
  description: "Compute the hyperbolic secant of x in radians. Defined as 1/cosh(x)",
  examples: ["sech(2)", "1 / cosh(2)"],
  seealso: ["coth", "csch", "cosh"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sin.js
var sinDocs = {
  name: "sin",
  category: "Trigonometry",
  syntax: ["sin(x)"],
  description: "Compute the sine of x in radians.",
  examples: ["sin(2)", "sin(pi / 4) ^ 2", "sin(90 deg)", "sin(30 deg)", "sin(0.2)^2 + cos(0.2)^2"],
  seealso: ["asin", "cos", "tan"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sinh.js
var sinhDocs = {
  name: "sinh",
  category: "Trigonometry",
  syntax: ["sinh(x)"],
  description: "Compute the hyperbolic sine of x in radians.",
  examples: ["sinh(0.5)"],
  seealso: ["cosh", "tanh"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/tan.js
var tanDocs = {
  name: "tan",
  category: "Trigonometry",
  syntax: ["tan(x)"],
  description: "Compute the tangent of x in radians.",
  examples: ["tan(0.5)", "sin(0.5) / cos(0.5)", "tan(pi / 4)", "tan(45 deg)"],
  seealso: ["atan", "sin", "cos"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/tanh.js
var tanhDocs = {
  name: "tanh",
  category: "Trigonometry",
  syntax: ["tanh(x)"],
  description: "Compute the hyperbolic tangent of x in radians.",
  examples: ["tanh(0.5)", "sinh(0.5) / cosh(0.5)"],
  seealso: ["sinh", "cosh"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/units/to.js
var toDocs = {
  name: "to",
  category: "Units",
  syntax: ["x to unit", "to(x, unit)"],
  description: "Change the unit of a value.",
  examples: ["5 inch to cm", "3.2kg to g", "16 bytes in bits"],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/bin.js
var binDocs = {
  name: "bin",
  category: "Utils",
  syntax: ["bin(value)"],
  description: "Format a number as binary",
  examples: ["bin(2)"],
  seealso: ["oct", "hex"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/clone.js
var cloneDocs = {
  name: "clone",
  category: "Utils",
  syntax: ["clone(x)"],
  description: "Clone a variable. Creates a copy of primitive variables,and a deep copy of matrices",
  examples: ["clone(3.5)", "clone(2 - 4i)", "clone(45 deg)", "clone([1, 2; 3, 4])", 'clone("hello world")'],
  seealso: []
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/format.js
var formatDocs = {
  name: "format",
  category: "Utils",
  syntax: ["format(value)", "format(value, precision)"],
  description: "Format a value of any type as string.",
  examples: ["format(2.3)", "format(3 - 4i)", "format([])", "format(pi, 3)"],
  seealso: ["print"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/hasNumericValue.js
var hasNumericValueDocs = {
  name: "hasNumericValue",
  category: "Utils",
  syntax: ["hasNumericValue(x)"],
  description: "Test whether a value is an numeric value. In case of a string, true is returned if the string contains a numeric value.",
  examples: ["hasNumericValue(2)", 'hasNumericValue("2")', 'isNumeric("2")', "hasNumericValue(0)", "hasNumericValue(bignumber(500))", "hasNumericValue(fraction(0.125))", "hasNumericValue(2 + 3i)", 'hasNumericValue([2.3, "foo", false])'],
  seealso: ["isInteger", "isZero", "isNegative", "isPositive", "isNaN", "isNumeric"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/hex.js
var hexDocs = {
  name: "hex",
  category: "Utils",
  syntax: ["hex(value)"],
  description: "Format a number as hexadecimal",
  examples: ["hex(240)"],
  seealso: ["bin", "oct"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isInteger.js
var isIntegerDocs = {
  name: "isInteger",
  category: "Utils",
  syntax: ["isInteger(x)"],
  description: "Test whether a value is an integer number.",
  examples: ["isInteger(2)", "isInteger(3.5)", "isInteger([3, 0.5, -2])"],
  seealso: ["isNegative", "isNumeric", "isPositive", "isZero"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNaN.js
var isNaNDocs = {
  name: "isNaN",
  category: "Utils",
  syntax: ["isNaN(x)"],
  description: "Test whether a value is NaN (not a number)",
  examples: ["isNaN(2)", "isNaN(0 / 0)", "isNaN(NaN)", "isNaN(Infinity)"],
  seealso: ["isNegative", "isNumeric", "isPositive", "isZero"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNegative.js
var isNegativeDocs = {
  name: "isNegative",
  category: "Utils",
  syntax: ["isNegative(x)"],
  description: "Test whether a value is negative: smaller than zero.",
  examples: ["isNegative(2)", "isNegative(0)", "isNegative(-4)", "isNegative([3, 0.5, -2])"],
  seealso: ["isInteger", "isNumeric", "isPositive", "isZero"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNumeric.js
var isNumericDocs = {
  name: "isNumeric",
  category: "Utils",
  syntax: ["isNumeric(x)"],
  description: "Test whether a value is a numeric value. Returns true when the input is a number, BigNumber, Fraction, or boolean.",
  examples: ["isNumeric(2)", 'isNumeric("2")', 'hasNumericValue("2")', "isNumeric(0)", "isNumeric(bignumber(500))", "isNumeric(fraction(0.125))", "isNumeric(2 + 3i)", 'isNumeric([2.3, "foo", false])'],
  seealso: ["isInteger", "isZero", "isNegative", "isPositive", "isNaN", "hasNumericValue"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isPositive.js
var isPositiveDocs = {
  name: "isPositive",
  category: "Utils",
  syntax: ["isPositive(x)"],
  description: "Test whether a value is positive: larger than zero.",
  examples: ["isPositive(2)", "isPositive(0)", "isPositive(-4)", "isPositive([3, 0.5, -2])"],
  seealso: ["isInteger", "isNumeric", "isNegative", "isZero"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isPrime.js
var isPrimeDocs = {
  name: "isPrime",
  category: "Utils",
  syntax: ["isPrime(x)"],
  description: "Test whether a value is prime: has no divisors other than itself and one.",
  examples: ["isPrime(3)", "isPrime(-2)", "isPrime([2, 17, 100])"],
  seealso: ["isInteger", "isNumeric", "isNegative", "isZero"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isZero.js
var isZeroDocs = {
  name: "isZero",
  category: "Utils",
  syntax: ["isZero(x)"],
  description: "Test whether a value is zero.",
  examples: ["isZero(2)", "isZero(0)", "isZero(-4)", "isZero([3, 0, -2, 0])"],
  seealso: ["isInteger", "isNumeric", "isNegative", "isPositive"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/numeric.js
var numericDocs = {
  name: "numeric",
  category: "Utils",
  syntax: ["numeric(x)"],
  description: "Convert a numeric input to a specific numeric type: number, BigNumber, bigint, or Fraction.",
  examples: ['numeric("4")', 'numeric("4", "number")', 'numeric("4", "bigint")', 'numeric("4", "BigNumber")', 'numeric("4", "Fraction")', 'numeric(4, "Fraction")', 'numeric(fraction(2, 5), "number")'],
  seealso: ["number", "bigint", "fraction", "bignumber", "string", "format"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/oct.js
var octDocs = {
  name: "oct",
  category: "Utils",
  syntax: ["oct(value)"],
  description: "Format a number as octal",
  examples: ["oct(56)"],
  seealso: ["bin", "hex"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/print.js
var printDocs = {
  name: "print",
  category: "Utils",
  syntax: ["print(template, values)", "print(template, values, precision)"],
  description: "Interpolate values into a string template.",
  examples: ['print("Lucy is $age years old", {age: 5})', 'print("The value of pi is $pi", {pi: pi}, 3)', 'print("Hello, $user.name!", {user: {name: "John"}})', 'print("Values: $1, $2, $3", [6, 9, 4])'],
  seealso: ["format"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/typeOf.js
var typeOfDocs = {
  name: "typeOf",
  category: "Utils",
  syntax: ["typeOf(x)"],
  description: "Get the type of a variable.",
  examples: ["typeOf(3.5)", "typeOf(2 - 4i)", "typeOf(45 deg)", 'typeOf("hello world")'],
  seealso: ["getMatrixDataType"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/numeric/solveODE.js
var solveODEDocs = {
  name: "solveODE",
  category: "Numeric",
  syntax: ["solveODE(func, tspan, y0)", "solveODE(func, tspan, y0, options)"],
  description: "Numerical Integration of Ordinary Differential Equations.",
  examples: ["f(t,y) = y", "tspan = [0, 4]", "solveODE(f, tspan, 1)", "solveODE(f, tspan, [1, 2])", 'solveODE(f, tspan, 1, { method:"RK23", maxStep:0.1 })'],
  seealso: ["derivative", "simplifyCore"]
};

// node_modules/mathjs/lib/esm/expression/embeddedDocs/embeddedDocs.js
var embeddedDocs = {
  // construction functions
  bignumber: bignumberDocs,
  bigint: bigintDocs,
  boolean: booleanDocs,
  complex: complexDocs,
  createUnit: createUnitDocs,
  fraction: fractionDocs,
  index: indexDocs,
  matrix: matrixDocs,
  number: numberDocs,
  sparse: sparseDocs,
  splitUnit: splitUnitDocs,
  string: stringDocs,
  unit: unitDocs,
  // constants
  e: eDocs,
  E: eDocs,
  false: falseDocs,
  i: iDocs,
  Infinity: InfinityDocs,
  LN2: LN2Docs,
  LN10: LN10Docs,
  LOG2E: LOG2EDocs,
  LOG10E: LOG10EDocs,
  NaN: NaNDocs,
  null: nullDocs,
  pi: piDocs,
  PI: piDocs,
  phi: phiDocs,
  SQRT1_2: SQRT12Docs,
  SQRT2: SQRT2Docs,
  tau: tauDocs,
  true: trueDocs,
  version: versionDocs,
  // physical constants
  // TODO: more detailed docs for physical constants
  speedOfLight: {
    description: "Speed of light in vacuum",
    examples: ["speedOfLight"]
  },
  gravitationConstant: {
    description: "Newtonian constant of gravitation",
    examples: ["gravitationConstant"]
  },
  planckConstant: {
    description: "Planck constant",
    examples: ["planckConstant"]
  },
  reducedPlanckConstant: {
    description: "Reduced Planck constant",
    examples: ["reducedPlanckConstant"]
  },
  magneticConstant: {
    description: "Magnetic constant (vacuum permeability)",
    examples: ["magneticConstant"]
  },
  electricConstant: {
    description: "Electric constant (vacuum permeability)",
    examples: ["electricConstant"]
  },
  vacuumImpedance: {
    description: "Characteristic impedance of vacuum",
    examples: ["vacuumImpedance"]
  },
  coulomb: {
    description: "Coulomb's constant",
    examples: ["coulomb"]
  },
  elementaryCharge: {
    description: "Elementary charge",
    examples: ["elementaryCharge"]
  },
  bohrMagneton: {
    description: "Borh magneton",
    examples: ["bohrMagneton"]
  },
  conductanceQuantum: {
    description: "Conductance quantum",
    examples: ["conductanceQuantum"]
  },
  inverseConductanceQuantum: {
    description: "Inverse conductance quantum",
    examples: ["inverseConductanceQuantum"]
  },
  // josephson: {description: 'Josephson constant', examples: ['josephson']},
  magneticFluxQuantum: {
    description: "Magnetic flux quantum",
    examples: ["magneticFluxQuantum"]
  },
  nuclearMagneton: {
    description: "Nuclear magneton",
    examples: ["nuclearMagneton"]
  },
  klitzing: {
    description: "Von Klitzing constant",
    examples: ["klitzing"]
  },
  bohrRadius: {
    description: "Borh radius",
    examples: ["bohrRadius"]
  },
  classicalElectronRadius: {
    description: "Classical electron radius",
    examples: ["classicalElectronRadius"]
  },
  electronMass: {
    description: "Electron mass",
    examples: ["electronMass"]
  },
  fermiCoupling: {
    description: "Fermi coupling constant",
    examples: ["fermiCoupling"]
  },
  fineStructure: {
    description: "Fine-structure constant",
    examples: ["fineStructure"]
  },
  hartreeEnergy: {
    description: "Hartree energy",
    examples: ["hartreeEnergy"]
  },
  protonMass: {
    description: "Proton mass",
    examples: ["protonMass"]
  },
  deuteronMass: {
    description: "Deuteron Mass",
    examples: ["deuteronMass"]
  },
  neutronMass: {
    description: "Neutron mass",
    examples: ["neutronMass"]
  },
  quantumOfCirculation: {
    description: "Quantum of circulation",
    examples: ["quantumOfCirculation"]
  },
  rydberg: {
    description: "Rydberg constant",
    examples: ["rydberg"]
  },
  thomsonCrossSection: {
    description: "Thomson cross section",
    examples: ["thomsonCrossSection"]
  },
  weakMixingAngle: {
    description: "Weak mixing angle",
    examples: ["weakMixingAngle"]
  },
  efimovFactor: {
    description: "Efimov factor",
    examples: ["efimovFactor"]
  },
  atomicMass: {
    description: "Atomic mass constant",
    examples: ["atomicMass"]
  },
  avogadro: {
    description: "Avogadro's number",
    examples: ["avogadro"]
  },
  boltzmann: {
    description: "Boltzmann constant",
    examples: ["boltzmann"]
  },
  faraday: {
    description: "Faraday constant",
    examples: ["faraday"]
  },
  firstRadiation: {
    description: "First radiation constant",
    examples: ["firstRadiation"]
  },
  loschmidt: {
    description: "Loschmidt constant at T=273.15 K and p=101.325 kPa",
    examples: ["loschmidt"]
  },
  gasConstant: {
    description: "Gas constant",
    examples: ["gasConstant"]
  },
  molarPlanckConstant: {
    description: "Molar Planck constant",
    examples: ["molarPlanckConstant"]
  },
  molarVolume: {
    description: "Molar volume of an ideal gas at T=273.15 K and p=101.325 kPa",
    examples: ["molarVolume"]
  },
  sackurTetrode: {
    description: "Sackur-Tetrode constant at T=1 K and p=101.325 kPa",
    examples: ["sackurTetrode"]
  },
  secondRadiation: {
    description: "Second radiation constant",
    examples: ["secondRadiation"]
  },
  stefanBoltzmann: {
    description: "Stefan-Boltzmann constant",
    examples: ["stefanBoltzmann"]
  },
  wienDisplacement: {
    description: "Wien displacement law constant",
    examples: ["wienDisplacement"]
  },
  // spectralRadiance: {description: 'First radiation constant for spectral radiance', examples: ['spectralRadiance']},
  molarMass: {
    description: "Molar mass constant",
    examples: ["molarMass"]
  },
  molarMassC12: {
    description: "Molar mass constant of carbon-12",
    examples: ["molarMassC12"]
  },
  gravity: {
    description: "Standard acceleration of gravity (standard acceleration of free-fall on Earth)",
    examples: ["gravity"]
  },
  planckLength: {
    description: "Planck length",
    examples: ["planckLength"]
  },
  planckMass: {
    description: "Planck mass",
    examples: ["planckMass"]
  },
  planckTime: {
    description: "Planck time",
    examples: ["planckTime"]
  },
  planckCharge: {
    description: "Planck charge",
    examples: ["planckCharge"]
  },
  planckTemperature: {
    description: "Planck temperature",
    examples: ["planckTemperature"]
  },
  // functions - algebra
  derivative: derivativeDocs,
  lsolve: lsolveDocs,
  lsolveAll: lsolveAllDocs,
  lup: lupDocs,
  lusolve: lusolveDocs,
  leafCount: leafCountDocs,
  polynomialRoot: polynomialRootDocs,
  resolve: resolveDocs,
  simplify: simplifyDocs,
  simplifyConstant: simplifyConstantDocs,
  simplifyCore: simplifyCoreDocs,
  symbolicEqual: symbolicEqualDocs,
  rationalize: rationalizeDocs,
  slu: sluDocs,
  usolve: usolveDocs,
  usolveAll: usolveAllDocs,
  qr: qrDocs,
  // functions - arithmetic
  abs: absDocs,
  add: addDocs,
  cbrt: cbrtDocs,
  ceil: ceilDocs,
  cube: cubeDocs,
  divide: divideDocs,
  dotDivide: dotDivideDocs,
  dotMultiply: dotMultiplyDocs,
  dotPow: dotPowDocs,
  exp: expDocs,
  expm: expmDocs,
  expm1: expm1Docs,
  fix: fixDocs,
  floor: floorDocs,
  gcd: gcdDocs,
  hypot: hypotDocs,
  lcm: lcmDocs,
  log: logDocs,
  log2: log2Docs,
  log1p: log1pDocs,
  log10: log10Docs,
  mod: modDocs,
  multiply: multiplyDocs,
  norm: normDocs,
  nthRoot: nthRootDocs,
  nthRoots: nthRootsDocs,
  pow: powDocs,
  round: roundDocs,
  sign: signDocs,
  sqrt: sqrtDocs,
  sqrtm: sqrtmDocs,
  square: squareDocs,
  subtract: subtractDocs,
  unaryMinus: unaryMinusDocs,
  unaryPlus: unaryPlusDocs,
  xgcd: xgcdDocs,
  invmod: invmodDocs,
  // functions - bitwise
  bitAnd: bitAndDocs,
  bitNot: bitNotDocs,
  bitOr: bitOrDocs,
  bitXor: bitXorDocs,
  leftShift: leftShiftDocs,
  rightArithShift: rightArithShiftDocs,
  rightLogShift: rightLogShiftDocs,
  // functions - combinatorics
  bellNumbers: bellNumbersDocs,
  catalan: catalanDocs,
  composition: compositionDocs,
  stirlingS2: stirlingS2Docs,
  // functions - core
  config: configDocs,
  import: importDocs,
  typed: typedDocs,
  // functions - complex
  arg: argDocs,
  conj: conjDocs,
  re: reDocs,
  im: imDocs,
  // functions - expression
  evaluate: evaluateDocs,
  help: helpDocs,
  // functions - geometry
  distance: distanceDocs,
  intersect: intersectDocs,
  // functions - logical
  and: andDocs,
  not: notDocs,
  or: orDocs,
  xor: xorDocs,
  // functions - matrix
  concat: concatDocs,
  count: countDocs,
  cross: crossDocs,
  column: columnDocs,
  ctranspose: ctransposeDocs,
  det: detDocs,
  diag: diagDocs,
  diff: diffDocs,
  dot: dotDocs,
  getMatrixDataType: getMatrixDataTypeDocs,
  identity: identityDocs,
  filter: filterDocs,
  flatten: flattenDocs,
  forEach: forEachDocs,
  inv: invDocs,
  pinv: pinvDocs,
  eigs: eigsDocs,
  kron: kronDocs,
  matrixFromFunction: matrixFromFunctionDocs,
  matrixFromRows: matrixFromRowsDocs,
  matrixFromColumns: matrixFromColumnsDocs,
  map: mapDocs,
  ones: onesDocs,
  partitionSelect: partitionSelectDocs,
  range: rangeDocs,
  resize: resizeDocs,
  reshape: reshapeDocs,
  rotate: rotateDocs,
  rotationMatrix: rotationMatrixDocs,
  row: rowDocs,
  size: sizeDocs,
  sort: sortDocs,
  squeeze: squeezeDocs,
  subset: subsetDocs,
  trace: traceDocs,
  transpose: transposeDocs,
  zeros: zerosDocs,
  fft: fftDocs,
  ifft: ifftDocs,
  sylvester: sylvesterDocs,
  schur: schurDocs,
  lyap: lyapDocs,
  // functions - numeric
  solveODE: solveODEDocs,
  // functions - probability
  combinations: combinationsDocs,
  combinationsWithRep: combinationsWithRepDocs,
  // distribution: distributionDocs,
  factorial: factorialDocs,
  gamma: gammaDocs,
  kldivergence: kldivergenceDocs,
  lgamma: lgammaDocs,
  multinomial: multinomialDocs,
  permutations: permutationsDocs,
  pickRandom: pickRandomDocs,
  random: randomDocs,
  randomInt: randomIntDocs,
  // functions - relational
  compare: compareDocs,
  compareNatural: compareNaturalDocs,
  compareText: compareTextDocs,
  deepEqual: deepEqualDocs,
  equal: equalDocs,
  equalText: equalTextDocs,
  larger: largerDocs,
  largerEq: largerEqDocs,
  smaller: smallerDocs,
  smallerEq: smallerEqDocs,
  unequal: unequalDocs,
  // functions - set
  setCartesian: setCartesianDocs,
  setDifference: setDifferenceDocs,
  setDistinct: setDistinctDocs,
  setIntersect: setIntersectDocs,
  setIsSubset: setIsSubsetDocs,
  setMultiplicity: setMultiplicityDocs,
  setPowerset: setPowersetDocs,
  setSize: setSizeDocs,
  setSymDifference: setSymDifferenceDocs,
  setUnion: setUnionDocs,
  // functions - signal
  zpk2tf: zpk2tfDocs,
  freqz: freqzDocs,
  // functions - special
  erf: erfDocs,
  zeta: zetaDocs,
  // functions - statistics
  cumsum: cumSumDocs,
  mad: madDocs,
  max: maxDocs,
  mean: meanDocs,
  median: medianDocs,
  min: minDocs,
  mode: modeDocs,
  prod: prodDocs,
  quantileSeq: quantileSeqDocs,
  std: stdDocs,
  sum: sumDocs,
  variance: varianceDocs,
  corr: corrDocs,
  // functions - trigonometry
  acos: acosDocs,
  acosh: acoshDocs,
  acot: acotDocs,
  acoth: acothDocs,
  acsc: acscDocs,
  acsch: acschDocs,
  asec: asecDocs,
  asech: asechDocs,
  asin: asinDocs,
  asinh: asinhDocs,
  atan: atanDocs,
  atanh: atanhDocs,
  atan2: atan2Docs,
  cos: cosDocs,
  cosh: coshDocs,
  cot: cotDocs,
  coth: cothDocs,
  csc: cscDocs,
  csch: cschDocs,
  sec: secDocs,
  sech: sechDocs,
  sin: sinDocs,
  sinh: sinhDocs,
  tan: tanDocs,
  tanh: tanhDocs,
  // functions - units
  to: toDocs,
  // functions - utils
  clone: cloneDocs,
  format: formatDocs,
  bin: binDocs,
  oct: octDocs,
  hex: hexDocs,
  isNaN: isNaNDocs,
  isInteger: isIntegerDocs,
  isNegative: isNegativeDocs,
  isNumeric: isNumericDocs,
  hasNumericValue: hasNumericValueDocs,
  isPositive: isPositiveDocs,
  isPrime: isPrimeDocs,
  isZero: isZeroDocs,
  print: printDocs,
  typeOf: typeOfDocs,
  numeric: numericDocs
};

// node_modules/mathjs/lib/esm/expression/function/help.js
var name239 = "help";
var dependencies240 = ["typed", "mathWithTransform", "Help"];
var createHelp = /* @__PURE__ */ factory(name239, dependencies240, (_ref) => {
  var {
    typed: typed3,
    mathWithTransform: mathWithTransform2,
    Help: Help2
  } = _ref;
  return typed3(name239, {
    any: function any(search) {
      var prop;
      var searchName = search;
      if (typeof search !== "string") {
        for (prop in mathWithTransform2) {
          if (hasOwnProperty(mathWithTransform2, prop) && search === mathWithTransform2[prop]) {
            searchName = prop;
            break;
          }
        }
      }
      var doc = getSafeProperty(embeddedDocs, searchName);
      if (!doc) {
        var searchText = typeof searchName === "function" ? searchName.name : searchName;
        throw new Error('No documentation found on "' + searchText + '"');
      }
      return new Help2(doc);
    }
  });
});

// node_modules/mathjs/lib/esm/type/chain/function/chain.js
var name240 = "chain";
var dependencies241 = ["typed", "Chain"];
var createChain = /* @__PURE__ */ factory(name240, dependencies241, (_ref) => {
  var {
    typed: typed3,
    Chain: Chain2
  } = _ref;
  return typed3(name240, {
    "": function _() {
      return new Chain2();
    },
    any: function any(value) {
      return new Chain2(value);
    }
  });
});

// node_modules/mathjs/lib/esm/function/matrix/det.js
var name241 = "det";
var dependencies242 = ["typed", "matrix", "subtractScalar", "multiply", "divideScalar", "isZero", "unaryMinus"];
var createDet = /* @__PURE__ */ factory(name241, dependencies242, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    subtractScalar: subtractScalar2,
    multiply: multiply2,
    divideScalar: divideScalar2,
    isZero: isZero2,
    unaryMinus: unaryMinus2
  } = _ref;
  return typed3(name241, {
    any: function any(x) {
      return clone(x);
    },
    "Array | Matrix": function det2(x) {
      var size2;
      if (isMatrix(x)) {
        size2 = x.size();
      } else if (Array.isArray(x)) {
        x = matrix2(x);
        size2 = x.size();
      } else {
        size2 = [];
      }
      switch (size2.length) {
        case 0:
          return clone(x);
        case 1:
          if (size2[0] === 1) {
            return clone(x.valueOf()[0]);
          }
          if (size2[0] === 0) {
            return 1;
          } else {
            throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
          }
        case 2: {
          var rows = size2[0];
          var cols = size2[1];
          if (rows === cols) {
            return _det(x.clone().valueOf(), rows, cols);
          }
          if (cols === 0) {
            return 1;
          } else {
            throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
          }
        }
        default:
          throw new RangeError("Matrix must be two dimensional (size: " + format3(size2) + ")");
      }
    }
  });
  function _det(matrix3, rows, cols) {
    if (rows === 1) {
      return clone(matrix3[0][0]);
    } else if (rows === 2) {
      return subtractScalar2(multiply2(matrix3[0][0], matrix3[1][1]), multiply2(matrix3[1][0], matrix3[0][1]));
    } else {
      var negated = false;
      var rowIndices = new Array(rows).fill(0).map((_, i3) => i3);
      for (var k = 0; k < rows; k++) {
        var k_ = rowIndices[k];
        if (isZero2(matrix3[k_][k])) {
          var _k = void 0;
          for (_k = k + 1; _k < rows; _k++) {
            if (!isZero2(matrix3[rowIndices[_k]][k])) {
              k_ = rowIndices[_k];
              rowIndices[_k] = rowIndices[k];
              rowIndices[k] = k_;
              negated = !negated;
              break;
            }
          }
          if (_k === rows)
            return matrix3[k_][k];
        }
        var piv = matrix3[k_][k];
        var piv_ = k === 0 ? 1 : matrix3[rowIndices[k - 1]][k - 1];
        for (var i2 = k + 1; i2 < rows; i2++) {
          var i_ = rowIndices[i2];
          for (var j = k + 1; j < rows; j++) {
            matrix3[i_][j] = divideScalar2(subtractScalar2(multiply2(matrix3[i_][j], piv), multiply2(matrix3[i_][k], matrix3[k_][j])), piv_);
          }
        }
      }
      var det2 = matrix3[rowIndices[rows - 1]][rows - 1];
      return negated ? unaryMinus2(det2) : det2;
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/inv.js
var name242 = "inv";
var dependencies243 = ["typed", "matrix", "divideScalar", "addScalar", "multiply", "unaryMinus", "det", "identity", "abs"];
var createInv = /* @__PURE__ */ factory(name242, dependencies243, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    divideScalar: divideScalar2,
    addScalar: addScalar2,
    multiply: multiply2,
    unaryMinus: unaryMinus2,
    det: det2,
    identity: identity2,
    abs: abs3
  } = _ref;
  return typed3(name242, {
    "Array | Matrix": function ArrayMatrix(x) {
      var size2 = isMatrix(x) ? x.size() : arraySize(x);
      switch (size2.length) {
        case 1:
          if (size2[0] === 1) {
            if (isMatrix(x)) {
              return matrix2([divideScalar2(1, x.valueOf()[0])]);
            } else {
              return [divideScalar2(1, x[0])];
            }
          } else {
            throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
          }
        case 2: {
          var rows = size2[0];
          var cols = size2[1];
          if (rows === cols) {
            if (isMatrix(x)) {
              return matrix2(_inv(x.valueOf(), rows, cols), x.storage());
            } else {
              return _inv(x, rows, cols);
            }
          } else {
            throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
          }
        }
        default:
          throw new RangeError("Matrix must be two dimensional (size: " + format3(size2) + ")");
      }
    },
    any: function any(x) {
      return divideScalar2(1, x);
    }
  });
  function _inv(mat, rows, cols) {
    var r, s, f, value, temp;
    if (rows === 1) {
      value = mat[0][0];
      if (value === 0) {
        throw Error("Cannot calculate inverse, determinant is zero");
      }
      return [[divideScalar2(1, value)]];
    } else if (rows === 2) {
      var d = det2(mat);
      if (d === 0) {
        throw Error("Cannot calculate inverse, determinant is zero");
      }
      return [[divideScalar2(mat[1][1], d), divideScalar2(unaryMinus2(mat[0][1]), d)], [divideScalar2(unaryMinus2(mat[1][0]), d), divideScalar2(mat[0][0], d)]];
    } else {
      var A = mat.concat();
      for (r = 0; r < rows; r++) {
        A[r] = A[r].concat();
      }
      var B = identity2(rows).valueOf();
      for (var c = 0; c < cols; c++) {
        var ABig = abs3(A[c][c]);
        var rBig = c;
        r = c + 1;
        while (r < rows) {
          if (abs3(A[r][c]) > ABig) {
            ABig = abs3(A[r][c]);
            rBig = r;
          }
          r++;
        }
        if (ABig === 0) {
          throw Error("Cannot calculate inverse, determinant is zero");
        }
        r = rBig;
        if (r !== c) {
          temp = A[c];
          A[c] = A[r];
          A[r] = temp;
          temp = B[c];
          B[c] = B[r];
          B[r] = temp;
        }
        var Ac = A[c];
        var Bc = B[c];
        for (r = 0; r < rows; r++) {
          var Ar = A[r];
          var Br = B[r];
          if (r !== c) {
            if (Ar[c] !== 0) {
              f = divideScalar2(unaryMinus2(Ar[c]), Ac[c]);
              for (s = c; s < cols; s++) {
                Ar[s] = addScalar2(Ar[s], multiply2(f, Ac[s]));
              }
              for (s = 0; s < cols; s++) {
                Br[s] = addScalar2(Br[s], multiply2(f, Bc[s]));
              }
            }
          } else {
            f = Ac[c];
            for (s = c; s < cols; s++) {
              Ar[s] = divideScalar2(Ar[s], f);
            }
            for (s = 0; s < cols; s++) {
              Br[s] = divideScalar2(Br[s], f);
            }
          }
        }
      }
      return B;
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/pinv.js
var name243 = "pinv";
var dependencies244 = ["typed", "matrix", "inv", "deepEqual", "equal", "dotDivide", "dot", "ctranspose", "divideScalar", "multiply", "add", "Complex"];
var createPinv = /* @__PURE__ */ factory(name243, dependencies244, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    inv: inv2,
    deepEqual: deepEqual2,
    equal: equal2,
    dotDivide: dotDivide2,
    dot: dot2,
    ctranspose: ctranspose2,
    divideScalar: divideScalar2,
    multiply: multiply2,
    add: add3,
    Complex: Complex3
  } = _ref;
  return typed3(name243, {
    "Array | Matrix": function ArrayMatrix(x) {
      var size2 = isMatrix(x) ? x.size() : arraySize(x);
      switch (size2.length) {
        case 1:
          if (_isZeros(x))
            return ctranspose2(x);
          if (size2[0] === 1) {
            return inv2(x);
          } else {
            return dotDivide2(ctranspose2(x), dot2(x, x));
          }
        case 2: {
          if (_isZeros(x))
            return ctranspose2(x);
          var rows = size2[0];
          var cols = size2[1];
          if (rows === cols) {
            try {
              return inv2(x);
            } catch (err) {
              if (err instanceof Error && err.message.match(/Cannot calculate inverse, determinant is zero/)) {
              } else {
                throw err;
              }
            }
          }
          if (isMatrix(x)) {
            return matrix2(_pinv(x.valueOf(), rows, cols), x.storage());
          } else {
            return _pinv(x, rows, cols);
          }
        }
        default:
          throw new RangeError("Matrix must be two dimensional (size: " + format3(size2) + ")");
      }
    },
    any: function any(x) {
      if (equal2(x, 0))
        return clone(x);
      return divideScalar2(1, x);
    }
  });
  function _pinv(mat, rows, cols) {
    var {
      C,
      F
    } = _rankFact(mat, rows, cols);
    var Cpinv = multiply2(inv2(multiply2(ctranspose2(C), C)), ctranspose2(C));
    var Fpinv = multiply2(ctranspose2(F), inv2(multiply2(F, ctranspose2(F))));
    return multiply2(Fpinv, Cpinv);
  }
  function _rref(mat, rows, cols) {
    var M = clone(mat);
    var lead = 0;
    for (var r = 0; r < rows; r++) {
      if (cols <= lead) {
        return M;
      }
      var i2 = r;
      while (_isZero(M[i2][lead])) {
        i2++;
        if (rows === i2) {
          i2 = r;
          lead++;
          if (cols === lead) {
            return M;
          }
        }
      }
      [M[i2], M[r]] = [M[r], M[i2]];
      var val = M[r][lead];
      for (var j = 0; j < cols; j++) {
        M[r][j] = dotDivide2(M[r][j], val);
      }
      for (var _i = 0; _i < rows; _i++) {
        if (_i === r)
          continue;
        val = M[_i][lead];
        for (var _j = 0; _j < cols; _j++) {
          M[_i][_j] = add3(M[_i][_j], multiply2(-1, multiply2(val, M[r][_j])));
        }
      }
      lead++;
    }
    return M;
  }
  function _rankFact(mat, rows, cols) {
    var rref = _rref(mat, rows, cols);
    var C = mat.map((_, i2) => _.filter((_2, j) => j < rows && !_isZero(dot2(rref[j], rref[j]))));
    var F = rref.filter((_, i2) => !_isZero(dot2(rref[i2], rref[i2])));
    return {
      C,
      F
    };
  }
  function _isZero(x) {
    return equal2(add3(x, Complex3(1, 1)), add3(0, Complex3(1, 1)));
  }
  function _isZeros(arr) {
    return deepEqual2(add3(arr, Complex3(1, 1)), add3(multiply2(arr, 0), Complex3(1, 1)));
  }
});

// node_modules/mathjs/lib/esm/function/matrix/eigs/complexEigs.js
function createComplexEigs(_ref) {
  var {
    addScalar: addScalar2,
    subtract: subtract2,
    flatten: flatten3,
    multiply: multiply2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    sqrt: sqrt3,
    abs: abs3,
    bignumber: bignumber2,
    diag: diag2,
    size: size2,
    reshape: reshape3,
    inv: inv2,
    qr: qr2,
    usolve: usolve2,
    usolveAll: usolveAll2,
    equal: equal2,
    complex: complex2,
    larger: larger2,
    smaller: smaller2,
    matrixFromColumns: matrixFromColumns2,
    dot: dot2
  } = _ref;
  function complexEigs(arr, N, prec, type) {
    var findVectors = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
    var R = balance(arr, N, prec, type, findVectors);
    reduceToHessenberg(arr, N, prec, type, findVectors, R);
    var {
      values,
      C
    } = iterateUntilTriangular(arr, N, prec, type, findVectors);
    if (findVectors) {
      var eigenvectors = findEigenvectors(arr, N, C, R, values, prec, type);
      return {
        values,
        eigenvectors
      };
    }
    return {
      values
    };
  }
  function balance(arr, N, prec, type, findVectors) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var realzero = big ? bignumber2(0) : 0;
    var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
    var realone = big ? bignumber2(1) : 1;
    var radix = big ? bignumber2(10) : 2;
    var radixSq = multiplyScalar2(radix, radix);
    var Rdiag;
    if (findVectors) {
      Rdiag = Array(N).fill(one);
    }
    var last = false;
    while (!last) {
      last = true;
      for (var i2 = 0; i2 < N; i2++) {
        var colNorm = realzero;
        var rowNorm = realzero;
        for (var j = 0; j < N; j++) {
          if (i2 === j)
            continue;
          colNorm = addScalar2(colNorm, abs3(arr[j][i2]));
          rowNorm = addScalar2(rowNorm, abs3(arr[i2][j]));
        }
        if (!equal2(colNorm, 0) && !equal2(rowNorm, 0)) {
          var f = realone;
          var c = colNorm;
          var rowDivRadix = divideScalar2(rowNorm, radix);
          var rowMulRadix = multiplyScalar2(rowNorm, radix);
          while (smaller2(c, rowDivRadix)) {
            c = multiplyScalar2(c, radixSq);
            f = multiplyScalar2(f, radix);
          }
          while (larger2(c, rowMulRadix)) {
            c = divideScalar2(c, radixSq);
            f = divideScalar2(f, radix);
          }
          var condition = smaller2(divideScalar2(addScalar2(c, rowNorm), f), multiplyScalar2(addScalar2(colNorm, rowNorm), 0.95));
          if (condition) {
            last = false;
            var g = divideScalar2(1, f);
            for (var _j = 0; _j < N; _j++) {
              if (i2 === _j) {
                continue;
              }
              arr[i2][_j] = multiplyScalar2(arr[i2][_j], g);
              arr[_j][i2] = multiplyScalar2(arr[_j][i2], f);
            }
            if (findVectors) {
              Rdiag[i2] = multiplyScalar2(Rdiag[i2], g);
            }
          }
        }
      }
    }
    return findVectors ? diag2(Rdiag) : null;
  }
  function reduceToHessenberg(arr, N, prec, type, findVectors, R) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var zero = big ? bignumber2(0) : cplx ? complex2(0) : 0;
    if (big) {
      prec = bignumber2(prec);
    }
    for (var i2 = 0; i2 < N - 2; i2++) {
      var maxIndex = 0;
      var max3 = zero;
      for (var j = i2 + 1; j < N; j++) {
        var el = arr[j][i2];
        if (smaller2(abs3(max3), abs3(el))) {
          max3 = el;
          maxIndex = j;
        }
      }
      if (smaller2(abs3(max3), prec)) {
        continue;
      }
      if (maxIndex !== i2 + 1) {
        var tmp1 = arr[maxIndex];
        arr[maxIndex] = arr[i2 + 1];
        arr[i2 + 1] = tmp1;
        for (var _j2 = 0; _j2 < N; _j2++) {
          var tmp2 = arr[_j2][maxIndex];
          arr[_j2][maxIndex] = arr[_j2][i2 + 1];
          arr[_j2][i2 + 1] = tmp2;
        }
        if (findVectors) {
          var tmp3 = R[maxIndex];
          R[maxIndex] = R[i2 + 1];
          R[i2 + 1] = tmp3;
        }
      }
      for (var _j3 = i2 + 2; _j3 < N; _j3++) {
        var n = divideScalar2(arr[_j3][i2], max3);
        if (n === 0) {
          continue;
        }
        for (var k = 0; k < N; k++) {
          arr[_j3][k] = subtract2(arr[_j3][k], multiplyScalar2(n, arr[i2 + 1][k]));
        }
        for (var _k = 0; _k < N; _k++) {
          arr[_k][i2 + 1] = addScalar2(arr[_k][i2 + 1], multiplyScalar2(n, arr[_k][_j3]));
        }
        if (findVectors) {
          for (var _k2 = 0; _k2 < N; _k2++) {
            R[_j3][_k2] = subtract2(R[_j3][_k2], multiplyScalar2(n, R[i2 + 1][_k2]));
          }
        }
      }
    }
    return R;
  }
  function iterateUntilTriangular(A, N, prec, type, findVectors) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
    if (big) {
      prec = bignumber2(prec);
    }
    var arr = clone(A);
    var lambdas = [];
    var n = N;
    var Sdiag = [];
    var Qtotal = findVectors ? diag2(Array(N).fill(one)) : void 0;
    var Qpartial = findVectors ? diag2(Array(n).fill(one)) : void 0;
    var lastConvergenceBefore = 0;
    while (lastConvergenceBefore <= 100) {
      lastConvergenceBefore += 1;
      var k = arr[n - 1][n - 1];
      for (var i2 = 0; i2 < n; i2++) {
        arr[i2][i2] = subtract2(arr[i2][i2], k);
      }
      var {
        Q: Q2,
        R
      } = qr2(arr);
      arr = multiply2(R, Q2);
      for (var _i = 0; _i < n; _i++) {
        arr[_i][_i] = addScalar2(arr[_i][_i], k);
      }
      if (findVectors) {
        Qpartial = multiply2(Qpartial, Q2);
      }
      if (n === 1 || smaller2(abs3(arr[n - 1][n - 2]), prec)) {
        lastConvergenceBefore = 0;
        lambdas.push(arr[n - 1][n - 1]);
        if (findVectors) {
          Sdiag.unshift([[1]]);
          inflateMatrix(Qpartial, N);
          Qtotal = multiply2(Qtotal, Qpartial);
          if (n > 1) {
            Qpartial = diag2(Array(n - 1).fill(one));
          }
        }
        n -= 1;
        arr.pop();
        for (var _i2 = 0; _i2 < n; _i2++) {
          arr[_i2].pop();
        }
      } else if (n === 2 || smaller2(abs3(arr[n - 2][n - 3]), prec)) {
        lastConvergenceBefore = 0;
        var ll = eigenvalues2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1]);
        lambdas.push(...ll);
        if (findVectors) {
          Sdiag.unshift(jordanBase2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1], ll[0], ll[1], prec, type));
          inflateMatrix(Qpartial, N);
          Qtotal = multiply2(Qtotal, Qpartial);
          if (n > 2) {
            Qpartial = diag2(Array(n - 2).fill(one));
          }
        }
        n -= 2;
        arr.pop();
        arr.pop();
        for (var _i3 = 0; _i3 < n; _i3++) {
          arr[_i3].pop();
          arr[_i3].pop();
        }
      }
      if (n === 0) {
        break;
      }
    }
    lambdas.sort((a, b) => +subtract2(abs3(a), abs3(b)));
    if (lastConvergenceBefore > 100) {
      var err = Error("The eigenvalues failed to converge. Only found these eigenvalues: " + lambdas.join(", "));
      err.values = lambdas;
      err.vectors = [];
      throw err;
    }
    var C = findVectors ? multiply2(Qtotal, blockDiag(Sdiag, N)) : void 0;
    return {
      values: lambdas,
      C
    };
  }
  function findEigenvectors(A, N, C, R, values, prec, type) {
    var Cinv = inv2(C);
    var U = multiply2(Cinv, A, C);
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var zero = big ? bignumber2(0) : cplx ? complex2(0) : 0;
    var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
    var uniqueValues = [];
    var multiplicities = [];
    for (var lambda of values) {
      var i2 = indexOf(uniqueValues, lambda, equal2);
      if (i2 === -1) {
        uniqueValues.push(lambda);
        multiplicities.push(1);
      } else {
        multiplicities[i2] += 1;
      }
    }
    var vectors = [];
    var len = uniqueValues.length;
    var b = Array(N).fill(zero);
    var E = diag2(Array(N).fill(one));
    var _loop = function _loop2() {
      var lambda2 = uniqueValues[_i4];
      var S = subtract2(U, multiply2(lambda2, E));
      var solutions = usolveAll2(S, b);
      solutions.shift();
      while (solutions.length < multiplicities[_i4]) {
        var approxVec = inverseIterate(S, N, solutions, prec, type);
        if (approxVec === null) {
          break;
        }
        solutions.push(approxVec);
      }
      var correction = multiply2(inv2(R), C);
      solutions = solutions.map((v) => multiply2(correction, v));
      vectors.push(...solutions.map((v) => ({
        value: lambda2,
        vector: flatten3(v)
      })));
    };
    for (var _i4 = 0; _i4 < len; _i4++) {
      _loop();
    }
    return vectors;
  }
  function eigenvalues2x2(a, b, c, d) {
    var trA = addScalar2(a, d);
    var detA = subtract2(multiplyScalar2(a, d), multiplyScalar2(b, c));
    var x = multiplyScalar2(trA, 0.5);
    var y = multiplyScalar2(sqrt3(subtract2(multiplyScalar2(trA, trA), multiplyScalar2(4, detA))), 0.5);
    return [addScalar2(x, y), subtract2(x, y)];
  }
  function jordanBase2x2(a, b, c, d, l1, l2, prec, type) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var zero = big ? bignumber2(0) : cplx ? complex2(0) : 0;
    var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
    if (smaller2(abs3(c), prec)) {
      return [[one, zero], [zero, one]];
    }
    if (larger2(abs3(subtract2(l1, l2)), prec)) {
      return [[subtract2(l1, d), subtract2(l2, d)], [c, c]];
    }
    var na = subtract2(a, l1);
    var nd = subtract2(d, l1);
    if (smaller2(abs3(b), prec) && smaller2(abs3(nd), prec)) {
      return [[na, one], [c, zero]];
    } else {
      return [[b, zero], [nd, one]];
    }
  }
  function inflateMatrix(arr, N) {
    for (var i2 = 0; i2 < arr.length; i2++) {
      arr[i2].push(...Array(N - arr[i2].length).fill(0));
    }
    for (var _i5 = arr.length; _i5 < N; _i5++) {
      arr.push(Array(N).fill(0));
      arr[_i5][_i5] = 1;
    }
    return arr;
  }
  function blockDiag(arr, N) {
    var M = [];
    for (var i2 = 0; i2 < N; i2++) {
      M[i2] = Array(N).fill(0);
    }
    var I = 0;
    for (var sub2 of arr) {
      var n = sub2.length;
      for (var _i6 = 0; _i6 < n; _i6++) {
        for (var j = 0; j < n; j++) {
          M[I + _i6][I + j] = sub2[_i6][j];
        }
      }
      I += n;
    }
    return M;
  }
  function indexOf(arr, el, fn) {
    for (var i2 = 0; i2 < arr.length; i2++) {
      if (fn(arr[i2], el)) {
        return i2;
      }
    }
    return -1;
  }
  function inverseIterate(A, N, orthog, prec, type) {
    var largeNum = type === "BigNumber" ? bignumber2(1e3) : 1e3;
    var b;
    var i2 = 0;
    for (; i2 < 5; ++i2) {
      b = randomOrthogonalVector(N, orthog, type);
      try {
        b = usolve2(A, b);
      } catch (_unused) {
        continue;
      }
      if (larger2(norm2(b), largeNum)) {
        break;
      }
    }
    if (i2 >= 5) {
      return null;
    }
    i2 = 0;
    while (true) {
      var c = usolve2(A, b);
      if (smaller2(norm2(orthogonalComplement(b, [c])), prec)) {
        break;
      }
      if (++i2 >= 10) {
        return null;
      }
      b = normalize(c);
    }
    return b;
  }
  function randomOrthogonalVector(N, orthog, type) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var v = Array(N).fill(0).map((_) => 2 * Math.random() - 1);
    if (big) {
      v = v.map((n) => bignumber2(n));
    }
    if (cplx) {
      v = v.map((n) => complex2(n));
    }
    v = orthogonalComplement(v, orthog);
    return normalize(v, type);
  }
  function orthogonalComplement(v, orthog) {
    var vectorShape = size2(v);
    for (var w of orthog) {
      w = reshape3(w, vectorShape);
      v = subtract2(v, multiply2(divideScalar2(dot2(w, v), dot2(w, w)), w));
    }
    return v;
  }
  function norm2(v) {
    return abs3(sqrt3(dot2(v, v)));
  }
  function normalize(v, type) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
    return multiply2(divideScalar2(one, norm2(v)), v);
  }
  return complexEigs;
}

// node_modules/mathjs/lib/esm/function/matrix/eigs/realSymmetric.js
function createRealSymmetric(_ref) {
  var {
    config: config5,
    addScalar: addScalar2,
    subtract: subtract2,
    abs: abs3,
    atan: atan4,
    cos: cos3,
    sin: sin3,
    multiplyScalar: multiplyScalar2,
    inv: inv2,
    bignumber: bignumber2,
    multiply: multiply2,
    add: add3
  } = _ref;
  function main(arr, N) {
    var prec = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : config5.relTol;
    var type = arguments.length > 3 ? arguments[3] : void 0;
    var computeVectors = arguments.length > 4 ? arguments[4] : void 0;
    if (type === "number") {
      return diag2(arr, prec, computeVectors);
    }
    if (type === "BigNumber") {
      return diagBig(arr, prec, computeVectors);
    }
    throw TypeError("Unsupported data type: " + type);
  }
  function diag2(x, precision, computeVectors) {
    var N = x.length;
    var e0 = Math.abs(precision / N);
    var psi;
    var Sij;
    if (computeVectors) {
      Sij = new Array(N);
      for (var i2 = 0; i2 < N; i2++) {
        Sij[i2] = Array(N).fill(0);
        Sij[i2][i2] = 1;
      }
    }
    var Vab = getAij(x);
    while (Math.abs(Vab[1]) >= Math.abs(e0)) {
      var _i = Vab[0][0];
      var j = Vab[0][1];
      psi = getTheta(x[_i][_i], x[j][j], x[_i][j]);
      x = x1(x, psi, _i, j);
      if (computeVectors)
        Sij = Sij1(Sij, psi, _i, j);
      Vab = getAij(x);
    }
    var Ei = Array(N).fill(0);
    for (var _i2 = 0; _i2 < N; _i2++) {
      Ei[_i2] = x[_i2][_i2];
    }
    return sorting(clone(Ei), Sij, computeVectors);
  }
  function diagBig(x, precision, computeVectors) {
    var N = x.length;
    var e0 = abs3(precision / N);
    var psi;
    var Sij;
    if (computeVectors) {
      Sij = new Array(N);
      for (var i2 = 0; i2 < N; i2++) {
        Sij[i2] = Array(N).fill(0);
        Sij[i2][i2] = 1;
      }
    }
    var Vab = getAijBig(x);
    while (abs3(Vab[1]) >= abs3(e0)) {
      var _i3 = Vab[0][0];
      var j = Vab[0][1];
      psi = getThetaBig(x[_i3][_i3], x[j][j], x[_i3][j]);
      x = x1Big(x, psi, _i3, j);
      if (computeVectors)
        Sij = Sij1Big(Sij, psi, _i3, j);
      Vab = getAijBig(x);
    }
    var Ei = Array(N).fill(0);
    for (var _i4 = 0; _i4 < N; _i4++) {
      Ei[_i4] = x[_i4][_i4];
    }
    return sorting(clone(Ei), Sij, computeVectors);
  }
  function getTheta(aii, ajj, aij) {
    var denom = ajj - aii;
    if (Math.abs(denom) <= config5.relTol) {
      return Math.PI / 4;
    } else {
      return 0.5 * Math.atan(2 * aij / (ajj - aii));
    }
  }
  function getThetaBig(aii, ajj, aij) {
    var denom = subtract2(ajj, aii);
    if (abs3(denom) <= config5.relTol) {
      return bignumber2(-1).acos().div(4);
    } else {
      return multiplyScalar2(0.5, atan4(multiply2(2, aij, inv2(denom))));
    }
  }
  function Sij1(Sij, theta, i2, j) {
    var N = Sij.length;
    var c = Math.cos(theta);
    var s = Math.sin(theta);
    var Ski = Array(N).fill(0);
    var Skj = Array(N).fill(0);
    for (var k = 0; k < N; k++) {
      Ski[k] = c * Sij[k][i2] - s * Sij[k][j];
      Skj[k] = s * Sij[k][i2] + c * Sij[k][j];
    }
    for (var _k = 0; _k < N; _k++) {
      Sij[_k][i2] = Ski[_k];
      Sij[_k][j] = Skj[_k];
    }
    return Sij;
  }
  function Sij1Big(Sij, theta, i2, j) {
    var N = Sij.length;
    var c = cos3(theta);
    var s = sin3(theta);
    var Ski = Array(N).fill(bignumber2(0));
    var Skj = Array(N).fill(bignumber2(0));
    for (var k = 0; k < N; k++) {
      Ski[k] = subtract2(multiplyScalar2(c, Sij[k][i2]), multiplyScalar2(s, Sij[k][j]));
      Skj[k] = addScalar2(multiplyScalar2(s, Sij[k][i2]), multiplyScalar2(c, Sij[k][j]));
    }
    for (var _k2 = 0; _k2 < N; _k2++) {
      Sij[_k2][i2] = Ski[_k2];
      Sij[_k2][j] = Skj[_k2];
    }
    return Sij;
  }
  function x1Big(Hij, theta, i2, j) {
    var N = Hij.length;
    var c = bignumber2(cos3(theta));
    var s = bignumber2(sin3(theta));
    var c2 = multiplyScalar2(c, c);
    var s2 = multiplyScalar2(s, s);
    var Aki = Array(N).fill(bignumber2(0));
    var Akj = Array(N).fill(bignumber2(0));
    var csHij = multiply2(bignumber2(2), c, s, Hij[i2][j]);
    var Aii = addScalar2(subtract2(multiplyScalar2(c2, Hij[i2][i2]), csHij), multiplyScalar2(s2, Hij[j][j]));
    var Ajj = add3(multiplyScalar2(s2, Hij[i2][i2]), csHij, multiplyScalar2(c2, Hij[j][j]));
    for (var k = 0; k < N; k++) {
      Aki[k] = subtract2(multiplyScalar2(c, Hij[i2][k]), multiplyScalar2(s, Hij[j][k]));
      Akj[k] = addScalar2(multiplyScalar2(s, Hij[i2][k]), multiplyScalar2(c, Hij[j][k]));
    }
    Hij[i2][i2] = Aii;
    Hij[j][j] = Ajj;
    Hij[i2][j] = bignumber2(0);
    Hij[j][i2] = bignumber2(0);
    for (var _k3 = 0; _k3 < N; _k3++) {
      if (_k3 !== i2 && _k3 !== j) {
        Hij[i2][_k3] = Aki[_k3];
        Hij[_k3][i2] = Aki[_k3];
        Hij[j][_k3] = Akj[_k3];
        Hij[_k3][j] = Akj[_k3];
      }
    }
    return Hij;
  }
  function x1(Hij, theta, i2, j) {
    var N = Hij.length;
    var c = Math.cos(theta);
    var s = Math.sin(theta);
    var c2 = c * c;
    var s2 = s * s;
    var Aki = Array(N).fill(0);
    var Akj = Array(N).fill(0);
    var Aii = c2 * Hij[i2][i2] - 2 * c * s * Hij[i2][j] + s2 * Hij[j][j];
    var Ajj = s2 * Hij[i2][i2] + 2 * c * s * Hij[i2][j] + c2 * Hij[j][j];
    for (var k = 0; k < N; k++) {
      Aki[k] = c * Hij[i2][k] - s * Hij[j][k];
      Akj[k] = s * Hij[i2][k] + c * Hij[j][k];
    }
    Hij[i2][i2] = Aii;
    Hij[j][j] = Ajj;
    Hij[i2][j] = 0;
    Hij[j][i2] = 0;
    for (var _k4 = 0; _k4 < N; _k4++) {
      if (_k4 !== i2 && _k4 !== j) {
        Hij[i2][_k4] = Aki[_k4];
        Hij[_k4][i2] = Aki[_k4];
        Hij[j][_k4] = Akj[_k4];
        Hij[_k4][j] = Akj[_k4];
      }
    }
    return Hij;
  }
  function getAij(Mij) {
    var N = Mij.length;
    var maxMij = 0;
    var maxIJ = [0, 1];
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = i2 + 1; j < N; j++) {
        if (Math.abs(maxMij) < Math.abs(Mij[i2][j])) {
          maxMij = Math.abs(Mij[i2][j]);
          maxIJ = [i2, j];
        }
      }
    }
    return [maxIJ, maxMij];
  }
  function getAijBig(Mij) {
    var N = Mij.length;
    var maxMij = 0;
    var maxIJ = [0, 1];
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = i2 + 1; j < N; j++) {
        if (abs3(maxMij) < abs3(Mij[i2][j])) {
          maxMij = abs3(Mij[i2][j]);
          maxIJ = [i2, j];
        }
      }
    }
    return [maxIJ, maxMij];
  }
  function sorting(E, S, computeVectors) {
    var N = E.length;
    var values = Array(N);
    var vecs;
    if (computeVectors) {
      vecs = Array(N);
      for (var k = 0; k < N; k++) {
        vecs[k] = Array(N);
      }
    }
    for (var i2 = 0; i2 < N; i2++) {
      var minID = 0;
      var minE = E[0];
      for (var j = 0; j < E.length; j++) {
        if (abs3(E[j]) < abs3(minE)) {
          minID = j;
          minE = E[minID];
        }
      }
      values[i2] = E.splice(minID, 1)[0];
      if (computeVectors) {
        for (var _k5 = 0; _k5 < N; _k5++) {
          vecs[i2][_k5] = S[_k5][minID];
          S[_k5].splice(minID, 1);
        }
      }
    }
    if (!computeVectors)
      return {
        values
      };
    var eigenvectors = vecs.map((vector, i3) => ({
      value: values[i3],
      vector
    }));
    return {
      values,
      eigenvectors
    };
  }
  return main;
}

// node_modules/mathjs/lib/esm/function/matrix/eigs.js
var name244 = "eigs";
var dependencies245 = ["config", "typed", "matrix", "addScalar", "equal", "subtract", "abs", "atan", "cos", "sin", "multiplyScalar", "divideScalar", "inv", "bignumber", "multiply", "add", "larger", "column", "flatten", "number", "complex", "sqrt", "diag", "size", "reshape", "qr", "usolve", "usolveAll", "im", "re", "smaller", "matrixFromColumns", "dot"];
var createEigs = /* @__PURE__ */ factory(name244, dependencies245, (_ref) => {
  var {
    config: config5,
    typed: typed3,
    matrix: matrix2,
    addScalar: addScalar2,
    subtract: subtract2,
    equal: equal2,
    abs: abs3,
    atan: atan4,
    cos: cos3,
    sin: sin3,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    inv: inv2,
    bignumber: bignumber2,
    multiply: multiply2,
    add: add3,
    larger: larger2,
    column: column2,
    flatten: flatten3,
    number: number2,
    complex: complex2,
    sqrt: sqrt3,
    diag: diag2,
    size: size2,
    reshape: reshape3,
    qr: qr2,
    usolve: usolve2,
    usolveAll: usolveAll2,
    im: im2,
    re: re2,
    smaller: smaller2,
    matrixFromColumns: matrixFromColumns2,
    dot: dot2
  } = _ref;
  var doRealSymmetric = createRealSymmetric({
    config: config5,
    addScalar: addScalar2,
    subtract: subtract2,
    column: column2,
    flatten: flatten3,
    equal: equal2,
    abs: abs3,
    atan: atan4,
    cos: cos3,
    sin: sin3,
    multiplyScalar: multiplyScalar2,
    inv: inv2,
    bignumber: bignumber2,
    complex: complex2,
    multiply: multiply2,
    add: add3
  });
  var doComplexEigs = createComplexEigs({
    config: config5,
    addScalar: addScalar2,
    subtract: subtract2,
    multiply: multiply2,
    multiplyScalar: multiplyScalar2,
    flatten: flatten3,
    divideScalar: divideScalar2,
    sqrt: sqrt3,
    abs: abs3,
    bignumber: bignumber2,
    diag: diag2,
    size: size2,
    reshape: reshape3,
    qr: qr2,
    inv: inv2,
    usolve: usolve2,
    usolveAll: usolveAll2,
    equal: equal2,
    complex: complex2,
    larger: larger2,
    smaller: smaller2,
    matrixFromColumns: matrixFromColumns2,
    dot: dot2
  });
  return typed3("eigs", {
    // The conversion to matrix in the first two implementations,
    // just to convert back to an array right away in
    // computeValuesAndVectors, is unfortunate, and should perhaps be
    // streamlined. It is done because the Matrix object carries some
    // type information about its entries, and so constructing the matrix
    // is a roundabout way of doing type detection.
    Array: function Array2(x) {
      return doEigs(matrix2(x));
    },
    "Array, number|BigNumber": function ArrayNumberBigNumber(x, prec) {
      return doEigs(matrix2(x), {
        precision: prec
      });
    },
    "Array, Object"(x, opts) {
      return doEigs(matrix2(x), opts);
    },
    Matrix: function Matrix2(mat) {
      return doEigs(mat, {
        matricize: true
      });
    },
    "Matrix, number|BigNumber": function MatrixNumberBigNumber(mat, prec) {
      return doEigs(mat, {
        precision: prec,
        matricize: true
      });
    },
    "Matrix, Object": function MatrixObject(mat, opts) {
      var useOpts = {
        matricize: true
      };
      _extends(useOpts, opts);
      return doEigs(mat, useOpts);
    }
  });
  function doEigs(mat) {
    var _opts$precision;
    var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var computeVectors = "eigenvectors" in opts ? opts.eigenvectors : true;
    var prec = (_opts$precision = opts.precision) !== null && _opts$precision !== void 0 ? _opts$precision : config5.relTol;
    var result = computeValuesAndVectors(mat, prec, computeVectors);
    if (opts.matricize) {
      result.values = matrix2(result.values);
      if (computeVectors) {
        result.eigenvectors = result.eigenvectors.map((_ref2) => {
          var {
            value,
            vector
          } = _ref2;
          return {
            value,
            vector: matrix2(vector)
          };
        });
      }
    }
    if (computeVectors) {
      Object.defineProperty(result, "vectors", {
        enumerable: false,
        // to make sure that the eigenvectors can still be
        // converted to string.
        get: () => {
          throw new Error("eigs(M).vectors replaced with eigs(M).eigenvectors");
        }
      });
    }
    return result;
  }
  function computeValuesAndVectors(mat, prec, computeVectors) {
    var arr = mat.toArray();
    var asize = mat.size();
    if (asize.length !== 2 || asize[0] !== asize[1]) {
      throw new RangeError("Matrix must be square (size: ".concat(format3(asize), ")"));
    }
    var N = asize[0];
    if (isReal(arr, N, prec)) {
      coerceReal(arr, N);
      if (isSymmetric(arr, N, prec)) {
        var _type = coerceTypes(mat, arr, N);
        return doRealSymmetric(arr, N, prec, _type, computeVectors);
      }
    }
    var type = coerceTypes(mat, arr, N);
    return doComplexEigs(arr, N, prec, type, computeVectors);
  }
  function isSymmetric(arr, N, prec) {
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = i2; j < N; j++) {
        if (larger2(bignumber2(abs3(subtract2(arr[i2][j], arr[j][i2]))), prec)) {
          return false;
        }
      }
    }
    return true;
  }
  function isReal(arr, N, prec) {
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = 0; j < N; j++) {
        if (larger2(bignumber2(abs3(im2(arr[i2][j]))), prec)) {
          return false;
        }
      }
    }
    return true;
  }
  function coerceReal(arr, N) {
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = 0; j < N; j++) {
        arr[i2][j] = re2(arr[i2][j]);
      }
    }
  }
  function coerceTypes(mat, arr, N) {
    var type = mat.datatype();
    if (type === "number" || type === "BigNumber" || type === "Complex") {
      return type;
    }
    var hasNumber = false;
    var hasBig = false;
    var hasComplex = false;
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = 0; j < N; j++) {
        var el = arr[i2][j];
        if (isNumber(el) || isFraction(el)) {
          hasNumber = true;
        } else if (isBigNumber(el)) {
          hasBig = true;
        } else if (isComplex(el)) {
          hasComplex = true;
        } else {
          throw TypeError("Unsupported type in Matrix: " + typeOf(el));
        }
      }
    }
    if (hasBig && hasComplex) {
      console.warn("Complex BigNumbers not supported, this operation will lose precission.");
    }
    if (hasComplex) {
      for (var _i = 0; _i < N; _i++) {
        for (var _j = 0; _j < N; _j++) {
          arr[_i][_j] = complex2(arr[_i][_j]);
        }
      }
      return "Complex";
    }
    if (hasBig) {
      for (var _i2 = 0; _i2 < N; _i2++) {
        for (var _j2 = 0; _j2 < N; _j2++) {
          arr[_i2][_j2] = bignumber2(arr[_i2][_j2]);
        }
      }
      return "BigNumber";
    }
    if (hasNumber) {
      for (var _i3 = 0; _i3 < N; _i3++) {
        for (var _j3 = 0; _j3 < N; _j3++) {
          arr[_i3][_j3] = number2(arr[_i3][_j3]);
        }
      }
      return "number";
    } else {
      throw TypeError("Matrix contains unsupported types only.");
    }
  }
});

// node_modules/mathjs/lib/esm/function/matrix/expm.js
var name245 = "expm";
var dependencies246 = ["typed", "abs", "add", "identity", "inv", "multiply"];
var createExpm = /* @__PURE__ */ factory(name245, dependencies246, (_ref) => {
  var {
    typed: typed3,
    abs: abs3,
    add: add3,
    identity: identity2,
    inv: inv2,
    multiply: multiply2
  } = _ref;
  return typed3(name245, {
    Matrix: function Matrix2(A) {
      var size2 = A.size();
      if (size2.length !== 2 || size2[0] !== size2[1]) {
        throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
      }
      var n = size2[0];
      var eps = 1e-15;
      var infNorm = infinityNorm(A);
      var params = findParams(infNorm, eps);
      var q = params.q;
      var j = params.j;
      var Apos = multiply2(A, Math.pow(2, -j));
      var N = identity2(n);
      var D = identity2(n);
      var factor = 1;
      var AposToI = Apos;
      var alternate = -1;
      for (var i2 = 1; i2 <= q; i2++) {
        if (i2 > 1) {
          AposToI = multiply2(AposToI, Apos);
          alternate = -alternate;
        }
        factor = factor * (q - i2 + 1) / ((2 * q - i2 + 1) * i2);
        N = add3(N, multiply2(factor, AposToI));
        D = add3(D, multiply2(factor * alternate, AposToI));
      }
      var R = multiply2(inv2(D), N);
      for (var _i = 0; _i < j; _i++) {
        R = multiply2(R, R);
      }
      return isSparseMatrix(A) ? A.createSparseMatrix(R) : R;
    }
  });
  function infinityNorm(A) {
    var n = A.size()[0];
    var infNorm = 0;
    for (var i2 = 0; i2 < n; i2++) {
      var rowSum = 0;
      for (var j = 0; j < n; j++) {
        rowSum += abs3(A.get([i2, j]));
      }
      infNorm = Math.max(rowSum, infNorm);
    }
    return infNorm;
  }
  function findParams(infNorm, eps) {
    var maxSearchSize = 30;
    for (var k = 0; k < maxSearchSize; k++) {
      for (var q = 0; q <= k; q++) {
        var j = k - q;
        if (errorEstimate(infNorm, q, j) < eps) {
          return {
            q,
            j
          };
        }
      }
    }
    throw new Error("Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)");
  }
  function errorEstimate(infNorm, q, j) {
    var qfac = 1;
    for (var i2 = 2; i2 <= q; i2++) {
      qfac *= i2;
    }
    var twoqfac = qfac;
    for (var _i2 = q + 1; _i2 <= 2 * q; _i2++) {
      twoqfac *= _i2;
    }
    var twoqp1fac = twoqfac * (2 * q + 1);
    return 8 * Math.pow(infNorm / Math.pow(2, j), 2 * q) * qfac * qfac / (twoqfac * twoqp1fac);
  }
});

// node_modules/mathjs/lib/esm/function/matrix/sqrtm.js
var name246 = "sqrtm";
var dependencies247 = ["typed", "abs", "add", "multiply", "map", "sqrt", "subtract", "inv", "size", "max", "identity"];
var createSqrtm = /* @__PURE__ */ factory(name246, dependencies247, (_ref) => {
  var {
    typed: typed3,
    abs: abs3,
    add: add3,
    multiply: multiply2,
    map: map3,
    sqrt: sqrt3,
    subtract: subtract2,
    inv: inv2,
    size: size2,
    max: max3,
    identity: identity2
  } = _ref;
  var _maxIterations = 1e3;
  var _tolerance = 1e-6;
  function _denmanBeavers(A) {
    var error;
    var iterations = 0;
    var Y = A;
    var Z = identity2(size2(A));
    do {
      var Yk = Y;
      Y = multiply2(0.5, add3(Yk, inv2(Z)));
      Z = multiply2(0.5, add3(Z, inv2(Yk)));
      error = max3(abs3(subtract2(Y, Yk)));
      if (error > _tolerance && ++iterations > _maxIterations) {
        throw new Error("computing square root of matrix: iterative method could not converge");
      }
    } while (error > _tolerance);
    return Y;
  }
  return typed3(name246, {
    "Array | Matrix": function ArrayMatrix(A) {
      var size3 = isMatrix(A) ? A.size() : arraySize(A);
      switch (size3.length) {
        case 1:
          if (size3[0] === 1) {
            return map3(A, sqrt3);
          } else {
            throw new RangeError("Matrix must be square (size: " + format3(size3) + ")");
          }
        case 2: {
          var rows = size3[0];
          var cols = size3[1];
          if (rows === cols) {
            return _denmanBeavers(A);
          } else {
            throw new RangeError("Matrix must be square (size: " + format3(size3) + ")");
          }
        }
        default:
          throw new RangeError("Matrix must be at most two dimensional (size: " + format3(size3) + ")");
      }
    }
  });
});

// node_modules/mathjs/lib/esm/function/algebra/sylvester.js
var name247 = "sylvester";
var dependencies248 = ["typed", "schur", "matrixFromColumns", "matrix", "multiply", "range", "concat", "transpose", "index", "subset", "add", "subtract", "identity", "lusolve", "abs"];
var createSylvester = /* @__PURE__ */ factory(name247, dependencies248, (_ref) => {
  var {
    typed: typed3,
    schur: schur2,
    matrixFromColumns: matrixFromColumns2,
    matrix: matrix2,
    multiply: multiply2,
    range: range2,
    concat: concat3,
    transpose: transpose2,
    index: index2,
    subset: subset2,
    add: add3,
    subtract: subtract2,
    identity: identity2,
    lusolve: lusolve2,
    abs: abs3
  } = _ref;
  return typed3(name247, {
    "Matrix, Matrix, Matrix": _sylvester,
    "Array, Matrix, Matrix": function ArrayMatrixMatrix(A, B, C) {
      return _sylvester(matrix2(A), B, C);
    },
    "Array, Array, Matrix": function ArrayArrayMatrix(A, B, C) {
      return _sylvester(matrix2(A), matrix2(B), C);
    },
    "Array, Matrix, Array": function ArrayMatrixArray(A, B, C) {
      return _sylvester(matrix2(A), B, matrix2(C));
    },
    "Matrix, Array, Matrix": function MatrixArrayMatrix(A, B, C) {
      return _sylvester(A, matrix2(B), C);
    },
    "Matrix, Array, Array": function MatrixArrayArray(A, B, C) {
      return _sylvester(A, matrix2(B), matrix2(C));
    },
    "Matrix, Matrix, Array": function MatrixMatrixArray(A, B, C) {
      return _sylvester(A, B, matrix2(C));
    },
    "Array, Array, Array": function ArrayArrayArray(A, B, C) {
      return _sylvester(matrix2(A), matrix2(B), matrix2(C)).toArray();
    }
  });
  function _sylvester(A, B, C) {
    var n = B.size()[0];
    var m = A.size()[0];
    var sA = schur2(A);
    var F = sA.T;
    var U = sA.U;
    var sB = schur2(multiply2(-1, B));
    var G = sB.T;
    var V = sB.U;
    var D = multiply2(multiply2(transpose2(U), C), V);
    var all = range2(0, m);
    var y = [];
    var hc = (a, b) => concat3(a, b, 1);
    var vc = (a, b) => concat3(a, b, 0);
    for (var k = 0; k < n; k++) {
      if (k < n - 1 && abs3(subset2(G, index2(k + 1, k))) > 1e-5) {
        var RHS = vc(subset2(D, index2(all, k)), subset2(D, index2(all, k + 1)));
        for (var j = 0; j < k; j++) {
          RHS = add3(RHS, vc(multiply2(y[j], subset2(G, index2(j, k))), multiply2(y[j], subset2(G, index2(j, k + 1)))));
        }
        var gkk = multiply2(identity2(m), multiply2(-1, subset2(G, index2(k, k))));
        var gmk = multiply2(identity2(m), multiply2(-1, subset2(G, index2(k + 1, k))));
        var gkm = multiply2(identity2(m), multiply2(-1, subset2(G, index2(k, k + 1))));
        var gmm = multiply2(identity2(m), multiply2(-1, subset2(G, index2(k + 1, k + 1))));
        var LHS = vc(hc(add3(F, gkk), gmk), hc(gkm, add3(F, gmm)));
        var yAux = lusolve2(LHS, RHS);
        y[k] = yAux.subset(index2(range2(0, m), 0));
        y[k + 1] = yAux.subset(index2(range2(m, 2 * m), 0));
        k++;
      } else {
        var _RHS = subset2(D, index2(all, k));
        for (var _j = 0; _j < k; _j++) {
          _RHS = add3(_RHS, multiply2(y[_j], subset2(G, index2(_j, k))));
        }
        var _gkk = subset2(G, index2(k, k));
        var _LHS = subtract2(F, multiply2(_gkk, identity2(m)));
        y[k] = lusolve2(_LHS, _RHS);
      }
    }
    var Y = matrix2(matrixFromColumns2(...y));
    var X = multiply2(U, multiply2(Y, transpose2(V)));
    return X;
  }
});

// node_modules/mathjs/lib/esm/function/algebra/decomposition/schur.js
var name248 = "schur";
var dependencies249 = ["typed", "matrix", "identity", "multiply", "qr", "norm", "subtract"];
var createSchur = /* @__PURE__ */ factory(name248, dependencies249, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    identity: identity2,
    multiply: multiply2,
    qr: qr2,
    norm: norm2,
    subtract: subtract2
  } = _ref;
  return typed3(name248, {
    Array: function Array2(X) {
      var r = _schur(matrix2(X));
      return {
        U: r.U.valueOf(),
        T: r.T.valueOf()
      };
    },
    Matrix: function Matrix2(X) {
      return _schur(X);
    }
  });
  function _schur(X) {
    var n = X.size()[0];
    var A = X;
    var U = identity2(n);
    var k = 0;
    var A0;
    do {
      A0 = A;
      var QR = qr2(A);
      var Q2 = QR.Q;
      var R = QR.R;
      A = multiply2(R, Q2);
      U = multiply2(U, Q2);
      if (k++ > 100) {
        break;
      }
    } while (norm2(subtract2(A, A0)) > 1e-4);
    return {
      U,
      T: A
    };
  }
});

// node_modules/mathjs/lib/esm/function/algebra/lyap.js
var name249 = "lyap";
var dependencies250 = ["typed", "matrix", "sylvester", "multiply", "transpose"];
var createLyap = /* @__PURE__ */ factory(name249, dependencies250, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    sylvester: sylvester2,
    multiply: multiply2,
    transpose: transpose2
  } = _ref;
  return typed3(name249, {
    "Matrix, Matrix": function MatrixMatrix(A, Q2) {
      return sylvester2(A, transpose2(A), multiply2(-1, Q2));
    },
    "Array, Matrix": function ArrayMatrix(A, Q2) {
      return sylvester2(matrix2(A), transpose2(matrix2(A)), multiply2(-1, Q2));
    },
    "Matrix, Array": function MatrixArray(A, Q2) {
      return sylvester2(A, transpose2(matrix2(A)), matrix2(multiply2(-1, Q2)));
    },
    "Array, Array": function ArrayArray(A, Q2) {
      return sylvester2(matrix2(A), transpose2(matrix2(A)), matrix2(multiply2(-1, Q2))).toArray();
    }
  });
});

// node_modules/mathjs/lib/esm/function/arithmetic/divide.js
var name250 = "divide";
var dependencies251 = ["typed", "matrix", "multiply", "equalScalar", "divideScalar", "inv"];
var createDivide = /* @__PURE__ */ factory(name250, dependencies251, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    multiply: multiply2,
    equalScalar: equalScalar2,
    divideScalar: divideScalar2,
    inv: inv2
  } = _ref;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed3,
    equalScalar: equalScalar2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed3
  });
  return typed3("divide", extend({
    // we extend the signatures of divideScalar with signatures dealing with matrices
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(x, y) {
      return multiply2(x, inv2(y));
    },
    "DenseMatrix, any": function DenseMatrixAny(x, y) {
      return matAlgo14xDs(x, y, divideScalar2, false);
    },
    "SparseMatrix, any": function SparseMatrixAny(x, y) {
      return matAlgo11xS0s(x, y, divideScalar2, false);
    },
    "Array, any": function ArrayAny(x, y) {
      return matAlgo14xDs(matrix2(x), y, divideScalar2, false).valueOf();
    },
    "any, Array | Matrix": function anyArrayMatrix(x, y) {
      return multiply2(x, inv2(y));
    }
  }, divideScalar2.signatures));
});

// node_modules/mathjs/lib/esm/function/geometry/distance.js
var name251 = "distance";
var dependencies252 = ["typed", "addScalar", "subtractScalar", "divideScalar", "multiplyScalar", "deepEqual", "sqrt", "abs"];
var createDistance = /* @__PURE__ */ factory(name251, dependencies252, (_ref) => {
  var {
    typed: typed3,
    addScalar: addScalar2,
    subtractScalar: subtractScalar2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    deepEqual: deepEqual2,
    sqrt: sqrt3,
    abs: abs3
  } = _ref;
  return typed3(name251, {
    "Array, Array, Array": function ArrayArrayArray(x, y, z) {
      if (x.length === 2 && y.length === 2 && z.length === 2) {
        if (!_2d(x)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
        }
        if (!_2d(y)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
        }
        if (!_2d(z)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
        }
        if (deepEqual2(y, z)) {
          throw new TypeError("LinePoint1 should not be same with LinePoint2");
        }
        var xCoeff = subtractScalar2(z[1], y[1]);
        var yCoeff = subtractScalar2(y[0], z[0]);
        var constant = subtractScalar2(multiplyScalar2(z[0], y[1]), multiplyScalar2(y[0], z[1]));
        return _distancePointLine2D(x[0], x[1], xCoeff, yCoeff, constant);
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    "Object, Object, Object": function ObjectObjectObject(x, y, z) {
      if (Object.keys(x).length === 2 && Object.keys(y).length === 2 && Object.keys(z).length === 2) {
        if (!_2d(x)) {
          throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
        }
        if (!_2d(y)) {
          throw new TypeError("Values of lineOnePtX and lineOnePtY should be numbers or BigNumbers");
        }
        if (!_2d(z)) {
          throw new TypeError("Values of lineTwoPtX and lineTwoPtY should be numbers or BigNumbers");
        }
        if (deepEqual2(_objectToArray(y), _objectToArray(z))) {
          throw new TypeError("LinePoint1 should not be same with LinePoint2");
        }
        if ("pointX" in x && "pointY" in x && "lineOnePtX" in y && "lineOnePtY" in y && "lineTwoPtX" in z && "lineTwoPtY" in z) {
          var xCoeff = subtractScalar2(z.lineTwoPtY, y.lineOnePtY);
          var yCoeff = subtractScalar2(y.lineOnePtX, z.lineTwoPtX);
          var constant = subtractScalar2(multiplyScalar2(z.lineTwoPtX, y.lineOnePtY), multiplyScalar2(y.lineOnePtX, z.lineTwoPtY));
          return _distancePointLine2D(x.pointX, x.pointY, xCoeff, yCoeff, constant);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    "Array, Array": function ArrayArray(x, y) {
      if (x.length === 2 && y.length === 3) {
        if (!_2d(x)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
        }
        if (!_3d(y)) {
          throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
        }
        return _distancePointLine2D(x[0], x[1], y[0], y[1], y[2]);
      } else if (x.length === 3 && y.length === 6) {
        if (!_3d(x)) {
          throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
        }
        if (!_parametricLine(y)) {
          throw new TypeError("Array with 6 numbers or BigNumbers expected for second argument");
        }
        return _distancePointLine3D(x[0], x[1], x[2], y[0], y[1], y[2], y[3], y[4], y[5]);
      } else if (x.length === y.length && x.length > 0) {
        if (!_containsOnlyNumbers(x)) {
          throw new TypeError("All values of an array should be numbers or BigNumbers");
        }
        if (!_containsOnlyNumbers(y)) {
          throw new TypeError("All values of an array should be numbers or BigNumbers");
        }
        return _euclideanDistance(x, y);
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    "Object, Object": function ObjectObject(x, y) {
      if (Object.keys(x).length === 2 && Object.keys(y).length === 3) {
        if (!_2d(x)) {
          throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
        }
        if (!_3d(y)) {
          throw new TypeError("Values of xCoeffLine, yCoeffLine and constant should be numbers or BigNumbers");
        }
        if ("pointX" in x && "pointY" in x && "xCoeffLine" in y && "yCoeffLine" in y && "constant" in y) {
          return _distancePointLine2D(x.pointX, x.pointY, y.xCoeffLine, y.yCoeffLine, y.constant);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else if (Object.keys(x).length === 3 && Object.keys(y).length === 6) {
        if (!_3d(x)) {
          throw new TypeError("Values of pointX, pointY and pointZ should be numbers or BigNumbers");
        }
        if (!_parametricLine(y)) {
          throw new TypeError("Values of x0, y0, z0, a, b and c should be numbers or BigNumbers");
        }
        if ("pointX" in x && "pointY" in x && "x0" in y && "y0" in y && "z0" in y && "a" in y && "b" in y && "c" in y) {
          return _distancePointLine3D(x.pointX, x.pointY, x.pointZ, y.x0, y.y0, y.z0, y.a, y.b, y.c);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else if (Object.keys(x).length === 2 && Object.keys(y).length === 2) {
        if (!_2d(x)) {
          throw new TypeError("Values of pointOneX and pointOneY should be numbers or BigNumbers");
        }
        if (!_2d(y)) {
          throw new TypeError("Values of pointTwoX and pointTwoY should be numbers or BigNumbers");
        }
        if ("pointOneX" in x && "pointOneY" in x && "pointTwoX" in y && "pointTwoY" in y) {
          return _euclideanDistance([x.pointOneX, x.pointOneY], [y.pointTwoX, y.pointTwoY]);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else if (Object.keys(x).length === 3 && Object.keys(y).length === 3) {
        if (!_3d(x)) {
          throw new TypeError("Values of pointOneX, pointOneY and pointOneZ should be numbers or BigNumbers");
        }
        if (!_3d(y)) {
          throw new TypeError("Values of pointTwoX, pointTwoY and pointTwoZ should be numbers or BigNumbers");
        }
        if ("pointOneX" in x && "pointOneY" in x && "pointOneZ" in x && "pointTwoX" in y && "pointTwoY" in y && "pointTwoZ" in y) {
          return _euclideanDistance([x.pointOneX, x.pointOneY, x.pointOneZ], [y.pointTwoX, y.pointTwoY, y.pointTwoZ]);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    Array: function Array2(arr) {
      if (!_pairwise(arr)) {
        throw new TypeError("Incorrect array format entered for pairwise distance calculation");
      }
      return _distancePairwise(arr);
    }
  });
  function _isNumber(a) {
    return typeof a === "number" || isBigNumber(a);
  }
  function _2d(a) {
    if (a.constructor !== Array) {
      a = _objectToArray(a);
    }
    return _isNumber(a[0]) && _isNumber(a[1]);
  }
  function _3d(a) {
    if (a.constructor !== Array) {
      a = _objectToArray(a);
    }
    return _isNumber(a[0]) && _isNumber(a[1]) && _isNumber(a[2]);
  }
  function _containsOnlyNumbers(a) {
    if (!Array.isArray(a)) {
      a = _objectToArray(a);
    }
    return a.every(_isNumber);
  }
  function _parametricLine(a) {
    if (a.constructor !== Array) {
      a = _objectToArray(a);
    }
    return _isNumber(a[0]) && _isNumber(a[1]) && _isNumber(a[2]) && _isNumber(a[3]) && _isNumber(a[4]) && _isNumber(a[5]);
  }
  function _objectToArray(o) {
    var keys = Object.keys(o);
    var a = [];
    for (var i2 = 0; i2 < keys.length; i2++) {
      a.push(o[keys[i2]]);
    }
    return a;
  }
  function _pairwise(a) {
    if (a[0].length === 2 && _isNumber(a[0][0]) && _isNumber(a[0][1])) {
      if (a.some((aI) => aI.length !== 2 || !_isNumber(aI[0]) || !_isNumber(aI[1]))) {
        return false;
      }
    } else if (a[0].length === 3 && _isNumber(a[0][0]) && _isNumber(a[0][1]) && _isNumber(a[0][2])) {
      if (a.some((aI) => aI.length !== 3 || !_isNumber(aI[0]) || !_isNumber(aI[1]) || !_isNumber(aI[2]))) {
        return false;
      }
    } else {
      return false;
    }
    return true;
  }
  function _distancePointLine2D(x, y, a, b, c) {
    var num = abs3(addScalar2(addScalar2(multiplyScalar2(a, x), multiplyScalar2(b, y)), c));
    var den = sqrt3(addScalar2(multiplyScalar2(a, a), multiplyScalar2(b, b)));
    return divideScalar2(num, den);
  }
  function _distancePointLine3D(x, y, z, x0, y0, z0, a, b, c) {
    var num = [subtractScalar2(multiplyScalar2(subtractScalar2(y0, y), c), multiplyScalar2(subtractScalar2(z0, z), b)), subtractScalar2(multiplyScalar2(subtractScalar2(z0, z), a), multiplyScalar2(subtractScalar2(x0, x), c)), subtractScalar2(multiplyScalar2(subtractScalar2(x0, x), b), multiplyScalar2(subtractScalar2(y0, y), a))];
    num = sqrt3(addScalar2(addScalar2(multiplyScalar2(num[0], num[0]), multiplyScalar2(num[1], num[1])), multiplyScalar2(num[2], num[2])));
    var den = sqrt3(addScalar2(addScalar2(multiplyScalar2(a, a), multiplyScalar2(b, b)), multiplyScalar2(c, c)));
    return divideScalar2(num, den);
  }
  function _euclideanDistance(x, y) {
    var vectorSize = x.length;
    var result = 0;
    var diff2 = 0;
    for (var i2 = 0; i2 < vectorSize; i2++) {
      diff2 = subtractScalar2(x[i2], y[i2]);
      result = addScalar2(multiplyScalar2(diff2, diff2), result);
    }
    return sqrt3(result);
  }
  function _distancePairwise(a) {
    var result = [];
    var pointA = [];
    var pointB = [];
    for (var i2 = 0; i2 < a.length - 1; i2++) {
      for (var j = i2 + 1; j < a.length; j++) {
        if (a[0].length === 2) {
          pointA = [a[i2][0], a[i2][1]];
          pointB = [a[j][0], a[j][1]];
        } else if (a[0].length === 3) {
          pointA = [a[i2][0], a[i2][1], a[i2][2]];
          pointB = [a[j][0], a[j][1], a[j][2]];
        }
        result.push(_euclideanDistance(pointA, pointB));
      }
    }
    return result;
  }
});

// node_modules/mathjs/lib/esm/function/geometry/intersect.js
var name252 = "intersect";
var dependencies253 = ["typed", "config", "abs", "add", "addScalar", "matrix", "multiply", "multiplyScalar", "divideScalar", "subtract", "smaller", "equalScalar", "flatten", "isZero", "isNumeric"];
var createIntersect = /* @__PURE__ */ factory(name252, dependencies253, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    abs: abs3,
    add: add3,
    addScalar: addScalar2,
    matrix: matrix2,
    multiply: multiply2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    subtract: subtract2,
    smaller: smaller2,
    equalScalar: equalScalar2,
    flatten: flatten3,
    isZero: isZero2,
    isNumeric: isNumeric2
  } = _ref;
  return typed3("intersect", {
    "Array, Array, Array": _AAA,
    "Array, Array, Array, Array": _AAAA,
    "Matrix, Matrix, Matrix": function MatrixMatrixMatrix(x, y, plane) {
      var arr = _AAA(x.valueOf(), y.valueOf(), plane.valueOf());
      return arr === null ? null : matrix2(arr);
    },
    "Matrix, Matrix, Matrix, Matrix": function MatrixMatrixMatrixMatrix(w, x, y, z) {
      var arr = _AAAA(w.valueOf(), x.valueOf(), y.valueOf(), z.valueOf());
      return arr === null ? null : matrix2(arr);
    }
  });
  function _AAA(x, y, plane) {
    x = _coerceArr(x);
    y = _coerceArr(y);
    plane = _coerceArr(plane);
    if (!_3d(x)) {
      throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
    }
    if (!_3d(y)) {
      throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
    }
    if (!_4d(plane)) {
      throw new TypeError("Array with 4 numbers expected as third argument");
    }
    return _intersectLinePlane(x[0], x[1], x[2], y[0], y[1], y[2], plane[0], plane[1], plane[2], plane[3]);
  }
  function _AAAA(w, x, y, z) {
    w = _coerceArr(w);
    x = _coerceArr(x);
    y = _coerceArr(y);
    z = _coerceArr(z);
    if (w.length === 2) {
      if (!_2d(w)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
      }
      if (!_2d(x)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
      }
      if (!_2d(y)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
      }
      if (!_2d(z)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for fourth argument");
      }
      return _intersect2d(w, x, y, z);
    } else if (w.length === 3) {
      if (!_3d(w)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
      }
      if (!_3d(x)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
      }
      if (!_3d(y)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for third argument");
      }
      if (!_3d(z)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for fourth argument");
      }
      return _intersect3d(w[0], w[1], w[2], x[0], x[1], x[2], y[0], y[1], y[2], z[0], z[1], z[2]);
    } else {
      throw new TypeError("Arrays with two or thee dimensional points expected");
    }
  }
  function _coerceArr(arr) {
    if (arr.length === 1)
      return arr[0];
    if (arr.length > 1 && Array.isArray(arr[0])) {
      if (arr.every((el) => Array.isArray(el) && el.length === 1))
        return flatten3(arr);
    }
    return arr;
  }
  function _2d(x) {
    return x.length === 2 && isNumeric2(x[0]) && isNumeric2(x[1]);
  }
  function _3d(x) {
    return x.length === 3 && isNumeric2(x[0]) && isNumeric2(x[1]) && isNumeric2(x[2]);
  }
  function _4d(x) {
    return x.length === 4 && isNumeric2(x[0]) && isNumeric2(x[1]) && isNumeric2(x[2]) && isNumeric2(x[3]);
  }
  function _intersect2d(p1a, p1b, p2a, p2b) {
    var o1 = p1a;
    var o2 = p2a;
    var d1 = subtract2(o1, p1b);
    var d2 = subtract2(o2, p2b);
    var det2 = subtract2(multiplyScalar2(d1[0], d2[1]), multiplyScalar2(d2[0], d1[1]));
    if (isZero2(det2))
      return null;
    if (smaller2(abs3(det2), config5.relTol)) {
      return null;
    }
    var d20o11 = multiplyScalar2(d2[0], o1[1]);
    var d21o10 = multiplyScalar2(d2[1], o1[0]);
    var d20o21 = multiplyScalar2(d2[0], o2[1]);
    var d21o20 = multiplyScalar2(d2[1], o2[0]);
    var t = divideScalar2(addScalar2(subtract2(subtract2(d20o11, d21o10), d20o21), d21o20), det2);
    return add3(multiply2(d1, t), o1);
  }
  function _intersect3dHelper(a, b, c, d, e3, f, g, h, i2, j, k, l) {
    var add1 = multiplyScalar2(subtract2(a, b), subtract2(c, d));
    var add22 = multiplyScalar2(subtract2(e3, f), subtract2(g, h));
    var add32 = multiplyScalar2(subtract2(i2, j), subtract2(k, l));
    return addScalar2(addScalar2(add1, add22), add32);
  }
  function _intersect3d(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
    var d1343 = _intersect3dHelper(x1, x3, x4, x3, y1, y3, y4, y3, z1, z3, z4, z3);
    var d4321 = _intersect3dHelper(x4, x3, x2, x1, y4, y3, y2, y1, z4, z3, z2, z1);
    var d1321 = _intersect3dHelper(x1, x3, x2, x1, y1, y3, y2, y1, z1, z3, z2, z1);
    var d4343 = _intersect3dHelper(x4, x3, x4, x3, y4, y3, y4, y3, z4, z3, z4, z3);
    var d2121 = _intersect3dHelper(x2, x1, x2, x1, y2, y1, y2, y1, z2, z1, z2, z1);
    var numerator = subtract2(multiplyScalar2(d1343, d4321), multiplyScalar2(d1321, d4343));
    var denominator = subtract2(multiplyScalar2(d2121, d4343), multiplyScalar2(d4321, d4321));
    if (isZero2(denominator))
      return null;
    var ta = divideScalar2(numerator, denominator);
    var tb = divideScalar2(addScalar2(d1343, multiplyScalar2(ta, d4321)), d4343);
    var pax = addScalar2(x1, multiplyScalar2(ta, subtract2(x2, x1)));
    var pay = addScalar2(y1, multiplyScalar2(ta, subtract2(y2, y1)));
    var paz = addScalar2(z1, multiplyScalar2(ta, subtract2(z2, z1)));
    var pbx = addScalar2(x3, multiplyScalar2(tb, subtract2(x4, x3)));
    var pby = addScalar2(y3, multiplyScalar2(tb, subtract2(y4, y3)));
    var pbz = addScalar2(z3, multiplyScalar2(tb, subtract2(z4, z3)));
    if (equalScalar2(pax, pbx) && equalScalar2(pay, pby) && equalScalar2(paz, pbz)) {
      return [pax, pay, paz];
    } else {
      return null;
    }
  }
  function _intersectLinePlane(x1, y1, z1, x2, y2, z2, x, y, z, c) {
    var x1x = multiplyScalar2(x1, x);
    var x2x = multiplyScalar2(x2, x);
    var y1y = multiplyScalar2(y1, y);
    var y2y = multiplyScalar2(y2, y);
    var z1z = multiplyScalar2(z1, z);
    var z2z = multiplyScalar2(z2, z);
    var numerator = subtract2(subtract2(subtract2(c, x1x), y1y), z1z);
    var denominator = subtract2(subtract2(subtract2(addScalar2(addScalar2(x2x, y2y), z2z), x1x), y1y), z1z);
    var t = divideScalar2(numerator, denominator);
    var px = addScalar2(x1, multiplyScalar2(t, subtract2(x2, x1)));
    var py = addScalar2(y1, multiplyScalar2(t, subtract2(y2, y1)));
    var pz = addScalar2(z1, multiplyScalar2(t, subtract2(z2, z1)));
    return [px, py, pz];
  }
});

// node_modules/mathjs/lib/esm/function/statistics/sum.js
var name253 = "sum";
var dependencies254 = ["typed", "config", "add", "numeric"];
var createSum = /* @__PURE__ */ factory(name253, dependencies254, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    add: add3,
    numeric: numeric3
  } = _ref;
  return typed3(name253, {
    // sum([a, b, c, d, ...])
    "Array | Matrix": _sum,
    // sum([a, b, c, d, ...], dim)
    "Array | Matrix, number | BigNumber": _nsumDim,
    // sum(a, b, c, d, ...)
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("Scalar values expected in function sum");
      }
      return _sum(args);
    }
  });
  function _sum(array) {
    var sum3;
    deepForEach(array, function(value) {
      try {
        sum3 = sum3 === void 0 ? value : add3(sum3, value);
      } catch (err) {
        throw improveErrorMessage(err, "sum", value);
      }
    });
    if (sum3 === void 0) {
      sum3 = numeric3(0, config5.number);
    }
    if (typeof sum3 === "string") {
      sum3 = numeric3(sum3, safeNumberType(sum3, config5));
    }
    return sum3;
  }
  function _nsumDim(array, dim) {
    try {
      var sum3 = reduce(array, dim, add3);
      return sum3;
    } catch (err) {
      throw improveErrorMessage(err, "sum");
    }
  }
});

// node_modules/mathjs/lib/esm/function/statistics/cumsum.js
var name254 = "cumsum";
var dependencies255 = ["typed", "add", "unaryPlus"];
var createCumSum = /* @__PURE__ */ factory(name254, dependencies255, (_ref) => {
  var {
    typed: typed3,
    add: add3,
    unaryPlus: unaryPlus2
  } = _ref;
  return typed3(name254, {
    // sum([a, b, c, d, ...])
    Array: _cumsum,
    Matrix: function Matrix2(matrix2) {
      return matrix2.create(_cumsum(matrix2.valueOf()));
    },
    // sum([a, b, c, d, ...], dim)
    "Array, number | BigNumber": _ncumSumDim,
    "Matrix, number | BigNumber": function MatrixNumberBigNumber(matrix2, dim) {
      return matrix2.create(_ncumSumDim(matrix2.valueOf(), dim));
    },
    // cumsum(a, b, c, d, ...)
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("All values expected to be scalar in function cumsum");
      }
      return _cumsum(args);
    }
  });
  function _cumsum(array) {
    try {
      return _cumsummap(array);
    } catch (err) {
      throw improveErrorMessage(err, name254);
    }
  }
  function _cumsummap(array) {
    if (array.length === 0) {
      return [];
    }
    var sums = [unaryPlus2(array[0])];
    for (var i2 = 1; i2 < array.length; ++i2) {
      sums.push(add3(sums[i2 - 1], array[i2]));
    }
    return sums;
  }
  function _ncumSumDim(array, dim) {
    var size2 = arraySize(array);
    if (dim < 0 || dim >= size2.length) {
      throw new IndexError(dim, size2.length);
    }
    try {
      return _cumsumDimensional(array, dim);
    } catch (err) {
      throw improveErrorMessage(err, name254);
    }
  }
  function _cumsumDimensional(mat, dim) {
    var i2, ret, tran;
    if (dim <= 0) {
      var initialValue = mat[0][0];
      if (!Array.isArray(initialValue)) {
        return _cumsummap(mat);
      } else {
        tran = _switch(mat);
        ret = [];
        for (i2 = 0; i2 < tran.length; i2++) {
          ret[i2] = _cumsumDimensional(tran[i2], dim - 1);
        }
        return ret;
      }
    } else {
      ret = [];
      for (i2 = 0; i2 < mat.length; i2++) {
        ret[i2] = _cumsumDimensional(mat[i2], dim - 1);
      }
      return ret;
    }
  }
});

// node_modules/mathjs/lib/esm/function/statistics/mean.js
var name255 = "mean";
var dependencies256 = ["typed", "add", "divide"];
var createMean = /* @__PURE__ */ factory(name255, dependencies256, (_ref) => {
  var {
    typed: typed3,
    add: add3,
    divide: divide3
  } = _ref;
  return typed3(name255, {
    // mean([a, b, c, d, ...])
    "Array | Matrix": _mean,
    // mean([a, b, c, d, ...], dim)
    "Array | Matrix, number | BigNumber": _nmeanDim,
    // mean(a, b, c, d, ...)
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("Scalar values expected in function mean");
      }
      return _mean(args);
    }
  });
  function _nmeanDim(array, dim) {
    try {
      var sum3 = reduce(array, dim, add3);
      var s = Array.isArray(array) ? arraySize(array) : array.size();
      return divide3(sum3, s[dim]);
    } catch (err) {
      throw improveErrorMessage(err, "mean");
    }
  }
  function _mean(array) {
    var sum3;
    var num = 0;
    deepForEach(array, function(value) {
      try {
        sum3 = sum3 === void 0 ? value : add3(sum3, value);
        num++;
      } catch (err) {
        throw improveErrorMessage(err, "mean", value);
      }
    });
    if (num === 0) {
      throw new Error("Cannot calculate the mean of an empty array");
    }
    return divide3(sum3, num);
  }
});

// node_modules/mathjs/lib/esm/function/statistics/median.js
var name256 = "median";
var dependencies257 = ["typed", "add", "divide", "compare", "partitionSelect"];
var createMedian = /* @__PURE__ */ factory(name256, dependencies257, (_ref) => {
  var {
    typed: typed3,
    add: add3,
    divide: divide3,
    compare: compare2,
    partitionSelect: partitionSelect2
  } = _ref;
  function _median(array) {
    try {
      array = flatten(array.valueOf());
      var num = array.length;
      if (num === 0) {
        throw new Error("Cannot calculate median of an empty array");
      }
      if (num % 2 === 0) {
        var mid = num / 2 - 1;
        var right = partitionSelect2(array, mid + 1);
        var left = array[mid];
        for (var i2 = 0; i2 < mid; ++i2) {
          if (compare2(array[i2], left) > 0) {
            left = array[i2];
          }
        }
        return middle2(left, right);
      } else {
        var m = partitionSelect2(array, (num - 1) / 2);
        return middle(m);
      }
    } catch (err) {
      throw improveErrorMessage(err, "median");
    }
  }
  var middle = typed3({
    "number | BigNumber | Complex | Unit": function numberBigNumberComplexUnit(value) {
      return value;
    }
  });
  var middle2 = typed3({
    "number | BigNumber | Complex | Unit, number | BigNumber | Complex | Unit": function numberBigNumberComplexUnitNumberBigNumberComplexUnit(left, right) {
      return divide3(add3(left, right), 2);
    }
  });
  return typed3(name256, {
    // median([a, b, c, d, ...])
    "Array | Matrix": _median,
    // median([a, b, c, d, ...], dim)
    "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
      throw new Error("median(A, dim) is not yet supported");
    },
    // median(a, b, c, d, ...)
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("Scalar values expected in function median");
      }
      return _median(args);
    }
  });
});

// node_modules/mathjs/lib/esm/function/statistics/mad.js
var name257 = "mad";
var dependencies258 = ["typed", "abs", "map", "median", "subtract"];
var createMad = /* @__PURE__ */ factory(name257, dependencies258, (_ref) => {
  var {
    typed: typed3,
    abs: abs3,
    map: map3,
    median: median2,
    subtract: subtract2
  } = _ref;
  return typed3(name257, {
    // mad([a, b, c, d, ...])
    "Array | Matrix": _mad,
    // mad(a, b, c, d, ...)
    "...": function _(args) {
      return _mad(args);
    }
  });
  function _mad(array) {
    array = flatten(array.valueOf());
    if (array.length === 0) {
      throw new Error("Cannot calculate median absolute deviation (mad) of an empty array");
    }
    try {
      var med = median2(array);
      return median2(map3(array, function(value) {
        return abs3(subtract2(value, med));
      }));
    } catch (err) {
      if (err instanceof TypeError && err.message.includes("median")) {
        throw new TypeError(err.message.replace("median", "mad"));
      } else {
        throw improveErrorMessage(err, "mad");
      }
    }
  }
});

// node_modules/mathjs/lib/esm/function/statistics/variance.js
var DEFAULT_NORMALIZATION = "unbiased";
var name258 = "variance";
var dependencies259 = ["typed", "add", "subtract", "multiply", "divide", "apply", "isNaN"];
var createVariance = /* @__PURE__ */ factory(name258, dependencies259, (_ref) => {
  var {
    typed: typed3,
    add: add3,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide3,
    apply: apply2,
    isNaN: isNaN3
  } = _ref;
  return typed3(name258, {
    // variance([a, b, c, d, ...])
    "Array | Matrix": function ArrayMatrix(array) {
      return _var(array, DEFAULT_NORMALIZATION);
    },
    // variance([a, b, c, d, ...], normalization)
    "Array | Matrix, string": _var,
    // variance([a, b, c, c, ...], dim)
    "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
      return _varDim(array, dim, DEFAULT_NORMALIZATION);
    },
    // variance([a, b, c, c, ...], dim, normalization)
    "Array | Matrix, number | BigNumber, string": _varDim,
    // variance(a, b, c, d, ...)
    "...": function _(args) {
      return _var(args, DEFAULT_NORMALIZATION);
    }
  });
  function _var(array, normalization) {
    var sum3;
    var num = 0;
    if (array.length === 0) {
      throw new SyntaxError("Function variance requires one or more parameters (0 provided)");
    }
    deepForEach(array, function(value) {
      try {
        sum3 = sum3 === void 0 ? value : add3(sum3, value);
        num++;
      } catch (err) {
        throw improveErrorMessage(err, "variance", value);
      }
    });
    if (num === 0)
      throw new Error("Cannot calculate variance of an empty array");
    var mean2 = divide3(sum3, num);
    sum3 = void 0;
    deepForEach(array, function(value) {
      var diff2 = subtract2(value, mean2);
      sum3 = sum3 === void 0 ? multiply2(diff2, diff2) : add3(sum3, multiply2(diff2, diff2));
    });
    if (isNaN3(sum3)) {
      return sum3;
    }
    switch (normalization) {
      case "uncorrected":
        return divide3(sum3, num);
      case "biased":
        return divide3(sum3, num + 1);
      case "unbiased": {
        var zero = isBigNumber(sum3) ? sum3.mul(0) : 0;
        return num === 1 ? zero : divide3(sum3, num - 1);
      }
      default:
        throw new Error('Unknown normalization "' + normalization + '". Choose "unbiased" (default), "uncorrected", or "biased".');
    }
  }
  function _varDim(array, dim, normalization) {
    try {
      if (array.length === 0) {
        throw new SyntaxError("Function variance requires one or more parameters (0 provided)");
      }
      return apply2(array, dim, (x) => _var(x, normalization));
    } catch (err) {
      throw improveErrorMessage(err, "variance");
    }
  }
});

// node_modules/mathjs/lib/esm/function/statistics/quantileSeq.js
var name259 = "quantileSeq";
var dependencies260 = ["typed", "?bignumber", "add", "subtract", "divide", "multiply", "partitionSelect", "compare", "isInteger", "smaller", "smallerEq", "larger"];
var createQuantileSeq = /* @__PURE__ */ factory(name259, dependencies260, (_ref) => {
  var {
    typed: typed3,
    bignumber: bignumber2,
    add: add3,
    subtract: subtract2,
    divide: divide3,
    multiply: multiply2,
    partitionSelect: partitionSelect2,
    compare: compare2,
    isInteger: isInteger3,
    smaller: smaller2,
    smallerEq: smallerEq2,
    larger: larger2
  } = _ref;
  var apply2 = createApply({
    typed: typed3,
    isInteger: isInteger3
  });
  return typed3(name259, {
    "Array | Matrix, number | BigNumber": (data, p) => _quantileSeqProbNumber(data, p, false),
    "Array | Matrix, number | BigNumber, number": (data, prob, dim) => _quantileSeqDim(data, prob, false, dim, _quantileSeqProbNumber),
    "Array | Matrix, number | BigNumber, boolean": _quantileSeqProbNumber,
    "Array | Matrix, number | BigNumber, boolean, number": (data, prob, sorted, dim) => _quantileSeqDim(data, prob, sorted, dim, _quantileSeqProbNumber),
    "Array | Matrix, Array | Matrix": (data, p) => _quantileSeqProbCollection(data, p, false),
    "Array | Matrix, Array | Matrix, number": (data, prob, dim) => _quantileSeqDim(data, prob, false, dim, _quantileSeqProbCollection),
    "Array | Matrix, Array | Matrix, boolean": _quantileSeqProbCollection,
    "Array | Matrix, Array | Matrix, boolean, number": (data, prob, sorted, dim) => _quantileSeqDim(data, prob, sorted, dim, _quantileSeqProbCollection)
  });
  function _quantileSeqDim(data, prob, sorted, dim, fn) {
    return apply2(data, dim, (x) => fn(x, prob, sorted));
  }
  function _quantileSeqProbNumber(data, probOrN, sorted) {
    var probArr;
    var dataArr = data.valueOf();
    if (smaller2(probOrN, 0)) {
      throw new Error("N/prob must be non-negative");
    }
    if (smallerEq2(probOrN, 1)) {
      return isNumber(probOrN) ? _quantileSeq(dataArr, probOrN, sorted) : bignumber2(_quantileSeq(dataArr, probOrN, sorted));
    }
    if (larger2(probOrN, 1)) {
      if (!isInteger3(probOrN)) {
        throw new Error("N must be a positive integer");
      }
      if (larger2(probOrN, 4294967295)) {
        throw new Error("N must be less than or equal to 2^32-1, as that is the maximum length of an Array");
      }
      var nPlusOne = add3(probOrN, 1);
      probArr = [];
      for (var i2 = 0; smaller2(i2, probOrN); i2++) {
        var prob = divide3(i2 + 1, nPlusOne);
        probArr.push(_quantileSeq(dataArr, prob, sorted));
      }
      return isNumber(probOrN) ? probArr : bignumber2(probArr);
    }
  }
  function _quantileSeqProbCollection(data, probOrN, sorted) {
    var dataArr = data.valueOf();
    var probOrNArr = probOrN.valueOf();
    var probArr = [];
    for (var i2 = 0; i2 < probOrNArr.length; ++i2) {
      probArr.push(_quantileSeq(dataArr, probOrNArr[i2], sorted));
    }
    return probArr;
  }
  function _quantileSeq(array, prob, sorted) {
    var flat = flatten(array);
    var len = flat.length;
    if (len === 0) {
      throw new Error("Cannot calculate quantile of an empty sequence");
    }
    var index2 = isNumber(prob) ? prob * (len - 1) : prob.times(len - 1);
    var integerPart = isNumber(prob) ? Math.floor(index2) : index2.floor().toNumber();
    var fracPart = isNumber(prob) ? index2 % 1 : index2.minus(integerPart);
    if (isInteger3(index2)) {
      return sorted ? flat[index2] : partitionSelect2(flat, isNumber(prob) ? index2 : index2.valueOf());
    }
    var left;
    var right;
    if (sorted) {
      left = flat[integerPart];
      right = flat[integerPart + 1];
    } else {
      right = partitionSelect2(flat, integerPart + 1);
      left = flat[integerPart];
      for (var i2 = 0; i2 < integerPart; ++i2) {
        if (compare2(flat[i2], left) > 0) {
          left = flat[i2];
        }
      }
    }
    return add3(multiply2(left, subtract2(1, fracPart)), multiply2(right, fracPart));
  }
});

// node_modules/mathjs/lib/esm/function/statistics/std.js
var name260 = "std";
var dependencies261 = ["typed", "map", "sqrt", "variance"];
var createStd = /* @__PURE__ */ factory(name260, dependencies261, (_ref) => {
  var {
    typed: typed3,
    map: map3,
    sqrt: sqrt3,
    variance: variance2
  } = _ref;
  return typed3(name260, {
    // std([a, b, c, d, ...])
    "Array | Matrix": _std,
    // std([a, b, c, d, ...], normalization)
    "Array | Matrix, string": _std,
    // std([a, b, c, c, ...], dim)
    "Array | Matrix, number | BigNumber": _std,
    // std([a, b, c, c, ...], dim, normalization)
    "Array | Matrix, number | BigNumber, string": _std,
    // std(a, b, c, d, ...)
    "...": function _(args) {
      return _std(args);
    }
  });
  function _std(array, normalization) {
    if (array.length === 0) {
      throw new SyntaxError("Function std requires one or more parameters (0 provided)");
    }
    try {
      var v = variance2.apply(null, arguments);
      if (isCollection(v)) {
        return map3(v, sqrt3);
      } else {
        return sqrt3(v);
      }
    } catch (err) {
      if (err instanceof TypeError && err.message.includes(" variance")) {
        throw new TypeError(err.message.replace(" variance", " std"));
      } else {
        throw err;
      }
    }
  }
});

// node_modules/mathjs/lib/esm/function/statistics/corr.js
var name261 = "corr";
var dependencies262 = ["typed", "matrix", "mean", "sqrt", "sum", "add", "subtract", "multiply", "pow", "divide"];
var createCorr = /* @__PURE__ */ factory(name261, dependencies262, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    sqrt: sqrt3,
    sum: sum3,
    add: add3,
    subtract: subtract2,
    multiply: multiply2,
    pow: pow3,
    divide: divide3
  } = _ref;
  return typed3(name261, {
    "Array, Array": function ArrayArray(A, B) {
      return _corr(A, B);
    },
    "Matrix, Matrix": function MatrixMatrix(A, B) {
      var res = _corr(A.toArray(), B.toArray());
      return Array.isArray(res) ? matrix2(res) : res;
    }
  });
  function _corr(A, B) {
    var correlations = [];
    if (Array.isArray(A[0]) && Array.isArray(B[0])) {
      if (A.length !== B.length) {
        throw new SyntaxError("Dimension mismatch. Array A and B must have the same length.");
      }
      for (var i2 = 0; i2 < A.length; i2++) {
        if (A[i2].length !== B[i2].length) {
          throw new SyntaxError("Dimension mismatch. Array A and B must have the same number of elements.");
        }
        correlations.push(correlation(A[i2], B[i2]));
      }
      return correlations;
    } else {
      if (A.length !== B.length) {
        throw new SyntaxError("Dimension mismatch. Array A and B must have the same number of elements.");
      }
      return correlation(A, B);
    }
  }
  function correlation(A, B) {
    var n = A.length;
    var sumX = sum3(A);
    var sumY = sum3(B);
    var sumXY = A.reduce((acc, x, index2) => add3(acc, multiply2(x, B[index2])), 0);
    var sumXSquare = sum3(A.map((x) => pow3(x, 2)));
    var sumYSquare = sum3(B.map((y) => pow3(y, 2)));
    var numerator = subtract2(multiply2(n, sumXY), multiply2(sumX, sumY));
    var denominator = sqrt3(multiply2(subtract2(multiply2(n, sumXSquare), pow3(sumX, 2)), subtract2(multiply2(n, sumYSquare), pow3(sumY, 2))));
    return divide3(numerator, denominator);
  }
});

// node_modules/mathjs/lib/esm/function/probability/combinations.js
var name262 = "combinations";
var dependencies263 = ["typed"];
var createCombinations = /* @__PURE__ */ factory(name262, dependencies263, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name262, {
    "number, number": combinationsNumber,
    "BigNumber, BigNumber": function BigNumberBigNumber(n, k) {
      var BigNumber2 = n.constructor;
      var result, i2;
      var nMinusk = n.minus(k);
      var one = new BigNumber2(1);
      if (!isPositiveInteger(n) || !isPositiveInteger(k)) {
        throw new TypeError("Positive integer value expected in function combinations");
      }
      if (k.gt(n)) {
        throw new TypeError("k must be less than n in function combinations");
      }
      result = one;
      if (k.lt(nMinusk)) {
        for (i2 = one; i2.lte(nMinusk); i2 = i2.plus(one)) {
          result = result.times(k.plus(i2)).dividedBy(i2);
        }
      } else {
        for (i2 = one; i2.lte(k); i2 = i2.plus(one)) {
          result = result.times(nMinusk.plus(i2)).dividedBy(i2);
        }
      }
      return result;
    }
    // TODO: implement support for collection in combinations
  });
});
function isPositiveInteger(n) {
  return n.isInteger() && n.gte(0);
}

// node_modules/mathjs/lib/esm/function/probability/combinationsWithRep.js
var name263 = "combinationsWithRep";
var dependencies264 = ["typed"];
var createCombinationsWithRep = /* @__PURE__ */ factory(name263, dependencies264, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  return typed3(name263, {
    "number, number": function numberNumber(n, k) {
      if (!isInteger(n) || n < 0) {
        throw new TypeError("Positive integer value expected in function combinationsWithRep");
      }
      if (!isInteger(k) || k < 0) {
        throw new TypeError("Positive integer value expected in function combinationsWithRep");
      }
      if (n < 1) {
        throw new TypeError("k must be less than or equal to n + k - 1");
      }
      if (k < n - 1) {
        var _prodrange = product2(n, n + k - 1);
        return _prodrange / product2(1, k);
      }
      var prodrange = product2(k + 1, n + k - 1);
      return prodrange / product2(1, n - 1);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(n, k) {
      var BigNumber2 = n.constructor;
      var result, i2;
      var one = new BigNumber2(1);
      var nMinusOne = n.minus(one);
      if (!isPositiveInteger2(n) || !isPositiveInteger2(k)) {
        throw new TypeError("Positive integer value expected in function combinationsWithRep");
      }
      if (n.lt(one)) {
        throw new TypeError("k must be less than or equal to n + k - 1 in function combinationsWithRep");
      }
      result = one;
      if (k.lt(nMinusOne)) {
        for (i2 = one; i2.lte(nMinusOne); i2 = i2.plus(one)) {
          result = result.times(k.plus(i2)).dividedBy(i2);
        }
      } else {
        for (i2 = one; i2.lte(k); i2 = i2.plus(one)) {
          result = result.times(nMinusOne.plus(i2)).dividedBy(i2);
        }
      }
      return result;
    }
  });
});
function isPositiveInteger2(n) {
  return n.isInteger() && n.gte(0);
}

// node_modules/mathjs/lib/esm/function/probability/gamma.js
var name264 = "gamma";
var dependencies265 = ["typed", "config", "multiplyScalar", "pow", "BigNumber", "Complex"];
var createGamma = /* @__PURE__ */ factory(name264, dependencies265, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    multiplyScalar: multiplyScalar2,
    pow: pow3,
    BigNumber: _BigNumber,
    Complex: Complex3
  } = _ref;
  function gammaComplex(n) {
    if (n.im === 0) {
      return gammaNumber(n.re);
    }
    if (n.re < 0.5) {
      var _t = new Complex3(1 - n.re, -n.im);
      var r = new Complex3(Math.PI * n.re, Math.PI * n.im);
      return new Complex3(Math.PI).div(r.sin()).div(gammaComplex(_t));
    }
    n = new Complex3(n.re - 1, n.im);
    var x = new Complex3(gammaP[0], 0);
    for (var i2 = 1; i2 < gammaP.length; ++i2) {
      var gammaPval = new Complex3(gammaP[i2], 0);
      x = x.add(gammaPval.div(n.add(i2)));
    }
    var t = new Complex3(n.re + gammaG + 0.5, n.im);
    var twoPiSqrt = Math.sqrt(2 * Math.PI);
    var tpow = t.pow(n.add(0.5));
    var expt = t.neg().exp();
    return x.mul(twoPiSqrt).mul(tpow).mul(expt);
  }
  return typed3(name264, {
    number: gammaNumber,
    Complex: gammaComplex,
    BigNumber: function BigNumber2(n) {
      if (n.isInteger()) {
        return n.isNegative() || n.isZero() ? new _BigNumber(Infinity) : bigFactorial(n.minus(1));
      }
      if (!n.isFinite()) {
        return new _BigNumber(n.isNegative() ? NaN : Infinity);
      }
      throw new Error("Integer BigNumber expected");
    }
  });
  function bigFactorial(n) {
    if (n < 8) {
      return new _BigNumber([1, 1, 2, 6, 24, 120, 720, 5040][n]);
    }
    var precision = config5.precision + (Math.log(n.toNumber()) | 0);
    var Big = _BigNumber.clone({
      precision
    });
    if (n % 2 === 1) {
      return n.times(bigFactorial(new _BigNumber(n - 1)));
    }
    var p = n;
    var prod2 = new Big(n);
    var sum3 = n.toNumber();
    while (p > 2) {
      p -= 2;
      sum3 += p;
      prod2 = prod2.times(sum3);
    }
    return new _BigNumber(prod2.toPrecision(_BigNumber.precision));
  }
});

// node_modules/mathjs/lib/esm/function/probability/lgamma.js
var name265 = "lgamma";
var dependencies266 = ["Complex", "typed"];
var createLgamma = /* @__PURE__ */ factory(name265, dependencies266, (_ref) => {
  var {
    Complex: Complex3,
    typed: typed3
  } = _ref;
  var SMALL_RE = 7;
  var SMALL_IM = 7;
  var coeffs = [-0.029550653594771242, 0.00641025641025641, -0.0019175269175269176, 8417508417508417e-19, -5952380952380953e-19, 7936507936507937e-19, -0.002777777777777778, 0.08333333333333333];
  return typed3(name265, {
    number: lgammaNumber,
    Complex: lgammaComplex,
    BigNumber: function BigNumber2() {
      throw new Error("mathjs doesn't yet provide an implementation of the algorithm lgamma for BigNumber");
    }
  });
  function lgammaComplex(n) {
    var TWOPI = 6.283185307179586;
    var LOGPI = 1.1447298858494002;
    var REFLECTION = 0.1;
    if (n.isNaN()) {
      return new Complex3(NaN, NaN);
    } else if (n.im === 0) {
      return new Complex3(lgammaNumber(n.re), 0);
    } else if (n.re >= SMALL_RE || Math.abs(n.im) >= SMALL_IM) {
      return lgammaStirling(n);
    } else if (n.re <= REFLECTION) {
      var tmp = copysign(TWOPI, n.im) * Math.floor(0.5 * n.re + 0.25);
      var a = n.mul(Math.PI).sin().log();
      var b = lgammaComplex(new Complex3(1 - n.re, -n.im));
      return new Complex3(LOGPI, tmp).sub(a).sub(b);
    } else if (n.im >= 0) {
      return lgammaRecurrence(n);
    } else {
      return lgammaRecurrence(n.conjugate()).conjugate();
    }
  }
  function lgammaStirling(z) {
    var leftPart = z.sub(0.5).mul(z.log()).sub(z).add(lnSqrt2PI);
    var rz = new Complex3(1, 0).div(z);
    var rzz = rz.div(z);
    var a = coeffs[0];
    var b = coeffs[1];
    var r = 2 * rzz.re;
    var s = rzz.re * rzz.re + rzz.im * rzz.im;
    for (var i2 = 2; i2 < 8; i2++) {
      var tmp = b;
      b = -s * a + coeffs[i2];
      a = r * a + tmp;
    }
    var rightPart = rz.mul(rzz.mul(a).add(b));
    return leftPart.add(rightPart);
  }
  function lgammaRecurrence(z) {
    var signflips = 0;
    var sb = 0;
    var shiftprod = z;
    z = z.add(1);
    while (z.re <= SMALL_RE) {
      shiftprod = shiftprod.mul(z);
      var nsb = shiftprod.im < 0 ? 1 : 0;
      if (nsb !== 0 && sb === 0)
        signflips++;
      sb = nsb;
      z = z.add(1);
    }
    return lgammaStirling(z).sub(shiftprod.log()).sub(new Complex3(0, signflips * 2 * Math.PI * 1));
  }
});

// node_modules/mathjs/lib/esm/function/probability/factorial.js
var name266 = "factorial";
var dependencies267 = ["typed", "gamma"];
var createFactorial = /* @__PURE__ */ factory(name266, dependencies267, (_ref) => {
  var {
    typed: typed3,
    gamma: gamma2
  } = _ref;
  return typed3(name266, {
    number: function number2(n) {
      if (n < 0) {
        throw new Error("Value must be non-negative");
      }
      return gamma2(n + 1);
    },
    BigNumber: function BigNumber2(n) {
      if (n.isNegative()) {
        throw new Error("Value must be non-negative");
      }
      return gamma2(n.plus(1));
    },
    "Array | Matrix": typed3.referToSelf((self2) => (n) => deepMap(n, self2))
  });
});

// node_modules/mathjs/lib/esm/function/probability/kldivergence.js
var name267 = "kldivergence";
var dependencies268 = ["typed", "matrix", "divide", "sum", "multiply", "map", "dotDivide", "log", "isNumeric"];
var createKldivergence = /* @__PURE__ */ factory(name267, dependencies268, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    divide: divide3,
    sum: sum3,
    multiply: multiply2,
    map: map3,
    dotDivide: dotDivide2,
    log: log4,
    isNumeric: isNumeric2
  } = _ref;
  return typed3(name267, {
    "Array, Array": function ArrayArray(q, p) {
      return _kldiv(matrix2(q), matrix2(p));
    },
    "Matrix, Array": function MatrixArray(q, p) {
      return _kldiv(q, matrix2(p));
    },
    "Array, Matrix": function ArrayMatrix(q, p) {
      return _kldiv(matrix2(q), p);
    },
    "Matrix, Matrix": function MatrixMatrix(q, p) {
      return _kldiv(q, p);
    }
  });
  function _kldiv(q, p) {
    var plength = p.size().length;
    var qlength = q.size().length;
    if (plength > 1) {
      throw new Error("first object must be one dimensional");
    }
    if (qlength > 1) {
      throw new Error("second object must be one dimensional");
    }
    if (plength !== qlength) {
      throw new Error("Length of two vectors must be equal");
    }
    var sumq = sum3(q);
    if (sumq === 0) {
      throw new Error("Sum of elements in first object must be non zero");
    }
    var sump = sum3(p);
    if (sump === 0) {
      throw new Error("Sum of elements in second object must be non zero");
    }
    var qnorm = divide3(q, sum3(q));
    var pnorm = divide3(p, sum3(p));
    var result = sum3(multiply2(qnorm, map3(dotDivide2(qnorm, pnorm), (x) => log4(x))));
    if (isNumeric2(result)) {
      return result;
    } else {
      return Number.NaN;
    }
  }
});

// node_modules/mathjs/lib/esm/function/probability/multinomial.js
var name268 = "multinomial";
var dependencies269 = ["typed", "add", "divide", "multiply", "factorial", "isInteger", "isPositive"];
var createMultinomial = /* @__PURE__ */ factory(name268, dependencies269, (_ref) => {
  var {
    typed: typed3,
    add: add3,
    divide: divide3,
    multiply: multiply2,
    factorial: factorial2,
    isInteger: isInteger3,
    isPositive: isPositive2
  } = _ref;
  return typed3(name268, {
    "Array | Matrix": function ArrayMatrix(a) {
      var sum3 = 0;
      var denom = 1;
      deepForEach(a, function(ai) {
        if (!isInteger3(ai) || !isPositive2(ai)) {
          throw new TypeError("Positive integer value expected in function multinomial");
        }
        sum3 = add3(sum3, ai);
        denom = multiply2(denom, factorial2(ai));
      });
      return divide3(factorial2(sum3), denom);
    }
  });
});

// node_modules/mathjs/lib/esm/function/probability/permutations.js
var name269 = "permutations";
var dependencies270 = ["typed", "factorial"];
var createPermutations = /* @__PURE__ */ factory(name269, dependencies270, (_ref) => {
  var {
    typed: typed3,
    factorial: factorial2
  } = _ref;
  return typed3(name269, {
    "number | BigNumber": factorial2,
    "number, number": function numberNumber(n, k) {
      if (!isInteger(n) || n < 0) {
        throw new TypeError("Positive integer value expected in function permutations");
      }
      if (!isInteger(k) || k < 0) {
        throw new TypeError("Positive integer value expected in function permutations");
      }
      if (k > n) {
        throw new TypeError("second argument k must be less than or equal to first argument n");
      }
      return product2(n - k + 1, n);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(n, k) {
      var result, i2;
      if (!isPositiveInteger3(n) || !isPositiveInteger3(k)) {
        throw new TypeError("Positive integer value expected in function permutations");
      }
      if (k.gt(n)) {
        throw new TypeError("second argument k must be less than or equal to first argument n");
      }
      var one = n.mul(0).add(1);
      result = one;
      for (i2 = n.minus(k).plus(1); i2.lte(n); i2 = i2.plus(1)) {
        result = result.times(i2);
      }
      return result;
    }
    // TODO: implement support for collection in permutations
  });
});
function isPositiveInteger3(n) {
  return n.isInteger() && n.gte(0);
}

// node_modules/mathjs/lib/esm/function/probability/util/seededRNG.js
var import_seedrandom = __toESM(require_seedrandom2(), 1);
var singletonRandom = /* @__PURE__ */ (0, import_seedrandom.default)(Date.now());
function createRng(randomSeed) {
  var random3;
  function setSeed(seed) {
    random3 = seed === null ? singletonRandom : (0, import_seedrandom.default)(String(seed));
  }
  setSeed(randomSeed);
  function rng2() {
    return random3();
  }
  return rng2;
}

// node_modules/mathjs/lib/esm/function/probability/pickRandom.js
var name270 = "pickRandom";
var dependencies271 = ["typed", "config", "?on"];
var createPickRandom = /* @__PURE__ */ factory(name270, dependencies271, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    on
  } = _ref;
  var rng2 = createRng(config5.randomSeed);
  if (on) {
    on("config", function(curr, prev) {
      if (curr.randomSeed !== prev.randomSeed) {
        rng2 = createRng(curr.randomSeed);
      }
    });
  }
  return typed3(name270, {
    "Array | Matrix": function ArrayMatrix(possibles) {
      return _pickRandom(possibles, {});
    },
    "Array | Matrix, Object": function ArrayMatrixObject(possibles, options2) {
      return _pickRandom(possibles, options2);
    },
    "Array | Matrix, number": function ArrayMatrixNumber(possibles, number2) {
      return _pickRandom(possibles, {
        number: number2
      });
    },
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(possibles, weights) {
      return _pickRandom(possibles, {
        weights
      });
    },
    "Array | Matrix, Array | Matrix, number": function ArrayMatrixArrayMatrixNumber(possibles, weights, number2) {
      return _pickRandom(possibles, {
        number: number2,
        weights
      });
    },
    "Array | Matrix, number, Array | Matrix": function ArrayMatrixNumberArrayMatrix(possibles, number2, weights) {
      return _pickRandom(possibles, {
        number: number2,
        weights
      });
    }
  });
  function _pickRandom(possibles, _ref2) {
    var {
      number: number2,
      weights,
      elementWise = true
    } = _ref2;
    var single = typeof number2 === "undefined";
    if (single) {
      number2 = 1;
    }
    var createMatrix2 = isMatrix(possibles) ? possibles.create : isMatrix(weights) ? weights.create : null;
    possibles = possibles.valueOf();
    if (weights) {
      weights = weights.valueOf();
    }
    if (elementWise === true) {
      possibles = flatten(possibles);
      weights = flatten(weights);
    }
    var totalWeights = 0;
    if (typeof weights !== "undefined") {
      if (weights.length !== possibles.length) {
        throw new Error("Weights must have the same length as possibles");
      }
      for (var i2 = 0, len = weights.length; i2 < len; i2++) {
        if (!isNumber(weights[i2]) || weights[i2] < 0) {
          throw new Error("Weights must be an array of positive numbers");
        }
        totalWeights += weights[i2];
      }
    }
    var length = possibles.length;
    var result = [];
    var pick;
    while (result.length < number2) {
      if (typeof weights === "undefined") {
        pick = possibles[Math.floor(rng2() * length)];
      } else {
        var randKey = rng2() * totalWeights;
        for (var _i = 0, _len = possibles.length; _i < _len; _i++) {
          randKey -= weights[_i];
          if (randKey < 0) {
            pick = possibles[_i];
            break;
          }
        }
      }
      result.push(pick);
    }
    return single ? result[0] : createMatrix2 ? createMatrix2(result) : result;
  }
});

// node_modules/mathjs/lib/esm/function/probability/util/randomMatrix.js
function randomMatrix(size2, random3) {
  var data = [];
  size2 = size2.slice(0);
  if (size2.length > 1) {
    for (var i2 = 0, length = size2.shift(); i2 < length; i2++) {
      data.push(randomMatrix(size2, random3));
    }
  } else {
    for (var _i = 0, _length = size2.shift(); _i < _length; _i++) {
      data.push(random3());
    }
  }
  return data;
}

// node_modules/mathjs/lib/esm/function/probability/random.js
var name271 = "random";
var dependencies272 = ["typed", "config", "?on"];
var createRandom = /* @__PURE__ */ factory(name271, dependencies272, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    on
  } = _ref;
  var rng2 = createRng(config5.randomSeed);
  if (on) {
    on("config", function(curr, prev) {
      if (curr.randomSeed !== prev.randomSeed) {
        rng2 = createRng(curr.randomSeed);
      }
    });
  }
  return typed3(name271, {
    "": () => _random(0, 1),
    number: (max3) => _random(0, max3),
    "number, number": (min3, max3) => _random(min3, max3),
    "Array | Matrix": (size2) => _randomMatrix(size2, 0, 1),
    "Array | Matrix, number": (size2, max3) => _randomMatrix(size2, 0, max3),
    "Array | Matrix, number, number": (size2, min3, max3) => _randomMatrix(size2, min3, max3)
  });
  function _randomMatrix(size2, min3, max3) {
    var res = randomMatrix(size2.valueOf(), () => _random(min3, max3));
    return isMatrix(size2) ? size2.create(res) : res;
  }
  function _random(min3, max3) {
    return min3 + rng2() * (max3 - min3);
  }
});

// node_modules/mathjs/lib/esm/function/probability/randomInt.js
var name272 = "randomInt";
var dependencies273 = ["typed", "config", "?on"];
var createRandomInt = /* @__PURE__ */ factory(name272, dependencies273, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    on
  } = _ref;
  var rng2 = createRng(config5.randomSeed);
  if (on) {
    on("config", function(curr, prev) {
      if (curr.randomSeed !== prev.randomSeed) {
        rng2 = createRng(curr.randomSeed);
      }
    });
  }
  return typed3(name272, {
    "": () => _randomInt(0, 1),
    number: (max3) => _randomInt(0, max3),
    "number, number": (min3, max3) => _randomInt(min3, max3),
    "Array | Matrix": (size2) => _randomIntMatrix(size2, 0, 1),
    "Array | Matrix, number": (size2, max3) => _randomIntMatrix(size2, 0, max3),
    "Array | Matrix, number, number": (size2, min3, max3) => _randomIntMatrix(size2, min3, max3)
  });
  function _randomIntMatrix(size2, min3, max3) {
    var res = randomMatrix(size2.valueOf(), () => _randomInt(min3, max3));
    return isMatrix(size2) ? size2.create(res) : res;
  }
  function _randomInt(min3, max3) {
    return Math.floor(min3 + rng2() * (max3 - min3));
  }
});

// node_modules/mathjs/lib/esm/function/combinatorics/stirlingS2.js
var name273 = "stirlingS2";
var dependencies274 = ["typed", "addScalar", "subtractScalar", "multiplyScalar", "divideScalar", "pow", "factorial", "combinations", "isNegative", "isInteger", "number", "?bignumber", "larger"];
var createStirlingS2 = /* @__PURE__ */ factory(name273, dependencies274, (_ref) => {
  var {
    typed: typed3,
    addScalar: addScalar2,
    subtractScalar: subtractScalar2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    pow: pow3,
    factorial: factorial2,
    combinations: combinations2,
    isNegative: isNegative2,
    isInteger: isInteger3,
    number: number2,
    bignumber: bignumber2,
    larger: larger2
  } = _ref;
  var smallCache = [];
  var bigCache = [];
  return typed3(name273, {
    "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n, k) {
      if (!isInteger3(n) || isNegative2(n) || !isInteger3(k) || isNegative2(k)) {
        throw new TypeError("Non-negative integer value expected in function stirlingS2");
      } else if (larger2(k, n)) {
        throw new TypeError("k must be less than or equal to n in function stirlingS2");
      }
      var big = !(isNumber(n) && isNumber(k));
      var cache2 = big ? bigCache : smallCache;
      var make = big ? bignumber2 : number2;
      var nn = number2(n);
      var nk = number2(k);
      if (cache2[nn] && cache2[nn].length > nk) {
        return cache2[nn][nk];
      }
      for (var m = 0; m <= nn; ++m) {
        if (!cache2[m]) {
          cache2[m] = [m === 0 ? make(1) : make(0)];
        }
        if (m === 0)
          continue;
        var row2 = cache2[m];
        var prev = cache2[m - 1];
        for (var i2 = row2.length; i2 <= m && i2 <= nk; ++i2) {
          if (i2 === m) {
            row2[i2] = 1;
          } else {
            row2[i2] = addScalar2(multiplyScalar2(make(i2), prev[i2]), prev[i2 - 1]);
          }
        }
      }
      return cache2[nn][nk];
    }
  });
});

// node_modules/mathjs/lib/esm/function/combinatorics/bellNumbers.js
var name274 = "bellNumbers";
var dependencies275 = ["typed", "addScalar", "isNegative", "isInteger", "stirlingS2"];
var createBellNumbers = /* @__PURE__ */ factory(name274, dependencies275, (_ref) => {
  var {
    typed: typed3,
    addScalar: addScalar2,
    isNegative: isNegative2,
    isInteger: isInteger3,
    stirlingS2: stirlingS22
  } = _ref;
  return typed3(name274, {
    "number | BigNumber": function numberBigNumber(n) {
      if (!isInteger3(n) || isNegative2(n)) {
        throw new TypeError("Non-negative integer value expected in function bellNumbers");
      }
      var result = 0;
      for (var i2 = 0; i2 <= n; i2++) {
        result = addScalar2(result, stirlingS22(n, i2));
      }
      return result;
    }
  });
});

// node_modules/mathjs/lib/esm/function/combinatorics/catalan.js
var name275 = "catalan";
var dependencies276 = ["typed", "addScalar", "divideScalar", "multiplyScalar", "combinations", "isNegative", "isInteger"];
var createCatalan = /* @__PURE__ */ factory(name275, dependencies276, (_ref) => {
  var {
    typed: typed3,
    addScalar: addScalar2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    combinations: combinations2,
    isNegative: isNegative2,
    isInteger: isInteger3
  } = _ref;
  return typed3(name275, {
    "number | BigNumber": function numberBigNumber(n) {
      if (!isInteger3(n) || isNegative2(n)) {
        throw new TypeError("Non-negative integer value expected in function catalan");
      }
      return divideScalar2(combinations2(multiplyScalar2(n, 2), n), addScalar2(n, 1));
    }
  });
});

// node_modules/mathjs/lib/esm/function/combinatorics/composition.js
var name276 = "composition";
var dependencies277 = ["typed", "addScalar", "combinations", "isNegative", "isPositive", "isInteger", "larger"];
var createComposition = /* @__PURE__ */ factory(name276, dependencies277, (_ref) => {
  var {
    typed: typed3,
    addScalar: addScalar2,
    combinations: combinations2,
    isPositive: isPositive2,
    isNegative: isNegative2,
    isInteger: isInteger3,
    larger: larger2
  } = _ref;
  return typed3(name276, {
    "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n, k) {
      if (!isInteger3(n) || !isPositive2(n) || !isInteger3(k) || !isPositive2(k)) {
        throw new TypeError("Positive integer value expected in function composition");
      } else if (larger2(k, n)) {
        throw new TypeError("k must be less than or equal to n in function composition");
      }
      return combinations2(addScalar2(n, -1), addScalar2(k, -1));
    }
  });
});

// node_modules/mathjs/lib/esm/function/algebra/leafCount.js
var name277 = "leafCount";
var dependencies278 = ["parse", "typed"];
var createLeafCount = /* @__PURE__ */ factory(name277, dependencies278, (_ref) => {
  var {
    parse: parse4,
    typed: typed3
  } = _ref;
  function countLeaves(node) {
    var count2 = 0;
    node.forEach((n) => {
      count2 += countLeaves(n);
    });
    return count2 || 1;
  }
  return typed3(name277, {
    Node: function Node2(expr) {
      return countLeaves(expr);
    }
  });
});

// node_modules/mathjs/lib/esm/function/algebra/simplify/wildcards.js
function isNumericNode(x) {
  return isConstantNode(x) || isOperatorNode(x) && x.isUnary() && isConstantNode(x.args[0]);
}
function isConstantExpression(x) {
  if (isConstantNode(x)) {
    return true;
  }
  if ((isFunctionNode(x) || isOperatorNode(x)) && x.args.every(isConstantExpression)) {
    return true;
  }
  if (isParenthesisNode(x) && isConstantExpression(x.content)) {
    return true;
  }
  return false;
}

// node_modules/mathjs/lib/esm/function/algebra/simplify/util.js
function ownKeys3(e3, r) {
  var t = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e3);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e3, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread3(e3) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys3(Object(t), true).forEach(function(r2) {
      _defineProperty(e3, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t)) : ownKeys3(Object(t)).forEach(function(r2) {
      Object.defineProperty(e3, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e3;
}
var name278 = "simplifyUtil";
var dependencies279 = ["FunctionNode", "OperatorNode", "SymbolNode"];
var createUtil = /* @__PURE__ */ factory(name278, dependencies279, (_ref) => {
  var {
    FunctionNode: FunctionNode2,
    OperatorNode: OperatorNode2,
    SymbolNode: SymbolNode2
  } = _ref;
  var T = true;
  var F = false;
  var defaultName = "defaultF";
  var defaultContext = {
    /*      */
    add: {
      trivial: T,
      total: T,
      commutative: T,
      associative: T
    },
    /**/
    unaryPlus: {
      trivial: T,
      total: T,
      commutative: T,
      associative: T
    },
    /* */
    subtract: {
      trivial: F,
      total: T,
      commutative: F,
      associative: F
    },
    /* */
    multiply: {
      trivial: T,
      total: T,
      commutative: T,
      associative: T
    },
    /*   */
    divide: {
      trivial: F,
      total: T,
      commutative: F,
      associative: F
    },
    /*    */
    paren: {
      trivial: T,
      total: T,
      commutative: T,
      associative: F
    },
    /* */
    defaultF: {
      trivial: F,
      total: T,
      commutative: F,
      associative: F
    }
  };
  var realContext = {
    divide: {
      total: F
    },
    log: {
      total: F
    }
  };
  var positiveContext = {
    subtract: {
      total: F
    },
    abs: {
      trivial: T
    },
    log: {
      total: T
    }
  };
  function hasProperty(nodeOrName, property) {
    var context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultContext;
    var name314 = defaultName;
    if (typeof nodeOrName === "string") {
      name314 = nodeOrName;
    } else if (isOperatorNode(nodeOrName)) {
      name314 = nodeOrName.fn.toString();
    } else if (isFunctionNode(nodeOrName)) {
      name314 = nodeOrName.name;
    } else if (isParenthesisNode(nodeOrName)) {
      name314 = "paren";
    }
    if (hasOwnProperty(context, name314)) {
      var properties2 = context[name314];
      if (hasOwnProperty(properties2, property)) {
        return properties2[property];
      }
      if (hasOwnProperty(defaultContext, name314)) {
        return defaultContext[name314][property];
      }
    }
    if (hasOwnProperty(context, defaultName)) {
      var _properties = context[defaultName];
      if (hasOwnProperty(_properties, property)) {
        return _properties[property];
      }
      return defaultContext[defaultName][property];
    }
    if (hasOwnProperty(defaultContext, name314)) {
      var _properties2 = defaultContext[name314];
      if (hasOwnProperty(_properties2, property)) {
        return _properties2[property];
      }
    }
    return defaultContext[defaultName][property];
  }
  function isCommutative(node) {
    var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultContext;
    return hasProperty(node, "commutative", context);
  }
  function isAssociative(node) {
    var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultContext;
    return hasProperty(node, "associative", context);
  }
  function mergeContext(primary, secondary) {
    var merged = _objectSpread3({}, primary);
    for (var prop in secondary) {
      if (hasOwnProperty(primary, prop)) {
        merged[prop] = _objectSpread3(_objectSpread3({}, secondary[prop]), primary[prop]);
      } else {
        merged[prop] = secondary[prop];
      }
    }
    return merged;
  }
  function flatten3(node, context) {
    if (!node.args || node.args.length === 0) {
      return node;
    }
    node.args = allChildren(node, context);
    for (var i2 = 0; i2 < node.args.length; i2++) {
      flatten3(node.args[i2], context);
    }
  }
  function allChildren(node, context) {
    var op;
    var children = [];
    var findChildren = function findChildren2(node2) {
      for (var i2 = 0; i2 < node2.args.length; i2++) {
        var child = node2.args[i2];
        if (isOperatorNode(child) && op === child.op) {
          findChildren2(child);
        } else {
          children.push(child);
        }
      }
    };
    if (isAssociative(node, context)) {
      op = node.op;
      findChildren(node);
      return children;
    } else {
      return node.args;
    }
  }
  function unflattenr(node, context) {
    if (!node.args || node.args.length === 0) {
      return;
    }
    var makeNode = createMakeNodeFunction(node);
    var l = node.args.length;
    for (var i2 = 0; i2 < l; i2++) {
      unflattenr(node.args[i2], context);
    }
    if (l > 2 && isAssociative(node, context)) {
      var curnode = node.args.pop();
      while (node.args.length > 0) {
        curnode = makeNode([node.args.pop(), curnode]);
      }
      node.args = curnode.args;
    }
  }
  function unflattenl(node, context) {
    if (!node.args || node.args.length === 0) {
      return;
    }
    var makeNode = createMakeNodeFunction(node);
    var l = node.args.length;
    for (var i2 = 0; i2 < l; i2++) {
      unflattenl(node.args[i2], context);
    }
    if (l > 2 && isAssociative(node, context)) {
      var curnode = node.args.shift();
      while (node.args.length > 0) {
        curnode = makeNode([curnode, node.args.shift()]);
      }
      node.args = curnode.args;
    }
  }
  function createMakeNodeFunction(node) {
    if (isOperatorNode(node)) {
      return function(args) {
        try {
          return new OperatorNode2(node.op, node.fn, args, node.implicit);
        } catch (err) {
          console.error(err);
          return [];
        }
      };
    } else {
      return function(args) {
        return new FunctionNode2(new SymbolNode2(node.name), args);
      };
    }
  }
  return {
    createMakeNodeFunction,
    hasProperty,
    isCommutative,
    isAssociative,
    mergeContext,
    flatten: flatten3,
    allChildren,
    unflattenr,
    unflattenl,
    defaultContext,
    realContext,
    positiveContext
  };
});

// node_modules/mathjs/lib/esm/function/algebra/simplify.js
var name279 = "simplify";
var dependencies280 = ["config", "typed", "parse", "add", "subtract", "multiply", "divide", "pow", "isZero", "equal", "resolve", "simplifyConstant", "simplifyCore", "?fraction", "?bignumber", "mathWithTransform", "matrix", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
var createSimplify = /* @__PURE__ */ factory(name279, dependencies280, (_ref) => {
  var {
    config: config5,
    typed: typed3,
    parse: parse4,
    add: add3,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide3,
    pow: pow3,
    isZero: isZero2,
    equal: equal2,
    resolve: resolve2,
    simplifyConstant: simplifyConstant2,
    simplifyCore: simplifyCore2,
    fraction: fraction2,
    bignumber: bignumber2,
    mathWithTransform: mathWithTransform2,
    matrix: matrix2,
    AccessorNode: AccessorNode2,
    ArrayNode: ArrayNode2,
    ConstantNode: ConstantNode2,
    FunctionNode: FunctionNode2,
    IndexNode: IndexNode2,
    ObjectNode: ObjectNode2,
    OperatorNode: OperatorNode2,
    ParenthesisNode: ParenthesisNode2,
    SymbolNode: SymbolNode2
  } = _ref;
  var {
    hasProperty,
    isCommutative,
    isAssociative,
    mergeContext,
    flatten: flatten3,
    unflattenr,
    unflattenl,
    createMakeNodeFunction,
    defaultContext,
    realContext,
    positiveContext
  } = createUtil({
    FunctionNode: FunctionNode2,
    OperatorNode: OperatorNode2,
    SymbolNode: SymbolNode2
  });
  typed3.addConversion({
    from: "Object",
    to: "Map",
    convert: createMap
  });
  var simplify2 = typed3("simplify", {
    Node: _simplify,
    "Node, Map": (expr, scope) => _simplify(expr, false, scope),
    "Node, Map, Object": (expr, scope, options2) => _simplify(expr, false, scope, options2),
    "Node, Array": _simplify,
    "Node, Array, Map": _simplify,
    "Node, Array, Map, Object": _simplify
  });
  typed3.removeConversion({
    from: "Object",
    to: "Map",
    convert: createMap
  });
  simplify2.defaultContext = defaultContext;
  simplify2.realContext = realContext;
  simplify2.positiveContext = positiveContext;
  function removeParens(node) {
    return node.transform(function(node2, path, parent) {
      return isParenthesisNode(node2) ? removeParens(node2.content) : node2;
    });
  }
  var SUPPORTED_CONSTANTS = {
    true: true,
    false: true,
    e: true,
    i: true,
    Infinity: true,
    LN2: true,
    LN10: true,
    LOG2E: true,
    LOG10E: true,
    NaN: true,
    phi: true,
    pi: true,
    SQRT1_2: true,
    SQRT2: true,
    tau: true
    // null: false,
    // undefined: false,
    // version: false,
  };
  simplify2.rules = [
    simplifyCore2,
    // { l: 'n+0', r: 'n' },     // simplifyCore
    // { l: 'n^0', r: '1' },     // simplifyCore
    // { l: '0*n', r: '0' },     // simplifyCore
    // { l: 'n/n', r: '1'},      // simplifyCore
    // { l: 'n^1', r: 'n' },     // simplifyCore
    // { l: '+n1', r:'n1' },     // simplifyCore
    // { l: 'n--n1', r:'n+n1' }, // simplifyCore
    {
      l: "log(e)",
      r: "1"
    },
    // temporary rules
    // Note initially we tend constants to the right because like-term
    // collection prefers the left, and we would rather collect nonconstants
    {
      s: "n-n1 -> n+-n1",
      // temporarily replace 'subtract' so we can further flatten the 'add' operator
      assuming: {
        subtract: {
          total: true
        }
      }
    },
    {
      s: "n-n -> 0",
      // partial alternative when we can't always subtract
      assuming: {
        subtract: {
          total: false
        }
      }
    },
    {
      s: "-(cl*v) -> v * (-cl)",
      // make non-constant terms positive
      assuming: {
        multiply: {
          commutative: true
        },
        subtract: {
          total: true
        }
      }
    },
    {
      s: "-(cl*v) -> (-cl) * v",
      // non-commutative version, part 1
      assuming: {
        multiply: {
          commutative: false
        },
        subtract: {
          total: true
        }
      }
    },
    {
      s: "-(v*cl) -> v * (-cl)",
      // non-commutative version, part 2
      assuming: {
        multiply: {
          commutative: false
        },
        subtract: {
          total: true
        }
      }
    },
    {
      l: "-(n1/n2)",
      r: "-n1/n2"
    },
    {
      l: "-v",
      r: "v * (-1)"
    },
    // finish making non-constant terms positive
    {
      l: "(n1 + n2)*(-1)",
      r: "n1*(-1) + n2*(-1)",
      repeat: true
    },
    // expand negations to achieve as much sign cancellation as possible
    {
      l: "n/n1^n2",
      r: "n*n1^-n2"
    },
    // temporarily replace 'divide' so we can further flatten the 'multiply' operator
    {
      l: "n/n1",
      r: "n*n1^-1"
    },
    {
      s: "(n1*n2)^n3 -> n1^n3 * n2^n3",
      assuming: {
        multiply: {
          commutative: true
        }
      }
    },
    {
      s: "(n1*n2)^(-1) -> n2^(-1) * n1^(-1)",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    // expand nested exponentiation
    {
      s: "(n ^ n1) ^ n2 -> n ^ (n1 * n2)",
      assuming: {
        divide: {
          total: true
        }
      }
      // 1/(1/n) = n needs 1/n to exist
    },
    // collect like factors; into a sum, only do this for nonconstants
    {
      l: " vd   * ( vd   * n1 + n2)",
      r: "vd^2       * n1 +  vd   * n2"
    },
    {
      s: " vd   * (vd^n4 * n1 + n2)   ->  vd^(1+n4)  * n1 +  vd   * n2",
      assuming: {
        divide: {
          total: true
        }
      }
      // v*1/v = v^(1+-1) needs 1/v
    },
    {
      s: "vd^n3 * ( vd   * n1 + n2)   ->  vd^(n3+1)  * n1 + vd^n3 * n2",
      assuming: {
        divide: {
          total: true
        }
      }
    },
    {
      s: "vd^n3 * (vd^n4 * n1 + n2)   ->  vd^(n3+n4) * n1 + vd^n3 * n2",
      assuming: {
        divide: {
          total: true
        }
      }
    },
    {
      l: "n*n",
      r: "n^2"
    },
    {
      s: "n * n^n1 -> n^(n1+1)",
      assuming: {
        divide: {
          total: true
        }
      }
      // n*1/n = n^(-1+1) needs 1/n
    },
    {
      s: "n^n1 * n^n2 -> n^(n1+n2)",
      assuming: {
        divide: {
          total: true
        }
      }
      // ditto for n^2*1/n^2
    },
    // Unfortunately, to deal with more complicated cancellations, it
    // becomes necessary to simplify constants twice per pass. It's not
    // terribly expensive compared to matching rules, so this should not
    // pose a performance problem.
    simplifyConstant2,
    // First: before collecting like terms
    // collect like terms
    {
      s: "n+n -> 2*n",
      assuming: {
        add: {
          total: true
        }
      }
      // 2 = 1 + 1 needs to exist
    },
    {
      l: "n+-n",
      r: "0"
    },
    {
      l: "vd*n + vd",
      r: "vd*(n+1)"
    },
    // NOTE: leftmost position is special:
    {
      l: "n3*n1 + n3*n2",
      r: "n3*(n1+n2)"
    },
    // All sub-monomials tried there.
    {
      l: "n3^(-n4)*n1 +   n3  * n2",
      r: "n3^(-n4)*(n1 + n3^(n4+1) *n2)"
    },
    {
      l: "n3^(-n4)*n1 + n3^n5 * n2",
      r: "n3^(-n4)*(n1 + n3^(n4+n5)*n2)"
    },
    // noncommutative additional cases (term collection & factoring)
    {
      s: "n*vd + vd -> (n+1)*vd",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "vd + n*vd -> (1+n)*vd",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "n1*n3 + n2*n3 -> (n1+n2)*n3",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "n^n1 * n -> n^(n1+1)",
      assuming: {
        divide: {
          total: true
        },
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "n1*n3^(-n4) + n2 * n3    -> (n1 + n2*n3^(n4 +  1))*n3^(-n4)",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "n1*n3^(-n4) + n2 * n3^n5 -> (n1 + n2*n3^(n4 + n5))*n3^(-n4)",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      l: "n*cd + cd",
      r: "(n+1)*cd"
    },
    {
      s: "cd*n + cd -> cd*(n+1)",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "cd + cd*n -> cd*(1+n)",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    simplifyConstant2,
    // Second: before returning expressions to "standard form"
    // make factors positive (and undo 'make non-constant terms positive')
    {
      s: "(-n)*n1 -> -(n*n1)",
      assuming: {
        subtract: {
          total: true
        }
      }
    },
    {
      s: "n1*(-n) -> -(n1*n)",
      // in case * non-commutative
      assuming: {
        subtract: {
          total: true
        },
        multiply: {
          commutative: false
        }
      }
    },
    // final ordering of constants
    {
      s: "ce+ve -> ve+ce",
      assuming: {
        add: {
          commutative: true
        }
      },
      imposeContext: {
        add: {
          commutative: false
        }
      }
    },
    {
      s: "vd*cd -> cd*vd",
      assuming: {
        multiply: {
          commutative: true
        }
      },
      imposeContext: {
        multiply: {
          commutative: false
        }
      }
    },
    // undo temporary rules
    // { l: '(-1) * n', r: '-n' }, // #811 added test which proved this is redundant
    {
      l: "n+-n1",
      r: "n-n1"
    },
    // undo replace 'subtract'
    {
      l: "n+-(n1)",
      r: "n-(n1)"
    },
    {
      s: "n*(n1^-1) -> n/n1",
      // undo replace 'divide'; for * commutative
      assuming: {
        multiply: {
          commutative: true
        }
      }
      // o.w. / not conventional
    },
    {
      s: "n*n1^-n2 -> n/n1^n2",
      assuming: {
        multiply: {
          commutative: true
        }
      }
      // o.w. / not conventional
    },
    {
      s: "n^-1 -> 1/n",
      assuming: {
        multiply: {
          commutative: true
        }
      }
      // o.w. / not conventional
    },
    {
      l: "n^1",
      r: "n"
    },
    // can be produced by power cancellation
    {
      s: "n*(n1/n2) -> (n*n1)/n2",
      // '*' before '/'
      assuming: {
        multiply: {
          associative: true
        }
      }
    },
    {
      s: "n-(n1+n2) -> n-n1-n2",
      // '-' before '+'
      assuming: {
        addition: {
          associative: true,
          commutative: true
        }
      }
    },
    // { l: '(n1/n2)/n3', r: 'n1/(n2*n3)' },
    // { l: '(n*n1)/(n*n2)', r: 'n1/n2' },
    // simplifyConstant can leave an extra factor of 1, which can always
    // be eliminated, since the identity always commutes
    {
      l: "1*n",
      r: "n",
      imposeContext: {
        multiply: {
          commutative: true
        }
      }
    },
    {
      s: "n1/(n2/n3) -> (n1*n3)/n2",
      assuming: {
        multiply: {
          associative: true
        }
      }
    },
    {
      l: "n1/(-n2)",
      r: "-n1/n2"
    }
  ];
  function _canonicalizeRule(ruleObject, context) {
    var newRule = {};
    if (ruleObject.s) {
      var lr = ruleObject.s.split("->");
      if (lr.length === 2) {
        newRule.l = lr[0];
        newRule.r = lr[1];
      } else {
        throw SyntaxError("Could not parse rule: " + ruleObject.s);
      }
    } else {
      newRule.l = ruleObject.l;
      newRule.r = ruleObject.r;
    }
    newRule.l = removeParens(parse4(newRule.l));
    newRule.r = removeParens(parse4(newRule.r));
    for (var prop of ["imposeContext", "repeat", "assuming"]) {
      if (prop in ruleObject) {
        newRule[prop] = ruleObject[prop];
      }
    }
    if (ruleObject.evaluate) {
      newRule.evaluate = parse4(ruleObject.evaluate);
    }
    if (isAssociative(newRule.l, context)) {
      var nonCommutative = !isCommutative(newRule.l, context);
      var leftExpandsym;
      if (nonCommutative)
        leftExpandsym = _getExpandPlaceholderSymbol();
      var makeNode = createMakeNodeFunction(newRule.l);
      var expandsym = _getExpandPlaceholderSymbol();
      newRule.expanded = {};
      newRule.expanded.l = makeNode([newRule.l, expandsym]);
      flatten3(newRule.expanded.l, context);
      unflattenr(newRule.expanded.l, context);
      newRule.expanded.r = makeNode([newRule.r, expandsym]);
      if (nonCommutative) {
        newRule.expandedNC1 = {};
        newRule.expandedNC1.l = makeNode([leftExpandsym, newRule.l]);
        newRule.expandedNC1.r = makeNode([leftExpandsym, newRule.r]);
        newRule.expandedNC2 = {};
        newRule.expandedNC2.l = makeNode([leftExpandsym, newRule.expanded.l]);
        newRule.expandedNC2.r = makeNode([leftExpandsym, newRule.expanded.r]);
      }
    }
    return newRule;
  }
  function _buildRules(rules, context) {
    var ruleSet = [];
    for (var i2 = 0; i2 < rules.length; i2++) {
      var rule = rules[i2];
      var newRule = void 0;
      var ruleType = typeof rule;
      switch (ruleType) {
        case "string":
          rule = {
            s: rule
          };
        case "object":
          newRule = _canonicalizeRule(rule, context);
          break;
        case "function":
          newRule = rule;
          break;
        default:
          throw TypeError("Unsupported type of rule: " + ruleType);
      }
      ruleSet.push(newRule);
    }
    return ruleSet;
  }
  var _lastsym = 0;
  function _getExpandPlaceholderSymbol() {
    return new SymbolNode2("_p" + _lastsym++);
  }
  function _simplify(expr, rules) {
    var scope = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : createEmptyMap();
    var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    var debug = options2.consoleDebug;
    rules = _buildRules(rules || simplify2.rules, options2.context);
    var res = resolve2(expr, scope);
    res = removeParens(res);
    var visited = {};
    var str = res.toString({
      parenthesis: "all"
    });
    while (!visited[str]) {
      visited[str] = true;
      _lastsym = 0;
      var laststr = str;
      if (debug)
        console.log("Working on: ", str);
      for (var i2 = 0; i2 < rules.length; i2++) {
        var rulestr = "";
        if (typeof rules[i2] === "function") {
          res = rules[i2](res, options2);
          if (debug)
            rulestr = rules[i2].name;
        } else {
          flatten3(res, options2.context);
          res = applyRule(res, rules[i2], options2.context);
          if (debug) {
            rulestr = "".concat(rules[i2].l.toString(), " -> ").concat(rules[i2].r.toString());
          }
        }
        if (debug) {
          var newstr = res.toString({
            parenthesis: "all"
          });
          if (newstr !== laststr) {
            console.log("Applying", rulestr, "produced", newstr);
            laststr = newstr;
          }
        }
        unflattenl(res, options2.context);
      }
      str = res.toString({
        parenthesis: "all"
      });
    }
    return res;
  }
  function mapRule(nodes, rule, context) {
    var resNodes = nodes;
    if (nodes) {
      for (var i2 = 0; i2 < nodes.length; ++i2) {
        var newNode = applyRule(nodes[i2], rule, context);
        if (newNode !== nodes[i2]) {
          if (resNodes === nodes) {
            resNodes = nodes.slice();
          }
          resNodes[i2] = newNode;
        }
      }
    }
    return resNodes;
  }
  function applyRule(node, rule, context) {
    if (rule.assuming) {
      for (var symbol in rule.assuming) {
        for (var property in rule.assuming[symbol]) {
          if (hasProperty(symbol, property, context) !== rule.assuming[symbol][property]) {
            return node;
          }
        }
      }
    }
    var mergedContext = mergeContext(rule.imposeContext, context);
    var res = node;
    if (res instanceof OperatorNode2 || res instanceof FunctionNode2) {
      var newArgs = mapRule(res.args, rule, context);
      if (newArgs !== res.args) {
        res = res.clone();
        res.args = newArgs;
      }
    } else if (res instanceof ParenthesisNode2) {
      if (res.content) {
        var newContent = applyRule(res.content, rule, context);
        if (newContent !== res.content) {
          res = new ParenthesisNode2(newContent);
        }
      }
    } else if (res instanceof ArrayNode2) {
      var newItems = mapRule(res.items, rule, context);
      if (newItems !== res.items) {
        res = new ArrayNode2(newItems);
      }
    } else if (res instanceof AccessorNode2) {
      var newObj = res.object;
      if (res.object) {
        newObj = applyRule(res.object, rule, context);
      }
      var newIndex = res.index;
      if (res.index) {
        newIndex = applyRule(res.index, rule, context);
      }
      if (newObj !== res.object || newIndex !== res.index) {
        res = new AccessorNode2(newObj, newIndex);
      }
    } else if (res instanceof IndexNode2) {
      var newDims = mapRule(res.dimensions, rule, context);
      if (newDims !== res.dimensions) {
        res = new IndexNode2(newDims);
      }
    } else if (res instanceof ObjectNode2) {
      var changed = false;
      var newProps = {};
      for (var prop in res.properties) {
        newProps[prop] = applyRule(res.properties[prop], rule, context);
        if (newProps[prop] !== res.properties[prop]) {
          changed = true;
        }
      }
      if (changed) {
        res = new ObjectNode2(newProps);
      }
    }
    var repl = rule.r;
    var matches = _ruleMatch(rule.l, res, mergedContext)[0];
    if (!matches && rule.expanded) {
      repl = rule.expanded.r;
      matches = _ruleMatch(rule.expanded.l, res, mergedContext)[0];
    }
    if (!matches && rule.expandedNC1) {
      repl = rule.expandedNC1.r;
      matches = _ruleMatch(rule.expandedNC1.l, res, mergedContext)[0];
      if (!matches) {
        repl = rule.expandedNC2.r;
        matches = _ruleMatch(rule.expandedNC2.l, res, mergedContext)[0];
      }
    }
    if (matches) {
      var implicit = res.implicit;
      res = repl.clone();
      if (implicit && "implicit" in repl) {
        res.implicit = true;
      }
      res = res.transform(function(node2) {
        if (node2.isSymbolNode && hasOwnProperty(matches.placeholders, node2.name)) {
          return matches.placeholders[node2.name].clone();
        } else {
          return node2;
        }
      });
    }
    if (rule.repeat && res !== node) {
      res = applyRule(res, rule, context);
    }
    return res;
  }
  function getSplits(node, context) {
    var res = [];
    var right, rightArgs;
    var makeNode = createMakeNodeFunction(node);
    if (isCommutative(node, context)) {
      for (var i2 = 0; i2 < node.args.length; i2++) {
        rightArgs = node.args.slice(0);
        rightArgs.splice(i2, 1);
        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
        res.push(makeNode([node.args[i2], right]));
      }
    } else {
      for (var _i = 1; _i < node.args.length; _i++) {
        var left = node.args[0];
        if (_i > 1) {
          left = makeNode(node.args.slice(0, _i));
        }
        rightArgs = node.args.slice(_i);
        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
        res.push(makeNode([left, right]));
      }
    }
    return res;
  }
  function mergeMatch(match1, match2) {
    var res = {
      placeholders: {}
    };
    if (!match1.placeholders && !match2.placeholders) {
      return res;
    } else if (!match1.placeholders) {
      return match2;
    } else if (!match2.placeholders) {
      return match1;
    }
    for (var key in match1.placeholders) {
      if (hasOwnProperty(match1.placeholders, key)) {
        res.placeholders[key] = match1.placeholders[key];
        if (hasOwnProperty(match2.placeholders, key)) {
          if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {
            return null;
          }
        }
      }
    }
    for (var _key in match2.placeholders) {
      if (hasOwnProperty(match2.placeholders, _key)) {
        res.placeholders[_key] = match2.placeholders[_key];
      }
    }
    return res;
  }
  function combineChildMatches(list1, list2) {
    var res = [];
    if (list1.length === 0 || list2.length === 0) {
      return res;
    }
    var merged;
    for (var i1 = 0; i1 < list1.length; i1++) {
      for (var i2 = 0; i2 < list2.length; i2++) {
        merged = mergeMatch(list1[i1], list2[i2]);
        if (merged) {
          res.push(merged);
        }
      }
    }
    return res;
  }
  function mergeChildMatches(childMatches) {
    if (childMatches.length === 0) {
      return childMatches;
    }
    var sets = childMatches.reduce(combineChildMatches);
    var uniqueSets = [];
    var unique = {};
    for (var i2 = 0; i2 < sets.length; i2++) {
      var s = JSON.stringify(sets[i2]);
      if (!unique[s]) {
        unique[s] = true;
        uniqueSets.push(sets[i2]);
      }
    }
    return uniqueSets;
  }
  function _ruleMatch(rule, node, context, isSplit) {
    var res = [{
      placeholders: {}
    }];
    if (rule instanceof OperatorNode2 && node instanceof OperatorNode2 || rule instanceof FunctionNode2 && node instanceof FunctionNode2) {
      if (rule instanceof OperatorNode2) {
        if (rule.op !== node.op || rule.fn !== node.fn) {
          return [];
        }
      } else if (rule instanceof FunctionNode2) {
        if (rule.name !== node.name) {
          return [];
        }
      }
      if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node, context) && node.args.length === rule.args.length || isSplit) {
        var childMatches = [];
        for (var i2 = 0; i2 < rule.args.length; i2++) {
          var childMatch = _ruleMatch(rule.args[i2], node.args[i2], context);
          if (childMatch.length === 0) {
            break;
          }
          childMatches.push(childMatch);
        }
        if (childMatches.length !== rule.args.length) {
          if (!isCommutative(node, context) || // exact match in order needed
          rule.args.length === 1) {
            return [];
          }
          if (rule.args.length > 2) {
            throw new Error("permuting >2 commutative non-associative rule arguments not yet implemented");
          }
          var leftMatch = _ruleMatch(rule.args[0], node.args[1], context);
          if (leftMatch.length === 0) {
            return [];
          }
          var rightMatch = _ruleMatch(rule.args[1], node.args[0], context);
          if (rightMatch.length === 0) {
            return [];
          }
          childMatches = [leftMatch, rightMatch];
        }
        res = mergeChildMatches(childMatches);
      } else if (node.args.length >= 2 && rule.args.length === 2) {
        var splits = getSplits(node, context);
        var splitMatches = [];
        for (var _i2 = 0; _i2 < splits.length; _i2++) {
          var matchSet = _ruleMatch(rule, splits[_i2], context, true);
          splitMatches = splitMatches.concat(matchSet);
        }
        return splitMatches;
      } else if (rule.args.length > 2) {
        throw Error("Unexpected non-binary associative function: " + rule.toString());
      } else {
        return [];
      }
    } else if (rule instanceof SymbolNode2) {
      if (rule.name.length === 0) {
        throw new Error("Symbol in rule has 0 length...!?");
      }
      if (SUPPORTED_CONSTANTS[rule.name]) {
        if (rule.name !== node.name) {
          return [];
        }
      } else {
        switch (rule.name[1] >= "a" && rule.name[1] <= "z" ? rule.name.substring(0, 2) : rule.name[0]) {
          case "n":
          case "_p":
            res[0].placeholders[rule.name] = node;
            break;
          case "c":
          case "cl":
            if (isConstantNode(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          case "v":
            if (!isConstantNode(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          case "vl":
            if (isSymbolNode(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          case "cd":
            if (isNumericNode(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          case "vd":
            if (!isNumericNode(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          case "ce":
            if (isConstantExpression(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          case "ve":
            if (!isConstantExpression(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          default:
            throw new Error("Invalid symbol in rule: " + rule.name);
        }
      }
    } else if (rule instanceof ConstantNode2) {
      if (!equal2(rule.value, node.value)) {
        return [];
      }
    } else {
      return [];
    }
    return res;
  }
  function _exactMatch(p, q) {
    if (p instanceof ConstantNode2 && q instanceof ConstantNode2) {
      if (!equal2(p.value, q.value)) {
        return false;
      }
    } else if (p instanceof SymbolNode2 && q instanceof SymbolNode2) {
      if (p.name !== q.name) {
        return false;
      }
    } else if (p instanceof OperatorNode2 && q instanceof OperatorNode2 || p instanceof FunctionNode2 && q instanceof FunctionNode2) {
      if (p instanceof OperatorNode2) {
        if (p.op !== q.op || p.fn !== q.fn) {
          return false;
        }
      } else if (p instanceof FunctionNode2) {
        if (p.name !== q.name) {
          return false;
        }
      }
      if (p.args.length !== q.args.length) {
        return false;
      }
      for (var i2 = 0; i2 < p.args.length; i2++) {
        if (!_exactMatch(p.args[i2], q.args[i2])) {
          return false;
        }
      }
    } else {
      return false;
    }
    return true;
  }
  return simplify2;
});

// node_modules/mathjs/lib/esm/function/algebra/simplifyConstant.js
var name280 = "simplifyConstant";
var dependencies281 = ["typed", "config", "mathWithTransform", "matrix", "?fraction", "?bignumber", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "SymbolNode"];
var createSimplifyConstant = /* @__PURE__ */ factory(name280, dependencies281, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    mathWithTransform: mathWithTransform2,
    matrix: matrix2,
    fraction: fraction2,
    bignumber: bignumber2,
    AccessorNode: AccessorNode2,
    ArrayNode: ArrayNode2,
    ConstantNode: ConstantNode2,
    FunctionNode: FunctionNode2,
    IndexNode: IndexNode2,
    ObjectNode: ObjectNode2,
    OperatorNode: OperatorNode2,
    SymbolNode: SymbolNode2
  } = _ref;
  var {
    isCommutative,
    isAssociative,
    allChildren,
    createMakeNodeFunction
  } = createUtil({
    FunctionNode: FunctionNode2,
    OperatorNode: OperatorNode2,
    SymbolNode: SymbolNode2
  });
  var simplifyConstant2 = typed3("simplifyConstant", {
    Node: (node) => _ensureNode(foldFraction(node, {})),
    "Node, Object": function NodeObject(expr, options2) {
      return _ensureNode(foldFraction(expr, options2));
    }
  });
  function _removeFractions(thing) {
    if (isFraction(thing)) {
      return thing.valueOf();
    }
    if (thing instanceof Array) {
      return thing.map(_removeFractions);
    }
    if (isMatrix(thing)) {
      return matrix2(_removeFractions(thing.valueOf()));
    }
    return thing;
  }
  function _eval(fnname, args, options2) {
    try {
      return mathWithTransform2[fnname].apply(null, args);
    } catch (ignore) {
      args = args.map(_removeFractions);
      return _toNumber(mathWithTransform2[fnname].apply(null, args), options2);
    }
  }
  var _toNode = typed3({
    Fraction: _fractionToNode,
    number: function number2(n) {
      if (n < 0) {
        return unaryMinusNode(new ConstantNode2(-n));
      }
      return new ConstantNode2(n);
    },
    BigNumber: function BigNumber2(n) {
      if (n < 0) {
        return unaryMinusNode(new ConstantNode2(-n));
      }
      return new ConstantNode2(n);
    },
    bigint: function bigint2(n) {
      if (n < 0n) {
        return unaryMinusNode(new ConstantNode2(-n));
      }
      return new ConstantNode2(n);
    },
    Complex: function Complex3(s) {
      throw new Error("Cannot convert Complex number to Node");
    },
    string: function string2(s) {
      return new ConstantNode2(s);
    },
    Matrix: function Matrix2(m) {
      return new ArrayNode2(m.valueOf().map((e3) => _toNode(e3)));
    }
  });
  function _ensureNode(thing) {
    if (isNode(thing)) {
      return thing;
    }
    return _toNode(thing);
  }
  function _exactFraction(n, options2) {
    var exactFractions = options2 && options2.exactFractions !== false;
    if (exactFractions && isFinite(n) && fraction2) {
      var f = fraction2(n);
      var fractionsLimit = options2 && typeof options2.fractionsLimit === "number" ? options2.fractionsLimit : Infinity;
      if (f.valueOf() === n && f.n < fractionsLimit && f.d < fractionsLimit) {
        return f;
      }
    }
    return n;
  }
  var _toNumber = typed3({
    "string, Object": function stringObject(s, options2) {
      var numericType = safeNumberType(s, config5);
      if (numericType === "BigNumber") {
        if (bignumber2 === void 0) {
          noBignumber();
        }
        return bignumber2(s);
      } else if (numericType === "bigint") {
        return BigInt(s);
      } else if (numericType === "Fraction") {
        if (fraction2 === void 0) {
          noFraction();
        }
        return fraction2(s);
      } else {
        var n = parseFloat(s);
        return _exactFraction(n, options2);
      }
    },
    "Fraction, Object": function FractionObject(s, options2) {
      return s;
    },
    // we don't need options here
    "BigNumber, Object": function BigNumberObject(s, options2) {
      return s;
    },
    // we don't need options here
    "number, Object": function numberObject(s, options2) {
      return _exactFraction(s, options2);
    },
    "bigint, Object": function bigintObject(s, options2) {
      return s;
    },
    "Complex, Object": function ComplexObject(s, options2) {
      if (s.im !== 0) {
        return s;
      }
      return _exactFraction(s.re, options2);
    },
    "Matrix, Object": function MatrixObject(s, options2) {
      return matrix2(_exactFraction(s.valueOf()));
    },
    "Array, Object": function ArrayObject(s, options2) {
      return s.map(_exactFraction);
    }
  });
  function unaryMinusNode(n) {
    return new OperatorNode2("-", "unaryMinus", [n]);
  }
  function _fractionToNode(f) {
    var n;
    var vn = f.s * f.n;
    if (vn < 0) {
      n = new OperatorNode2("-", "unaryMinus", [new ConstantNode2(-vn)]);
    } else {
      n = new ConstantNode2(vn);
    }
    if (f.d === 1) {
      return n;
    }
    return new OperatorNode2("/", "divide", [n, new ConstantNode2(f.d)]);
  }
  function _foldAccessor(obj, index2, options2) {
    if (!isIndexNode(index2)) {
      return new AccessorNode2(_ensureNode(obj), _ensureNode(index2));
    }
    if (isArrayNode(obj) || isMatrix(obj)) {
      var remainingDims = Array.from(index2.dimensions);
      while (remainingDims.length > 0) {
        if (isConstantNode(remainingDims[0]) && typeof remainingDims[0].value !== "string") {
          var first = _toNumber(remainingDims.shift().value, options2);
          if (isArrayNode(obj)) {
            obj = obj.items[first - 1];
          } else {
            obj = obj.valueOf()[first - 1];
            if (obj instanceof Array) {
              obj = matrix2(obj);
            }
          }
        } else if (remainingDims.length > 1 && isConstantNode(remainingDims[1]) && typeof remainingDims[1].value !== "string") {
          var second = _toNumber(remainingDims[1].value, options2);
          var tryItems = [];
          var fromItems = isArrayNode(obj) ? obj.items : obj.valueOf();
          for (var item of fromItems) {
            if (isArrayNode(item)) {
              tryItems.push(item.items[second - 1]);
            } else if (isMatrix(obj)) {
              tryItems.push(item[second - 1]);
            } else {
              break;
            }
          }
          if (tryItems.length === fromItems.length) {
            if (isArrayNode(obj)) {
              obj = new ArrayNode2(tryItems);
            } else {
              obj = matrix2(tryItems);
            }
            remainingDims.splice(1, 1);
          } else {
            break;
          }
        } else {
          break;
        }
      }
      if (remainingDims.length === index2.dimensions.length) {
        return new AccessorNode2(_ensureNode(obj), index2);
      }
      if (remainingDims.length > 0) {
        index2 = new IndexNode2(remainingDims);
        return new AccessorNode2(_ensureNode(obj), index2);
      }
      return obj;
    }
    if (isObjectNode(obj) && index2.dimensions.length === 1 && isConstantNode(index2.dimensions[0])) {
      var key = index2.dimensions[0].value;
      if (key in obj.properties) {
        return obj.properties[key];
      }
      return new ConstantNode2();
    }
    return new AccessorNode2(_ensureNode(obj), index2);
  }
  function foldOp(fn, args, makeNode, options2) {
    var first = args.shift();
    var reduction = args.reduce((sofar, next) => {
      if (!isNode(next)) {
        var last = sofar.pop();
        if (isNode(last)) {
          return [last, next];
        }
        try {
          sofar.push(_eval(fn, [last, next], options2));
          return sofar;
        } catch (ignoreandcontinue) {
          sofar.push(last);
        }
      }
      sofar.push(_ensureNode(sofar.pop()));
      var newtree = sofar.length === 1 ? sofar[0] : makeNode(sofar);
      return [makeNode([newtree, _ensureNode(next)])];
    }, [first]);
    if (reduction.length === 1) {
      return reduction[0];
    }
    return makeNode([reduction[0], _toNode(reduction[1])]);
  }
  function foldFraction(node, options2) {
    switch (node.type) {
      case "SymbolNode":
        return node;
      case "ConstantNode":
        switch (typeof node.value) {
          case "number":
            return _toNumber(node.value, options2);
          case "bigint":
            return _toNumber(node.value, options2);
          case "string":
            return node.value;
          default:
            if (!isNaN(node.value))
              return _toNumber(node.value, options2);
        }
        return node;
      case "FunctionNode":
        if (mathWithTransform2[node.name] && mathWithTransform2[node.name].rawArgs) {
          return node;
        }
        {
          var operatorFunctions = ["add", "multiply"];
          if (!operatorFunctions.includes(node.name)) {
            var args = node.args.map((arg2) => foldFraction(arg2, options2));
            if (!args.some(isNode)) {
              try {
                return _eval(node.name, args, options2);
              } catch (ignoreandcontinue) {
              }
            }
            if (node.name === "size" && args.length === 1 && isArrayNode(args[0])) {
              var sz = [];
              var section = args[0];
              while (isArrayNode(section)) {
                sz.push(section.items.length);
                section = section.items[0];
              }
              return matrix2(sz);
            }
            return new FunctionNode2(node.name, args.map(_ensureNode));
          } else {
          }
        }
      case "OperatorNode": {
        var fn = node.fn.toString();
        var _args;
        var res;
        var makeNode = createMakeNodeFunction(node);
        if (isOperatorNode(node) && node.isUnary()) {
          _args = [foldFraction(node.args[0], options2)];
          if (!isNode(_args[0])) {
            res = _eval(fn, _args, options2);
          } else {
            res = makeNode(_args);
          }
        } else if (isAssociative(node, options2.context)) {
          _args = allChildren(node, options2.context);
          _args = _args.map((arg2) => foldFraction(arg2, options2));
          if (isCommutative(fn, options2.context)) {
            var consts = [];
            var vars = [];
            for (var i2 = 0; i2 < _args.length; i2++) {
              if (!isNode(_args[i2])) {
                consts.push(_args[i2]);
              } else {
                vars.push(_args[i2]);
              }
            }
            if (consts.length > 1) {
              res = foldOp(fn, consts, makeNode, options2);
              vars.unshift(res);
              res = foldOp(fn, vars, makeNode, options2);
            } else {
              res = foldOp(fn, _args, makeNode, options2);
            }
          } else {
            res = foldOp(fn, _args, makeNode, options2);
          }
        } else {
          _args = node.args.map((arg2) => foldFraction(arg2, options2));
          res = foldOp(fn, _args, makeNode, options2);
        }
        return res;
      }
      case "ParenthesisNode":
        return foldFraction(node.content, options2);
      case "AccessorNode":
        return _foldAccessor(foldFraction(node.object, options2), foldFraction(node.index, options2), options2);
      case "ArrayNode": {
        var foldItems = node.items.map((item) => foldFraction(item, options2));
        if (foldItems.some(isNode)) {
          return new ArrayNode2(foldItems.map(_ensureNode));
        }
        return matrix2(foldItems);
      }
      case "IndexNode": {
        return new IndexNode2(node.dimensions.map((n) => simplifyConstant2(n, options2)));
      }
      case "ObjectNode": {
        var foldProps = {};
        for (var prop in node.properties) {
          foldProps[prop] = simplifyConstant2(node.properties[prop], options2);
        }
        return new ObjectNode2(foldProps);
      }
      case "AssignmentNode":
      case "BlockNode":
      case "FunctionAssignmentNode":
      case "RangeNode":
      case "ConditionalNode":
      default:
        throw new Error("Unimplemented node type in simplifyConstant: ".concat(node.type));
    }
  }
  return simplifyConstant2;
});

// node_modules/mathjs/lib/esm/function/algebra/simplifyCore.js
var name281 = "simplifyCore";
var dependencies282 = ["typed", "parse", "equal", "isZero", "add", "subtract", "multiply", "divide", "pow", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
var createSimplifyCore = /* @__PURE__ */ factory(name281, dependencies282, (_ref) => {
  var {
    typed: typed3,
    parse: parse4,
    equal: equal2,
    isZero: isZero2,
    add: add3,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide3,
    pow: pow3,
    AccessorNode: AccessorNode2,
    ArrayNode: ArrayNode2,
    ConstantNode: ConstantNode2,
    FunctionNode: FunctionNode2,
    IndexNode: IndexNode2,
    ObjectNode: ObjectNode2,
    OperatorNode: OperatorNode2,
    ParenthesisNode: ParenthesisNode2,
    SymbolNode: SymbolNode2
  } = _ref;
  var node0 = new ConstantNode2(0);
  var node1 = new ConstantNode2(1);
  var nodeT = new ConstantNode2(true);
  var nodeF = new ConstantNode2(false);
  function isAlwaysBoolean(node) {
    return isOperatorNode(node) && ["and", "not", "or"].includes(node.op);
  }
  var {
    hasProperty,
    isCommutative
  } = createUtil({
    FunctionNode: FunctionNode2,
    OperatorNode: OperatorNode2,
    SymbolNode: SymbolNode2
  });
  function _simplifyCore(nodeToSimplify) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var context = options2 ? options2.context : void 0;
    if (hasProperty(nodeToSimplify, "trivial", context)) {
      if (isFunctionNode(nodeToSimplify) && nodeToSimplify.args.length === 1) {
        return _simplifyCore(nodeToSimplify.args[0], options2);
      }
      var simpChild = false;
      var childCount = 0;
      nodeToSimplify.forEach((c) => {
        ++childCount;
        if (childCount === 1) {
          simpChild = _simplifyCore(c, options2);
        }
      });
      if (childCount === 1) {
        return simpChild;
      }
    }
    var node = nodeToSimplify;
    if (isFunctionNode(node)) {
      var op = getOperator(node.name);
      if (op) {
        if (node.args.length > 2 && hasProperty(node, "associative", context)) {
          while (node.args.length > 2) {
            var last = node.args.pop();
            var seclast = node.args.pop();
            node.args.push(new OperatorNode2(op, node.name, [last, seclast]));
          }
        }
        node = new OperatorNode2(op, node.name, node.args);
      } else {
        return new FunctionNode2(_simplifyCore(node.fn), node.args.map((n) => _simplifyCore(n, options2)));
      }
    }
    if (isOperatorNode(node) && node.isUnary()) {
      var a0 = _simplifyCore(node.args[0], options2);
      if (node.op === "~") {
        if (isOperatorNode(a0) && a0.isUnary() && a0.op === "~") {
          return a0.args[0];
        }
      }
      if (node.op === "not") {
        if (isOperatorNode(a0) && a0.isUnary() && a0.op === "not") {
          if (isAlwaysBoolean(a0.args[0])) {
            return a0.args[0];
          }
        }
      }
      var finish = true;
      if (node.op === "-") {
        if (isOperatorNode(a0)) {
          if (a0.isBinary() && a0.fn === "subtract") {
            node = new OperatorNode2("-", "subtract", [a0.args[1], a0.args[0]]);
            finish = false;
          }
          if (a0.isUnary() && a0.op === "-") {
            return a0.args[0];
          }
        }
      }
      if (finish)
        return new OperatorNode2(node.op, node.fn, [a0]);
    }
    if (isOperatorNode(node) && node.isBinary()) {
      var _a = _simplifyCore(node.args[0], options2);
      var a1 = _simplifyCore(node.args[1], options2);
      if (node.op === "+") {
        if (isConstantNode(_a) && isZero2(_a.value)) {
          return a1;
        }
        if (isConstantNode(a1) && isZero2(a1.value)) {
          return _a;
        }
        if (isOperatorNode(a1) && a1.isUnary() && a1.op === "-") {
          a1 = a1.args[0];
          node = new OperatorNode2("-", "subtract", [_a, a1]);
        }
      }
      if (node.op === "-") {
        if (isOperatorNode(a1) && a1.isUnary() && a1.op === "-") {
          return _simplifyCore(new OperatorNode2("+", "add", [_a, a1.args[0]]), options2);
        }
        if (isConstantNode(_a) && isZero2(_a.value)) {
          return _simplifyCore(new OperatorNode2("-", "unaryMinus", [a1]));
        }
        if (isConstantNode(a1) && isZero2(a1.value)) {
          return _a;
        }
        return new OperatorNode2(node.op, node.fn, [_a, a1]);
      }
      if (node.op === "*") {
        if (isConstantNode(_a)) {
          if (isZero2(_a.value)) {
            return node0;
          } else if (equal2(_a.value, 1)) {
            return a1;
          }
        }
        if (isConstantNode(a1)) {
          if (isZero2(a1.value)) {
            return node0;
          } else if (equal2(a1.value, 1)) {
            return _a;
          }
          if (isCommutative(node, context)) {
            return new OperatorNode2(node.op, node.fn, [a1, _a], node.implicit);
          }
        }
        return new OperatorNode2(node.op, node.fn, [_a, a1], node.implicit);
      }
      if (node.op === "/") {
        if (isConstantNode(_a) && isZero2(_a.value)) {
          return node0;
        }
        if (isConstantNode(a1) && equal2(a1.value, 1)) {
          return _a;
        }
        return new OperatorNode2(node.op, node.fn, [_a, a1]);
      }
      if (node.op === "^") {
        if (isConstantNode(a1)) {
          if (isZero2(a1.value)) {
            return node1;
          } else if (equal2(a1.value, 1)) {
            return _a;
          }
        }
      }
      if (node.op === "and") {
        if (isConstantNode(_a)) {
          if (_a.value) {
            if (isAlwaysBoolean(a1))
              return a1;
            if (isConstantNode(a1)) {
              return a1.value ? nodeT : nodeF;
            }
          } else {
            return nodeF;
          }
        }
        if (isConstantNode(a1)) {
          if (a1.value) {
            if (isAlwaysBoolean(_a))
              return _a;
          } else {
            return nodeF;
          }
        }
      }
      if (node.op === "or") {
        if (isConstantNode(_a)) {
          if (_a.value) {
            return nodeT;
          } else {
            if (isAlwaysBoolean(a1))
              return a1;
          }
        }
        if (isConstantNode(a1)) {
          if (a1.value) {
            return nodeT;
          } else {
            if (isAlwaysBoolean(_a))
              return _a;
          }
        }
      }
      return new OperatorNode2(node.op, node.fn, [_a, a1]);
    }
    if (isOperatorNode(node)) {
      return new OperatorNode2(node.op, node.fn, node.args.map((a) => _simplifyCore(a, options2)));
    }
    if (isArrayNode(node)) {
      return new ArrayNode2(node.items.map((n) => _simplifyCore(n, options2)));
    }
    if (isAccessorNode(node)) {
      return new AccessorNode2(_simplifyCore(node.object, options2), _simplifyCore(node.index, options2));
    }
    if (isIndexNode(node)) {
      return new IndexNode2(node.dimensions.map((n) => _simplifyCore(n, options2)));
    }
    if (isObjectNode(node)) {
      var newProps = {};
      for (var prop in node.properties) {
        newProps[prop] = _simplifyCore(node.properties[prop], options2);
      }
      return new ObjectNode2(newProps);
    }
    return node;
  }
  return typed3(name281, {
    Node: _simplifyCore,
    "Node,Object": _simplifyCore
  });
});

// node_modules/mathjs/lib/esm/function/algebra/resolve.js
var name282 = "resolve";
var dependencies283 = ["typed", "parse", "ConstantNode", "FunctionNode", "OperatorNode", "ParenthesisNode"];
var createResolve = /* @__PURE__ */ factory(name282, dependencies283, (_ref) => {
  var {
    typed: typed3,
    parse: parse4,
    ConstantNode: ConstantNode2,
    FunctionNode: FunctionNode2,
    OperatorNode: OperatorNode2,
    ParenthesisNode: ParenthesisNode2
  } = _ref;
  function _resolve(node, scope) {
    var within = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : /* @__PURE__ */ new Set();
    if (!scope) {
      return node;
    }
    if (isSymbolNode(node)) {
      if (within.has(node.name)) {
        var variables = Array.from(within).join(", ");
        throw new ReferenceError("recursive loop of variable definitions among {".concat(variables, "}"));
      }
      var value = scope.get(node.name);
      if (isNode(value)) {
        var nextWithin = new Set(within);
        nextWithin.add(node.name);
        return _resolve(value, scope, nextWithin);
      } else if (typeof value === "number") {
        return parse4(String(value));
      } else if (value !== void 0) {
        return new ConstantNode2(value);
      } else {
        return node;
      }
    } else if (isOperatorNode(node)) {
      var args = node.args.map(function(arg2) {
        return _resolve(arg2, scope, within);
      });
      return new OperatorNode2(node.op, node.fn, args, node.implicit);
    } else if (isParenthesisNode(node)) {
      return new ParenthesisNode2(_resolve(node.content, scope, within));
    } else if (isFunctionNode(node)) {
      var _args = node.args.map(function(arg2) {
        return _resolve(arg2, scope, within);
      });
      return new FunctionNode2(node.name, _args);
    }
    return node.map((child) => _resolve(child, scope, within));
  }
  return typed3("resolve", {
    Node: _resolve,
    "Node, Map | null | undefined": _resolve,
    "Node, Object": (n, scope) => _resolve(n, createMap(scope)),
    // For arrays and matrices, we map `self` rather than `_resolve`
    // because resolve is fairly expensive anyway, and this way
    // we get nice error messages if one entry in the array has wrong type.
    "Array | Matrix": typed3.referToSelf((self2) => (A) => A.map((n) => self2(n))),
    "Array | Matrix, null | undefined": typed3.referToSelf((self2) => (A) => A.map((n) => self2(n))),
    "Array, Object": typed3.referTo("Array,Map", (selfAM) => (A, scope) => selfAM(A, createMap(scope))),
    "Matrix, Object": typed3.referTo("Matrix,Map", (selfMM) => (A, scope) => selfMM(A, createMap(scope))),
    "Array | Matrix, Map": typed3.referToSelf((self2) => (A, scope) => A.map((n) => self2(n, scope)))
  });
});

// node_modules/mathjs/lib/esm/function/algebra/symbolicEqual.js
var name283 = "symbolicEqual";
var dependencies284 = ["parse", "simplify", "typed", "OperatorNode"];
var createSymbolicEqual = /* @__PURE__ */ factory(name283, dependencies284, (_ref) => {
  var {
    parse: parse4,
    simplify: simplify2,
    typed: typed3,
    OperatorNode: OperatorNode2
  } = _ref;
  function _symbolicEqual(e1, e22) {
    var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var diff2 = new OperatorNode2("-", "subtract", [e1, e22]);
    var simplified = simplify2(diff2, {}, options2);
    return isConstantNode(simplified) && !simplified.value;
  }
  return typed3(name283, {
    "Node, Node": _symbolicEqual,
    "Node, Node, Object": _symbolicEqual
  });
});

// node_modules/mathjs/lib/esm/function/algebra/derivative.js
var name284 = "derivative";
var dependencies285 = ["typed", "config", "parse", "simplify", "equal", "isZero", "numeric", "ConstantNode", "FunctionNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
var createDerivative = /* @__PURE__ */ factory(name284, dependencies285, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    parse: parse4,
    simplify: simplify2,
    equal: equal2,
    isZero: isZero2,
    numeric: numeric3,
    ConstantNode: ConstantNode2,
    FunctionNode: FunctionNode2,
    OperatorNode: OperatorNode2,
    ParenthesisNode: ParenthesisNode2,
    SymbolNode: SymbolNode2
  } = _ref;
  function plainDerivative(expr, variable) {
    var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      simplify: true
    };
    var constNodes = {};
    constTag(constNodes, expr, variable.name);
    var res = _derivative(expr, constNodes);
    return options2.simplify ? simplify2(res) : res;
  }
  typed3.addConversion({
    from: "identifier",
    to: "SymbolNode",
    convert: parse4
  });
  var derivative2 = typed3(name284, {
    "Node, SymbolNode": plainDerivative,
    "Node, SymbolNode, Object": plainDerivative
    /* TODO: implement and test syntax with order of derivatives -> implement as an option {order: number}
    'Node, SymbolNode, ConstantNode': function (expr, variable, {order}) {
      let res = expr
      for (let i = 0; i < order; i++) {
        let constNodes = {}
        constTag(constNodes, expr, variable.name)
        res = _derivative(res, constNodes)
      }
      return res
    }
    */
  });
  typed3.removeConversion({
    from: "identifier",
    to: "SymbolNode",
    convert: parse4
  });
  derivative2._simplify = true;
  derivative2.toTex = function(deriv) {
    return _derivTex.apply(null, deriv.args);
  };
  var _derivTex = typed3("_derivTex", {
    "Node, SymbolNode": function NodeSymbolNode(expr, x) {
      if (isConstantNode(expr) && typeOf(expr.value) === "string") {
        return _derivTex(parse4(expr.value).toString(), x.toString(), 1);
      } else {
        return _derivTex(expr.toTex(), x.toString(), 1);
      }
    },
    "Node, ConstantNode": function NodeConstantNode(expr, x) {
      if (typeOf(x.value) === "string") {
        return _derivTex(expr, parse4(x.value));
      } else {
        throw new Error("The second parameter to 'derivative' is a non-string constant");
      }
    },
    "Node, SymbolNode, ConstantNode": function NodeSymbolNodeConstantNode(expr, x, order) {
      return _derivTex(expr.toString(), x.name, order.value);
    },
    "string, string, number": function stringStringNumber(expr, x, order) {
      var d;
      if (order === 1) {
        d = "{d\\over d" + x + "}";
      } else {
        d = "{d^{" + order + "}\\over d" + x + "^{" + order + "}}";
      }
      return d + "\\left[".concat(expr, "\\right]");
    }
  });
  var constTag = typed3("constTag", {
    "Object, ConstantNode, string": function ObjectConstantNodeString(constNodes, node) {
      constNodes[node] = true;
      return true;
    },
    "Object, SymbolNode, string": function ObjectSymbolNodeString(constNodes, node, varName) {
      if (node.name !== varName) {
        constNodes[node] = true;
        return true;
      }
      return false;
    },
    "Object, ParenthesisNode, string": function ObjectParenthesisNodeString(constNodes, node, varName) {
      return constTag(constNodes, node.content, varName);
    },
    "Object, FunctionAssignmentNode, string": function ObjectFunctionAssignmentNodeString(constNodes, node, varName) {
      if (!node.params.includes(varName)) {
        constNodes[node] = true;
        return true;
      }
      return constTag(constNodes, node.expr, varName);
    },
    "Object, FunctionNode | OperatorNode, string": function ObjectFunctionNodeOperatorNodeString(constNodes, node, varName) {
      if (node.args.length > 0) {
        var isConst = constTag(constNodes, node.args[0], varName);
        for (var i2 = 1; i2 < node.args.length; ++i2) {
          isConst = constTag(constNodes, node.args[i2], varName) && isConst;
        }
        if (isConst) {
          constNodes[node] = true;
          return true;
        }
      }
      return false;
    }
  });
  var _derivative = typed3("_derivative", {
    "ConstantNode, Object": function ConstantNodeObject(node) {
      return createConstantNode2(0);
    },
    "SymbolNode, Object": function SymbolNodeObject(node, constNodes) {
      if (constNodes[node] !== void 0) {
        return createConstantNode2(0);
      }
      return createConstantNode2(1);
    },
    "ParenthesisNode, Object": function ParenthesisNodeObject(node, constNodes) {
      return new ParenthesisNode2(_derivative(node.content, constNodes));
    },
    "FunctionAssignmentNode, Object": function FunctionAssignmentNodeObject(node, constNodes) {
      if (constNodes[node] !== void 0) {
        return createConstantNode2(0);
      }
      return _derivative(node.expr, constNodes);
    },
    "FunctionNode, Object": function FunctionNodeObject(node, constNodes) {
      if (constNodes[node] !== void 0) {
        return createConstantNode2(0);
      }
      var arg0 = node.args[0];
      var arg1;
      var div2 = false;
      var negative = false;
      var funcDerivative;
      switch (node.name) {
        case "cbrt":
          div2 = true;
          funcDerivative = new OperatorNode2("*", "multiply", [createConstantNode2(3), new OperatorNode2("^", "pow", [arg0, new OperatorNode2("/", "divide", [createConstantNode2(2), createConstantNode2(3)])])]);
          break;
        case "sqrt":
        case "nthRoot":
          if (node.args.length === 1) {
            div2 = true;
            funcDerivative = new OperatorNode2("*", "multiply", [createConstantNode2(2), new FunctionNode2("sqrt", [arg0])]);
          } else if (node.args.length === 2) {
            arg1 = new OperatorNode2("/", "divide", [createConstantNode2(1), node.args[1]]);
            constNodes[arg1] = constNodes[node.args[1]];
            return _derivative(new OperatorNode2("^", "pow", [arg0, arg1]), constNodes);
          }
          break;
        case "log10":
          arg1 = createConstantNode2(10);
        case "log":
          if (!arg1 && node.args.length === 1) {
            funcDerivative = arg0.clone();
            div2 = true;
          } else if (node.args.length === 1 && arg1 || node.args.length === 2 && constNodes[node.args[1]] !== void 0) {
            funcDerivative = new OperatorNode2("*", "multiply", [arg0.clone(), new FunctionNode2("log", [arg1 || node.args[1]])]);
            div2 = true;
          } else if (node.args.length === 2) {
            return _derivative(new OperatorNode2("/", "divide", [new FunctionNode2("log", [arg0]), new FunctionNode2("log", [node.args[1]])]), constNodes);
          }
          break;
        case "pow":
          if (node.args.length === 2) {
            constNodes[arg1] = constNodes[node.args[1]];
            return _derivative(new OperatorNode2("^", "pow", [arg0, node.args[1]]), constNodes);
          }
          break;
        case "exp":
          funcDerivative = new FunctionNode2("exp", [arg0.clone()]);
          break;
        case "sin":
          funcDerivative = new FunctionNode2("cos", [arg0.clone()]);
          break;
        case "cos":
          funcDerivative = new OperatorNode2("-", "unaryMinus", [new FunctionNode2("sin", [arg0.clone()])]);
          break;
        case "tan":
          funcDerivative = new OperatorNode2("^", "pow", [new FunctionNode2("sec", [arg0.clone()]), createConstantNode2(2)]);
          break;
        case "sec":
          funcDerivative = new OperatorNode2("*", "multiply", [node, new FunctionNode2("tan", [arg0.clone()])]);
          break;
        case "csc":
          negative = true;
          funcDerivative = new OperatorNode2("*", "multiply", [node, new FunctionNode2("cot", [arg0.clone()])]);
          break;
        case "cot":
          negative = true;
          funcDerivative = new OperatorNode2("^", "pow", [new FunctionNode2("csc", [arg0.clone()]), createConstantNode2(2)]);
          break;
        case "asin":
          div2 = true;
          funcDerivative = new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [createConstantNode2(1), new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)])])]);
          break;
        case "acos":
          div2 = true;
          negative = true;
          funcDerivative = new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [createConstantNode2(1), new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)])])]);
          break;
        case "atan":
          div2 = true;
          funcDerivative = new OperatorNode2("+", "add", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)]);
          break;
        case "asec":
          div2 = true;
          funcDerivative = new OperatorNode2("*", "multiply", [new FunctionNode2("abs", [arg0.clone()]), new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
          break;
        case "acsc":
          div2 = true;
          negative = true;
          funcDerivative = new OperatorNode2("*", "multiply", [new FunctionNode2("abs", [arg0.clone()]), new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
          break;
        case "acot":
          div2 = true;
          negative = true;
          funcDerivative = new OperatorNode2("+", "add", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)]);
          break;
        case "sinh":
          funcDerivative = new FunctionNode2("cosh", [arg0.clone()]);
          break;
        case "cosh":
          funcDerivative = new FunctionNode2("sinh", [arg0.clone()]);
          break;
        case "tanh":
          funcDerivative = new OperatorNode2("^", "pow", [new FunctionNode2("sech", [arg0.clone()]), createConstantNode2(2)]);
          break;
        case "sech":
          negative = true;
          funcDerivative = new OperatorNode2("*", "multiply", [node, new FunctionNode2("tanh", [arg0.clone()])]);
          break;
        case "csch":
          negative = true;
          funcDerivative = new OperatorNode2("*", "multiply", [node, new FunctionNode2("coth", [arg0.clone()])]);
          break;
        case "coth":
          negative = true;
          funcDerivative = new OperatorNode2("^", "pow", [new FunctionNode2("csch", [arg0.clone()]), createConstantNode2(2)]);
          break;
        case "asinh":
          div2 = true;
          funcDerivative = new FunctionNode2("sqrt", [new OperatorNode2("+", "add", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])]);
          break;
        case "acosh":
          div2 = true;
          funcDerivative = new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])]);
          break;
        case "atanh":
          div2 = true;
          funcDerivative = new OperatorNode2("-", "subtract", [createConstantNode2(1), new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)])]);
          break;
        case "asech":
          div2 = true;
          negative = true;
          funcDerivative = new OperatorNode2("*", "multiply", [arg0.clone(), new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [createConstantNode2(1), new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)])])])]);
          break;
        case "acsch":
          div2 = true;
          negative = true;
          funcDerivative = new OperatorNode2("*", "multiply", [new FunctionNode2("abs", [arg0.clone()]), new FunctionNode2("sqrt", [new OperatorNode2("+", "add", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
          break;
        case "acoth":
          div2 = true;
          negative = true;
          funcDerivative = new OperatorNode2("-", "subtract", [createConstantNode2(1), new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)])]);
          break;
        case "abs":
          funcDerivative = new OperatorNode2("/", "divide", [new FunctionNode2(new SymbolNode2("abs"), [arg0.clone()]), arg0.clone()]);
          break;
        case "gamma":
        default:
          throw new Error('Cannot process function "' + node.name + '" in derivative: the function is not supported, undefined, or the number of arguments passed to it are not supported');
      }
      var op, func;
      if (div2) {
        op = "/";
        func = "divide";
      } else {
        op = "*";
        func = "multiply";
      }
      var chainDerivative = _derivative(arg0, constNodes);
      if (negative) {
        chainDerivative = new OperatorNode2("-", "unaryMinus", [chainDerivative]);
      }
      return new OperatorNode2(op, func, [chainDerivative, funcDerivative]);
    },
    "OperatorNode, Object": function OperatorNodeObject(node, constNodes) {
      if (constNodes[node] !== void 0) {
        return createConstantNode2(0);
      }
      if (node.op === "+") {
        return new OperatorNode2(node.op, node.fn, node.args.map(function(arg2) {
          return _derivative(arg2, constNodes);
        }));
      }
      if (node.op === "-") {
        if (node.isUnary()) {
          return new OperatorNode2(node.op, node.fn, [_derivative(node.args[0], constNodes)]);
        }
        if (node.isBinary()) {
          return new OperatorNode2(node.op, node.fn, [_derivative(node.args[0], constNodes), _derivative(node.args[1], constNodes)]);
        }
      }
      if (node.op === "*") {
        var constantTerms = node.args.filter(function(arg2) {
          return constNodes[arg2] !== void 0;
        });
        if (constantTerms.length > 0) {
          var nonConstantTerms = node.args.filter(function(arg2) {
            return constNodes[arg2] === void 0;
          });
          var nonConstantNode = nonConstantTerms.length === 1 ? nonConstantTerms[0] : new OperatorNode2("*", "multiply", nonConstantTerms);
          var newArgs = constantTerms.concat(_derivative(nonConstantNode, constNodes));
          return new OperatorNode2("*", "multiply", newArgs);
        }
        return new OperatorNode2("+", "add", node.args.map(function(argOuter) {
          return new OperatorNode2("*", "multiply", node.args.map(function(argInner) {
            return argInner === argOuter ? _derivative(argInner, constNodes) : argInner.clone();
          }));
        }));
      }
      if (node.op === "/" && node.isBinary()) {
        var arg0 = node.args[0];
        var arg1 = node.args[1];
        if (constNodes[arg1] !== void 0) {
          return new OperatorNode2("/", "divide", [_derivative(arg0, constNodes), arg1]);
        }
        if (constNodes[arg0] !== void 0) {
          return new OperatorNode2("*", "multiply", [new OperatorNode2("-", "unaryMinus", [arg0]), new OperatorNode2("/", "divide", [_derivative(arg1, constNodes), new OperatorNode2("^", "pow", [arg1.clone(), createConstantNode2(2)])])]);
        }
        return new OperatorNode2("/", "divide", [new OperatorNode2("-", "subtract", [new OperatorNode2("*", "multiply", [_derivative(arg0, constNodes), arg1.clone()]), new OperatorNode2("*", "multiply", [arg0.clone(), _derivative(arg1, constNodes)])]), new OperatorNode2("^", "pow", [arg1.clone(), createConstantNode2(2)])]);
      }
      if (node.op === "^" && node.isBinary()) {
        var _arg = node.args[0];
        var _arg2 = node.args[1];
        if (constNodes[_arg] !== void 0) {
          if (isConstantNode(_arg) && (isZero2(_arg.value) || equal2(_arg.value, 1))) {
            return createConstantNode2(0);
          }
          return new OperatorNode2("*", "multiply", [node, new OperatorNode2("*", "multiply", [new FunctionNode2("log", [_arg.clone()]), _derivative(_arg2.clone(), constNodes)])]);
        }
        if (constNodes[_arg2] !== void 0) {
          if (isConstantNode(_arg2)) {
            if (isZero2(_arg2.value)) {
              return createConstantNode2(0);
            }
            if (equal2(_arg2.value, 1)) {
              return _derivative(_arg, constNodes);
            }
          }
          var powMinusOne = new OperatorNode2("^", "pow", [_arg.clone(), new OperatorNode2("-", "subtract", [_arg2, createConstantNode2(1)])]);
          return new OperatorNode2("*", "multiply", [_arg2.clone(), new OperatorNode2("*", "multiply", [_derivative(_arg, constNodes), powMinusOne])]);
        }
        return new OperatorNode2("*", "multiply", [new OperatorNode2("^", "pow", [_arg.clone(), _arg2.clone()]), new OperatorNode2("+", "add", [new OperatorNode2("*", "multiply", [_derivative(_arg, constNodes), new OperatorNode2("/", "divide", [_arg2.clone(), _arg.clone()])]), new OperatorNode2("*", "multiply", [_derivative(_arg2, constNodes), new FunctionNode2("log", [_arg.clone()])])])]);
      }
      throw new Error('Cannot process operator "' + node.op + '" in derivative: the operator is not supported, undefined, or the number of arguments passed to it are not supported');
    }
  });
  function createConstantNode2(value, valueType) {
    return new ConstantNode2(numeric3(value, valueType || safeNumberType(String(value), config5)));
  }
  return derivative2;
});

// node_modules/mathjs/lib/esm/function/algebra/rationalize.js
var name285 = "rationalize";
var dependencies286 = ["config", "typed", "equal", "isZero", "add", "subtract", "multiply", "divide", "pow", "parse", "simplifyConstant", "simplifyCore", "simplify", "?bignumber", "?fraction", "mathWithTransform", "matrix", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "SymbolNode", "ParenthesisNode"];
var createRationalize = /* @__PURE__ */ factory(name285, dependencies286, (_ref) => {
  var {
    config: config5,
    typed: typed3,
    equal: equal2,
    isZero: isZero2,
    add: add3,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide3,
    pow: pow3,
    parse: parse4,
    simplifyConstant: simplifyConstant2,
    simplifyCore: simplifyCore2,
    simplify: simplify2,
    fraction: fraction2,
    bignumber: bignumber2,
    mathWithTransform: mathWithTransform2,
    matrix: matrix2,
    AccessorNode: AccessorNode2,
    ArrayNode: ArrayNode2,
    ConstantNode: ConstantNode2,
    FunctionNode: FunctionNode2,
    IndexNode: IndexNode2,
    ObjectNode: ObjectNode2,
    OperatorNode: OperatorNode2,
    SymbolNode: SymbolNode2,
    ParenthesisNode: ParenthesisNode2
  } = _ref;
  function _rationalize(expr) {
    var scope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var detailed = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var setRules = rulesRationalize();
    var polyRet = polynomial(expr, scope, true, setRules.firstRules);
    var nVars = polyRet.variables.length;
    var noExactFractions = {
      exactFractions: false
    };
    var withExactFractions = {
      exactFractions: true
    };
    expr = polyRet.expression;
    if (nVars >= 1) {
      expr = expandPower(expr);
      var sBefore;
      var rules;
      var eDistrDiv = true;
      var redoInic = false;
      expr = simplify2(expr, setRules.firstRules, {}, noExactFractions);
      var s;
      while (true) {
        rules = eDistrDiv ? setRules.distrDivRules : setRules.sucDivRules;
        expr = simplify2(expr, rules, {}, withExactFractions);
        eDistrDiv = !eDistrDiv;
        s = expr.toString();
        if (s === sBefore) {
          break;
        }
        redoInic = true;
        sBefore = s;
      }
      if (redoInic) {
        expr = simplify2(expr, setRules.firstRulesAgain, {}, noExactFractions);
      }
      expr = simplify2(expr, setRules.finalRules, {}, noExactFractions);
    }
    var coefficients = [];
    var retRationalize = {};
    if (expr.type === "OperatorNode" && expr.isBinary() && expr.op === "/") {
      if (nVars === 1) {
        expr.args[0] = polyToCanonical(expr.args[0], coefficients);
        expr.args[1] = polyToCanonical(expr.args[1]);
      }
      if (detailed) {
        retRationalize.numerator = expr.args[0];
        retRationalize.denominator = expr.args[1];
      }
    } else {
      if (nVars === 1) {
        expr = polyToCanonical(expr, coefficients);
      }
      if (detailed) {
        retRationalize.numerator = expr;
        retRationalize.denominator = null;
      }
    }
    if (!detailed)
      return expr;
    retRationalize.coefficients = coefficients;
    retRationalize.variables = polyRet.variables;
    retRationalize.expression = expr;
    return retRationalize;
  }
  return typed3(name285, {
    Node: _rationalize,
    "Node, boolean": (expr, detailed) => _rationalize(expr, {}, detailed),
    "Node, Object": _rationalize,
    "Node, Object, boolean": _rationalize
  });
  function polynomial(expr, scope, extended, rules) {
    var variables = [];
    var node = simplify2(expr, rules, scope, {
      exactFractions: false
    });
    extended = !!extended;
    var oper = "+-*" + (extended ? "/" : "");
    recPoly(node);
    var retFunc = {};
    retFunc.expression = node;
    retFunc.variables = variables;
    return retFunc;
    function recPoly(node2) {
      var tp = node2.type;
      if (tp === "FunctionNode") {
        throw new Error("There is an unsolved function call");
      } else if (tp === "OperatorNode") {
        if (node2.op === "^") {
          if (node2.args[1].type !== "ConstantNode" || !isInteger(parseFloat(node2.args[1].value))) {
            throw new Error("There is a non-integer exponent");
          } else {
            recPoly(node2.args[0]);
          }
        } else {
          if (!oper.includes(node2.op)) {
            throw new Error("Operator " + node2.op + " invalid in polynomial expression");
          }
          for (var i2 = 0; i2 < node2.args.length; i2++) {
            recPoly(node2.args[i2]);
          }
        }
      } else if (tp === "SymbolNode") {
        var _name = node2.name;
        var pos = variables.indexOf(_name);
        if (pos === -1) {
          variables.push(_name);
        }
      } else if (tp === "ParenthesisNode") {
        recPoly(node2.content);
      } else if (tp !== "ConstantNode") {
        throw new Error("type " + tp + " is not allowed in polynomial expression");
      }
    }
  }
  function rulesRationalize() {
    var oldRules = [
      simplifyCore2,
      // sCore
      {
        l: "n+n",
        r: "2*n"
      },
      {
        l: "n+-n",
        r: "0"
      },
      simplifyConstant2,
      // sConstant
      {
        l: "n*(n1^-1)",
        r: "n/n1"
      },
      {
        l: "n*n1^-n2",
        r: "n/n1^n2"
      },
      {
        l: "n1^-1",
        r: "1/n1"
      },
      {
        l: "n*(n1/n2)",
        r: "(n*n1)/n2"
      },
      {
        l: "1*n",
        r: "n"
      }
    ];
    var rulesFirst = [
      {
        l: "(-n1)/(-n2)",
        r: "n1/n2"
      },
      // Unary division
      {
        l: "(-n1)*(-n2)",
        r: "n1*n2"
      },
      // Unary multiplication
      {
        l: "n1--n2",
        r: "n1+n2"
      },
      // '--' elimination
      {
        l: "n1-n2",
        r: "n1+(-n2)"
      },
      // Subtraction turn into add with un�ry minus
      {
        l: "(n1+n2)*n3",
        r: "(n1*n3 + n2*n3)"
      },
      // Distributive 1
      {
        l: "n1*(n2+n3)",
        r: "(n1*n2+n1*n3)"
      },
      // Distributive 2
      {
        l: "c1*n + c2*n",
        r: "(c1+c2)*n"
      },
      // Joining constants
      {
        l: "c1*n + n",
        r: "(c1+1)*n"
      },
      // Joining constants
      {
        l: "c1*n - c2*n",
        r: "(c1-c2)*n"
      },
      // Joining constants
      {
        l: "c1*n - n",
        r: "(c1-1)*n"
      },
      // Joining constants
      {
        l: "v/c",
        r: "(1/c)*v"
      },
      // variable/constant (new!)
      {
        l: "v/-c",
        r: "-(1/c)*v"
      },
      // variable/constant (new!)
      {
        l: "-v*-c",
        r: "c*v"
      },
      // Inversion constant and variable 1
      {
        l: "-v*c",
        r: "-c*v"
      },
      // Inversion constant and variable 2
      {
        l: "v*-c",
        r: "-c*v"
      },
      // Inversion constant and variable 3
      {
        l: "v*c",
        r: "c*v"
      },
      // Inversion constant and variable 4
      {
        l: "-(-n1*n2)",
        r: "(n1*n2)"
      },
      // Unary propagation
      {
        l: "-(n1*n2)",
        r: "(-n1*n2)"
      },
      // Unary propagation
      {
        l: "-(-n1+n2)",
        r: "(n1-n2)"
      },
      // Unary propagation
      {
        l: "-(n1+n2)",
        r: "(-n1-n2)"
      },
      // Unary propagation
      {
        l: "(n1^n2)^n3",
        r: "(n1^(n2*n3))"
      },
      // Power to Power
      {
        l: "-(-n1/n2)",
        r: "(n1/n2)"
      },
      // Division and Unary
      {
        l: "-(n1/n2)",
        r: "(-n1/n2)"
      }
    ];
    var rulesDistrDiv = [
      {
        l: "(n1/n2 + n3/n4)",
        r: "((n1*n4 + n3*n2)/(n2*n4))"
      },
      // Sum of fractions
      {
        l: "(n1/n2 + n3)",
        r: "((n1 + n3*n2)/n2)"
      },
      // Sum fraction with number 1
      {
        l: "(n1 + n2/n3)",
        r: "((n1*n3 + n2)/n3)"
      }
    ];
    var rulesSucDiv = [
      {
        l: "(n1/(n2/n3))",
        r: "((n1*n3)/n2)"
      },
      // Division simplification
      {
        l: "(n1/n2/n3)",
        r: "(n1/(n2*n3))"
      }
    ];
    var setRules = {};
    setRules.firstRules = oldRules.concat(rulesFirst, rulesSucDiv);
    setRules.distrDivRules = rulesDistrDiv;
    setRules.sucDivRules = rulesSucDiv;
    setRules.firstRulesAgain = oldRules.concat(rulesFirst);
    setRules.finalRules = [
      simplifyCore2,
      // simplify.rules[0]
      {
        l: "n*-n",
        r: "-n^2"
      },
      // Joining multiply with power 1
      {
        l: "n*n",
        r: "n^2"
      },
      // Joining multiply with power 2
      simplifyConstant2,
      // simplify.rules[14] old 3rd index in oldRules
      {
        l: "n*-n^n1",
        r: "-n^(n1+1)"
      },
      // Joining multiply with power 3
      {
        l: "n*n^n1",
        r: "n^(n1+1)"
      },
      // Joining multiply with power 4
      {
        l: "n^n1*-n^n2",
        r: "-n^(n1+n2)"
      },
      // Joining multiply with power 5
      {
        l: "n^n1*n^n2",
        r: "n^(n1+n2)"
      },
      // Joining multiply with power 6
      {
        l: "n^n1*-n",
        r: "-n^(n1+1)"
      },
      // Joining multiply with power 7
      {
        l: "n^n1*n",
        r: "n^(n1+1)"
      },
      // Joining multiply with power 8
      {
        l: "n^n1/-n",
        r: "-n^(n1-1)"
      },
      // Joining multiply with power 8
      {
        l: "n^n1/n",
        r: "n^(n1-1)"
      },
      // Joining division with power 1
      {
        l: "n/-n^n1",
        r: "-n^(1-n1)"
      },
      // Joining division with power 2
      {
        l: "n/n^n1",
        r: "n^(1-n1)"
      },
      // Joining division with power 3
      {
        l: "n^n1/-n^n2",
        r: "n^(n1-n2)"
      },
      // Joining division with power 4
      {
        l: "n^n1/n^n2",
        r: "n^(n1-n2)"
      },
      // Joining division with power 5
      {
        l: "n1+(-n2*n3)",
        r: "n1-n2*n3"
      },
      // Solving useless parenthesis 1
      {
        l: "v*(-c)",
        r: "-c*v"
      },
      // Solving useless unary 2
      {
        l: "n1+-n2",
        r: "n1-n2"
      },
      // Solving +- together (new!)
      {
        l: "v*c",
        r: "c*v"
      },
      // inversion constant with variable
      {
        l: "(n1^n2)^n3",
        r: "(n1^(n2*n3))"
      }
      // Power to Power
    ];
    return setRules;
  }
  function expandPower(node, parent, indParent) {
    var tp = node.type;
    var internal = arguments.length > 1;
    if (tp === "OperatorNode" && node.isBinary()) {
      var does = false;
      var val;
      if (node.op === "^") {
        if ((node.args[0].type === "ParenthesisNode" || node.args[0].type === "OperatorNode") && node.args[1].type === "ConstantNode") {
          val = parseFloat(node.args[1].value);
          does = val >= 2 && isInteger(val);
        }
      }
      if (does) {
        if (val > 2) {
          var nEsqTopo = node.args[0];
          var nDirTopo = new OperatorNode2("^", "pow", [node.args[0].cloneDeep(), new ConstantNode2(val - 1)]);
          node = new OperatorNode2("*", "multiply", [nEsqTopo, nDirTopo]);
        } else {
          node = new OperatorNode2("*", "multiply", [node.args[0], node.args[0].cloneDeep()]);
        }
        if (internal) {
          if (indParent === "content") {
            parent.content = node;
          } else {
            parent.args[indParent] = node;
          }
        }
      }
    }
    if (tp === "ParenthesisNode") {
      expandPower(node.content, node, "content");
    } else if (tp !== "ConstantNode" && tp !== "SymbolNode") {
      for (var i2 = 0; i2 < node.args.length; i2++) {
        expandPower(node.args[i2], node, i2);
      }
    }
    if (!internal) {
      return node;
    }
  }
  function polyToCanonical(node, coefficients) {
    if (coefficients === void 0) {
      coefficients = [];
    }
    coefficients[0] = 0;
    var o = {};
    o.cte = 1;
    o.oper = "+";
    o.fire = "";
    var maxExpo = 0;
    var varname = "";
    recurPol(node, null, o);
    maxExpo = coefficients.length - 1;
    var first = true;
    var no;
    for (var i2 = maxExpo; i2 >= 0; i2--) {
      if (coefficients[i2] === 0)
        continue;
      var n16 = new ConstantNode2(first ? coefficients[i2] : Math.abs(coefficients[i2]));
      var op = coefficients[i2] < 0 ? "-" : "+";
      if (i2 > 0) {
        var n25 = new SymbolNode2(varname);
        if (i2 > 1) {
          var n3 = new ConstantNode2(i2);
          n25 = new OperatorNode2("^", "pow", [n25, n3]);
        }
        if (coefficients[i2] === -1 && first) {
          n16 = new OperatorNode2("-", "unaryMinus", [n25]);
        } else if (Math.abs(coefficients[i2]) === 1) {
          n16 = n25;
        } else {
          n16 = new OperatorNode2("*", "multiply", [n16, n25]);
        }
      }
      if (first) {
        no = n16;
      } else if (op === "+") {
        no = new OperatorNode2("+", "add", [no, n16]);
      } else {
        no = new OperatorNode2("-", "subtract", [no, n16]);
      }
      first = false;
    }
    if (first) {
      return new ConstantNode2(0);
    } else {
      return no;
    }
    function recurPol(node2, noPai, o2) {
      var tp = node2.type;
      if (tp === "FunctionNode") {
        throw new Error("There is an unsolved function call");
      } else if (tp === "OperatorNode") {
        if (!"+-*^".includes(node2.op))
          throw new Error("Operator " + node2.op + " invalid");
        if (noPai !== null) {
          if ((node2.fn === "unaryMinus" || node2.fn === "pow") && noPai.fn !== "add" && noPai.fn !== "subtract" && noPai.fn !== "multiply") {
            throw new Error("Invalid " + node2.op + " placing");
          }
          if ((node2.fn === "subtract" || node2.fn === "add" || node2.fn === "multiply") && noPai.fn !== "add" && noPai.fn !== "subtract") {
            throw new Error("Invalid " + node2.op + " placing");
          }
          if ((node2.fn === "subtract" || node2.fn === "add" || node2.fn === "unaryMinus") && o2.noFil !== 0) {
            throw new Error("Invalid " + node2.op + " placing");
          }
        }
        if (node2.op === "^" || node2.op === "*") {
          o2.fire = node2.op;
        }
        for (var _i = 0; _i < node2.args.length; _i++) {
          if (node2.fn === "unaryMinus")
            o2.oper = "-";
          if (node2.op === "+" || node2.fn === "subtract") {
            o2.fire = "";
            o2.cte = 1;
            o2.oper = _i === 0 ? "+" : node2.op;
          }
          o2.noFil = _i;
          recurPol(node2.args[_i], node2, o2);
        }
      } else if (tp === "SymbolNode") {
        if (node2.name !== varname && varname !== "") {
          throw new Error("There is more than one variable");
        }
        varname = node2.name;
        if (noPai === null) {
          coefficients[1] = 1;
          return;
        }
        if (noPai.op === "^" && o2.noFil !== 0) {
          throw new Error("In power the variable should be the first parameter");
        }
        if (noPai.op === "*" && o2.noFil !== 1) {
          throw new Error("In multiply the variable should be the second parameter");
        }
        if (o2.fire === "" || o2.fire === "*") {
          if (maxExpo < 1)
            coefficients[1] = 0;
          coefficients[1] += o2.cte * (o2.oper === "+" ? 1 : -1);
          maxExpo = Math.max(1, maxExpo);
        }
      } else if (tp === "ConstantNode") {
        var valor = parseFloat(node2.value);
        if (noPai === null) {
          coefficients[0] = valor;
          return;
        }
        if (noPai.op === "^") {
          if (o2.noFil !== 1)
            throw new Error("Constant cannot be powered");
          if (!isInteger(valor) || valor <= 0) {
            throw new Error("Non-integer exponent is not allowed");
          }
          for (var _i2 = maxExpo + 1; _i2 < valor; _i2++)
            coefficients[_i2] = 0;
          if (valor > maxExpo)
            coefficients[valor] = 0;
          coefficients[valor] += o2.cte * (o2.oper === "+" ? 1 : -1);
          maxExpo = Math.max(valor, maxExpo);
          return;
        }
        o2.cte = valor;
        if (o2.fire === "") {
          coefficients[0] += o2.cte * (o2.oper === "+" ? 1 : -1);
        }
      } else {
        throw new Error("Type " + tp + " is not allowed");
      }
    }
  }
});

// node_modules/mathjs/lib/esm/function/signal/zpk2tf.js
var name286 = "zpk2tf";
var dependencies287 = ["typed", "add", "multiply", "Complex", "number"];
var createZpk2tf = /* @__PURE__ */ factory(name286, dependencies287, (_ref) => {
  var {
    typed: typed3,
    add: add3,
    multiply: multiply2,
    Complex: Complex3,
    number: number2
  } = _ref;
  return typed3(name286, {
    "Array,Array,number": function ArrayArrayNumber(z, p, k) {
      return _zpk2tf(z, p, k);
    },
    "Array,Array": function ArrayArray(z, p) {
      return _zpk2tf(z, p, 1);
    },
    "Matrix,Matrix,number": function MatrixMatrixNumber(z, p, k) {
      return _zpk2tf(z.valueOf(), p.valueOf(), k);
    },
    "Matrix,Matrix": function MatrixMatrix(z, p) {
      return _zpk2tf(z.valueOf(), p.valueOf(), 1);
    }
  });
  function _zpk2tf(z, p, k) {
    if (z.some((el) => el.type === "BigNumber")) {
      z = z.map((el) => number2(el));
    }
    if (p.some((el) => el.type === "BigNumber")) {
      p = p.map((el) => number2(el));
    }
    var num = [Complex3(1, 0)];
    var den = [Complex3(1, 0)];
    for (var i2 = 0; i2 < z.length; i2++) {
      var zero = z[i2];
      if (typeof zero === "number")
        zero = Complex3(zero, 0);
      num = _multiply(num, [Complex3(1, 0), Complex3(-zero.re, -zero.im)]);
    }
    for (var _i = 0; _i < p.length; _i++) {
      var pole = p[_i];
      if (typeof pole === "number")
        pole = Complex3(pole, 0);
      den = _multiply(den, [Complex3(1, 0), Complex3(-pole.re, -pole.im)]);
    }
    for (var _i2 = 0; _i2 < num.length; _i2++) {
      num[_i2] = multiply2(num[_i2], k);
    }
    return [num, den];
  }
  function _multiply(a, b) {
    var c = [];
    for (var i2 = 0; i2 < a.length + b.length - 1; i2++) {
      c[i2] = Complex3(0, 0);
      for (var j = 0; j < a.length; j++) {
        if (i2 - j >= 0 && i2 - j < b.length) {
          c[i2] = add3(c[i2], multiply2(a[j], b[i2 - j]));
        }
      }
    }
    return c;
  }
});

// node_modules/mathjs/lib/esm/function/signal/freqz.js
var name287 = "freqz";
var dependencies288 = ["typed", "add", "multiply", "Complex", "divide", "matrix"];
var createFreqz = /* @__PURE__ */ factory(name287, dependencies288, (_ref) => {
  var {
    typed: typed3,
    add: add3,
    multiply: multiply2,
    Complex: Complex3,
    divide: divide3,
    matrix: matrix2
  } = _ref;
  return typed3(name287, {
    "Array, Array": function ArrayArray(b, a) {
      var w = createBins(512);
      return _freqz(b, a, w);
    },
    "Array, Array, Array": function ArrayArrayArray(b, a, w) {
      return _freqz(b, a, w);
    },
    "Array, Array, number": function ArrayArrayNumber(b, a, w) {
      if (w < 0) {
        throw new Error("w must be a positive number");
      }
      var w2 = createBins(w);
      return _freqz(b, a, w2);
    },
    "Matrix, Matrix": function MatrixMatrix(b, a) {
      var _w = createBins(512);
      var {
        w,
        h
      } = _freqz(b.valueOf(), a.valueOf(), _w);
      return {
        w: matrix2(w),
        h: matrix2(h)
      };
    },
    "Matrix, Matrix, Matrix": function MatrixMatrixMatrix(b, a, w) {
      var {
        h
      } = _freqz(b.valueOf(), a.valueOf(), w.valueOf());
      return {
        h: matrix2(h),
        w: matrix2(w)
      };
    },
    "Matrix, Matrix, number": function MatrixMatrixNumber(b, a, w) {
      if (w < 0) {
        throw new Error("w must be a positive number");
      }
      var _w = createBins(w);
      var {
        h
      } = _freqz(b.valueOf(), a.valueOf(), _w);
      return {
        h: matrix2(h),
        w: matrix2(_w)
      };
    }
  });
  function _freqz(b, a, w) {
    var num = [];
    var den = [];
    for (var i2 = 0; i2 < w.length; i2++) {
      var sumNum = Complex3(0, 0);
      var sumDen = Complex3(0, 0);
      for (var j = 0; j < b.length; j++) {
        sumNum = add3(sumNum, multiply2(b[j], Complex3(Math.cos(-j * w[i2]), Math.sin(-j * w[i2]))));
      }
      for (var _j = 0; _j < a.length; _j++) {
        sumDen = add3(sumDen, multiply2(a[_j], Complex3(Math.cos(-_j * w[i2]), Math.sin(-_j * w[i2]))));
      }
      num.push(sumNum);
      den.push(sumDen);
    }
    var h = [];
    for (var _i = 0; _i < num.length; _i++) {
      h.push(divide3(num[_i], den[_i]));
    }
    return {
      h,
      w
    };
  }
  function createBins(n) {
    var bins = [];
    for (var i2 = 0; i2 < n; i2++) {
      bins.push(i2 / n * Math.PI);
    }
    return bins;
  }
});

// node_modules/mathjs/lib/esm/json/reviver.js
var name288 = "reviver";
var dependencies289 = ["classes"];
var createReviver = /* @__PURE__ */ factory(name288, dependencies289, (_ref) => {
  var {
    classes: classes2
  } = _ref;
  return function reviver2(key, value) {
    var constructor = classes2[value && value.mathjs];
    if (constructor && typeof constructor.fromJSON === "function") {
      return constructor.fromJSON(value);
    }
    return value;
  };
});

// node_modules/mathjs/lib/esm/json/replacer.js
var name289 = "replacer";
var dependencies290 = [];
var createReplacer = /* @__PURE__ */ factory(name289, dependencies290, () => {
  return function replacer2(key, value) {
    if (typeof value === "number" && (!isFinite(value) || isNaN(value))) {
      return {
        mathjs: "number",
        value: String(value)
      };
    }
    if (typeof value === "bigint") {
      return {
        mathjs: "bigint",
        value: String(value)
      };
    }
    return value;
  };
});

// node_modules/mathjs/lib/esm/version.js
var version2 = "13.0.3";

// node_modules/mathjs/lib/esm/constants.js
var createTrue = /* @__PURE__ */ factory("true", [], () => true);
var createFalse = /* @__PURE__ */ factory("false", [], () => false);
var createNull = /* @__PURE__ */ factory("null", [], () => null);
var createInfinity = /* @__PURE__ */ recreateFactory("Infinity", ["config", "?BigNumber"], (_ref) => {
  var {
    config: config5,
    BigNumber: BigNumber2
  } = _ref;
  return config5.number === "BigNumber" ? new BigNumber2(Infinity) : Infinity;
});
var createNaN = /* @__PURE__ */ recreateFactory("NaN", ["config", "?BigNumber"], (_ref2) => {
  var {
    config: config5,
    BigNumber: BigNumber2
  } = _ref2;
  return config5.number === "BigNumber" ? new BigNumber2(NaN) : NaN;
});
var createPi = /* @__PURE__ */ recreateFactory("pi", ["config", "?BigNumber"], (_ref3) => {
  var {
    config: config5,
    BigNumber: BigNumber2
  } = _ref3;
  return config5.number === "BigNumber" ? createBigNumberPi(BigNumber2) : pi;
});
var createTau = /* @__PURE__ */ recreateFactory("tau", ["config", "?BigNumber"], (_ref4) => {
  var {
    config: config5,
    BigNumber: BigNumber2
  } = _ref4;
  return config5.number === "BigNumber" ? createBigNumberTau(BigNumber2) : tau;
});
var createE = /* @__PURE__ */ recreateFactory("e", ["config", "?BigNumber"], (_ref5) => {
  var {
    config: config5,
    BigNumber: BigNumber2
  } = _ref5;
  return config5.number === "BigNumber" ? createBigNumberE(BigNumber2) : e;
});
var createPhi = /* @__PURE__ */ recreateFactory("phi", ["config", "?BigNumber"], (_ref6) => {
  var {
    config: config5,
    BigNumber: BigNumber2
  } = _ref6;
  return config5.number === "BigNumber" ? createBigNumberPhi(BigNumber2) : phi;
});
var createLN2 = /* @__PURE__ */ recreateFactory("LN2", ["config", "?BigNumber"], (_ref7) => {
  var {
    config: config5,
    BigNumber: BigNumber2
  } = _ref7;
  return config5.number === "BigNumber" ? new BigNumber2(2).ln() : Math.LN2;
});
var createLN10 = /* @__PURE__ */ recreateFactory("LN10", ["config", "?BigNumber"], (_ref8) => {
  var {
    config: config5,
    BigNumber: BigNumber2
  } = _ref8;
  return config5.number === "BigNumber" ? new BigNumber2(10).ln() : Math.LN10;
});
var createLOG2E = /* @__PURE__ */ recreateFactory("LOG2E", ["config", "?BigNumber"], (_ref9) => {
  var {
    config: config5,
    BigNumber: BigNumber2
  } = _ref9;
  return config5.number === "BigNumber" ? new BigNumber2(1).div(new BigNumber2(2).ln()) : Math.LOG2E;
});
var createLOG10E = /* @__PURE__ */ recreateFactory("LOG10E", ["config", "?BigNumber"], (_ref10) => {
  var {
    config: config5,
    BigNumber: BigNumber2
  } = _ref10;
  return config5.number === "BigNumber" ? new BigNumber2(1).div(new BigNumber2(10).ln()) : Math.LOG10E;
});
var createSQRT1_2 = /* @__PURE__ */ recreateFactory(
  // eslint-disable-line camelcase
  "SQRT1_2",
  ["config", "?BigNumber"],
  (_ref11) => {
    var {
      config: config5,
      BigNumber: BigNumber2
    } = _ref11;
    return config5.number === "BigNumber" ? new BigNumber2("0.5").sqrt() : Math.SQRT1_2;
  }
);
var createSQRT2 = /* @__PURE__ */ recreateFactory("SQRT2", ["config", "?BigNumber"], (_ref12) => {
  var {
    config: config5,
    BigNumber: BigNumber2
  } = _ref12;
  return config5.number === "BigNumber" ? new BigNumber2(2).sqrt() : Math.SQRT2;
});
var createI = /* @__PURE__ */ recreateFactory("i", ["Complex"], (_ref13) => {
  var {
    Complex: Complex3
  } = _ref13;
  return Complex3.I;
});
var createVersion = /* @__PURE__ */ factory("version", [], () => version2);
function recreateFactory(name314, dependencies315, create) {
  return factory(name314, dependencies315, create, {
    recreateOnConfigChange: true
  });
}

// node_modules/mathjs/lib/esm/type/unit/physicalConstants.js
var createSpeedOfLight = /* @__PURE__ */ unitFactory("speedOfLight", "299792458", "m s^-1");
var createGravitationConstant = /* @__PURE__ */ unitFactory("gravitationConstant", "6.67430e-11", "m^3 kg^-1 s^-2");
var createPlanckConstant = /* @__PURE__ */ unitFactory("planckConstant", "6.62607015e-34", "J s");
var createReducedPlanckConstant = /* @__PURE__ */ unitFactory("reducedPlanckConstant", "1.0545718176461565e-34", "J s");
var createMagneticConstant = /* @__PURE__ */ unitFactory("magneticConstant", "1.25663706212e-6", "N A^-2");
var createElectricConstant = /* @__PURE__ */ unitFactory("electricConstant", "8.8541878128e-12", "F m^-1");
var createVacuumImpedance = /* @__PURE__ */ unitFactory("vacuumImpedance", "376.730313667", "ohm");
var createCoulomb = /* @__PURE__ */ unitFactory("coulomb", "8.987551792261171e9", "N m^2 C^-2");
var createElementaryCharge = /* @__PURE__ */ unitFactory("elementaryCharge", "1.602176634e-19", "C");
var createBohrMagneton = /* @__PURE__ */ unitFactory("bohrMagneton", "9.2740100783e-24", "J T^-1");
var createConductanceQuantum = /* @__PURE__ */ unitFactory("conductanceQuantum", "7.748091729863649e-5", "S");
var createInverseConductanceQuantum = /* @__PURE__ */ unitFactory("inverseConductanceQuantum", "12906.403729652257", "ohm");
var createMagneticFluxQuantum = /* @__PURE__ */ unitFactory("magneticFluxQuantum", "2.0678338484619295e-15", "Wb");
var createNuclearMagneton = /* @__PURE__ */ unitFactory("nuclearMagneton", "5.0507837461e-27", "J T^-1");
var createKlitzing = /* @__PURE__ */ unitFactory("klitzing", "25812.807459304513", "ohm");
var createBohrRadius = /* @__PURE__ */ unitFactory("bohrRadius", "5.29177210903e-11", "m");
var createClassicalElectronRadius = /* @__PURE__ */ unitFactory("classicalElectronRadius", "2.8179403262e-15", "m");
var createElectronMass = /* @__PURE__ */ unitFactory("electronMass", "9.1093837015e-31", "kg");
var createFermiCoupling = /* @__PURE__ */ unitFactory("fermiCoupling", "1.1663787e-5", "GeV^-2");
var createFineStructure = numberFactory("fineStructure", 0.0072973525693);
var createHartreeEnergy = /* @__PURE__ */ unitFactory("hartreeEnergy", "4.3597447222071e-18", "J");
var createProtonMass = /* @__PURE__ */ unitFactory("protonMass", "1.67262192369e-27", "kg");
var createDeuteronMass = /* @__PURE__ */ unitFactory("deuteronMass", "3.3435830926e-27", "kg");
var createNeutronMass = /* @__PURE__ */ unitFactory("neutronMass", "1.6749271613e-27", "kg");
var createQuantumOfCirculation = /* @__PURE__ */ unitFactory("quantumOfCirculation", "3.6369475516e-4", "m^2 s^-1");
var createRydberg = /* @__PURE__ */ unitFactory("rydberg", "10973731.568160", "m^-1");
var createThomsonCrossSection = /* @__PURE__ */ unitFactory("thomsonCrossSection", "6.6524587321e-29", "m^2");
var createWeakMixingAngle = numberFactory("weakMixingAngle", 0.2229);
var createEfimovFactor = numberFactory("efimovFactor", 22.7);
var createAtomicMass = /* @__PURE__ */ unitFactory("atomicMass", "1.66053906660e-27", "kg");
var createAvogadro = /* @__PURE__ */ unitFactory("avogadro", "6.02214076e23", "mol^-1");
var createBoltzmann = /* @__PURE__ */ unitFactory("boltzmann", "1.380649e-23", "J K^-1");
var createFaraday = /* @__PURE__ */ unitFactory("faraday", "96485.33212331001", "C mol^-1");
var createFirstRadiation = /* @__PURE__ */ unitFactory("firstRadiation", "3.7417718521927573e-16", "W m^2");
var createLoschmidt = /* @__PURE__ */ unitFactory("loschmidt", "2.686780111798444e25", "m^-3");
var createGasConstant = /* @__PURE__ */ unitFactory("gasConstant", "8.31446261815324", "J K^-1 mol^-1");
var createMolarPlanckConstant = /* @__PURE__ */ unitFactory("molarPlanckConstant", "3.990312712893431e-10", "J s mol^-1");
var createMolarVolume = /* @__PURE__ */ unitFactory("molarVolume", "0.022413969545014137", "m^3 mol^-1");
var createSackurTetrode = numberFactory("sackurTetrode", -1.16487052358);
var createSecondRadiation = /* @__PURE__ */ unitFactory("secondRadiation", "0.014387768775039337", "m K");
var createStefanBoltzmann = /* @__PURE__ */ unitFactory("stefanBoltzmann", "5.67037441918443e-8", "W m^-2 K^-4");
var createWienDisplacement = /* @__PURE__ */ unitFactory("wienDisplacement", "2.897771955e-3", "m K");
var createMolarMass = /* @__PURE__ */ unitFactory("molarMass", "0.99999999965e-3", "kg mol^-1");
var createMolarMassC12 = /* @__PURE__ */ unitFactory("molarMassC12", "11.9999999958e-3", "kg mol^-1");
var createGravity = /* @__PURE__ */ unitFactory("gravity", "9.80665", "m s^-2");
var createPlanckLength = /* @__PURE__ */ unitFactory("planckLength", "1.616255e-35", "m");
var createPlanckMass = /* @__PURE__ */ unitFactory("planckMass", "2.176435e-8", "kg");
var createPlanckTime = /* @__PURE__ */ unitFactory("planckTime", "5.391245e-44", "s");
var createPlanckCharge = /* @__PURE__ */ unitFactory("planckCharge", "1.87554603778e-18", "C");
var createPlanckTemperature = /* @__PURE__ */ unitFactory("planckTemperature", "1.416785e+32", "K");
function unitFactory(name314, valueStr, unitStr) {
  var dependencies315 = ["config", "Unit", "BigNumber"];
  return factory(name314, dependencies315, (_ref) => {
    var {
      config: config5,
      Unit: Unit2,
      BigNumber: BigNumber2
    } = _ref;
    var value = config5.number === "BigNumber" ? new BigNumber2(valueStr) : parseFloat(valueStr);
    var unit2 = new Unit2(value, unitStr);
    unit2.fixPrefix = true;
    return unit2;
  });
}
function numberFactory(name314, value) {
  var dependencies315 = ["config", "BigNumber"];
  return factory(name314, dependencies315, (_ref2) => {
    var {
      config: config5,
      BigNumber: BigNumber2
    } = _ref2;
    return config5.number === "BigNumber" ? new BigNumber2(value) : value;
  });
}

// node_modules/mathjs/lib/esm/expression/transform/apply.transform.js
var name290 = "apply";
var dependencies291 = ["typed", "isInteger"];
var createApplyTransform = /* @__PURE__ */ factory(name290, dependencies291, (_ref) => {
  var {
    typed: typed3,
    isInteger: isInteger3
  } = _ref;
  var apply2 = createApply({
    typed: typed3,
    isInteger: isInteger3
  });
  return typed3("apply", {
    "...any": function any(args) {
      var dim = args[1];
      if (isNumber(dim)) {
        args[1] = dim - 1;
      } else if (isBigNumber(dim)) {
        args[1] = dim.minus(1);
      }
      try {
        return apply2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/column.transform.js
var name291 = "column";
var dependencies292 = ["typed", "Index", "matrix", "range"];
var createColumnTransform = /* @__PURE__ */ factory(name291, dependencies292, (_ref) => {
  var {
    typed: typed3,
    Index: Index2,
    matrix: matrix2,
    range: range2
  } = _ref;
  var column2 = createColumn({
    typed: typed3,
    Index: Index2,
    matrix: matrix2,
    range: range2
  });
  return typed3("column", {
    "...any": function any(args) {
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (isNumber(last)) {
        args[lastIndex] = last - 1;
      }
      try {
        return column2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/utils/compileInlineExpression.js
function compileInlineExpression(expression, math2, scope) {
  var symbol = expression.filter(function(node) {
    return isSymbolNode(node) && !(node.name in math2) && !scope.has(node.name);
  })[0];
  if (!symbol) {
    throw new Error('No undefined variable found in inline expression "' + expression + '"');
  }
  var name314 = symbol.name;
  var argsScope = /* @__PURE__ */ new Map();
  var subScope = new PartitionedMap(scope, argsScope, /* @__PURE__ */ new Set([name314]));
  var eq = expression.compile();
  return function inlineExpression(x) {
    argsScope.set(name314, x);
    return eq.evaluate(subScope);
  };
}

// node_modules/mathjs/lib/esm/expression/transform/filter.transform.js
var name292 = "filter";
var dependencies293 = ["typed"];
var createFilterTransform = /* @__PURE__ */ factory(name292, dependencies293, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  function filterTransform(args, math2, scope) {
    var x, callback;
    if (args[0]) {
      x = args[0].compile().evaluate(scope);
    }
    if (args[1]) {
      if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
        callback = args[1].compile().evaluate(scope);
      } else {
        callback = compileInlineExpression(args[1], math2, scope);
      }
    }
    return filter3(x, callback);
  }
  filterTransform.rawArgs = true;
  var filter3 = typed3("filter", {
    "Array, function": _filter,
    "Matrix, function": function MatrixFunction(x, test) {
      return x.create(_filter(x.toArray(), test));
    },
    "Array, RegExp": filterRegExp,
    "Matrix, RegExp": function MatrixRegExp(x, test) {
      return x.create(filterRegExp(x.toArray(), test));
    }
  });
  return filterTransform;
}, {
  isTransformFunction: true
});
function _filter(x, callback) {
  return filter(x, function(value, index2, array) {
    return applyCallback(callback, value, [index2 + 1], array, "filter");
  });
}

// node_modules/mathjs/lib/esm/expression/transform/forEach.transform.js
var name293 = "forEach";
var dependencies294 = ["typed"];
var createForEachTransform = /* @__PURE__ */ factory(name293, dependencies294, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  function forEachTransform(args, math2, scope) {
    var x, callback;
    if (args[0]) {
      x = args[0].compile().evaluate(scope);
    }
    if (args[1]) {
      if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
        callback = args[1].compile().evaluate(scope);
      } else {
        callback = compileInlineExpression(args[1], math2, scope);
      }
    }
    return _forEach2(x, callback);
  }
  forEachTransform.rawArgs = true;
  var _forEach2 = typed3("forEach", {
    "Array | Matrix, function": function ArrayMatrixFunction(array, callback) {
      var recurse = function recurse2(value, index2) {
        if (Array.isArray(value)) {
          forEach(value, function(child, i2) {
            recurse2(child, index2.concat(i2 + 1));
          });
        } else {
          return applyCallback(callback, value, index2, array, "forEach");
        }
      };
      recurse(array.valueOf(), []);
    }
  });
  return forEachTransform;
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/index.transform.js
var name294 = "index";
var dependencies295 = ["Index", "getMatrixDataType"];
var createIndexTransform = /* @__PURE__ */ factory(name294, dependencies295, (_ref) => {
  var {
    Index: Index2,
    getMatrixDataType: getMatrixDataType2
  } = _ref;
  return function indexTransform() {
    var args = [];
    for (var i2 = 0, ii = arguments.length; i2 < ii; i2++) {
      var arg2 = arguments[i2];
      if (isRange(arg2)) {
        arg2.start--;
        arg2.end -= arg2.step > 0 ? 0 : 2;
      } else if (arg2 && arg2.isSet === true) {
        arg2 = arg2.map(function(v) {
          return v - 1;
        });
      } else if (isArray(arg2) || isMatrix(arg2)) {
        if (getMatrixDataType2(arg2) !== "boolean") {
          arg2 = arg2.map(function(v) {
            return v - 1;
          });
        }
      } else if (isNumber(arg2)) {
        arg2--;
      } else if (isBigNumber(arg2)) {
        arg2 = arg2.toNumber() - 1;
      } else if (typeof arg2 === "string") {
      } else {
        throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");
      }
      args[i2] = arg2;
    }
    var res = new Index2();
    Index2.apply(res, args);
    return res;
  };
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/map.transform.js
var name295 = "map";
var dependencies296 = ["typed"];
var createMapTransform = /* @__PURE__ */ factory(name295, dependencies296, (_ref) => {
  var {
    typed: typed3
  } = _ref;
  function mapTransform(args, math2, scope) {
    var x, callback;
    if (args[0]) {
      x = args[0].compile().evaluate(scope);
    }
    if (args[1]) {
      if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
        callback = args[1].compile().evaluate(scope);
      } else {
        callback = compileInlineExpression(args[1], math2, scope);
      }
    }
    return map3(x, callback);
  }
  mapTransform.rawArgs = true;
  var map3 = typed3("map", {
    "Array, function": function ArrayFunction(x, callback) {
      return _map2(x, callback, x);
    },
    "Matrix, function": function MatrixFunction(x, callback) {
      return x.create(_map2(x.valueOf(), callback, x));
    }
  });
  return mapTransform;
}, {
  isTransformFunction: true
});
function _map2(array, callback, orig) {
  function recurse(value, index2) {
    if (Array.isArray(value)) {
      return map(value, function(child, i2) {
        return recurse(child, index2.concat(i2 + 1));
      });
    } else {
      return applyCallback(callback, value, index2, orig, "map");
    }
  }
  return recurse(array, []);
}

// node_modules/mathjs/lib/esm/expression/transform/utils/lastDimToZeroBase.js
function lastDimToZeroBase(args) {
  if (args.length === 2 && isCollection(args[0])) {
    args = args.slice();
    var dim = args[1];
    if (isNumber(dim)) {
      args[1] = dim - 1;
    } else if (isBigNumber(dim)) {
      args[1] = dim.minus(1);
    }
  }
  return args;
}

// node_modules/mathjs/lib/esm/expression/transform/max.transform.js
var name296 = "max";
var dependencies297 = ["typed", "config", "numeric", "larger"];
var createMaxTransform = /* @__PURE__ */ factory(name296, dependencies297, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    numeric: numeric3,
    larger: larger2
  } = _ref;
  var max3 = createMax({
    typed: typed3,
    config: config5,
    numeric: numeric3,
    larger: larger2
  });
  return typed3("max", {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return max3.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/mean.transform.js
var name297 = "mean";
var dependencies298 = ["typed", "add", "divide"];
var createMeanTransform = /* @__PURE__ */ factory(name297, dependencies298, (_ref) => {
  var {
    typed: typed3,
    add: add3,
    divide: divide3
  } = _ref;
  var mean2 = createMean({
    typed: typed3,
    add: add3,
    divide: divide3
  });
  return typed3("mean", {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return mean2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/min.transform.js
var name298 = "min";
var dependencies299 = ["typed", "config", "numeric", "smaller"];
var createMinTransform = /* @__PURE__ */ factory(name298, dependencies299, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    numeric: numeric3,
    smaller: smaller2
  } = _ref;
  var min3 = createMin({
    typed: typed3,
    config: config5,
    numeric: numeric3,
    smaller: smaller2
  });
  return typed3("min", {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return min3.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/range.transform.js
var name299 = "range";
var dependencies300 = ["typed", "config", "?matrix", "?bignumber", "smaller", "smallerEq", "larger", "largerEq", "add", "isPositive"];
var createRangeTransform = /* @__PURE__ */ factory(name299, dependencies300, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    matrix: matrix2,
    bignumber: bignumber2,
    smaller: smaller2,
    smallerEq: smallerEq2,
    larger: larger2,
    largerEq: largerEq2,
    add: add3,
    isPositive: isPositive2
  } = _ref;
  var range2 = createRange({
    typed: typed3,
    config: config5,
    matrix: matrix2,
    bignumber: bignumber2,
    smaller: smaller2,
    smallerEq: smallerEq2,
    larger: larger2,
    largerEq: largerEq2,
    add: add3,
    isPositive: isPositive2
  });
  return typed3("range", {
    "...any": function any(args) {
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (typeof last !== "boolean") {
        args.push(true);
      }
      return range2.apply(null, args);
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/row.transform.js
var name300 = "row";
var dependencies301 = ["typed", "Index", "matrix", "range"];
var createRowTransform = /* @__PURE__ */ factory(name300, dependencies301, (_ref) => {
  var {
    typed: typed3,
    Index: Index2,
    matrix: matrix2,
    range: range2
  } = _ref;
  var row2 = createRow({
    typed: typed3,
    Index: Index2,
    matrix: matrix2,
    range: range2
  });
  return typed3("row", {
    "...any": function any(args) {
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (isNumber(last)) {
        args[lastIndex] = last - 1;
      }
      try {
        return row2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/subset.transform.js
var name301 = "subset";
var dependencies302 = ["typed", "matrix", "zeros", "add"];
var createSubsetTransform = /* @__PURE__ */ factory(name301, dependencies302, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    zeros: zeros3,
    add: add3
  } = _ref;
  var subset2 = createSubset({
    typed: typed3,
    matrix: matrix2,
    zeros: zeros3,
    add: add3
  });
  return typed3("subset", {
    "...any": function any(args) {
      try {
        return subset2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/concat.transform.js
var name302 = "concat";
var dependencies303 = ["typed", "matrix", "isInteger"];
var createConcatTransform = /* @__PURE__ */ factory(name302, dependencies303, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    isInteger: isInteger3
  } = _ref;
  var concat3 = createConcat({
    typed: typed3,
    matrix: matrix2,
    isInteger: isInteger3
  });
  return typed3("concat", {
    "...any": function any(args) {
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (isNumber(last)) {
        args[lastIndex] = last - 1;
      } else if (isBigNumber(last)) {
        args[lastIndex] = last.minus(1);
      }
      try {
        return concat3.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/diff.transform.js
var name303 = "diff";
var dependencies304 = ["typed", "matrix", "subtract", "number", "bignumber"];
var createDiffTransform = /* @__PURE__ */ factory(name303, dependencies304, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    subtract: subtract2,
    number: number2,
    bignumber: bignumber2
  } = _ref;
  var diff2 = createDiff({
    typed: typed3,
    matrix: matrix2,
    subtract: subtract2,
    number: number2,
    bignumber: bignumber2
  });
  return typed3(name303, {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return diff2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/std.transform.js
var name304 = "std";
var dependencies305 = ["typed", "map", "sqrt", "variance"];
var createStdTransform = /* @__PURE__ */ factory(name304, dependencies305, (_ref) => {
  var {
    typed: typed3,
    map: map3,
    sqrt: sqrt3,
    variance: variance2
  } = _ref;
  var std2 = createStd({
    typed: typed3,
    map: map3,
    sqrt: sqrt3,
    variance: variance2
  });
  return typed3("std", {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return std2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/sum.transform.js
var name305 = "sum";
var dependencies306 = ["typed", "config", "add", "numeric"];
var createSumTransform = /* @__PURE__ */ factory(name305, dependencies306, (_ref) => {
  var {
    typed: typed3,
    config: config5,
    add: add3,
    numeric: numeric3
  } = _ref;
  var sum3 = createSum({
    typed: typed3,
    config: config5,
    add: add3,
    numeric: numeric3
  });
  return typed3(name305, {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return sum3.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/quantileSeq.transform.js
var name306 = "quantileSeq";
var dependencies307 = ["typed", "bignumber", "add", "subtract", "divide", "multiply", "partitionSelect", "compare", "isInteger", "smaller", "smallerEq", "larger"];
var createQuantileSeqTransform = /* @__PURE__ */ factory(name306, dependencies307, (_ref) => {
  var {
    typed: typed3,
    bignumber: bignumber2,
    add: add3,
    subtract: subtract2,
    divide: divide3,
    multiply: multiply2,
    partitionSelect: partitionSelect2,
    compare: compare2,
    isInteger: isInteger3,
    smaller: smaller2,
    smallerEq: smallerEq2,
    larger: larger2
  } = _ref;
  var quantileSeq2 = createQuantileSeq({
    typed: typed3,
    bignumber: bignumber2,
    add: add3,
    subtract: subtract2,
    divide: divide3,
    multiply: multiply2,
    partitionSelect: partitionSelect2,
    compare: compare2,
    isInteger: isInteger3,
    smaller: smaller2,
    smallerEq: smallerEq2,
    larger: larger2
  });
  return typed3("quantileSeq", {
    "Array | Matrix, number | BigNumber": quantileSeq2,
    "Array | Matrix, number | BigNumber, number": (arr, prob, dim) => quantileSeq2(arr, prob, dimToZeroBase(dim)),
    "Array | Matrix, number | BigNumber, boolean": quantileSeq2,
    "Array | Matrix, number | BigNumber, boolean, number": (arr, prob, sorted, dim) => quantileSeq2(arr, prob, sorted, dimToZeroBase(dim)),
    "Array | Matrix, Array | Matrix": quantileSeq2,
    "Array | Matrix, Array | Matrix, number": (data, prob, dim) => quantileSeq2(data, prob, dimToZeroBase(dim)),
    "Array | Matrix, Array | Matrix, boolean": quantileSeq2,
    "Array | Matrix, Array | Matrix, boolean, number": (data, prob, sorted, dim) => quantileSeq2(data, prob, sorted, dimToZeroBase(dim))
  });
  function dimToZeroBase(dim) {
    return lastDimToZeroBase([[], dim])[1];
  }
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/cumsum.transform.js
var name307 = "cumsum";
var dependencies308 = ["typed", "add", "unaryPlus"];
var createCumSumTransform = /* @__PURE__ */ factory(name307, dependencies308, (_ref) => {
  var {
    typed: typed3,
    add: add3,
    unaryPlus: unaryPlus2
  } = _ref;
  var cumsum2 = createCumSum({
    typed: typed3,
    add: add3,
    unaryPlus: unaryPlus2
  });
  return typed3(name307, {
    "...any": function any(args) {
      if (args.length === 2 && isCollection(args[0])) {
        var dim = args[1];
        if (isNumber(dim)) {
          args[1] = dim - 1;
        } else if (isBigNumber(dim)) {
          args[1] = dim.minus(1);
        }
      }
      try {
        return cumsum2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/variance.transform.js
var name308 = "variance";
var dependencies309 = ["typed", "add", "subtract", "multiply", "divide", "apply", "isNaN"];
var createVarianceTransform = /* @__PURE__ */ factory(name308, dependencies309, (_ref) => {
  var {
    typed: typed3,
    add: add3,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide3,
    apply: apply2,
    isNaN: isNaN3
  } = _ref;
  var variance2 = createVariance({
    typed: typed3,
    add: add3,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide3,
    apply: apply2,
    isNaN: isNaN3
  });
  return typed3(name308, {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return variance2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/print.transform.js
var name309 = "print";
var dependencies310 = ["typed", "matrix", "zeros", "add"];
var createPrintTransform = /* @__PURE__ */ factory(name309, dependencies310, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    zeros: zeros3,
    add: add3
  } = _ref;
  var print2 = createPrint({
    typed: typed3,
    matrix: matrix2,
    zeros: zeros3,
    add: add3
  });
  return typed3(name309, {
    "string, Object | Array": function stringObjectArray(template, values) {
      return print2(_convertTemplateToZeroBasedIndex(template), values);
    },
    "string, Object | Array, number | Object": function stringObjectArrayNumberObject(template, values, options2) {
      return print2(_convertTemplateToZeroBasedIndex(template), values, options2);
    }
  });
  function _convertTemplateToZeroBasedIndex(template) {
    return template.replace(printTemplate, (x) => {
      var parts = x.slice(1).split(".");
      var result = parts.map(function(part) {
        if (!isNaN(part) && part.length > 0) {
          return parseInt(part) - 1;
        } else {
          return part;
        }
      });
      return "$" + result.join(".");
    });
  }
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/and.transform.js
var name310 = "and";
var dependencies311 = ["typed", "matrix", "zeros", "add", "equalScalar", "not", "concat"];
var createAndTransform = /* @__PURE__ */ factory(name310, dependencies311, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros3,
    not: not2,
    concat: concat3
  } = _ref;
  var and2 = createAnd({
    typed: typed3,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros3,
    not: not2,
    concat: concat3
  });
  function andTransform(args, math2, scope) {
    var condition1 = args[0].compile().evaluate(scope);
    if (!isCollection(condition1) && !and2(condition1, true)) {
      return false;
    }
    var condition2 = args[1].compile().evaluate(scope);
    return and2(condition1, condition2);
  }
  andTransform.rawArgs = true;
  return andTransform;
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/or.transform.js
var name311 = "or";
var dependencies312 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
var createOrTransform = /* @__PURE__ */ factory(name311, dependencies312, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var or2 = createOr({
    typed: typed3,
    matrix: matrix2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  });
  function orTransform(args, math2, scope) {
    var condition1 = args[0].compile().evaluate(scope);
    if (!isCollection(condition1) && or2(condition1, false)) {
      return true;
    }
    var condition2 = args[1].compile().evaluate(scope);
    return or2(condition1, condition2);
  }
  orTransform.rawArgs = true;
  return orTransform;
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/bitAnd.transform.js
var name312 = "bitAnd";
var dependencies313 = ["typed", "matrix", "zeros", "add", "equalScalar", "not", "concat"];
var createBitAndTransform = /* @__PURE__ */ factory(name312, dependencies313, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros3,
    not: not2,
    concat: concat3
  } = _ref;
  var bitAnd2 = createBitAnd({
    typed: typed3,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros3,
    not: not2,
    concat: concat3
  });
  function bitAndTransform(args, math2, scope) {
    var condition1 = args[0].compile().evaluate(scope);
    if (!isCollection(condition1)) {
      if (isNaN(condition1)) {
        return NaN;
      }
      if (condition1 === 0 || condition1 === false) {
        return 0;
      }
    }
    var condition2 = args[1].compile().evaluate(scope);
    return bitAnd2(condition1, condition2);
  }
  bitAndTransform.rawArgs = true;
  return bitAndTransform;
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/expression/transform/bitOr.transform.js
var name313 = "bitOr";
var dependencies314 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
var createBitOrTransform = /* @__PURE__ */ factory(name313, dependencies314, (_ref) => {
  var {
    typed: typed3,
    matrix: matrix2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  } = _ref;
  var bitOr2 = createBitOr({
    typed: typed3,
    matrix: matrix2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2,
    concat: concat3
  });
  function bitOrTransform(args, math2, scope) {
    var condition1 = args[0].compile().evaluate(scope);
    if (!isCollection(condition1)) {
      if (isNaN(condition1)) {
        return NaN;
      }
      if (condition1 === -1) {
        return -1;
      }
      if (condition1 === true) {
        return 1;
      }
    }
    var condition2 = args[1].compile().evaluate(scope);
    return bitOr2(condition1, condition2);
  }
  bitOrTransform.rawArgs = true;
  return bitOrTransform;
}, {
  isTransformFunction: true
});

// node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js
var BigNumber = /* @__PURE__ */ createBigNumberClass({
  config: config2
});
var Complex2 = /* @__PURE__ */ createComplexClass({});
var e2 = /* @__PURE__ */ createE({
  BigNumber,
  config: config2
});
var _false = /* @__PURE__ */ createFalse({});
var fineStructure = /* @__PURE__ */ createFineStructure({
  BigNumber,
  config: config2
});
var Fraction2 = /* @__PURE__ */ createFractionClass({});
var i = /* @__PURE__ */ createI({
  Complex: Complex2
});
var _Infinity = /* @__PURE__ */ createInfinity({
  BigNumber,
  config: config2
});
var LN102 = /* @__PURE__ */ createLN10({
  BigNumber,
  config: config2
});
var LOG10E = /* @__PURE__ */ createLOG10E({
  BigNumber,
  config: config2
});
var Matrix = /* @__PURE__ */ createMatrixClass({});
var _NaN = /* @__PURE__ */ createNaN({
  BigNumber,
  config: config2
});
var _null = /* @__PURE__ */ createNull({});
var phi2 = /* @__PURE__ */ createPhi({
  BigNumber,
  config: config2
});
var Range = /* @__PURE__ */ createRangeClass({});
var ResultSet = /* @__PURE__ */ createResultSet({});
var SQRT1_2 = /* @__PURE__ */ createSQRT1_2({
  BigNumber,
  config: config2
});
var sackurTetrode = /* @__PURE__ */ createSackurTetrode({
  BigNumber,
  config: config2
});
var tau2 = /* @__PURE__ */ createTau({
  BigNumber,
  config: config2
});
var _true = /* @__PURE__ */ createTrue({});
var version3 = /* @__PURE__ */ createVersion({});
var DenseMatrix = /* @__PURE__ */ createDenseMatrixClass({
  Matrix
});
var efimovFactor = /* @__PURE__ */ createEfimovFactor({
  BigNumber,
  config: config2
});
var LN2 = /* @__PURE__ */ createLN2({
  BigNumber,
  config: config2
});
var pi2 = /* @__PURE__ */ createPi({
  BigNumber,
  config: config2
});
var replacer = /* @__PURE__ */ createReplacer({});
var SQRT2 = /* @__PURE__ */ createSQRT2({
  BigNumber,
  config: config2
});
var typed2 = /* @__PURE__ */ createTyped({
  BigNumber,
  Complex: Complex2,
  DenseMatrix,
  Fraction: Fraction2
});
var weakMixingAngle = /* @__PURE__ */ createWeakMixingAngle({
  BigNumber,
  config: config2
});
var abs2 = /* @__PURE__ */ createAbs({
  typed: typed2
});
var acos2 = /* @__PURE__ */ createAcos({
  Complex: Complex2,
  config: config2,
  typed: typed2
});
var acot = /* @__PURE__ */ createAcot({
  BigNumber,
  typed: typed2
});
var acsc = /* @__PURE__ */ createAcsc({
  BigNumber,
  Complex: Complex2,
  config: config2,
  typed: typed2
});
var addScalar = /* @__PURE__ */ createAddScalar({
  typed: typed2
});
var arg = /* @__PURE__ */ createArg({
  typed: typed2
});
var asech = /* @__PURE__ */ createAsech({
  BigNumber,
  Complex: Complex2,
  config: config2,
  typed: typed2
});
var asinh3 = /* @__PURE__ */ createAsinh({
  typed: typed2
});
var atan3 = /* @__PURE__ */ createAtan({
  typed: typed2
});
var atanh3 = /* @__PURE__ */ createAtanh({
  Complex: Complex2,
  config: config2,
  typed: typed2
});
var bigint = /* @__PURE__ */ createBigint({
  typed: typed2
});
var bitNot = /* @__PURE__ */ createBitNot({
  typed: typed2
});
var boolean = /* @__PURE__ */ createBoolean({
  typed: typed2
});
var clone4 = /* @__PURE__ */ createClone({
  typed: typed2
});
var combinations = /* @__PURE__ */ createCombinations({
  typed: typed2
});
var complex = /* @__PURE__ */ createComplex({
  Complex: Complex2,
  typed: typed2
});
var conj = /* @__PURE__ */ createConj({
  typed: typed2
});
var cos2 = /* @__PURE__ */ createCos({
  typed: typed2
});
var cot = /* @__PURE__ */ createCot({
  BigNumber,
  typed: typed2
});
var csc = /* @__PURE__ */ createCsc({
  BigNumber,
  typed: typed2
});
var cube = /* @__PURE__ */ createCube({
  typed: typed2
});
var equalScalar = /* @__PURE__ */ createEqualScalar({
  config: config2,
  typed: typed2
});
var erf = /* @__PURE__ */ createErf({
  typed: typed2
});
var exp2 = /* @__PURE__ */ createExp({
  typed: typed2
});
var expm13 = /* @__PURE__ */ createExpm1({
  Complex: Complex2,
  typed: typed2
});
var filter2 = /* @__PURE__ */ createFilter({
  typed: typed2
});
var forEach2 = /* @__PURE__ */ createForEach({
  typed: typed2
});
var format4 = /* @__PURE__ */ createFormat({
  typed: typed2
});
var getMatrixDataType = /* @__PURE__ */ createGetMatrixDataType({
  typed: typed2
});
var hex = /* @__PURE__ */ createHex({
  format: format4,
  typed: typed2
});
var im = /* @__PURE__ */ createIm({
  typed: typed2
});
var isInteger2 = /* @__PURE__ */ createIsInteger({
  typed: typed2
});
var isNegative = /* @__PURE__ */ createIsNegative({
  config: config2,
  typed: typed2
});
var isPositive = /* @__PURE__ */ createIsPositive({
  config: config2,
  typed: typed2
});
var isZero = /* @__PURE__ */ createIsZero({
  equalScalar,
  typed: typed2
});
var LOG2E = /* @__PURE__ */ createLOG2E({
  BigNumber,
  config: config2
});
var lgamma = /* @__PURE__ */ createLgamma({
  Complex: Complex2,
  typed: typed2
});
var log104 = /* @__PURE__ */ createLog10({
  Complex: Complex2,
  config: config2,
  typed: typed2
});
var log24 = /* @__PURE__ */ createLog2({
  Complex: Complex2,
  config: config2,
  typed: typed2
});
var map2 = /* @__PURE__ */ createMap2({
  typed: typed2
});
var multiplyScalar = /* @__PURE__ */ createMultiplyScalar({
  typed: typed2
});
var not = /* @__PURE__ */ createNot({
  typed: typed2
});
var number = /* @__PURE__ */ createNumber({
  typed: typed2
});
var oct = /* @__PURE__ */ createOct({
  format: format4,
  typed: typed2
});
var pickRandom = /* @__PURE__ */ createPickRandom({
  config: config2,
  typed: typed2
});
var print = /* @__PURE__ */ createPrint({
  typed: typed2
});
var random2 = /* @__PURE__ */ createRandom({
  config: config2,
  typed: typed2
});
var re = /* @__PURE__ */ createRe({
  typed: typed2
});
var sec = /* @__PURE__ */ createSec({
  BigNumber,
  typed: typed2
});
var sign3 = /* @__PURE__ */ createSign({
  BigNumber,
  Fraction: Fraction2,
  complex,
  typed: typed2
});
var sin2 = /* @__PURE__ */ createSin({
  typed: typed2
});
var SparseMatrix = /* @__PURE__ */ createSparseMatrixClass({
  Matrix,
  equalScalar,
  typed: typed2
});
var splitUnit = /* @__PURE__ */ createSplitUnit({
  typed: typed2
});
var square = /* @__PURE__ */ createSquare({
  typed: typed2
});
var string = /* @__PURE__ */ createString({
  typed: typed2
});
var subtractScalar = /* @__PURE__ */ createSubtractScalar({
  typed: typed2
});
var tan2 = /* @__PURE__ */ createTan({
  typed: typed2
});
var typeOf2 = /* @__PURE__ */ createTypeOf({
  typed: typed2
});
var acosh3 = /* @__PURE__ */ createAcosh({
  Complex: Complex2,
  config: config2,
  typed: typed2
});
var acsch = /* @__PURE__ */ createAcsch({
  BigNumber,
  typed: typed2
});
var apply = /* @__PURE__ */ createApply({
  isInteger: isInteger2,
  typed: typed2
});
var asec = /* @__PURE__ */ createAsec({
  BigNumber,
  Complex: Complex2,
  config: config2,
  typed: typed2
});
var bignumber = /* @__PURE__ */ createBignumber({
  BigNumber,
  typed: typed2
});
var combinationsWithRep = /* @__PURE__ */ createCombinationsWithRep({
  typed: typed2
});
var cosh3 = /* @__PURE__ */ createCosh({
  typed: typed2
});
var csch = /* @__PURE__ */ createCsch({
  BigNumber,
  typed: typed2
});
var isNaN2 = /* @__PURE__ */ createIsNaN({
  typed: typed2
});
var isPrime = /* @__PURE__ */ createIsPrime({
  typed: typed2
});
var randomInt = /* @__PURE__ */ createRandomInt({
  config: config2,
  typed: typed2
});
var sech = /* @__PURE__ */ createSech({
  BigNumber,
  typed: typed2
});
var sinh3 = /* @__PURE__ */ createSinh({
  typed: typed2
});
var sparse = /* @__PURE__ */ createSparse({
  SparseMatrix,
  typed: typed2
});
var sqrt2 = /* @__PURE__ */ createSqrt({
  Complex: Complex2,
  config: config2,
  typed: typed2
});
var tanh3 = /* @__PURE__ */ createTanh({
  typed: typed2
});
var unaryMinus = /* @__PURE__ */ createUnaryMinus({
  typed: typed2
});
var acoth = /* @__PURE__ */ createAcoth({
  BigNumber,
  Complex: Complex2,
  config: config2,
  typed: typed2
});
var bin = /* @__PURE__ */ createBin({
  format: format4,
  typed: typed2
});
var coth = /* @__PURE__ */ createCoth({
  BigNumber,
  typed: typed2
});
var fraction = /* @__PURE__ */ createFraction({
  Fraction: Fraction2,
  typed: typed2
});
var isNumeric = /* @__PURE__ */ createIsNumeric({
  typed: typed2
});
var matrix = /* @__PURE__ */ createMatrix({
  DenseMatrix,
  Matrix,
  SparseMatrix,
  typed: typed2
});
var matrixFromFunction = /* @__PURE__ */ createMatrixFromFunction({
  isZero,
  matrix,
  typed: typed2
});
var mode = /* @__PURE__ */ createMode({
  isNaN: isNaN2,
  isNumeric,
  typed: typed2
});
var numeric2 = /* @__PURE__ */ createNumeric({
  bignumber,
  fraction,
  number
});
var prod = /* @__PURE__ */ createProd({
  config: config2,
  multiplyScalar,
  numeric: numeric2,
  typed: typed2
});
var reshape2 = /* @__PURE__ */ createReshape({
  isInteger: isInteger2,
  matrix,
  typed: typed2
});
var size = /* @__PURE__ */ createSize({
  matrix,
  config: config2,
  typed: typed2
});
var squeeze2 = /* @__PURE__ */ createSqueeze({
  matrix,
  typed: typed2
});
var transpose = /* @__PURE__ */ createTranspose({
  matrix,
  typed: typed2
});
var xgcd = /* @__PURE__ */ createXgcd({
  BigNumber,
  config: config2,
  matrix,
  typed: typed2
});
var zeros2 = /* @__PURE__ */ createZeros({
  BigNumber,
  config: config2,
  matrix,
  typed: typed2
});
var asin2 = /* @__PURE__ */ createAsin({
  Complex: Complex2,
  config: config2,
  typed: typed2
});
var cbrt4 = /* @__PURE__ */ createCbrt({
  BigNumber,
  Complex: Complex2,
  Fraction: Fraction2,
  config: config2,
  isNegative,
  matrix,
  typed: typed2,
  unaryMinus
});
var concat2 = /* @__PURE__ */ createConcat({
  isInteger: isInteger2,
  matrix,
  typed: typed2
});
var count = /* @__PURE__ */ createCount({
  prod,
  size,
  typed: typed2
});
var ctranspose = /* @__PURE__ */ createCtranspose({
  conj,
  transpose,
  typed: typed2
});
var diag = /* @__PURE__ */ createDiag({
  DenseMatrix,
  SparseMatrix,
  matrix,
  typed: typed2
});
var divideScalar = /* @__PURE__ */ createDivideScalar({
  numeric: numeric2,
  typed: typed2
});
var dotDivide = /* @__PURE__ */ createDotDivide({
  DenseMatrix,
  concat: concat2,
  divideScalar,
  equalScalar,
  matrix,
  typed: typed2
});
var equal = /* @__PURE__ */ createEqual({
  DenseMatrix,
  concat: concat2,
  equalScalar,
  matrix,
  typed: typed2
});
var flatten2 = /* @__PURE__ */ createFlatten({
  matrix,
  typed: typed2
});
var hasNumericValue = /* @__PURE__ */ createHasNumericValue({
  isNumeric,
  typed: typed2
});
var identity = /* @__PURE__ */ createIdentity({
  BigNumber,
  DenseMatrix,
  SparseMatrix,
  config: config2,
  matrix,
  typed: typed2
});
var kron = /* @__PURE__ */ createKron({
  matrix,
  multiplyScalar,
  typed: typed2
});
var largerEq = /* @__PURE__ */ createLargerEq({
  DenseMatrix,
  concat: concat2,
  config: config2,
  matrix,
  typed: typed2
});
var leftShift = /* @__PURE__ */ createLeftShift({
  DenseMatrix,
  concat: concat2,
  equalScalar,
  matrix,
  typed: typed2,
  zeros: zeros2
});
var lsolve = /* @__PURE__ */ createLsolve({
  DenseMatrix,
  divideScalar,
  equalScalar,
  matrix,
  multiplyScalar,
  subtractScalar,
  typed: typed2
});
var matrixFromColumns = /* @__PURE__ */ createMatrixFromColumns({
  flatten: flatten2,
  matrix,
  size,
  typed: typed2
});
var nthRoot = /* @__PURE__ */ createNthRoot({
  BigNumber,
  concat: concat2,
  equalScalar,
  matrix,
  typed: typed2
});
var ones = /* @__PURE__ */ createOnes({
  BigNumber,
  config: config2,
  matrix,
  typed: typed2
});
var qr = /* @__PURE__ */ createQr({
  addScalar,
  complex,
  conj,
  divideScalar,
  equal,
  identity,
  isZero,
  matrix,
  multiplyScalar,
  sign: sign3,
  sqrt: sqrt2,
  subtractScalar,
  typed: typed2,
  unaryMinus,
  zeros: zeros2
});
var resize2 = /* @__PURE__ */ createResize({
  config: config2,
  matrix
});
var rightArithShift = /* @__PURE__ */ createRightArithShift({
  DenseMatrix,
  concat: concat2,
  equalScalar,
  matrix,
  typed: typed2,
  zeros: zeros2
});
var round2 = /* @__PURE__ */ createRound({
  BigNumber,
  DenseMatrix,
  config: config2,
  equalScalar,
  matrix,
  typed: typed2,
  zeros: zeros2
});
var smaller = /* @__PURE__ */ createSmaller({
  DenseMatrix,
  concat: concat2,
  config: config2,
  matrix,
  typed: typed2
});
var subtract = /* @__PURE__ */ createSubtract({
  DenseMatrix,
  concat: concat2,
  equalScalar,
  matrix,
  subtractScalar,
  typed: typed2,
  unaryMinus
});
var to = /* @__PURE__ */ createTo({
  concat: concat2,
  matrix,
  typed: typed2
});
var unaryPlus = /* @__PURE__ */ createUnaryPlus({
  config: config2,
  numeric: numeric2,
  typed: typed2
});
var usolve = /* @__PURE__ */ createUsolve({
  DenseMatrix,
  divideScalar,
  equalScalar,
  matrix,
  multiplyScalar,
  subtractScalar,
  typed: typed2
});
var xor = /* @__PURE__ */ createXor({
  DenseMatrix,
  concat: concat2,
  matrix,
  typed: typed2
});
var add2 = /* @__PURE__ */ createAdd({
  DenseMatrix,
  SparseMatrix,
  addScalar,
  concat: concat2,
  equalScalar,
  matrix,
  typed: typed2
});
var atan22 = /* @__PURE__ */ createAtan2({
  BigNumber,
  DenseMatrix,
  concat: concat2,
  equalScalar,
  matrix,
  typed: typed2
});
var bitAnd = /* @__PURE__ */ createBitAnd({
  concat: concat2,
  equalScalar,
  matrix,
  typed: typed2
});
var bitOr = /* @__PURE__ */ createBitOr({
  DenseMatrix,
  concat: concat2,
  equalScalar,
  matrix,
  typed: typed2
});
var bitXor2 = /* @__PURE__ */ createBitXor({
  DenseMatrix,
  concat: concat2,
  matrix,
  typed: typed2
});
var catalan = /* @__PURE__ */ createCatalan({
  addScalar,
  combinations,
  divideScalar,
  isInteger: isInteger2,
  isNegative,
  multiplyScalar,
  typed: typed2
});
var compare = /* @__PURE__ */ createCompare({
  BigNumber,
  DenseMatrix,
  Fraction: Fraction2,
  concat: concat2,
  config: config2,
  equalScalar,
  matrix,
  typed: typed2
});
var compareText2 = /* @__PURE__ */ createCompareText({
  concat: concat2,
  matrix,
  typed: typed2
});
var cumsum = /* @__PURE__ */ createCumSum({
  add: add2,
  typed: typed2,
  unaryPlus
});
var deepEqual = /* @__PURE__ */ createDeepEqual({
  equal,
  typed: typed2
});
var diff = /* @__PURE__ */ createDiff({
  matrix,
  number,
  subtract,
  typed: typed2
});
var distance = /* @__PURE__ */ createDistance({
  abs: abs2,
  addScalar,
  deepEqual,
  divideScalar,
  multiplyScalar,
  sqrt: sqrt2,
  subtractScalar,
  typed: typed2
});
var dot = /* @__PURE__ */ createDot({
  addScalar,
  conj,
  multiplyScalar,
  size,
  typed: typed2
});
var equalText = /* @__PURE__ */ createEqualText({
  compareText: compareText2,
  isZero,
  typed: typed2
});
var floor2 = /* @__PURE__ */ createFloor({
  DenseMatrix,
  config: config2,
  equalScalar,
  matrix,
  round: round2,
  typed: typed2,
  zeros: zeros2
});
var gcd2 = /* @__PURE__ */ createGcd({
  BigNumber,
  DenseMatrix,
  concat: concat2,
  config: config2,
  equalScalar,
  matrix,
  round: round2,
  typed: typed2,
  zeros: zeros2
});
var hypot2 = /* @__PURE__ */ createHypot({
  abs: abs2,
  addScalar,
  divideScalar,
  isPositive,
  multiplyScalar,
  smaller,
  sqrt: sqrt2,
  typed: typed2
});
var ImmutableDenseMatrix = /* @__PURE__ */ createImmutableDenseMatrixClass({
  DenseMatrix,
  smaller
});
var Index = /* @__PURE__ */ createIndexClass({
  ImmutableDenseMatrix,
  getMatrixDataType
});
var larger = /* @__PURE__ */ createLarger({
  DenseMatrix,
  concat: concat2,
  config: config2,
  matrix,
  typed: typed2
});
var log3 = /* @__PURE__ */ createLog({
  Complex: Complex2,
  config: config2,
  divideScalar,
  typed: typed2
});
var lsolveAll = /* @__PURE__ */ createLsolveAll({
  DenseMatrix,
  divideScalar,
  equalScalar,
  matrix,
  multiplyScalar,
  subtractScalar,
  typed: typed2
});
var matrixFromRows = /* @__PURE__ */ createMatrixFromRows({
  flatten: flatten2,
  matrix,
  size,
  typed: typed2
});
var min2 = /* @__PURE__ */ createMin({
  config: config2,
  numeric: numeric2,
  smaller,
  typed: typed2
});
var mod2 = /* @__PURE__ */ createMod({
  DenseMatrix,
  concat: concat2,
  config: config2,
  equalScalar,
  matrix,
  round: round2,
  typed: typed2,
  zeros: zeros2
});
var multiply = /* @__PURE__ */ createMultiply({
  addScalar,
  dot,
  equalScalar,
  matrix,
  multiplyScalar,
  typed: typed2
});
var nthRoots = /* @__PURE__ */ createNthRoots({
  Complex: Complex2,
  config: config2,
  divideScalar,
  typed: typed2
});
var or = /* @__PURE__ */ createOr({
  DenseMatrix,
  concat: concat2,
  equalScalar,
  matrix,
  typed: typed2
});
var partitionSelect = /* @__PURE__ */ createPartitionSelect({
  compare,
  isNaN: isNaN2,
  isNumeric,
  typed: typed2
});
var rightLogShift = /* @__PURE__ */ createRightLogShift({
  DenseMatrix,
  concat: concat2,
  equalScalar,
  matrix,
  typed: typed2,
  zeros: zeros2
});
var slu = /* @__PURE__ */ createSlu({
  SparseMatrix,
  abs: abs2,
  add: add2,
  divideScalar,
  larger,
  largerEq,
  multiply,
  subtract,
  transpose,
  typed: typed2
});
var subset = /* @__PURE__ */ createSubset({
  add: add2,
  matrix,
  typed: typed2,
  zeros: zeros2
});
var sum2 = /* @__PURE__ */ createSum({
  add: add2,
  config: config2,
  numeric: numeric2,
  typed: typed2
});
var trace = /* @__PURE__ */ createTrace({
  add: add2,
  matrix,
  typed: typed2
});
var usolveAll = /* @__PURE__ */ createUsolveAll({
  DenseMatrix,
  divideScalar,
  equalScalar,
  matrix,
  multiplyScalar,
  subtractScalar,
  typed: typed2
});
var zpk2tf = /* @__PURE__ */ createZpk2tf({
  Complex: Complex2,
  add: add2,
  multiply,
  number,
  typed: typed2
});
var ceil2 = /* @__PURE__ */ createCeil({
  DenseMatrix,
  config: config2,
  equalScalar,
  matrix,
  round: round2,
  typed: typed2,
  zeros: zeros2
});
var compareNatural = /* @__PURE__ */ createCompareNatural({
  compare,
  typed: typed2
});
var composition = /* @__PURE__ */ createComposition({
  addScalar,
  combinations,
  isInteger: isInteger2,
  isNegative,
  isPositive,
  larger,
  typed: typed2
});
var cross = /* @__PURE__ */ createCross({
  matrix,
  multiply,
  subtract,
  typed: typed2
});
var det = /* @__PURE__ */ createDet({
  divideScalar,
  isZero,
  matrix,
  multiply,
  subtractScalar,
  typed: typed2,
  unaryMinus
});
var dotMultiply = /* @__PURE__ */ createDotMultiply({
  concat: concat2,
  equalScalar,
  matrix,
  multiplyScalar,
  typed: typed2
});
var FibonacciHeap = /* @__PURE__ */ createFibonacciHeapClass({
  larger,
  smaller
});
var fix = /* @__PURE__ */ createFix({
  Complex: Complex2,
  DenseMatrix,
  ceil: ceil2,
  equalScalar,
  floor: floor2,
  matrix,
  typed: typed2,
  zeros: zeros2
});
var index = /* @__PURE__ */ createIndex({
  Index,
  typed: typed2
});
var intersect = /* @__PURE__ */ createIntersect({
  abs: abs2,
  add: add2,
  addScalar,
  config: config2,
  divideScalar,
  equalScalar,
  flatten: flatten2,
  isNumeric,
  isZero,
  matrix,
  multiply,
  multiplyScalar,
  smaller,
  subtract,
  typed: typed2
});
var invmod = /* @__PURE__ */ createInvmod({
  BigNumber,
  add: add2,
  config: config2,
  equal,
  isInteger: isInteger2,
  mod: mod2,
  smaller,
  typed: typed2,
  xgcd
});
var lcm = /* @__PURE__ */ createLcm({
  concat: concat2,
  equalScalar,
  matrix,
  typed: typed2
});
var log1p2 = /* @__PURE__ */ createLog1p({
  Complex: Complex2,
  config: config2,
  divideScalar,
  log: log3,
  typed: typed2
});
var max2 = /* @__PURE__ */ createMax({
  config: config2,
  larger,
  numeric: numeric2,
  typed: typed2
});
var setCartesian = /* @__PURE__ */ createSetCartesian({
  DenseMatrix,
  Index,
  compareNatural,
  size,
  subset,
  typed: typed2
});
var setDistinct = /* @__PURE__ */ createSetDistinct({
  DenseMatrix,
  Index,
  compareNatural,
  size,
  subset,
  typed: typed2
});
var setIsSubset = /* @__PURE__ */ createSetIsSubset({
  Index,
  compareNatural,
  size,
  subset,
  typed: typed2
});
var setPowerset = /* @__PURE__ */ createSetPowerset({
  Index,
  compareNatural,
  size,
  subset,
  typed: typed2
});
var smallerEq = /* @__PURE__ */ createSmallerEq({
  DenseMatrix,
  concat: concat2,
  config: config2,
  matrix,
  typed: typed2
});
var sort = /* @__PURE__ */ createSort({
  compare,
  compareNatural,
  matrix,
  typed: typed2
});
var unequal = /* @__PURE__ */ createUnequal({
  DenseMatrix,
  concat: concat2,
  config: config2,
  equalScalar,
  matrix,
  typed: typed2
});
var and = /* @__PURE__ */ createAnd({
  concat: concat2,
  equalScalar,
  matrix,
  not,
  typed: typed2,
  zeros: zeros2
});
var range = /* @__PURE__ */ createRange({
  bignumber,
  matrix,
  add: add2,
  config: config2,
  isPositive,
  larger,
  largerEq,
  smaller,
  smallerEq,
  typed: typed2
});
var row = /* @__PURE__ */ createRow({
  Index,
  matrix,
  range,
  typed: typed2
});
var setDifference = /* @__PURE__ */ createSetDifference({
  DenseMatrix,
  Index,
  compareNatural,
  size,
  subset,
  typed: typed2
});
var setMultiplicity = /* @__PURE__ */ createSetMultiplicity({
  Index,
  compareNatural,
  size,
  subset,
  typed: typed2
});
var setSymDifference = /* @__PURE__ */ createSetSymDifference({
  Index,
  concat: concat2,
  setDifference,
  size,
  subset,
  typed: typed2
});
var Spa = /* @__PURE__ */ createSpaClass({
  FibonacciHeap,
  addScalar,
  equalScalar
});
var column = /* @__PURE__ */ createColumn({
  Index,
  matrix,
  range,
  typed: typed2
});
var inv = /* @__PURE__ */ createInv({
  abs: abs2,
  addScalar,
  det,
  divideScalar,
  identity,
  matrix,
  multiply,
  typed: typed2,
  unaryMinus
});
var lup = /* @__PURE__ */ createLup({
  DenseMatrix,
  Spa,
  SparseMatrix,
  abs: abs2,
  addScalar,
  divideScalar,
  equalScalar,
  larger,
  matrix,
  multiplyScalar,
  subtractScalar,
  typed: typed2,
  unaryMinus
});
var pinv = /* @__PURE__ */ createPinv({
  Complex: Complex2,
  add: add2,
  ctranspose,
  deepEqual,
  divideScalar,
  dot,
  dotDivide,
  equal,
  inv,
  matrix,
  multiply,
  typed: typed2
});
var pow2 = /* @__PURE__ */ createPow({
  Complex: Complex2,
  config: config2,
  fraction,
  identity,
  inv,
  matrix,
  multiply,
  number,
  typed: typed2
});
var setIntersect = /* @__PURE__ */ createSetIntersect({
  DenseMatrix,
  Index,
  compareNatural,
  size,
  subset,
  typed: typed2
});
var setUnion = /* @__PURE__ */ createSetUnion({
  Index,
  concat: concat2,
  setIntersect,
  setSymDifference,
  size,
  subset,
  typed: typed2
});
var sqrtm = /* @__PURE__ */ createSqrtm({
  abs: abs2,
  add: add2,
  identity,
  inv,
  map: map2,
  max: max2,
  multiply,
  size,
  sqrt: sqrt2,
  subtract,
  typed: typed2
});
var Unit = /* @__PURE__ */ createUnitClass({
  BigNumber,
  Complex: Complex2,
  Fraction: Fraction2,
  abs: abs2,
  addScalar,
  config: config2,
  divideScalar,
  equal,
  fix,
  format: format4,
  isNumeric,
  multiplyScalar,
  number,
  pow: pow2,
  round: round2,
  subtractScalar
});
var vacuumImpedance = /* @__PURE__ */ createVacuumImpedance({
  BigNumber,
  Unit,
  config: config2
});
var wienDisplacement = /* @__PURE__ */ createWienDisplacement({
  BigNumber,
  Unit,
  config: config2
});
var atomicMass = /* @__PURE__ */ createAtomicMass({
  BigNumber,
  Unit,
  config: config2
});
var bohrMagneton = /* @__PURE__ */ createBohrMagneton({
  BigNumber,
  Unit,
  config: config2
});
var boltzmann = /* @__PURE__ */ createBoltzmann({
  BigNumber,
  Unit,
  config: config2
});
var conductanceQuantum = /* @__PURE__ */ createConductanceQuantum({
  BigNumber,
  Unit,
  config: config2
});
var coulomb = /* @__PURE__ */ createCoulomb({
  BigNumber,
  Unit,
  config: config2
});
var deuteronMass = /* @__PURE__ */ createDeuteronMass({
  BigNumber,
  Unit,
  config: config2
});
var dotPow = /* @__PURE__ */ createDotPow({
  DenseMatrix,
  concat: concat2,
  equalScalar,
  matrix,
  pow: pow2,
  typed: typed2
});
var electricConstant = /* @__PURE__ */ createElectricConstant({
  BigNumber,
  Unit,
  config: config2
});
var elementaryCharge = /* @__PURE__ */ createElementaryCharge({
  BigNumber,
  Unit,
  config: config2
});
var expm = /* @__PURE__ */ createExpm({
  abs: abs2,
  add: add2,
  identity,
  inv,
  multiply,
  typed: typed2
});
var faraday = /* @__PURE__ */ createFaraday({
  BigNumber,
  Unit,
  config: config2
});
var fft = /* @__PURE__ */ createFft({
  addScalar,
  ceil: ceil2,
  conj,
  divideScalar,
  dotDivide,
  exp: exp2,
  i,
  log2: log24,
  matrix,
  multiplyScalar,
  pow: pow2,
  tau: tau2,
  typed: typed2
});
var gamma = /* @__PURE__ */ createGamma({
  BigNumber,
  Complex: Complex2,
  config: config2,
  multiplyScalar,
  pow: pow2,
  typed: typed2
});
var gravitationConstant = /* @__PURE__ */ createGravitationConstant({
  BigNumber,
  Unit,
  config: config2
});
var hartreeEnergy = /* @__PURE__ */ createHartreeEnergy({
  BigNumber,
  Unit,
  config: config2
});
var ifft = /* @__PURE__ */ createIfft({
  conj,
  dotDivide,
  fft,
  typed: typed2
});
var klitzing = /* @__PURE__ */ createKlitzing({
  BigNumber,
  Unit,
  config: config2
});
var loschmidt = /* @__PURE__ */ createLoschmidt({
  BigNumber,
  Unit,
  config: config2
});
var magneticConstant = /* @__PURE__ */ createMagneticConstant({
  BigNumber,
  Unit,
  config: config2
});
var molarMass = /* @__PURE__ */ createMolarMass({
  BigNumber,
  Unit,
  config: config2
});
var molarPlanckConstant = /* @__PURE__ */ createMolarPlanckConstant({
  BigNumber,
  Unit,
  config: config2
});
var neutronMass = /* @__PURE__ */ createNeutronMass({
  BigNumber,
  Unit,
  config: config2
});
var nuclearMagneton = /* @__PURE__ */ createNuclearMagneton({
  BigNumber,
  Unit,
  config: config2
});
var planckCharge = /* @__PURE__ */ createPlanckCharge({
  BigNumber,
  Unit,
  config: config2
});
var planckLength = /* @__PURE__ */ createPlanckLength({
  BigNumber,
  Unit,
  config: config2
});
var planckTemperature = /* @__PURE__ */ createPlanckTemperature({
  BigNumber,
  Unit,
  config: config2
});
var protonMass = /* @__PURE__ */ createProtonMass({
  BigNumber,
  Unit,
  config: config2
});
var quantumOfCirculation = /* @__PURE__ */ createQuantumOfCirculation({
  BigNumber,
  Unit,
  config: config2
});
var reducedPlanckConstant = /* @__PURE__ */ createReducedPlanckConstant({
  BigNumber,
  Unit,
  config: config2
});
var rydberg = /* @__PURE__ */ createRydberg({
  BigNumber,
  Unit,
  config: config2
});
var secondRadiation = /* @__PURE__ */ createSecondRadiation({
  BigNumber,
  Unit,
  config: config2
});
var speedOfLight = /* @__PURE__ */ createSpeedOfLight({
  BigNumber,
  Unit,
  config: config2
});
var stefanBoltzmann = /* @__PURE__ */ createStefanBoltzmann({
  BigNumber,
  Unit,
  config: config2
});
var thomsonCrossSection = /* @__PURE__ */ createThomsonCrossSection({
  BigNumber,
  Unit,
  config: config2
});
var avogadro = /* @__PURE__ */ createAvogadro({
  BigNumber,
  Unit,
  config: config2
});
var bohrRadius = /* @__PURE__ */ createBohrRadius({
  BigNumber,
  Unit,
  config: config2
});
var createUnit = /* @__PURE__ */ createCreateUnit({
  Unit,
  typed: typed2
});
var divide2 = /* @__PURE__ */ createDivide({
  divideScalar,
  equalScalar,
  inv,
  matrix,
  multiply,
  typed: typed2
});
var electronMass = /* @__PURE__ */ createElectronMass({
  BigNumber,
  Unit,
  config: config2
});
var factorial = /* @__PURE__ */ createFactorial({
  gamma,
  typed: typed2
});
var firstRadiation = /* @__PURE__ */ createFirstRadiation({
  BigNumber,
  Unit,
  config: config2
});
var gravity = /* @__PURE__ */ createGravity({
  BigNumber,
  Unit,
  config: config2
});
var inverseConductanceQuantum = /* @__PURE__ */ createInverseConductanceQuantum({
  BigNumber,
  Unit,
  config: config2
});
var lusolve = /* @__PURE__ */ createLusolve({
  DenseMatrix,
  lsolve,
  lup,
  matrix,
  slu,
  typed: typed2,
  usolve
});
var magneticFluxQuantum = /* @__PURE__ */ createMagneticFluxQuantum({
  BigNumber,
  Unit,
  config: config2
});
var molarMassC12 = /* @__PURE__ */ createMolarMassC12({
  BigNumber,
  Unit,
  config: config2
});
var multinomial = /* @__PURE__ */ createMultinomial({
  add: add2,
  divide: divide2,
  factorial,
  isInteger: isInteger2,
  isPositive,
  multiply,
  typed: typed2
});
var permutations = /* @__PURE__ */ createPermutations({
  factorial,
  typed: typed2
});
var planckMass = /* @__PURE__ */ createPlanckMass({
  BigNumber,
  Unit,
  config: config2
});
var polynomialRoot = /* @__PURE__ */ createPolynomialRoot({
  add: add2,
  cbrt: cbrt4,
  divide: divide2,
  equalScalar,
  im,
  isZero,
  multiply,
  re,
  sqrt: sqrt2,
  subtract,
  typeOf: typeOf2,
  typed: typed2,
  unaryMinus
});
var setSize = /* @__PURE__ */ createSetSize({
  compareNatural,
  typed: typed2
});
var solveODE = /* @__PURE__ */ createSolveODE({
  abs: abs2,
  add: add2,
  bignumber,
  divide: divide2,
  isNegative,
  isPositive,
  larger,
  map: map2,
  matrix,
  max: max2,
  multiply,
  smaller,
  subtract,
  typed: typed2,
  unaryMinus
});
var stirlingS2 = /* @__PURE__ */ createStirlingS2({
  bignumber,
  addScalar,
  combinations,
  divideScalar,
  factorial,
  isInteger: isInteger2,
  isNegative,
  larger,
  multiplyScalar,
  number,
  pow: pow2,
  subtractScalar,
  typed: typed2
});
var unit = /* @__PURE__ */ createUnitFunction({
  Unit,
  typed: typed2
});
var bellNumbers = /* @__PURE__ */ createBellNumbers({
  addScalar,
  isInteger: isInteger2,
  isNegative,
  stirlingS2,
  typed: typed2
});
var eigs = /* @__PURE__ */ createEigs({
  abs: abs2,
  add: add2,
  addScalar,
  atan: atan3,
  bignumber,
  column,
  complex,
  config: config2,
  cos: cos2,
  diag,
  divideScalar,
  dot,
  equal,
  flatten: flatten2,
  im,
  inv,
  larger,
  matrix,
  matrixFromColumns,
  multiply,
  multiplyScalar,
  number,
  qr,
  re,
  reshape: reshape2,
  sin: sin2,
  size,
  smaller,
  sqrt: sqrt2,
  subtract,
  typed: typed2,
  usolve,
  usolveAll
});
var fermiCoupling = /* @__PURE__ */ createFermiCoupling({
  BigNumber,
  Unit,
  config: config2
});
var gasConstant = /* @__PURE__ */ createGasConstant({
  BigNumber,
  Unit,
  config: config2
});
var kldivergence = /* @__PURE__ */ createKldivergence({
  divide: divide2,
  dotDivide,
  isNumeric,
  log: log3,
  map: map2,
  matrix,
  multiply,
  sum: sum2,
  typed: typed2
});
var mean = /* @__PURE__ */ createMean({
  add: add2,
  divide: divide2,
  typed: typed2
});
var molarVolume = /* @__PURE__ */ createMolarVolume({
  BigNumber,
  Unit,
  config: config2
});
var planckConstant = /* @__PURE__ */ createPlanckConstant({
  BigNumber,
  Unit,
  config: config2
});
var quantileSeq = /* @__PURE__ */ createQuantileSeq({
  bignumber,
  add: add2,
  compare,
  divide: divide2,
  isInteger: isInteger2,
  larger,
  multiply,
  partitionSelect,
  smaller,
  smallerEq,
  subtract,
  typed: typed2
});
var variance = /* @__PURE__ */ createVariance({
  add: add2,
  apply,
  divide: divide2,
  isNaN: isNaN2,
  multiply,
  subtract,
  typed: typed2
});
var classicalElectronRadius = /* @__PURE__ */ createClassicalElectronRadius({
  BigNumber,
  Unit,
  config: config2
});
var median = /* @__PURE__ */ createMedian({
  add: add2,
  compare,
  divide: divide2,
  partitionSelect,
  typed: typed2
});
var corr = /* @__PURE__ */ createCorr({
  add: add2,
  divide: divide2,
  matrix,
  mean,
  multiply,
  pow: pow2,
  sqrt: sqrt2,
  subtract,
  sum: sum2,
  typed: typed2
});
var freqz = /* @__PURE__ */ createFreqz({
  Complex: Complex2,
  add: add2,
  divide: divide2,
  matrix,
  multiply,
  typed: typed2
});
var mad = /* @__PURE__ */ createMad({
  abs: abs2,
  map: map2,
  median,
  subtract,
  typed: typed2
});
var std = /* @__PURE__ */ createStd({
  map: map2,
  sqrt: sqrt2,
  typed: typed2,
  variance
});
var zeta = /* @__PURE__ */ createZeta({
  BigNumber,
  Complex: Complex2,
  add: add2,
  config: config2,
  divide: divide2,
  equal,
  factorial,
  gamma,
  isNegative,
  multiply,
  pi: pi2,
  pow: pow2,
  sin: sin2,
  smallerEq,
  subtract,
  typed: typed2
});
var norm = /* @__PURE__ */ createNorm({
  abs: abs2,
  add: add2,
  conj,
  ctranspose,
  eigs,
  equalScalar,
  larger,
  matrix,
  multiply,
  pow: pow2,
  smaller,
  sqrt: sqrt2,
  typed: typed2
});
var rotationMatrix = /* @__PURE__ */ createRotationMatrix({
  BigNumber,
  DenseMatrix,
  SparseMatrix,
  addScalar,
  config: config2,
  cos: cos2,
  matrix,
  multiplyScalar,
  norm,
  sin: sin2,
  typed: typed2,
  unaryMinus
});
var planckTime = /* @__PURE__ */ createPlanckTime({
  BigNumber,
  Unit,
  config: config2
});
var schur = /* @__PURE__ */ createSchur({
  identity,
  matrix,
  multiply,
  norm,
  qr,
  subtract,
  typed: typed2
});
var rotate = /* @__PURE__ */ createRotate({
  multiply,
  rotationMatrix,
  typed: typed2
});
var sylvester = /* @__PURE__ */ createSylvester({
  abs: abs2,
  add: add2,
  concat: concat2,
  identity,
  index,
  lusolve,
  matrix,
  matrixFromColumns,
  multiply,
  range,
  schur,
  subset,
  subtract,
  transpose,
  typed: typed2
});
var lyap = /* @__PURE__ */ createLyap({
  matrix,
  multiply,
  sylvester,
  transpose,
  typed: typed2
});

// node_modules/mathjs/lib/esm/entry/impureFunctionsAny.generated.js
var math = {};
var mathWithTransform = {};
var classes = {};
var Node = createNode({
  mathWithTransform
});
var ObjectNode = createObjectNode({
  Node
});
var OperatorNode = createOperatorNode({
  Node
});
var ParenthesisNode = createParenthesisNode({
  Node
});
var RelationalNode = createRelationalNode({
  Node
});
var ArrayNode = createArrayNode({
  Node
});
var BlockNode = createBlockNode({
  Node,
  ResultSet
});
var ConditionalNode = createConditionalNode({
  Node
});
var ConstantNode = createConstantNode({
  Node
});
var RangeNode = createRangeNode({
  Node
});
var reviver = createReviver({
  classes
});
var Chain = createChainClass({
  math,
  typed: typed2
});
var FunctionAssignmentNode = createFunctionAssignmentNode({
  Node,
  typed: typed2
});
var chain = createChain({
  Chain,
  typed: typed2
});
var IndexNode = createIndexNode({
  Node,
  size
});
var AccessorNode = createAccessorNode({
  Node,
  subset
});
var AssignmentNode = createAssignmentNode({
  matrix,
  Node,
  subset
});
var SymbolNode = createSymbolNode({
  Unit,
  Node,
  math
});
var FunctionNode = createFunctionNode({
  Node,
  SymbolNode,
  math
});
var parse3 = createParse({
  AccessorNode,
  ArrayNode,
  AssignmentNode,
  BlockNode,
  ConditionalNode,
  ConstantNode,
  FunctionAssignmentNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  RangeNode,
  RelationalNode,
  SymbolNode,
  config: config2,
  numeric: numeric2,
  typed: typed2
});
var resolve = createResolve({
  ConstantNode,
  FunctionNode,
  OperatorNode,
  ParenthesisNode,
  parse: parse3,
  typed: typed2
});
var simplifyConstant = createSimplifyConstant({
  bignumber,
  fraction,
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  SymbolNode,
  config: config2,
  mathWithTransform,
  matrix,
  typed: typed2
});
var compile = createCompile({
  parse: parse3,
  typed: typed2
});
var simplifyCore = createSimplifyCore({
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  add: add2,
  divide: divide2,
  equal,
  isZero,
  multiply,
  parse: parse3,
  pow: pow2,
  subtract,
  typed: typed2
});
var evaluate = createEvaluate({
  parse: parse3,
  typed: typed2
});
var Help = createHelpClass({
  evaluate
});
var Parser = createParserClass({
  evaluate
});
var simplify = createSimplify({
  bignumber,
  fraction,
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  add: add2,
  config: config2,
  divide: divide2,
  equal,
  isZero,
  mathWithTransform,
  matrix,
  multiply,
  parse: parse3,
  pow: pow2,
  resolve,
  simplifyConstant,
  simplifyCore,
  subtract,
  typed: typed2
});
var symbolicEqual = createSymbolicEqual({
  OperatorNode,
  parse: parse3,
  simplify,
  typed: typed2
});
var leafCount = createLeafCount({
  parse: parse3,
  typed: typed2
});
var parser = createParser({
  Parser,
  typed: typed2
});
var rationalize = createRationalize({
  bignumber,
  fraction,
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  add: add2,
  config: config2,
  divide: divide2,
  equal,
  isZero,
  mathWithTransform,
  matrix,
  multiply,
  parse: parse3,
  pow: pow2,
  simplify,
  simplifyConstant,
  simplifyCore,
  subtract,
  typed: typed2
});
var derivative = createDerivative({
  ConstantNode,
  FunctionNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  config: config2,
  equal,
  isZero,
  numeric: numeric2,
  parse: parse3,
  simplify,
  typed: typed2
});
var help = createHelp({
  Help,
  mathWithTransform,
  typed: typed2
});
_extends(math, {
  e: e2,
  false: _false,
  fineStructure,
  i,
  Infinity: _Infinity,
  LN10: LN102,
  LOG10E,
  NaN: _NaN,
  null: _null,
  phi: phi2,
  SQRT1_2,
  sackurTetrode,
  tau: tau2,
  true: _true,
  "E": e2,
  version: version3,
  efimovFactor,
  LN2,
  pi: pi2,
  replacer,
  reviver,
  SQRT2,
  typed: typed2,
  "PI": pi2,
  weakMixingAngle,
  abs: abs2,
  acos: acos2,
  acot,
  acsc,
  addScalar,
  arg,
  asech,
  asinh: asinh3,
  atan: atan3,
  atanh: atanh3,
  bigint,
  bitNot,
  boolean,
  clone: clone4,
  combinations,
  complex,
  conj,
  cos: cos2,
  cot,
  csc,
  cube,
  equalScalar,
  erf,
  exp: exp2,
  expm1: expm13,
  filter: filter2,
  forEach: forEach2,
  format: format4,
  getMatrixDataType,
  hex,
  im,
  isInteger: isInteger2,
  isNegative,
  isPositive,
  isZero,
  LOG2E,
  lgamma,
  log10: log104,
  log2: log24,
  map: map2,
  multiplyScalar,
  not,
  number,
  oct,
  pickRandom,
  print,
  random: random2,
  re,
  sec,
  sign: sign3,
  sin: sin2,
  splitUnit,
  square,
  string,
  subtractScalar,
  tan: tan2,
  typeOf: typeOf2,
  acosh: acosh3,
  acsch,
  apply,
  asec,
  bignumber,
  chain,
  combinationsWithRep,
  cosh: cosh3,
  csch,
  isNaN: isNaN2,
  isPrime,
  randomInt,
  sech,
  sinh: sinh3,
  sparse,
  sqrt: sqrt2,
  tanh: tanh3,
  unaryMinus,
  acoth,
  bin,
  coth,
  fraction,
  isNumeric,
  matrix,
  matrixFromFunction,
  mode,
  numeric: numeric2,
  prod,
  reshape: reshape2,
  size,
  squeeze: squeeze2,
  transpose,
  xgcd,
  zeros: zeros2,
  asin: asin2,
  cbrt: cbrt4,
  concat: concat2,
  count,
  ctranspose,
  diag,
  divideScalar,
  dotDivide,
  equal,
  flatten: flatten2,
  hasNumericValue,
  identity,
  kron,
  largerEq,
  leftShift,
  lsolve,
  matrixFromColumns,
  nthRoot,
  ones,
  qr,
  resize: resize2,
  rightArithShift,
  round: round2,
  smaller,
  subtract,
  to,
  unaryPlus,
  usolve,
  xor,
  add: add2,
  atan2: atan22,
  bitAnd,
  bitOr,
  bitXor: bitXor2,
  catalan,
  compare,
  compareText: compareText2,
  cumsum,
  deepEqual,
  diff,
  distance,
  dot,
  equalText,
  floor: floor2,
  gcd: gcd2,
  hypot: hypot2,
  larger,
  log: log3,
  lsolveAll,
  matrixFromRows,
  min: min2,
  mod: mod2,
  multiply,
  nthRoots,
  or,
  partitionSelect,
  rightLogShift,
  slu,
  subset,
  sum: sum2,
  trace,
  usolveAll,
  zpk2tf,
  ceil: ceil2,
  compareNatural,
  composition,
  cross,
  det,
  dotMultiply,
  fix,
  index,
  intersect,
  invmod,
  lcm,
  log1p: log1p2,
  max: max2,
  setCartesian,
  setDistinct,
  setIsSubset,
  setPowerset,
  smallerEq,
  sort,
  unequal,
  and,
  range,
  row,
  setDifference,
  setMultiplicity,
  setSymDifference,
  column,
  inv,
  lup,
  pinv,
  pow: pow2,
  setIntersect,
  setUnion,
  sqrtm,
  vacuumImpedance,
  wienDisplacement,
  atomicMass,
  bohrMagneton,
  boltzmann,
  conductanceQuantum,
  coulomb,
  deuteronMass,
  dotPow,
  electricConstant,
  elementaryCharge,
  expm,
  faraday,
  fft,
  gamma,
  gravitationConstant,
  hartreeEnergy,
  ifft,
  klitzing,
  loschmidt,
  magneticConstant,
  molarMass,
  molarPlanckConstant,
  neutronMass,
  nuclearMagneton,
  planckCharge,
  planckLength,
  planckTemperature,
  protonMass,
  quantumOfCirculation,
  reducedPlanckConstant,
  rydberg,
  secondRadiation,
  speedOfLight,
  stefanBoltzmann,
  thomsonCrossSection,
  avogadro,
  bohrRadius,
  createUnit,
  divide: divide2,
  electronMass,
  factorial,
  firstRadiation,
  gravity,
  inverseConductanceQuantum,
  lusolve,
  magneticFluxQuantum,
  molarMassC12,
  multinomial,
  parse: parse3,
  permutations,
  planckMass,
  polynomialRoot,
  resolve,
  setSize,
  simplifyConstant,
  solveODE,
  stirlingS2,
  unit,
  bellNumbers,
  compile,
  eigs,
  fermiCoupling,
  gasConstant,
  kldivergence,
  mean,
  molarVolume,
  planckConstant,
  quantileSeq,
  simplifyCore,
  variance,
  classicalElectronRadius,
  evaluate,
  median,
  simplify,
  symbolicEqual,
  corr,
  freqz,
  leafCount,
  mad,
  parser,
  rationalize,
  std,
  zeta,
  derivative,
  norm,
  rotationMatrix,
  help,
  planckTime,
  schur,
  rotate,
  sylvester,
  lyap,
  config: config2
});
_extends(mathWithTransform, math, {
  filter: createFilterTransform({
    typed: typed2
  }),
  forEach: createForEachTransform({
    typed: typed2
  }),
  map: createMapTransform({
    typed: typed2
  }),
  apply: createApplyTransform({
    isInteger: isInteger2,
    typed: typed2
  }),
  or: createOrTransform({
    DenseMatrix,
    concat: concat2,
    equalScalar,
    matrix,
    typed: typed2
  }),
  and: createAndTransform({
    add: add2,
    concat: concat2,
    equalScalar,
    matrix,
    not,
    typed: typed2,
    zeros: zeros2
  }),
  concat: createConcatTransform({
    isInteger: isInteger2,
    matrix,
    typed: typed2
  }),
  max: createMaxTransform({
    config: config2,
    larger,
    numeric: numeric2,
    typed: typed2
  }),
  print: createPrintTransform({
    add: add2,
    matrix,
    typed: typed2,
    zeros: zeros2
  }),
  bitAnd: createBitAndTransform({
    add: add2,
    concat: concat2,
    equalScalar,
    matrix,
    not,
    typed: typed2,
    zeros: zeros2
  }),
  diff: createDiffTransform({
    bignumber,
    matrix,
    number,
    subtract,
    typed: typed2
  }),
  min: createMinTransform({
    config: config2,
    numeric: numeric2,
    smaller,
    typed: typed2
  }),
  subset: createSubsetTransform({
    add: add2,
    matrix,
    typed: typed2,
    zeros: zeros2
  }),
  bitOr: createBitOrTransform({
    DenseMatrix,
    concat: concat2,
    equalScalar,
    matrix,
    typed: typed2
  }),
  cumsum: createCumSumTransform({
    add: add2,
    typed: typed2,
    unaryPlus
  }),
  index: createIndexTransform({
    Index,
    getMatrixDataType
  }),
  sum: createSumTransform({
    add: add2,
    config: config2,
    numeric: numeric2,
    typed: typed2
  }),
  range: createRangeTransform({
    bignumber,
    matrix,
    add: add2,
    config: config2,
    isPositive,
    larger,
    largerEq,
    smaller,
    smallerEq,
    typed: typed2
  }),
  row: createRowTransform({
    Index,
    matrix,
    range,
    typed: typed2
  }),
  column: createColumnTransform({
    Index,
    matrix,
    range,
    typed: typed2
  }),
  mean: createMeanTransform({
    add: add2,
    divide: divide2,
    typed: typed2
  }),
  quantileSeq: createQuantileSeqTransform({
    add: add2,
    bignumber,
    compare,
    divide: divide2,
    isInteger: isInteger2,
    larger,
    multiply,
    partitionSelect,
    smaller,
    smallerEq,
    subtract,
    typed: typed2
  }),
  variance: createVarianceTransform({
    add: add2,
    apply,
    divide: divide2,
    isNaN: isNaN2,
    multiply,
    subtract,
    typed: typed2
  }),
  std: createStdTransform({
    map: map2,
    sqrt: sqrt2,
    typed: typed2,
    variance
  })
});
_extends(classes, {
  BigNumber,
  Complex: Complex2,
  Fraction: Fraction2,
  Matrix,
  Node,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  Range,
  RelationalNode,
  ResultSet,
  ArrayNode,
  BlockNode,
  ConditionalNode,
  ConstantNode,
  DenseMatrix,
  RangeNode,
  Chain,
  FunctionAssignmentNode,
  SparseMatrix,
  IndexNode,
  ImmutableDenseMatrix,
  Index,
  AccessorNode,
  AssignmentNode,
  FibonacciHeap,
  Spa,
  Unit,
  SymbolNode,
  FunctionNode,
  Help,
  Parser
});
Chain.createProxy(math);

// src/ui/views/copilot/evaluateCalc.ts
function evaluateCalcExpression(expression) {
  let sanitizedExpression = expression.replace(/calc\(|\)/g, "");
  if (sanitizedExpression.contains("%")) {
    sanitizedExpression = sanitizedExpression.replace("%", "");
    const res = Math.round(evaluate(sanitizedExpression));
    return res + "%";
  } else {
    return Math.round(evaluate(sanitizedExpression)).toString();
  }
}
function evaluateCalcInColorString(colorString) {
  const calcRegex = /calc\(([^)]+)\)/g;
  const matches = colorString.match(calcRegex);
  if (!matches)
    return colorString;
  let evaluatedColorString = colorString;
  matches.forEach((match) => {
    const evaluatedValue = evaluateCalcExpression(match);
    evaluatedColorString = evaluatedColorString.replace(
      match,
      evaluatedValue.toString()
    );
  });
  return evaluatedColorString;
}

// src/ui/views/copilot/theme.ts
function cssColorToArgb(color) {
  function rgbaToArgb(r, g, b, a) {
    r = Math.max(0, Math.min(255, r));
    g = Math.max(0, Math.min(255, g));
    b = Math.max(0, Math.min(255, b));
    a = Math.max(0, Math.min(255));
    const argb = a << 24 | r << 16 | g << 8 | b;
    return argb;
  }
  const noCalc = evaluateCalcInColorString(color).replace(/[\n]+/g, "");
  const rgbaValues = rgba(noCalc);
  for (let i2 = 0; i2 < rgbaValues.length; i2++) {
    if (i2 === 3) {
      rgbaValues[i2] = Math.round(rgbaValues[i2] * 255);
    } else {
      rgbaValues[i2] = Math.round(rgbaValues[i2]);
    }
  }
  if (!rgbaValues.length)
    throw new Error("unsupported color " + color);
  return rgbaToArgb(rgbaValues[0], rgbaValues[1], rgbaValues[2], rgbaValues[3]);
}
function getTheme() {
  const style = getComputedStyle(document.body);
  const darkMode = document.body.classList.contains("theme-dark");
  try {
    const theme2 = {
      darkMode,
      error: cssColorToArgb(style.getPropertyValue("--text-error")),
      onPrimary: cssColorToArgb(style.getPropertyValue("--text-normal")),
      onSecondary: cssColorToArgb(style.getPropertyValue("--text-normal")),
      onSurface: cssColorToArgb(style.getPropertyValue("--text-normal")),
      primary: cssColorToArgb(style.getPropertyValue("--text-normal")),
      primaryContainer: cssColorToArgb(
        style.getPropertyValue("--background-modifier-border-hover")
      ),
      scaffoldBackgroundColor: cssColorToArgb(
        style.getPropertyValue("--background-secondary")
      ),
      secondary: cssColorToArgb(
        style.getPropertyValue("--background-modifier-border")
      ),
      surface: cssColorToArgb(style.getPropertyValue("--interactive-normal"))
    };
    return theme2;
  } catch (e3) {
    console.log(e3);
    return {
      darkMode
    };
  }
}

// src/ui/views/copilot/globals.ts
function createEl(parent, tagName) {
  const el = document.createElement(tagName);
  parent.appendChild(el);
  return el;
}
function addClass(el, className) {
  el.classList.add(className);
}
function createDiv(parent, className) {
  const el = createEl(parent, "div");
  if (className)
    addClass(el, className);
  return el;
}
function emptyEl(el) {
  el.innerHTML = "";
}

// src/ui/views/copilot/errorView.ts
var showErorrView = (title) => {
  const container = document.getElementById("gpt-tab");
  const errorViewContainer = createDiv(container);
  errorViewContainer.classList.add(
    "flex",
    "flex-col",
    "w-full",
    "h-full",
    "py-10",
    "px-4",
    "text-center",
    "text-[var(--pieces-text-muted)]",
    "justify-center"
  );
  errorViewContainer.id = "copilot-error-view";
  const darkMode = getTheme().darkMode;
  const imgDiv = createDiv(errorViewContainer);
  imgDiv.classList.add("flex", "justify-center");
  const img = createEl(imgDiv, "div");
  img.classList.add(
    darkMode ? "guy-asleep-dm" : "guy-asleep-lm",
    "h-32",
    "w-32",
    "bg-contain",
    "bg-no-repeat"
  );
  const loadTxtContainer = createDiv(errorViewContainer);
  loadTxtContainer.classList.add("px-2", "text-lg", "font-bold");
  const loadTxtP = createEl(loadTxtContainer, "p");
  loadTxtP.classList.add("m-0");
  loadTxtP.innerText = title;
  const expText = createDiv(errorViewContainer);
  expText.classList.add("pt-4", "px-2", "font-semibold", "break-words");
  expText.innerHTML = "Please make sure that Pieces OS is running, and up to date to use the Pieces Copilot! If the issue persists, please ";
  const contactSupportBtn = createEl(expText, "a");
  contactSupportBtn.classList.add("underline", "cursor-pointer");
  contactSupportBtn.onclick = () => {
    copilotParams.openLink(
      "https://getpieces.typeform.com/to/mCjBSIjF#page=vscode-plugin"
    );
  };
  contactSupportBtn.innerText = "contact support";
  const launchBtnDiv = createDiv(errorViewContainer);
  launchBtnDiv.classList.add(
    "pt-4",
    "flex-row",
    "gap-2",
    "flex",
    "justify-center"
  );
  const launchBtn = createEl(launchBtnDiv, "button");
  launchBtn.classList.add(
    `vs-btn-${darkMode ? "dark" : "light"}`,
    "p-2",
    "rounded",
    "vs-btn",
    "shadow-sm",
    "shadow-[var(--pieces-background-modifier-box-shadow)]",
    "w-fit"
  );
  launchBtn.innerText = "Launch";
  launchBtn.onclick = () => {
    launchPos();
  };
  const installBtn = createEl(launchBtnDiv, "button");
  installBtn.classList.add(
    `vs-btn-${darkMode ? "dark" : "light"}`,
    "p-2",
    "rounded",
    "vs-btn",
    "shadow-sm",
    "shadow-[var(--pieces-background-modifier-box-shadow)]",
    "w-fit"
  );
  installBtn.innerText = "Install";
  installBtn.onclick = () => {
    window.open(
      "https://docs.pieces.app/installation-getting-started/what-am-i-installing"
    );
  };
};

// src/ui/views/copilot/PiecesOSUpdating.ts
var PiecesOSUpdating = class {
  constructor() {
  }
  /**
   * This will render the 'Pieces OS is updating' ui & update pieces os
   * @returns a promise which is resolved after timing out, or after pieces os has successfully been updated
   */
  async performUpdate() {
    const container = document.getElementById(
      "gpt-tab"
    );
    if (!container)
      throw new Error("gpt-tab id is missing");
    emptyEl(container);
    container.classList.add(
      "w-full",
      "h-full",
      "flex",
      "flex-col",
      "py-10",
      "justify-center",
      "items-center",
      "bg-[var(--background-primary)]",
      "text-center",
      "text-[var(--text-muted)]",
      "px-4",
      "gap-2"
    );
    const titleEl = createDiv(container);
    titleEl.classList.add("px-2", "text-lg", "font-bold");
    titleEl.innerText = "Pieces OS is Updating!";
    const expText = createDiv(container);
    expText.classList.add("px-2", "font-semibold", "break-words");
    expText.innerHTML = "Please wait while the latest version of Pieces OS is downloaded and installed! This should only take a few minutes.";
    const statusEl = createDiv(container);
    statusEl.classList.add("font-bold");
    statusEl.innerText = "Checking for updates...";
    const progressContainer = createDiv(container);
    progressContainer.classList.add("w-1/2", "self-center");
    let resolve2;
    const ret = new Promise((res) => {
      resolve2 = res;
    });
    const intervalId = setInterval(async () => {
      const status = await ConnectorSingleton.getInstance().osApi.osUpdateCheck({ uncheckedOSServerUpdate: {} }).catch(() => {
        return null;
      });
      statusEl.innerText = this.getStatusText(status?.status);
      if (status?.status === UpdatingStatusEnum.ReadyToRestart) {
        clearInterval(intervalId);
        statusEl.innerText = "Restarting to apply the update";
        ConnectorSingleton.getInstance().osApi.osRestart();
        this.pollForConnection(resolve2);
      }
    }, 3e3);
    setTimeout(() => {
      clearInterval(intervalId);
      resolve2(false);
    }, 10 * 60 * 1e3);
    return ret;
  }
  /**
   * This will poll for a connection to pieces os (after the connection is lost due to restarting)
   * & resolve the updater promise when it has found a connection
   * if it doesn't find a connection after 5 minutes it will cancel the task
   * @param resolver the function to resolve the updater promise
   * @param removeMouseMoveListener function to remove the mouse move listener from the svg
   */
  async pollForConnection(resolver) {
    let timeoutId = void 0;
    const intervalId = setInterval(async () => {
      const connected = await ConnectorSingleton.getInstance().wellKnownApi.getWellKnownHealth().then(() => true).catch(() => false);
      if (connected) {
        clearInterval(intervalId);
        resolver(true);
        clearTimeout(timeoutId);
      }
    }, 500);
    timeoutId = setTimeout(() => {
      clearInterval(intervalId);
      resolver(false);
    }, 5 * 60 * 1e3);
  }
  isInProgressStatus(status) {
    return [
      UpdatingStatusEnum.Available,
      UpdatingStatusEnum.ReadyToRestart,
      UpdatingStatusEnum.Downloading
    ].includes(status);
  }
  /**
   * This converts UpdatingStatusEnum to a more user friendly format
   * @param status the status from the os update check endpoint
   * @returns readable text to represent the status
   */
  getStatusText(status) {
    switch (status) {
      case UpdatingStatusEnum.Available:
        return "Update detected...";
      case UpdatingStatusEnum.ContactSupport:
        return "Something went wrong. Please contact support at https://docs.pieces.app/support";
      case UpdatingStatusEnum.Downloading:
        return "Update is downloading...";
      case UpdatingStatusEnum.ReadyToRestart:
        return "Restarting to apply the update...";
      case UpdatingStatusEnum.ReinstallRequired:
        return "You need to reinstall Pieces OS for this feature to work!";
      case UpdatingStatusEnum.Unknown:
        return "Unknown status";
      case UpdatingStatusEnum.UpToDate:
        return "Pieces OS is up to date.";
      case void 0:
        return "Failed to get update status, please contact support at https://docs.pieces.app/support";
    }
  }
  static getInstance() {
    return this.instance ?? (this.instance = new PiecesOSUpdating());
  }
};

// src/ui/views/copilot/index.ts
async function initCopilot() {
  connectionPoller();
  const iframe = document.createElement("iframe");
  iframe.id = "pieces-copilot";
  iframe.name = "pieces-copilot";
  iframe.setAttribute(
    "style",
    "width: 100%; height: 100%; margin: 0px; overflow: hidden; border: none;"
  );
  iframe.setAttribute("allow", "clipboard-read; clipboard-write;");
  const url = await getCopilotUrl();
  iframe.src = url.href;
  document.getElementById("gpt-tab")?.appendChild(iframe);
  const setTheme = () => {
    iframe.contentWindow?.postMessage(
      {
        type: "setTheme",
        destination: "webview",
        data: getTheme()
      },
      "*"
    );
  };
  const observer = new MutationObserver(() => {
    setTheme();
  });
  app.workspace.on("css-change", () => {
    setTheme();
  });
  observer.observe(document.body, { attributes: true });
}
var messageMap = /* @__PURE__ */ new Map();
var port = navigator.userAgent.toLowerCase().includes("linux") ? 5323 : 1e3;
var resolveLoading;
var loadingPromise = new Promise(
  (resolve2) => resolveLoading = resolve2
);
var minimumVersion = "10.0.0";
var maximumVersion = "11.0.0";
function launchPos() {
  launchRuntime();
}
async function handleWebviewMessage(event) {
  if (event.data.type === "displayNotification") {
    const params = {
      actions: event.data.data.actions,
      message: event.data.data.message,
      title: event.data.data.title,
      type: event.data.data.type === "warning" ? "warn" : event.data.data.type === "success" || event.data.data.type === "information" ? "info" : "error"
    };
    copilotParams.sendNotification(params);
    return;
  }
  if (event.data.type === "corsProxy") {
    const res = await copilotParams.corsProxyFetch?.(
      event.data.data.url,
      event.data.data.options
    );
    const response = {
      type: "corsProxy",
      data: res?.content ?? "",
      destination: "webview",
      responseId: event.data.responseId
    };
    return postToFrame(response);
  }
  if (event.data.type === "copyToClipboard") {
    window.navigator.clipboard.writeText(event.data.data);
    return;
  }
  let timeoutId = void 0;
  if (event.data.type === "persistState") {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      copilotParams.saveState(JSON.stringify(event.data.data));
    }, 200);
    return;
  }
  if (event.data.type === "insertAtCursor") {
    if (typeof event.data.data !== "string")
      throw new Error("invalid insert at cursor data");
    copilotParams.insertAtCursor(event.data.data);
  }
  if (event.data.type === "previewAsset") {
    DisplayController.createExpandedView({
      snippetId: event.data.data,
      snippetTitle: PiecesCacheSingleton.getInstance().mappedAssets[event.data.data ?? ""].title || ""
    });
  }
  if (event.data.type === "openSettings") {
    app.setting.open();
    app.setting.openTabById("pieces-for-developers");
  }
  if (event.data.type === "launchPos") {
    launchPos();
  }
}
async function postToFrame(message) {
  const iframe = document.getElementById(
    "pieces-copilot"
  );
  if (!iframe)
    throw new Error("pieces-copilot id is missing on the iframe");
  await loadingPromise;
  iframe.contentWindow?.postMessage(message, "*");
}
async function handleMessage(event) {
  if (event.data.type === "loaded") {
    resolveLoading();
  }
  if (event.data.destination === "extension")
    handleWebviewMessage(event);
  if (event.data.action === "addAnchorToContext") {
    return postToFrame({
      type: "addToContext",
      data: event.data.directory ? {
        action: "addAnchorsToContext",
        directories: [event.data.path],
        files: []
      } : {
        action: "addAnchorsToContext",
        files: [event.data.path],
        directories: []
      },
      destination: "webview"
    });
  }
  if (event.data.action === "addSnippetToContext") {
    return postToFrame({
      type: "addToContext",
      data: {
        action: "addSnippetsToContext",
        assets: [event.data.asset]
      },
      destination: "webview"
    });
  }
  const message = event.data;
  if (message.type === "performQuery") {
    postToFrame({
      type: "askCopilot",
      data: message.data,
      destination: "webview"
    });
    return;
  }
  const id = message.id;
  const handler = messageMap.get(id);
  if (message.error) {
    handler?.reject(message.error);
  } else {
    handler?.resolve(message.data);
  }
  messageMap.delete(id);
}
async function checkForConnection() {
  return ConnectorSingleton.getInstance().wellKnownApi.getWellKnownHealth().then(() => true).catch(() => false);
}
async function setIframeUrl() {
  const iframe = document.getElementById(
    "pieces-copilot"
  );
  if (!iframe)
    throw new Error("Iframe is not present");
  const url = await getCopilotUrl();
  iframe.src = url.href;
}
async function connectionPoller() {
  const connected = await checkForConnection();
  let version4 = await ConnectorSingleton.getInstance().wellKnownApi.getWellKnownVersion().catch(() => null);
  version4 = version4?.replace("-staging", "") ?? null;
  const isStaging = version4?.includes("staging");
  const isDebug = version4?.includes("debug");
  if (!isStaging && !isDebug) {
    if (version4 && semver.lt(version4, minimumVersion)) {
      document.getElementById("gpt-tab")?.classList.remove("!hidden");
      document.getElementById("pieces-copilot")?.classList.add("!hidden");
      if (semver.lt(version4, "9.0.2"))
        showErorrView("Please Update Pieces OS!");
      else
        await PiecesOSUpdating.getInstance().performUpdate();
    }
    if (version4 && semver.gte(version4, maximumVersion)) {
      document.getElementById("gpt-tab")?.classList.remove("!hidden");
      document.getElementById("pieces-copilot")?.classList.add("!hidden");
      showErorrView(
        `The Pieces for VS Code extension needs to be updated in order to work with Pieces OS version >= ${maximumVersion}`
      );
    }
  }
  if (!connected) {
    document.getElementById("pieces-copilot")?.classList.add("!hidden");
    if (!document.getElementById("copilot-error-view"))
      showErorrView("Pieces OS is not running!");
  } else if (document.getElementById("pieces-copilot")?.classList.contains("!hidden")) {
    document.getElementById("copilot-error-view")?.remove();
    document.getElementById("pieces-copilot")?.classList.remove("!hidden");
    setIframeUrl();
  }
  await new Promise((res) => setTimeout(res, 5e3));
  return connectionPoller();
}
async function getCopilotUrl() {
  const application = await copilotParams.getApplication();
  const baseUrl = await ConnectorSingleton.getInstance().osApi.osAppletLaunch({
    inactiveOSServerApplet: {
      type: OSAppletEnum.Copilot,
      parent: application
    }
  });
  const url = new URL(`http://localhost:${baseUrl.port}`);
  const theme2 = getTheme();
  url.searchParams.append("theme", JSON.stringify(theme2));
  url.searchParams.append("application", JSON.stringify(application));
  url.searchParams.append(
    "capabilities",
    (1 /* insertAtCursor */ | 2 /* askCopilot */ | 8 /* displayNotification */ | 16 /* persistState */ | 256 /* launchPos */ | 1024 /* corsProxy */ | 2048 /* setTheme */ | 4096 /* addToContext */ | 8192 /* copyToClipboard */ | 16384 /* loaded */ | 32 /* previewAsset */ | 64 /* openSettings */).toString()
  );
  if (copilotState)
    url.searchParams.append("state", copilotState);
  return url;
}
window.addEventListener("message", handleMessage);

// src/ui/views/pieces-snippet-list-view.ts
var PiecesSnippetListView = class extends import_obsidian19.ItemView {
  // Current Tab that is selected
  constructor(leaf) {
    super(leaf);
    this.cache = PiecesCacheSingleton.getInstance();
  }
  getViewType() {
    return Constants.PIECES_SNIPPET_LIST_VIEW_TYPE;
  }
  getIcon() {
    return "pieces_logo";
  }
  getDisplayText() {
    return "Pieces for Developers";
  }
  async changeViews(event, parentDiv, snippetsTab, gptTab, navTab) {
    if (event.target != this.currentTab) {
      if (event.target == navTab.children[1]) {
        navTab.children[0].checked = true;
        navTab.children[2].checked = false;
        this.currentTab = navTab.children[1];
      } else if (event.target == navTab.children[3]) {
        navTab.children[0].checked = false;
        navTab.children[2].checked = true;
        this.currentTab = navTab.children[3];
      }
      if (navTab.children[0].checked) {
        gptTab.style.display = "none";
        snippetsTab.style.display = "block";
      } else if (navTab.children[2].checked) {
        snippetsTab.style.display = "none";
        gptTab.style.display = "flex";
      }
    }
  }
  async onOpen() {
    this.containerVar = this.containerEl.children[1];
    this.containerVar.empty();
    const snippets = this.cache.assets;
    const wrapper = renderNavBar({ containerVar: this.containerVar });
    this.navTab = wrapper.children[0];
    this.currentTab = this.navTab.children[1];
    this.parentDiv = this.containerVar.createEl("div");
    this.parentDiv.classList.add("flex", "flex-col", "w-full", "h-full");
    this.parentDiv.id = "pieces-parent";
    this.snippetsTab = this.parentDiv.createDiv();
    this.snippetsTab.classList.add("flex", "flex-col", "w-full", "h-full");
    this.snippetsTab.id = "snippets-tab";
    this.gptTab = this.parentDiv.createDiv();
    this.gptTab.id = "gpt-tab";
    this.gptTab.classList.add("pt-6", "relative", "w-full", "h-full");
    this.navTab.addEventListener("click", (event) => {
      this.changeViews(
        event,
        this.parentDiv,
        this.snippetsTab,
        this.gptTab,
        this.navTab
      );
    });
    if (this.navTab.children[0].checked) {
      DisplayController.createSnippetListView({
        containerVar: this.snippetsTab,
        snippets,
        viewType: "newest" /* RECENT */
      });
      initCopilot();
      this.gptTab.style.display = "none";
    } else if (this.navTab.children[2].checked) {
      initCopilot();
      DisplayController.createSnippetListView({
        containerVar: this.snippetsTab,
        snippets,
        viewType: "newest" /* RECENT */
      });
      this.snippetsTab.style.display = "none";
    }
  }
  async onClose() {
    this.containerVar.empty();
    this.navTab.removeEventListener("click", async (event) => {
      this.changeViews(
        event,
        this.parentDiv,
        this.snippetsTab,
        this.gptTab,
        this.navTab
      );
    });
  }
};

// src/ui/plugins/CodeDetectionPlugin.ts
var import_view2 = require("@codemirror/view");
var import_state = require("@codemirror/state");
var import_language = require("@codemirror/language");

// src/ui/plugins/SaveToPiecesWidget.ts
var import_view = require("@codemirror/view");
var import_obsidian21 = require("obsidian");

// src/actions/auto_link.ts
var AutoLinker = class {
  /*
  	Initialize code block search
  */
  static async findCode() {
    if (this.findingCode) {
      return;
    }
    this._findCode().then(() => {
      this.linkCode("nothing");
    });
  }
  /*
  	Setter in order to relate a code snippet to a file path
  */
  static setSeedToPath(code, path) {
    this.seedToPath[code.substring(this.KEY_SUBSTR_LEN)] = path;
  }
  /*
  	Getter in order to relate a code snippet to a file path
  */
  static getSeedToPath(code) {
    return this.seedToPath[code.substring(this.KEY_SUBSTR_LEN)];
  }
  /*
  	Private runner to parse the markdown in order to find the code.
  	- uses regex to find code fences within the markdown and appends them to this.codeBlocks
  */
  static async _findCode() {
    this.codeBlocks = [];
    this.findingCode = true;
    const vault = app.vault;
    const allFiles = vault.getMarkdownFiles();
    for (let i2 = 0; i2 < allFiles.length; i2++) {
      const data = await vault.read(allFiles[i2]);
      let match;
      while ((match = this.fence_regex.exec(data)) !== null) {
        const [, lang, code] = match;
        code.trim();
        this.codeBlocks.push({
          codeBlock: {
            lang,
            code
          },
          path: allFiles[i2].path
        });
        this.setSeedToPath(code, allFiles[i2]);
        await sleep(this.CODE_FENCE_SEARCH_WAIT);
      }
    }
    this.findingCode = false;
  }
  /*
  	Pass in a code block and receive a list of paths to the relevant snippets
  	- uses all of the code blocks in this.codeBlocks as the NCS search space
  	- calls /relevance with the inputted code block as the query.
  */
  static async linkCode(code) {
    const config5 = ConnectorSingleton.getInstance();
    const relevanceParams = {
      qGPTRelevanceInput: {
        query: code,
        seeds: {
          iterable: []
        }
      }
    };
    for (let i2 = 0; i2 < this.codeBlocks.length; i2++) {
      const currentSeed = {
        type: SeedTypeEnum.Asset,
        asset: {
          application: config5.context.application,
          format: {
            fragment: {
              string: { raw: this.codeBlocks[i2].codeBlock.code },
              metadata: {
                ext: langExtToClassificationSpecificEnum(
                  this.codeBlocks[i2].codeBlock.lang
                )
              }
            }
          }
        }
      };
      relevanceParams.qGPTRelevanceInput.seeds.iterable.push(currentSeed);
    }
    const relevant = await config5.QGPTApi.relevance(relevanceParams);
    const paths = /* @__PURE__ */ new Set();
    for (let i2 = 0; i2 < relevant.relevant.iterable.length && i2 < 5; i2++) {
      const raw = relevant.relevant.iterable[i2].seed?.asset?.format.fragment?.string?.raw;
      if (!raw)
        continue;
      paths.add(this.getSeedToPath(raw));
    }
    return paths;
  }
  constructor() {
  }
};
AutoLinker.fence_regex = /```([\w-]+)(?::[\s\S]*?)?\n([\s\S]*?)```/g;
AutoLinker.codeBlocks = [];
AutoLinker.CODE_FENCE_SEARCH_WAIT = 50;
AutoLinker.KEY_SUBSTR_LEN = 100;
AutoLinker.seedToPath = {};
AutoLinker.findingCode = false;

// src/actions/expiring_map.ts
var ExpirationMinutes = 5;
var ExpiringMap = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  set(key, value, expirationTimeMs = ExpirationMinutes * 60 * 1e3) {
    const expirationTime = Date.now() + expirationTimeMs;
    this.map.set(key, { value, expirationTime });
    setTimeout(() => {
      this.delete(key);
    }, expirationTimeMs);
  }
  get(key) {
    const entry = this.map.get(key);
    if (entry && entry.expirationTime > Date.now()) {
      return entry.value;
    }
    this.delete(key);
    return void 0;
  }
  delete(key) {
    this.map.delete(key);
  }
  clear() {
    this.map.clear();
  }
  size() {
    return this.map.size;
  }
};

// src/actions/DebounceNCS.ts
var DebounceNCS = class {
  constructor() {
    this.ExpiringMap = new ExpiringMap();
  }
  static getInstance() {
    if (!DebounceNCS.instance) {
      DebounceNCS.instance = new DebounceNCS();
    }
    return DebounceNCS.instance;
  }
  async ncsSearch(code) {
    const config5 = ConnectorSingleton.getInstance();
    if (!this.ExpiringMap.get(code)) {
      const ncsResult = await config5.searchApi.neuralCodeSearch({
        query: code
      });
      this.ExpiringMap.set(code, this.findHighestRelated(ncsResult.iterable));
    }
    return this.ExpiringMap.get(code);
  }
  saveCodeToExpand(code, identifier) {
    this.ExpiringMap.set(code, { score: 1, identifier });
  }
  findHighestRelated(assets) {
    if (assets.length === 0)
      return { score: 0, identifier: "" };
    let index2 = 0;
    let highest = assets[0].score ?? 0;
    for (let i2 = 1; i2 < assets.length; i2++) {
      if (assets[i2].score > highest) {
        highest = assets[i2].score;
        index2 = i2;
      }
    }
    return { score: assets[index2].score, identifier: assets[index2].identifier };
  }
};

// src/ui/modals/enriched-modal.ts
var import_obsidian20 = require("obsidian");

// assets/Robot_Enrich.png
var Robot_Enrich_default = "data:image/png;base64,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";

// assets/Robot_Enrich_DM.png
var Robot_Enrich_DM_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAChQAAAhqCAMAAABaP5dtAAABGlBMVEUAAADb29vd3d2AgIDc3Nzd3d3f39/d3d2AgIDe3t6AgIDc3Nzd3d3d3d3f39/f39+AgIDd3d3e3t6AgIDc3NyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDOzs7d3d3e3t7Ozs6mpqYwMDAAAADd3d2AgIBbW1v29vZvb2+cnJyysrI3NzdERESmpqZ8fHyXl5eHh4dYWFi9vb3Hx8fQ0NA6OjpsbGxQUFCTk5NnZ2fT09Otra0ODg6Li4tTU1N3d3e0tLQpKSk1NTU/Pz9hYWHx8fHo6OjCwsJOTk7Y2NhiYmLj4+OGhoZJSUkICAgcHBzt7e3MzMyjo6MYGBi6urqZmZnS0tK1tbUgICDf398QEBBjY2PvV6uiAAAAJHRSTlMAQICAwHAQ8ECgwGDg0CAwEJCw8FBgoNAw4CBwUJCw5awf+6BIbtM3AAFDO0lEQVR42uzBgQAAAACAoP2pF6kCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGD24EAAAAAAAMj/tRFUVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVYWdezGREAiiKGoVbQ+NzohiDOYf4m4ACwPLfPycE8XlFRQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAmAVzMowOArkYMmVl+bcBl3UopLTMjpg6AC5miz6YDgb+MpWSuUTsATqvGkEu5bQDP3cucpkOAk3lENssg8A9jySE6AI6uRi8HgRek4Wo1BDioGrmMG8CrlHlQhgDHEn3Tg8A7lFw9sgE4grqmezHwVmPrTYYAe1bX+b4BfMBtEYYAuyQIgSeEIcDpTU7GwHeMbfDpGmAX6tA8pAa+6Z4GQ4Af9u4wNXEoCsBoW9Qipg7KLEEeEh8qjwQxyf7XNZ2fU4Ym0Vhje84qPu7Nfbmz5XQShlVE4AcowrCy+e8nAO7k1yoLV4oxVikdt+9OG+DHOW3f5SmlGGMTrrS2SAZoN6oiLOIuHWUg8NHfQKxiDJ/ThQCjcWERNnGXai0IdKjDVMUy/I8uBBiLS4qwjCnfbgB6OdfpUIR/6UKAUVhO30I/sZKDwJVp2Hdq+OruBOCmFuvQQxNTvd8ADOC0TYdeZZit/CMZ4DZ+9XmPsKjy8wZgUKc6xdDdmzUywOBm0yx0FZN9MXAz52OPkeH8+QmA4TzPBSEwIvt81zUMs6lxIcAwZou30EkhCIGvsz8emo5XJ/6CB3C95eo1dFDuau8PAl/tnIrQxWTxBMA1ntehg3h0VALcySnfNaFd9mKLDHCxRRZaNYfciBC4r21VhnZzb9QAXGL2krUX4a7eAIxAp0Xy2i0yQF/Ll1dFCDyU/bG9Cyf+dALQx3KuCIEHtD+WoUXm5gRguCQ8KEJgpM5VKQsBviQJC5clwKjVu0YWAtw4CctqvwEYuVMeZSHAVUlobQx8D/uqkYUAN0nCMhkSAo8kj7IQoL/ZypAQ+GZaxoWZdwsBPpp9+i5h40tC4DGd8iJ8YiIL/7B3d6kJA1EUgKOYhFJ/ULqEMAQNFYJBtO5/Xe1LoYWM1L6Z+32ruMy95wzAL691yhvEjYEn1h59fgfwN7NlyuvsjYEnd3+LvK0KAL6sFynvcGkAnt65H1JWXRYAVFunhEAE+0HiBCCvrFPOrXdKCEzJvYqandNCILTZykgIBNJ2KWvutBAIq3oxEgLB3BkLl28FQEhlbSQE4mk7O2SAHzYLIyEQU34srOcFQCzV3EgIxPUxpIzVpgAIJN9WfTUSAhHsB13WAPlqwoNeQiCK/qa0EAjubZnGdW0DEMa591gIRFbt0rjBH8dAMO9Hj4VAWLM6ly9pAMJpTx4LgZCy14QH+RIgpv3NYyEQTy503F0agKDO1zRuWwBM1DyNuu0bgMAunc5CIJL1SjMhwEM75LIAmJzXOo05qaEByO6QF/ImwMRUO5ljgMdzyLW8CTApm2Ua0/nABOBbL28CTF4pYALw38DJal0ATEJmdXwUMIFP9u5otW0giMKwC4mDMWmh5BEGSyhhI7IKWjW6kEG6EQK9/9uUlt6UTFontpyd9f89gq4OO3NGwN/KVh0h360AIAH66Ljlp3YA8Ip7YIQMIFVbngkB4HBlSwsZQIrWGzvPhO63zids7uU0Brufae4FiFtTqSNkDlkDMO3rbdyl48HN3k8hFNmFKL2cwBAyw0ovQOSeOGQNIDVfbnaKUj6dc94H08nmwyY52lBmtk0CRK553ik2jJABWHW9U1SNfKLadXmwnmmO4+VIvf3vx1sholffc5sGQDrWm7j+dOzGS4+Df/RyHJ/Zx14h4vfSslgIIBHr23gaJkM3XczW4P+NcpwUPuUoQPRctVNsVwBgzLebOBom/ewvc3dwudlplgDmxzDhiYuFABKw1TLhk5xXP+cpvGrFFoiyBBAKYUOujZC/UzcBYIlWMWlz+QcC4ZtiG52m8PLK+BhG1BV1EwC2aRWTysnZDF0KwWUhZS/HGTP7KJrAjB/UTQAYtr7SWsdyLvO0z/C2TuTimyZMj2GI1kK+uVsBgAFa7bgt5Cz68SXD0oebe+upkOPVMKWpKCEDsEmrHT83oiARnt9+lhPoc8sHH/nNHaypHykhA7BIy4QPtbwSWSLchxAm/0vnEjbIqTizBgHM0W7TbFYAELXt56wTzh9KhGUI3o/O0ToAEDdtsfCK0zQAYqZlwkIWNkxl9j5F8B0vRgDsaJ6V0zSkQgDxulYqJo0squ+Kd8XBFz+TBgGYU1ekQgCGKOcJq1qW5KbsYCEfnQCAUfccLARghpIJH2tZTt/ts8Psp47nQQDGlaRCAEYomfBellMfuElY5DNFEgApKFpSIQALNmetmLhAIARwaRpSIYCf7N1RattAFEBRFxoZ0xpvQkRBhkRUAbm4HxEoP8aQ/e+m361HcRI848FzzioueqP38letU14xOYwfGRkfBCFwWwLXTZbfFgAZqdbpfjue+vNJ2HpDCNyi4dnJOyBr1TrZZbup75oz9j4RArdqeFKFQMaqdapVNEPfKUKgaFtVCGQrWRMOR0UIFE8VArkKNOE20ITRB8c7RQgUoVWFQJZCTVgHxE3C8WWoAcqgCoEspWnCd5OwO7pfB5Skta8QyM9qpgnT7SVsjY2B0qhCIDunTdjVl/bYNvN8JARK9PBHFQJZWcU/bTfsm1lj7yMhUKbfqhDISfwmnPr35sY1QKlUIZCRu1ATpnpMuDM3Bop2WoXragFwDT9iN+Gwa+YcbaABSqcKgUzEbsKpl4QAqhDI3SZyEz6OkhDgk1W4WgAktllGbcJpLwkBznm4V4XAlVUnTfirvqC3ThICfGWL9d0CIJHwweNtitWEe0kI8I/WGWTgqr7HbMJDZwkNwJer0LpCIJ1VoAljvyYc32oATrSWWAOpzS+tfor+mrB7qQEI2d7/56fFNEB04QWFz0N9IdOxCTq6cQwwZ2tdIXAVm2W0Jnwdm5Ddaw3ArL/s3dFKG1EUBdBRjFJokYqfcJkJY4hDTZmk5sFC+hIC/v/f9NmbUKtzTp7W+oph7t77PBqmASYIG6PZjiXIU3fKsC8A/MO4aiuXDUCu4zGa7abE2K27U+ZejgHeMa4M0wATxBSPNyXGcuhO6M3QALxvuVVBBs5r1lb61KfjpwLAf9hsVZCBc7pvK0Pm03GvYALw2bnCqwagklg8fohqHZsmBJhmaCvfG4BKWslkkXjXrnfnGOAjHpRNgHP5kjNQeJAmBAiwUDYBzmOWMkazW0sTAkQYV8omwDnctpV5TJzQNiFAUgX5rgEId32TMUbzOnRHhtcCwCfMXTYB8l1lFI9fumNrvwkBoirIFw1ArMu6ZFICHDRMAEpmBflGrBCIdVGXTMaAislzd2Rw1g5ggnFlwxrIdH0Tf/F413dHek/HAJMst2KFQCUzUNjn1I7nBYBp5mKFQJ5ZfMnkz9DVhn0BYKofYoVAltv4SybLoav9NlgNEGFhrRDIcf21Kpksy1R7SzQAWcaf7VuzBiDj5PFzxjfhoQAQY+MIMpDhvn3rV8Y3oTghQN6G9bcGIHyNZlWmenHYDiDXo10aINxddKDw0NUGFROAUOPWLg0QbBYdKDxYrOYve3ez0joURQE4gveKqJX6DIc2FLHBH0K1Awd2IgXf/20cJxNt9k5q4fueYsE6ex1gdPWi69ouDRAzu0h+ULh3dgwwQHStcF4BRJwnLxTunR0DTOJZgQyMWB5vZEKA0/CwVSADo5XHjyWmXva9FwBGsVIgA2OVx/cl5tM8IcB01gpkYJzyePsgEwKcjvZFgQyMMlvdyIQAp6RWIANjzFavZUKA0/KqQAby/zzetiVi1/jaDiAmXiBXAAf7f535lcmu8bUdwORqfyADYfPM8rhtlj0yIcAA0QJ5VgEc5jazPP5YeU8IEBcvkM8rgMPcLDpWJUImBAjILJCvKoBD/Mucrd7LhAABmQXyhbFCIDBRGJutrmVCgKNpX4wVAsNdJs5Wf8qEAAHZBfJtBfBbZ4uO5xKwW/bUBYAJrd2aAElXJpvMMZp9AWBK7datCTDM1aLjNTRGIxMCHFnj1gRIuTJpy3Bvy67VRwFgYvf+NQGGmOdNFD7JhADHt/GvCTDALG+i8MuHxwB/QW+s8K4C+Nld2pXJrpEJAf6C/q3JWQV8s3cHqW0DYRSAjRctIe6idxgsoRjF2ASZKgsbpI0p5P63KTSURILSavQ70eL7DmGsN/PeMHGO5seckomBQoBlqLYD31YA0+Zonpu41+2OCYBPsjNLA0xzH9YyORujAViMUddkY5YG+IdN1FsmveIxQJymPtZdmuHBLA0wxXo7UKZc3aUY2DcJgEz96fXIpZvTNbFgDWTvVj/GrVYrHgNk6/cBKw4HUSGQHRTWYRcKzwmAXFXxx6VL2Z4sWAOZQeFhxketkglAlGvxpk3Z2u3A3Qrgb75HzdFUSiYAYX4GnbzsRIVA1gN3h5TrqGQCEOcU9JNaigqB/3O3fe8pbI3mJQEQ9KewqFK2R1EhkBEUVlFrNGUCYIY26n2oWlQIfGRQWBYDVQJgjmvYyNeDqBD4uKCwdqEQINa4vScqBDJkBoW7qMPjawJgnn4fdS3nICoEJgaFZVDzuE0ALOYAuXkWFQLTgsKg5vHFQiFAfNekEhUCGXIeMymDLr7UCYD5un0xcBQVAjeyjgkKj9ZoAG6hLoZ6USHw20KDwmZvjQbgJspi4CQqBF4tMyg8jT9kARiK2nY4x0SFX7+sAN7ZhASFL+MrLwCMha3AxkSF6xXAm/uQoLBzeAxwO2Ux0IoKgXibkMdMSofHAL/Yu6PVxIEojONzYVuKS6WLjzBMBi1jiJGJ1osK5iYIvv/bLLLb3YkbMU1PYiT/3yMYDOSbOd8JtXuA7GSiwrECgE9Tka3HOYfHANAmF5XsZDYg/1AA8GkkEhRm1FYDQKuszMe3MyVTBQC/TUSCwoLaagC4QrbCOvYiUeFIAUDVhrtE5K7LQQMApB2jkoNMVDhRAHDyaEJbL7HLJObwGABakMkcyrxRYA3ganH1RmSXyYcGAMjzMntNrCmhlQZARR+N040czl5TAIA2LKOSQjeTUmAN4EofzVw34pgyAYBO7ERqaWa00gD4z0hiw13GlAkACOhsoeiKVhoAZ15MKNWNOKZMAKAjmcgbNzGhnwoAXiWKq3fsMgGAjniRqNCbkhcFYPCeTGAr0Vu90wCA9tioxEsUWL8qAEM3NqFEIig8agBAe/axxDXutQk9KQBDNxLooymoowGADn2IRIUpoyYALo6ZLBouuKOOBgC6JLJXdMaoCYCLYybvuokldTQA0KlCJCrcMmoC4MI2k5XE5RavAQDy5MthNyb0oAAM2dSEEoJCALgLTiIqdGw1AfDXswm57weFMUEhAFTpY1SYmtBEARiuR4Exk4LeagCooYdR4cyEnhWA4RoLbDPZseAOAGroYVTot1QVAqgoKdwSFH6Nszfl9M3k7iTXX+btcKz13RjSYzlz39ddcomocE5VIYCKksINQWFtNlmk5ubSRWJ1t/zRZnH0R5br+mzch5+sU6u35N3r+vbL2elPlGV26fa6G+t4PrTHciZdxFbfq0MUsroJa/6hqhAYsgcTWhMU1uJnC9Mjv9i7/x0ngSAO4NVEjfFXND7CdJfbVti04EIhWhT0jmCI949/+P7v4akxt6WAdHeh0J3PC1zSHvDtDDPrMQEjyR1GDxW9P7KEWMrnLvSTcypJyyIDVfi1nCbx2DxLhjk18KM8ILLHC4SQpV7oLykMbSsUxpNKhH95MQxPbFN6LJ/pRzYqn4n+mVAWFzAcZ0XQ4VU0Q6GBX+UbInu2QAjZ6SWRcVDg2rWjUPCATFLABQxKlLRRDP/DJvqRjSrZuf0f7zLuCFCBX4uCgMHsuFSWaq8qxP4xQvZ6rb+kMLbqMBM+4WZbwmE4oqRtMHv0tBM9G4F1pYA/MBJ2sDcWhlRWaK8qxP4xQtZ6TiQ+KBA2FQqdiT9IAweGkW1pOxc6OJbPMJwS2/e01TYDo6I1QS38uQ2duFTGtFcVYv8YIVu90l9SWNpTKBQzeDHOEzAAN6VqoVDsCJL5EbTrSt68AoM2BHXYzew+xmrXowJB7mH/GCFbvSYyoX3CXQgXzJlw5/he4oBxDu0EraKJV1bPgXfN8XeJMzAkwurtfwQz2jB5pzDQrvHIPewfI2SpF9pH3O2pzIXLNZviygbMEox2iqENJ+iUYq6gnXgORrBZ/Lo5M663tInHRQbjSalMYP8YIaQ/e8y070bze0X7olrHw7SQc0675dAC952c2kIuabcCDMCOfi8rUCFi+g8vYDR7Ktti/xghpOKRdve4qj2zLpWYVcPNF2BMwRWDisBRhjZJBM0yRruV0BtGdU1rASdzOZWUGYwk41SSYv8YIXSe7nFMJRwu1bwyoclUWNBuYX4hH5kS86kwpN1Ky/6TT3L2q6iihxiMxaGyAvvHCKFzdI+FHSfcdT5Jv53NCKmwoC3ScHunypU+Mn9t+1ttSQQtqjIMw+FSoU/affLeE6RxFQlOaxwYiaCyUL9//HSBELLNM+3u8daKfTRtAefn9e3Xq7P6env9c8hUWNEmaVlliuEjWDEH7kSODTabddKeCjvllcMUUqFi7/jm45d3yzuf39nHZR8/kRa+8hJp/dG78c8Q8IjkyQIhZJs3RLIGBakVi6u9xkR4Fwgn4ettYy70hpoxKSvV8BFsLnk6vUXEfdIkEPA/WcFoA8fwjMkN/7y0nctv9KdNXHoshJFU+k0bRmRvFwghy2ivYKis2Eeza+oZTyQR/vW1qZO8A11ZqnrgGifH1jFYyt0kqlWovDQ5g8zIMW+/RL+5nu5mmpg2EDCSlEpS/f7x6wVCyC5viczVbVmkMAY33mzWd1YbFsEo4qlHwrZYGIOmkNaFAvpwyJFgbkeHmcUS1dQuQmP7CqOE1N24S/TPd48cc6A3ThvsYSR7Kqu0Xzh9vkAI2eWp7rnH2dh3v3gVEEniMQFDEwmpu72aoFtSlwjdp0wN30MvIiB1G7Cc2CnnjYrTmjQzNGTClkj27kahzd+9eryEkWT6f5YT2csFQsgqz4lkp50aMhiWaGzCrSIY1nr6ZcK2YuEadAhaw4TqNIM/r0PDhhH5qqk9i2mNY+Q1iBt8l7DuA1d/rdClTUIYS6l9O3aJ7NECIWSTl0QW6R7DHoMC1Ugo81wYUExqrq8m69poAzlUPXrXITXepY6ln0aslF/73BoYao1IjfdhiY6470mNM5NQaOAgAanEj4eaIGSbR0SSwOlyKqtgSHGgctivPhHMJxMep8JAgLJCuQ0WHJVaUMvx2ZHqt5Hql7w/LlGTz/VUGJzcv5U5MJpUO4zuiGyBELLJG90HtzPemMmOdPJdGMhmDq8T3rs1FpezVDUTcsyErZhyg7/QnV9gmAl7+vCJHOKzGDQxsTU2JrIHC4SQRbSPM0nH+kEsfLUDIvSJZEZ1wt+uTc2abFWbYCLBTNg/MTuqqZBnCp1ByY8lavP9vdpVVNIGAkYj9NMoLqVByFoPiEzodo9zkI2SCRVSrWah8NvV5H0zVCrkquOuvL6ND8lWyrNADj2w1SoUfsL3CU/oIPP+d8S6GEbEqIRp7+l/sUAI2eOh7qPb0boD6WdChZqLZqHw59UM/DRSKizogVy1IpXgjEmNr/xvG+qUCgMie/99iTq45ECgvr06hxEVVCa0K9mPFwj9Yu/udpQGojiAo/EjxqxG4yMcTruzOCUFbEuJ7ibFD4IheuP7v4mumjiQIJ1z2tKh/9/93pRuezrnCwbjSjuQZirIVajeot1nkA3v6eksmn2fGjlBvYtcM/ElG+wWk6PsSppdz6by9tKY93wcw39NRf9F1TQ6MCON7gfHWmy6AxioJ9pjtl1HlTNLrmmRUdPmYRUU/vG5gfTtWtzqmrArITiRX8+kc0GNPGudjOH/3n9hVyJcFr6lbpXq7M0CRYUAw/SGXdpRqYbaUnJtCTWs4D3XgeA9hX4O7k560rC61HXYKhPxcl0jzUxmvAfJ45PesmgJ6NpIzgl7lD++QVEhwDC90q6+uOske5ytuL6SmrUMaRrNP9/ZtVS3meQ+f4jldifF4qNcK52AZzCNxlciC92r2TT6K7dUT5/yxwZFhQDDdCV45LnW3WSPU/awoGbNgzwovL5W54+tuHhtgi6T0ybixv9cmNVPcFDo6620S7zabPNfZmuqrUf54wxFhQDDxK6ir73Hlr0YapINsaLw3md22Q7HkmcYUVhDLL5pN8L88QoHhcqjwkC+bzbq/cdzFBUCDNEDdqx6mz1O2cuCmmTCaz3+45M2UjaRIxZXgBYEp6v5b9pv+S/YZcdQw22IbfSVev/xEkWFAEP0UFlSmHWTPV6xn5IadBPY3Op/virP68ST1lLMrfZ+8S7EZ7ilqNLzyxhqeRdieWypnZxdoqgQYIgeKR94t51kjw17SqhB8yDbTO5918VmVrzUehLie7R7Bbuy1n+aG2SPBT6wY0Jh2ESOKfnLsP4YYIi0UwrzTiYvJOyLGhRq9vgwf6yL+Lfik92Y4IiF+DqJasbmyB5r88crCkMVuXbae/PhCACG4KUykqq6WeW0Yl8lNcYG2nt8T9dpMhPXi7KLoNbXjhF/jVnJz4KtxzW9D/JuziNHrK2aeTQCgCF4rMyM7DyyWHIFe0upMXGwJYUHRYWx6r1iqb44xITbOaTie3YmaCTIUFIo8iXEc291YY9hx9MRAAzBM+V4420nu5wMe5tQY0ygA2nufWaHUQWF5CHGQJq2L9RGULcRY8WdSBJiUKgeIGvZ9XIEAANwpUy53nkUrsil7G1BjUmD7TM56DRJVRNpyEOJPpN6CvGHjNUGhWYMNZkAZ9IcPJs32qKd5yMAGADldONMUO4ukLA/akwabJ/JQadJqplIY8SXbEpwlDgoXEeOHEFhm0yQ3zjqLM4E46sBhuaB8nDtVvBmEpggKDx7UJiThzTEfFttvQgKCUFhZ2yQQeFOO5QmRacJwNA8VM72mx3NYSEo7AUEhT2HoDAAbyX/RZn9raIz0U+GiNk1AoDL91r5CTw72p6KoLAXEBT2HILCAAiCQmuiv7YVnUmu3ECaodMEYGiu2BErO9zIhaCwF5oLCu8QFLYgQ1AYAP+g0O0NNxWdx0y76W6BThOAgWFXRv7MsacOgsJe+ITu416LxRfKRo4tgsI2fWRH6T0OJqfzsNqiwgSdJgDDouozOXz6rak1y7MGheWlzCksyVMu7S2PERQKZmCmrY+kwepjEeN78L2N9qzpPCJXhk4TAPDZZ5KQxG4qGITVwZzCCTUmvpSgMCZPpbRktNi/seCYpThov5X0eGF4tcgPdhR02jTaMyM1fVHhBp0mAHDCqwYOdKrY3GdILLUoZm831Bh7KWvuzrT7eEFwzJwdhXgK3U7ws7wbg2TNXa2+334EhTPlpMKMXS9GAHDhHjXTD1DZilqVsTdDzWHXdVB0GfVN5CjFJeoZQZ0bW17vaSXFud/G8JO9e91VGgjiAI7GS0yMRuMjLLN1KcuGy2mhjYL2CBoIkS9+4P3fQ+N1W9DTzhbbpf/fC5A4RObMbUt5U/VPHN2SpFBLi3LdNLnXA4ArRzYt2iukqnSdn+7tpsnaraN+y55UH3n5MNh/l7Djk0mbKGlAlmUfSllWHYZYyry9aIi0ZY7/893vAcB1e0aWVLSYoYpmokYLb4cKN2RZOP6o3HKnQAcCSiRpC3YRV7H2Wr70oZS3VadsApljRO345WT+MPfLHgBct3v5OkWLaapofLF6zvG1R46OBbuYO5QUePP3RpMiYscnYUVmTrY3fSjhzU3VKZtY5mxFUwLHJrbC+jFAl9zP1ynabNRg91hE5Gn/eE22yHFS3WSiPEL/+G6GHZ9M8hZLZ+gfV7as/AeOaUn3mDUUbJtj/RigS16QxYg2Cxx2j91NPe0fb8gyZZ2h5B61GHlThW7QjH25ZyJtGa9f/a4PJbyrGqVM5onGRJw3iWxYPwbokgcePUYW8guF7oyfpcI1OWf9K+6vivJmiak5imyKHRfFnISgYR/uNKwcJS1zEtEc47hpMsX6MUCHPPboboimCha1f7iXpcKNe2IWSOapwohwv7pSoTCNRHlLblhEivvVFY0qR2kpCwX25sTSorF+DAD/QjbRcmMqLY1EzUIfS4Vrcm/hRpI7VTggj+rQjRizJx4yU+gec8Oi+3CHZfUoBbIQnuZMHDdNxnj9GKA7/Fk+/m5KZSWiboo8fNVkV8c175jbCQvINhVQoFOyzdn124S/OvARC8glVo+rRiluTfdY7KUlwfoxAPzDK79uyemU3Tx2NyPb4bUHDmSb8fcXbXvuP9lYQF7ILuRqmaMdPtb04Z++MKJkWtM9zlf6leOC39MeAFyz+579aM/Zm8fuxuRbA3ld0+HGlbSZ2wpFBjSQ/2FBOQG7eawq/8zjLE1pS0aUMpkTiSY5rkFHuEkD0B1PfDslp6iEaSQuIErJswvWxxJjloxSocqYpcJ0LuAPRdxCYabc9hhCst2878Nfvb9hREkXcvZGxYw3iWxke94DgCvm00WaH5KU7jKKxEUo8mus8Eg5SrCtuFmhopxpy/fb/6s5sQuFW5mjHE9+3nzuQ7mckALWanijAscr2iFu0gB0xlOflo9/mM+Y84TuZl5lhbv6noLWkpsVhsgK/2KeskcetjJPu74O9A7LJiVzwpEoJWhR9zifoU4ck8KHPQC4Yl5dpPkpGtE/pIm4mIA8ygqPVONAXyLzVMQsh01xw9qqeLOa+9lW5iWsjS10kBk5YapFKXGLusdCO35ZxjhUCNAVz/y6SPNLMqO/GUTighaUd2zttsn6WGv9NDMyz+jyvyiYKzxlqMBw5wmlyWr4/BucKzxD3zCjZPLFuWZl0hI7flde9gDgenl2pvC3aJzSOWEgLiqaEZEPl2kOVDCLXI+dFQVZ+duSuExzV7F7VDoQRhZ8qufNSNWHAkUFIScNk7eiYcZt/TjAoUKArnjl74+1CqlgttDi0uZUtGthsXC9o6K5cLSVRas9a3aOaNr1YmGScnP2LJFFCXuXvuAdnkHOGb5jP5OkpWUlmhZLS4ZDhQBwLWcKcyI1COmn2Wg8FwzMDeR2v4O8oRNKOFPyRKxFCQmdGHR5sjAIiZmzZxMji1TGH5Ateost5N8+v+VGqbja0fxRh63j68c4VAjQFfd9O1N4KvhGi/9nQKc2LaoWrjcXOuadGXlqtcx4T1YPulotDEJi5uzRxMgT5rbWk59vUS38bvi2cpRsQau6x2LiOG1Atkc9ALha/p0pbN6AztgdWpEXrg+7yz3wcmvkOfFEs/7JZuPu5YXzxYwsFdYXomUsz9Gua1NFH03nF5Hfm49kYXRS4lZ1j8Xece1likOFAB3xgCxdbulVMaXzdpvD+pvXTfj2uYfNjs6bClFzVli0ipPJZLIvkxXa0nCsgiDowBcvCAI1DtPqjzJmWuv9JFlJC6PsUyksNyP1YTgcdq6X/Hk4HH5QIzpvwNzs2IrGaWnZ4no1AFzR7ermRSF5JYzEBbNCm9n/Pf2A6g91R1tp4+eECIuzAfcGzF40zvEmjf01wfVqgKtGfyAp/Mre3a0mDoRhHLdlYQ/KUug1vGSClcmQWGKMBwrxJAR6/3ezZbfYoTVR8+Vk8v9dwrxKHifOPJ4+S1/FMnAqVKUXSzYqI3XKy6vd1TbAVbZtd+aMOEBZDtxeDaDORK8pvLsJPUu30qd0qZppqWECnLNsiBbNzFG6WwZoMaVme7feHn+7OYBQCKDGM6GwpeUumITdUvpVVKrRRuqEE1myUb1lUuugGi2P0oeMsdRo38JTufX2uPNFhXlwQqUJ4LOHwBIJrqfXwQQM0TS8N6pJIXX0xP6LOYIolVpH1agq+mtXQaNV2iGDiQtCZdFUmgA472HKd1ffWxw4b5iRphvVQEs9w66UbZdLg33zkZ4Zbnvfx87IrXJ14sblrwmhEMAVngiFl01252ulZSDloV0oFM15ky+vqTRJWmwTtpQyFkv38p1SnezFBfseb6/+vQDgq0m33DkgdDgWrkJppU3fmm3CSzaqVSbN3lWdjZa+ZYylx29RcVCfTCEu0MqS0HMH4LxHCk08jYWroadZJAd1TiWXhPyHLQiiy/Mp2kTC9jJ2C+um1P7qJnP/ijtCIQBC4Yj09i1wzNtWywjec/WDSeUyHTu3ZKN6i/VNpwNslZahaDPvsdRMqZW0MkqZKhU3pMqSy82sDwahEPDYC6GwD9nWoaPI620mYynK3CibOU5xyVoYYz7FUn2Tl4UMKovnOpYfU/KrmFtZNvTcAaD6eFhpHkd3f56uozhPZWTHMtwc1H837YykYRw5+vJ9IOvVbfMpQvtRnrxLa4zleqsoDl3Z4SMUAhiRHQppueuDDu9Gy13pD1NbslFl0kKa/FPqVEaWhrPk6y9jo74sCYUACIUAME+bbj13EaEQmIU/hEIA8Nymx/LjpwUATwWEQgDwXJ+h8HEBwFOBZS0AAP/khEIAt4XClQAA/JMoiyYUAiAUAsAsEQoBjBIKizJJSjf6PQEA/YdCQygEZqFzKEyM+mASAQC4qWMoDAmFwCx0DYWV+lQJAMBJhEIAlz13DIV7dbIXAICL+gyFLwsAfnroGAqNOjECAHBR2WMo/LUA4KeOoVAri6+loQAwcZpQiL/s3EFKw1AUheFYdFrQNTz6SpEizcCgHSjoTOj+d+PQCwohJJHH7fet4ucMDkyLwlOZ6lKDSwGgQcca9KIQWCEKe0shQPNEISAKARCFgCgEQBQCohAAUQiIQgBEISAKAfgdhW+iEBiNwhdRCJCQn0Lgf8+r+wJAg3pRCIzaikKA7JaMwvsOSEoUAmS3ZBRuOiApUQiQnSgERCEAc6PwJArhKohCgOxEISAKASj7GnyKQmCFKHyuwVcBoEFDDYooBEaj8Fwmq8FQAGjQklF41wFJ3e4CUQiQ0JJReNMBSYlCgOwO86LwURTCVZgZhU/1x3sBoEE1OIhCYJUoHGpQAGhQDQZRCPztYRfsRSFAPktG4bYDktosGIUfBYDmHGvwWiY774IOyGpmFO5rcCwA3+zdQWobQRAF0IkwCSFxQoKPMHSLwchGY5CT2dhgb0RA979NtrVRGFFZNK33DtF8aOp/mpPdGShCIVyFTQmW8VKzUAjQuJNQCKzwpQT7XCg8jgA0J/lSH0pwOwC9+lCCvfFjgO4k/3S2JbgZgF4JhQCdW4RCYIVvJbgfL3UwaQLQuGR52FKCHwPQrRLc27kD6M7jf5w+3gxAt0rwlHtrHkcAmlODSSgEzrm1cwfQs/fkl86DlTu4Esnx46UG7yMAjdnV4I/pY2BVKPylvRqgMy/JmoinEnwfgG4ld+5edNIANG2uwdGgCbAqFE65b4ntCEBjnmuwEwqBc+5KsFdUCNCZqQZvuquBVZMmv3NVB68jAI2p0SgUArlJk/MmnTQADcs20uwNmsDVSLZXPzs/BmjYqQaL7mrgvK8lSJ+1AdCUuQZzsqbwbgA6dlOCw3ipo04agIYtNTjprgbO+5wrKtw5PwZo2JQcnirRxwHo2KYEk/NjgK4kj48PagrheiSLCsfXGryNADRkV4NJIw2wtqjwYbzY4vwYoFnH5PHxVIKfA9C1ZFHh7NIEoFnbGswaaYB/+VSCdAUWf9m7t902gSAMwNvzUVVa95C0aq5GO4hYG2RiYZtUhQrfUCRfVOr7P0pPqjuNgRgW7BX8n3IfySNZY5h/BgDAIbbLZKdaeKYAYNDua8FQUxGSJgAAzmIposbm2EgDMCIv7XbSUICkCQCAo9YsBNQcwscAY3JXCwEO3QEADEdiuUt2qYVHCgCG7Y4WVkiaAAAMR2H5De1jIw3AmLywjB9vcNMEAMBRKQsby/DxSwUAA6clskuaBAQAAK7IWIosw8cPFAAMnGX8mFIW1gQAAI7YsJDSwMLHJx/Oz5jfnb85UQDQjSeW8eOYhYQAAMARHgvxsC4fn3zkvyb30BYCdOOB5fXjBOurAQCc5LOQWF4+fq5ccnrGwtmpAgAHrh8bDBUenBfPxiX26DiMCX/LqSHj+bPhalGPLA9/MxgxOaSMLXeGzZy9fHw6YZYm6AoBuvBQC3NqjjFUeEDL4HKux2h+GSzpkKKkSHkrNbS3eDbVg9ewHnnAW36RRwQHsWGJmrvQW25dPn4/4RvO8AYZoAvPtRBRYwsMFR7KcjXOhvCv+WpJh7H2Ur4hp31E/qUejf3rkfMNfoK+8BA825VhV1p4rdzxlHe8VQBg75Vl0iTEUOFBRMG4O8I/5kFEfcuSlHft84+9Cz0y+9XDcIlFTtA33/a4gJZeKGc85hLvFQB0e+huhqFCN5mLaw2/XF8Y6lMWBlzKo1t4I3hr3K4eMZdKQ1xL3+XUSKGnt9w6cnfOJT4oADh60oQY54/7Fs00/DOLSOizJZR8tIRt68FVgpws5XHKzGmBL54+RgplzsSpI3cnXOapAoDjJ00WOH/cMx9PCf937VM/NilXoxrR6F4cN6kHV/MNWRD5lQVCbrsK25FCMSHrVM7kMZeZKAA4ftIkZMEn6JgZ7yOoalND3ctirhFQtXjsbXt9PbiOl7WuV8ESZhTr702FdvdMnMqZ3ONS2EoD0HXSJLYcKmRMCbWBfqOp65i6ZgKuE+MxYdt6pFzHX7dPUaArrLO23RdmtPRQOeMpl3qjAODoN00owBdzf1Yayq2oWyHXy6nC8kpDbT1CrhXk7detYKK5RmIbAoz1llv3TCb8E5bSAPTijham1FyMpTR9ifDquNo0og4VXG9BFZZ4lHtbPTKf63nUnOEdKd5TVD9Kje1+kjp1z+SUy71TAGBPS9RcgqU0PYnwDKrOVUQWmrUti4zK+RpEPVp+vEX736JYnl8ls365PtXCA+WMN1wBR00AOnBfC0tqLGJpQ4Ce8DaOdYW3NS1pTugJrbrCMOVaReuOBzm3KjlLke3q6jvKGW+5wmMFANZeaiGwzbgVBL33hF8uP/tj8fnyi0VXaNcTLrzEGLMmat4Tfp3PP32aDvDv+/xbu3qsjTFh4XfUFW64DI7nCbFtv+xpSbnjHVe4p+AHe/e22zQQhAHYCHE+n5E4XE1mLTvYmxBjtwklQSlS0qoRAkF5/xfhLEZ2gurZNVj2/933IppWnezM/gvg7L5rfHWI+bGCtidM370Y9M2Ld2mTXWFhtrDhps5/Teno08c3pstGaaaux3JzbF26Qnl5BVdNznwDMOx8dLUxiK8G8B9fPaP6NpgfNyDmLVbzg0E/HcxXvEXc0B2TYkNCrTsmn2LTAycfT9X1WK4XpmqNptCrjZESt5XCFkdXvzS/Ib4awI/rjkuFZLs+Pw7t/vCHsQ3p3xhzVdq/M0LpRcpVY1+rV1KRqM9yX3f7jFAaZfp6JAtTkaiaQnwjPct3HUsdWik8b4RINL+Irwbw4goL1nV5ZUHdktshs5RGOTUu5IpVMui7ZMUVoZeEX8luar0BJq360xJ+F5/q6zG3psQucVLY1PT4uEsrhVeNEIorR4ivBvDiGgup81kLdUkYc9UsTqhZecZltq+DY+nAclmWe75kMl3SmURcdjoyPXPyRV+PvDAlU01MIR5UamqpZ8zCjaA97hlhLS46Ir4awIubLMwcA7E61RTufnc4zqlJMZe86vfk+I8Xr/yuFb7UrrblMy5ZnZj+GR3p6xG6rBVaRNLU2JRduq4U3gla47GRcvFJEV8N0JKlwmk33zQZKx979T88fvt+AD+9f8slocfhsU2IlMPj16aX3nzQ12OtGSDLbh6vH+9kXZ8zyVm6H7TGAyNYkq8nIL4aoB1LhZsu7nqLewT/+rBwUu4JMTr+46DcFU78pdHYQ3Xf/tH01MkHfT3W+vfulhYHhX+xce6Wp21dKXxohCnJL3aIrwZox1IhHXfv8vHeTPmAg7sIPWGtrjAirY22J6QJesKdXWGk7wpzRe1E9eC30Hl6vN/SlMLgkRHmJA9FEV8N4MVFlkgj7F9PyDzbo0Zk6AlrdYUZaS20iSYRekLZFerrMddHWK8xPN5t4To9pqylKYW3jZSQPO5HfDWAHzfcV7TysCiKaWdmx7In3G2WUA3KhuMVesKyg1fMUuTnoPClesD/yfTayZG+HlP9Q3Vra/6wiKMRDp3b5YSlW0FrXDYSfYP4agDf7rCwT5DMWFBMkD0eFOLecdULP0eFhZEK9U2gD6bnRvp6LBfqo0KZanOMNBq/0+OIhUtBe5w3QlGKJ0J8NYD/548nBBM+o5S8C5mlaABVkY8LyIdGsjmR7urxUb8iq7d5ra9Hok+wJsrnxTfTeU4gLYxQkELKwt2gPa5WbiYhvhrAO5YwhxnzmVnyLWZpNYBtVh6yCkPt8DhHGE3Zqb4eU2wG+nZopDkpsHQtaI971S3gyPyG+GoAP+6y0Ptkhz0W/vVaYY7hsWKAnDtHuS2WNX6QpVMDZqSvR45cGd9CI+XOgTQ3g9Z4XP1oiK8G8O4CCyn13JBrSMmviKV0ANulLEX/NMptwlLvHrfbKtPX49hImAS7Wzi32fttfePugREWlXvoiK8G8OImS9RvIdcSklcxDgoVR4Wxps7aXbYct0yqRvp65Jgff9Ou6XHW0jfuKtHVRIivBmjAdRY69FKdxpBricmrGQ4KFUeFM9fjlJDOLkJE4RaZvh6F6eY7mTW1aHq8x9K5oD0q0dWE+GqABtxhIaY+S7impLl9xvkAdpmz25PduZEOtYe5RwZ++Kivx9oIlsBR5Dw9Hrc1kKYaXU2IrwZowDkWMuqzfa7JkkeWJeRW73bgWISNERZUwwS51Vuc6OuxNBJeq3OUu0+PJyxcCdrjqZHoG8RXAzTiEgt71GMZ1zQhj2IWPg9gt89up9svtdNjYik28NNKX48CS4UezY2UO09L7gft8awSwIj4aoBGXMGjJorpsf/58RDTY9X8eOj2nMlGfRHJwLb58VDfoL8k+M/TY8vSxaA9Hm3/TTHCkwAA3F3D/PiniGuLyJ8ZC+8HsNt7t5smkRFybYRbZuCXN/p6JLhp4k9unFvsSVufM7ltpM3WP+bnAQC4u8iYH4uVwlrG5A9LA/ibV045SurLDWO8ZvKVvTvbbRoKwgBsBIhFrALKUuBqcsZyKsdqG5zGgcTgINFG5ALE8v4vAmWRxqmT+IyPW9f+v/tWak+TTvyfmSl2oj6PjIURQRWzyjc0w8auM3nJUlbQb41LhQB1LDXZp87aM9b2yJkjDKQpb1Dpc4y6DtnHQJpiQ9156Cv048Xo1AK3EKWAhbRd6fEOC0Fh1xguFQLUkB8fUmddbFHoo89E2Wnik51YXRT2sc6k2Cf9eYxYoHLmKf8XoGN5TXrsk8LACNe8BnnOgl/4qBmXCgHqyI9D6iqjUFNRGPRgk6BKURiycKD+2DBl+O/tuRaFcZRfSAOu0uPYSNe95njG0rLw8SgmFQLUkR93d4IsisJLowlFIcMFFYUjlhYEBb+XtHqv3T2vOXZZyoqXuGD9MYAb15Efoyi8VFAUNsu5FoUx5+FR4V+Z4/T4rtcgT1kI1o6if+kBQHX3kB+jKLxUUBQ2y7kWhUvO6+wb1orjFqfHDzYM22FhxwMAB+4iP/5taKwNURSW0eCiMFEXhZ8ZLqQoPEBRWChpcXr8hKX5mp8bQ2kAkB+3s/t42oNNpkbwz28kDbqPi33Tn0fEQuniR4oJ2p4ev2YhWttfg6E0AMiP3ekba31yB3MKlXMKyZb6ico+Vh+XmFNYd4UecE5AcDY9XrY4PV5suGP6ygMA1/lxV99lI2MtqqkofNOD+jaapCyQhQAbTVxvNAnti0LOmxGcSliIVN/hkqTHyw2fEp57AOA6Px5QNx0Za0fkziF2H6t2Hx9WG90RaiP+Twz/TPXnMbPOPOech+nVBenxonJUcsdrkNsrBS/yYwAFfX7c1Us6E2NpQg4NjDDrwXqzap9hfBYOtPnaCcM/X/XnsWBhpmg+TgncpMc0McJDrzlerBa8yI8BCiA/dq1/kVcKaR+dJqo+k/1q/z9H6gb1McNf3/TnEbEQKpqPfYI60uP7XnPsbix4ZX6M/mMARx4iPyZKjKWEHPJxqVB1pdAnW3OWMu3T3J8MBVcKff1RUBkJ0uMibU6Pn7MQbbyDgPnVAG7cR35sP6lwSE4ZKezBOqGRyF7Ewkzbi/SD4Y++/jwWiuZjpMcFli1Oj29uK3hjFl57AODAHeTHRJG299j9nMTvPVjnuxH2znPM75HBUJqzPqnPI4vsr3ciPS6yaHF6vMPScvMHBew/BkB+7Ew8NBaGseuSFP3H1r3HJqp8KT/UPkseMvw21Z/HjKW5ovl4SXAqam96/IClaOvf0a4HAK7zY+qowFgIyK3QoNWkjGnlUesZa1tNxgZLTVZ9U59HlrKQKnLSzu7k3PhbOW5VerzLkr/lBY1RhQB15McJddSeYsWdM4dG+tCDIh9M9aWMifZp05HBo8IVY/15HLDkK75mQXBqwVJWeUrrFa85nrM03/6CvukBgOP8uE8dFU5MSZOQXAsMVt1tNzBS4ODBSppZFO64VbhiqD6POFLsME6QHm9LjxNSGBvhhtccN1kKSrygdzwAqO6KESbUVYliHI0r8cRIH3tw1kcjTWJSSVnytYX7yWfuuoH+PEaaFD9AelxLejw0wi2vOW6X+tlSFl54AFDdDeTHFh3IEdVgbKQ3CJDP+vDGSGPSOeCc0KZwx647YXyiPo+ZqmWEpe6+TdWbHj/2GuMFS1FW5gV91QOA6m4hPy6/16RPdQhNzvt3Pch7997khKSTRSxFsc3iGWnAnfb5i/o85pyTar7qmKDl6fFOuTukMQuPMJUGwIHHyI9/sXevu00DQRSALW5C5Q4q4v5r2Im2ITF2gu3YJUmxkRoiIlTUwvu/CC23ru3GtddOu7XP9wbtROl0z85O6bNCmzZjIgQeKyxyJFImpMvlFBlrHhWK79xl+9r1SGxOWekEpTHBsaS96fGLsvtrQlZsWwCA/LgxMhKFIkkb4kUC79IUmGYK4ZGu2NbtCh2R8qXLK5APtesRS9Z6F8hFepzXa296fL3sp2TA/+FVGgDkx80KRqLAKKCNcQS6wtI9oXBI34J1u8IxusK/DrXrkcxZ71ZniPQ4b97a9PjhE1Ytyv0ScFQI0Hx+PKZOcyKxRuTQJo1E2hHuFf7z8UikjagOn9NkQuX0hECCfOzrvnY9Eps1t9VJVnR1R3vz6fHI0PT4OqvmJf/Lw1EhwAby44A6zXOis1tCjzYqEBl7mEH+49OeyAjqVdjmNHtV5VhF9ZM7aHKgXY8ZM2u+FMmKrq5oL06PvdoTbncsU2QOCmdlp21wVAjQiMdCMaGO8+RIZIykR5vmiIwPeK/wxOcPIsOhemacFcaaK7IPptw1wy+69fB8zhpoHYrNCHLBqaw/W3fLMsV1Vtlx2eumOCoEaMQd5Mdpnpz0I/Fb1J9odoT1N+0Nv73tum/DDawZXHKWPaMygkhkfNnlTpmOdesRuzZnuVTWCunxOenxrHZ6/NgyxcMnVT4mMY4KARp2SyA/vnzeWORMu90WfpuKnLFHdcWSc+aLmM4nRc6PDt0snB5q1UNtCTVHI1ykxx1Kj/MHhTgqBDgH8uP2CSKRN333tqveTUVeFFB9ns159jIpf61Q9WO3GyHy+0PdeqyWrFLnvjWGj12CVqfHLyoOI3l8CkeFAMiPW0PpChX79qB7k8gfB/a+0OhBNKZgFXY4G8Q6e28Ohi1/n+brzs8fWvXwBm7IXLcnJMmnEoJWp8dPOcWrdh/kOdaaACA/bgkp1tgbSik/v+uCmZTyaE+sIYka7grz5r7vz7zK2xDHh7u7uzvv2+b78U+1f1C9Hl7P9/05r2UnVIFaHoITs7amx884ZUlU5agQG5ABGs+PHYJLEkYC1otCakpicyF7sb4rhPPr0eNiMqEqUmkinJBtTY+3Kq8nVz9t2IAM0Hh+PCK4LAG6QoV+dly/K2R0hTXqseRiMta+PzcgOObVT4+HQnHDMsQrTnGrL698agFAo/kxvnYvTzAScCFrBmPJxbz1KT8U12PFxcJYe9LWJsinxwlV5wnVTcsMD5+XHT1Wuax6ZgFATfeEAt+7l8gbCjjL0KOGLbnQEue5uvWQXMglVbWjoBVB7lc8r3+D+b5lhusaH5XsUeGWBQA13UR+bAyJliMvktS8lc0F5ujcdevBReYJVZfIf1c9IZ8e92qnx/csM7zQ3IM441N4lgagvvvIj80x6AtI6w9oE+KQC2AkSLceXKAXk5bF0g9nMUGr0+MtTllQWXPMmgAgP26tcCzg1DikTRlIXsemIp4jOuvcevBaPl4ZRHq83janSCptxVdx1uThyzdbb16ihQUTIT82i0Rb+M9Y0iYt5ny2kIoNOjqGXKIecz6bjwwC6XGJpcc6k+Y+q25bV8H2Ez7xBHE3GAj5sWkk5pBPjCRt2sJnRYW/SINJ90LkUvVY8FlCfK00ZVE7PSZxypj0+A2nhFRBwldur8k2LkGCyVL5MXbOmyCYdP24cDwJ6CJ4vXmF4WOV7NTISel6+JwlZx5BU8La6XEoTpmSHr/iFNujKnqsem0ZTx2qeWEBmOaaUAwJjBA43R066TsBXZzE9cv3hCpP7nSjd69Sj9hnhR2iI2xUXD893hGKu5YJsuGxS5XE9hULkF9frR4WOueBUOE73Bw96fT7XcqSR/2+I3t08ZKFG/qSme2KSafXcyb9fluzZK16LEKbmX0/dFeYLTlhWHocCcUjywSZ8FhSRasrFiBv4WlFMNtd5McAAMYLWWHXT48fWAbY5rQBVeVfrQnkX+zdy2rbQBiG4SlJc4SSxrGdJmlWg/6gQipyIE3SRQ3Sxgh8/3fT7S8ZuuhM0Tfu+1yCVh+8mpkTP2EDIOcz/RgA1LXm9btRj69mlhrFXxrzboK2E3MCIId+DADy1uZtdqMeL8dvmSRf6T0TP73BKIQ6+jEAqNvFevw1OR5vB+RlkMYohDr6MQCI28V6fGMJ8dgH5ILupWEUQt2wH0cAgJpNej1+FqvHV7OkeOwDcjm/FTIKIe+wct4jAEBMn1yPXyvvQ5ja2TJLPN4OyLPLoItRCHnHlfMtAgDENMn1+K1yDsPkFn+Ix2kBeSl8WyGjEPIuKudnBABoyV2Pj8PUrm2ozvd57DbIYhRCH/0YAJT15qXX44swsSMbarqM38f2gipGIfTRjwFAWWPOe/n1+HJmQ+uYpK1tYB5EMQqhj34MAMI25q2Lr8dnX2yoj4m6pozDJoxCFIB+DAC6evPa0uvx1sHjuo2p1lbEKrw1R/z1Ffy36McAoCu9Hj8o1eNFrh8Kvd5KOIK8Z85RABQN+vFzBADoyFCPn4Tq8cJGNjGHuoRVyChEAQ4q7zUCAGTcJdfj+8o7DVPas5HHmEXbmP4ryIxClOC8ct4iAEDGKrkeN5V3ECY0t5H3mElnQ4ugh1GIEpzSjwFAU5e5Hp+HCc0t7yETb62/ChmFKAH9GABE7VI9nttI85LzS8mvQkYhikA/BgBNK3N+FF2PtzdhF3Pq1VchoxBFoB8DgKTOvF8l1+O5jW1iXrX4KmQUogj0YwCQdGfeS8H1eG5j65hZK74KGYUow37lPEQAgISVOXX8C7VGPZ7b2GPMrm1saCF1XyGjEGX4WDlPEQCgIEM9/l45+2Ei1zbWx3+ga0z4FmtGIcrwqfLuIwD8Zu/+etKGwjiOn4QsVqezrgJWhKuTPqYmrBkxOPECk3JjSHj/72Z37IyWCaw9f+D7eRW/9Ns+hQcm/12Pp5npi3Kjt3UTntIqHIihqwBfXWWGQgMAPJA3XI+/qd2EuglrVmF6p3wRiaGjAF/RjwHAO9OG6/GVciHuy6YX3ZqxbEi8WYWMQgSCfgwA3pkfQz2+70trPzLZ/msTH0stoxChoB8DgG+OoR7fJfY2obkKPRxgjEKEgn4MAJ6ZiukxyHrclYpZqdu1KmTDyIvPTRiFCMU1/RgA/DIX00IfwHU97knFUrduUciGvg8vFjIKEYzLzJBrAIBjuRje9QFmbutx3HewCetXYfKgnGMUIhg3meGHBgDszbd6/OS0HkeJi01orkLTUO2NUYhTdZ2ZphoAsC/f6vFbZrhRdnWkaqItWeSyqX+v2hV9YiCGXtT5jA/JG6eKfgwAPnlpuB5fK5viC6n60NaUudhMyHEnkcZdMAuxD/oxABypUgwN1ONLZdNDIhXFSltUzqSiF6t23KXSBH8Pb+PU0I8BwCPmub3Q6nE8lKpioe1aSkUaqTbEibQj9eKWDk4R/RgA/DGTtdDqcZRKVV5q2z6kahir5vWkLQMF7I5+DADHqBTTMqB6HA+lxrLU9o0LOw8LE2nLhQKcuM0MbxoA4M6HmFb6AM9O6nGUSo25dmKai4U3C+9kK0YhQnWWGWYaAODMTAyFPsAvF/U4HkmNYqwdKZdSlXRVoyLZilGIUJ1nhicNANidd/X4NTOcKSsGidTIp9qdefvHXmJpzUgBu6MfA8ARaroenysLor7UedROLd6l7Ybcl7ZECtgH/RgAjk7T9fhWte5+JHWKlXasnEmNpKMa8yBb8aAQoaIfA4AfClkLox7HQ6n14sPZ23khNdKu7zdp+pwpxH7oxwBwfOSPEOrx1r+8TbQXFrkYWjhPM0ikcWlHAQ5l9GMA8IGshVCPt03CfKF9MZFaF5FqRjzofOrvxfcQ/du9Apz6nhleNQDAjVzWDqvHP+3V424q9R5L7Y/x+9ZZaAu3ZhCUr5nhWeM3e3fQ2zQMgGHYaAKmAYMxMcaAm2VXaeVEzaqUpodNyi5Vpf7/fwNjiJkSQ5LFaZy8z51LJLZ3/WIXAA7jRj+6kQ1cO9fjrpIwMrJXilQfOAvtJ3UugJ57oWzfJADgIIrocT0uZH3GtR53lIS9eZvQ+Wah7aKbqfZEWwTQd+zHANALd4n+ZSMbSJTthfDj+KN2WPbnbUJbmtTKQqIQo8Z+DAD9UGz1vdudfPJ6/F54cXyiHZKN7Kks1zWykCjEqLEfA0BfFCa9MbIRo2yvhKXNJAzhgEnJgROHr+/EHqIQ48Z+DADh874eX7qSsCfXVVe+ytp2frSfhUQhRu05+zEABM/zenx1oV1ue3bmuEwx0RWzkCjEqJ2yHwNA6Fzrsf8k7O3LhH/KttWykCjEuL1RlkQCAIITOdZjz0mY9PAaGpe7pba4vhKZKMS4PVeWawkACE7sbz0++kcS9vl8yd+MOwu/iJ+IQozdqbIF8G4IAOBPmbI9F+1591G7bMNKwns790Fk8YAoxMixHwNA2CJlO+2iCbd9P3JcbuPKwgvxE1GIkWM/BoCwxcryps2qCfUWmvr303wW7bvQlksB9B/7MQAEzdt6/MGRhEH/pijS0iw8vxKtO9KWYwEEgP0YAELmbT3+pEtEQSfhQxY6B2SiEGN3xn4MAAHztR5/CfhiwvrXFp6LH4hCjN1bZQv3RREAGCdf6/FXvS8ZRBLey3L9m1VtRCFG77WyRBKVTZJ5PBup6TyayAMwmzRf3ss3Nf/hZL6aBSeeJ00fc7ZJ03RnjOxUNpnPZ02t5nnww+RB5L7W45PALyaseW3hZyGIQuBMWWKJKrJ8da1Gb7bqNAx3k0hbokJWZJJ4rcJ1vcozWVO2fJz7lqmRXTDRdKGeah0nfN1mXVNlafXs8YCTsCQLj4QgCgH249qiWOHBeprLTuy2ibZUr0KTDCHf40jWcbf/sPJNIb3KWnzMixUfGNayVpazNqNwMPfQlLtJiEKA/fhpzCrkT508WMwz6VmR3uoS2woT/2D6fV2nlCL9t3wnvZlMVbtm/CBquh6/bTMKB3Jjtfsea6IQYD9+CjNV2Lf2m4XZVjsU/2ujhRqSqZHVbLTF/7nRyUy1b0EWNlqPX4sWnQziu+0qf+PdByGIQkA8Yz+uKlsplGeh9KVIE+1i/tcqQ7PKZBVLrbvLQuPrMS8msrHCpGlqhtIv3a/HdtMM8rCJKfs/ciUEUQgI8ZL9uJqc4bjSb3Cvf8/bNtItG+Rnuuu8XhT6v3h4rvyJM9mIyfWDUZxm9rcei0tdJkll4O6WusQn8QNR+J29e19qGojCAL5jR0UdFW8o3v7a7JYUN7G0pG0ipJpCKUUGZATG938PxQuzJtm02QvdpOf3BE5l4Ov5zu4CgO5BfzyPoDbraWYMAqxdEtIibAkDvBdIhEJeM8H69DvEpChU/aEJ6zDWUmmP1fvj2l1gLdpHeYG0e0E5bxAA1fCccCIMcjXrmjK06fSxZqMhLZRgkRr3/FETzxLSIu4I6+IT01oBLilxKc+tfSrsEs4TpNUKpXWLhVwkFAwKTX1+DQRARdwlnBCDHD4Bs0Qu1mpCi02xQFCHW2jEfNUPboIlLKih77DymXCpUmGf8B4jvRpUpFfJar5gRfkVQghCIQCZ/riFQVYtF9T087FGUyow6699v+5D3ZZ0fyyO02ILjt5RH5cR0rSaf80dEM5dpNsarVEs5CKhqDyGUAgA9MewTqhNCzLhTfCCkuOytKn164SSi4WMZlUuu8i3x/eQdg0qFlbrsoqJT0WeraDfIBQCAP2xLSORWmjdTCYchhO8vJmQkE4gMRKRKlVt+JjdUoPC5RoV9gnvOdLvFX/apMK3WU+GVOjdKvoLQiEAvzyF/riIRwS+ff/kfVw+rU+X3UPDqXAqCIPTmCWSYeVoPD7dr5LT8fiICHh4FsbY8Vaz54u6P6wk6Ar/Zb4bfyiPua63TQT6eE4JzVPnrUJT7TFvpSgWVuTaQuZSobXX6B8IhQBceQD9cel9wovLj3SZ7XoHBvcKm7mJMA7wLCzKD4Sn+xvVtD/+oRa+gzikeaYGhuef9744Kk7ic7W9QkbpkvXH5tpj3spLeqWy1xaOelQgFQkhFAJw5Q6B/rjcuePvAwq+ehckR2jm3HHIZMPKj9ONStsfK4bvJB7SrKbm4fm2e+Ko24kPSFY3wHPZonkqkFrsbY//erFOhYbH2GrJlAqlIyGEQgAy/fEAW401f8E3pkmyPn2l4LezC8FYR8mIZvRGeB5e/SLhb3mxsKm6UDXR+YzJduzo8uEzydiEUJirLdEeG4iFPZtXC2OfitxfQUat0mtweTWolAeE08W26re967ak03IZNi+ISNrBLgXXvEOS1sFqkiFN8Y+lp7p1iIT508IoUPzT6I/0fVFydxyN4m2S1oZQmKdjvj3mY2EFVwuFy4RcJDSHr91fIwAq405qrdtGbNAlKR03wIZ5JOWwRQFvt0vSBpoPmYSJ7InYo6quEmadkjQPlxL0aIqr65DJ5y+OXjvnJK0PO4VZLNUem9Z4VrEOWdgcc5HQpLf02hoCoEKs74+bmyRP1A6wSS5J+QZjwoxPgj/gkpj0oGeTpIw3amT/SHV7c0vPCK1FUnZ3HO32SEoHTh/PGo3fQcatpmOh3e9MH/tUYF0iEipd/v1yFQFQIZb3x0GLiEQ+TjNYHn+HbcIcZ1oL5KHs6ptb0+r42pGgQJY/wDPSUR7vOSawdIXchnsKi9vjp0iJeiz0Y2yVoEcF1l+gm/Lmz8f1HjIhqBa7++MwIgU2GTZlkM6EFOT5eFhw3bDiOGsineDrUx3/M1bt6Zmvflthh/wvdsz4kkqFEYMXTQrb4wfoZqwWPIhs07BQ+IAJHwnNW33TaDReIQAq5qHF/fFA7h0sdQwy4Zw+Ks2weIkve0S2XftMmE2FDJfElAOTK8qExlNhC94+lmiPTXi9RgV8azYLk5DmuoqEAICZblvbHweennew1JenvlEwb4Pc1jQo3CpR9de7O85tkFuqV0AOZW5L5vmOOUwQgUs9++zaNLy6Uu32+DoWWr5ZKNomfNaAHheAeTyytT8OOhKvoxoZFF7APmGBS/KfrvSgULbebNf4jAnnRyonqT4WM1EbFJ47Ju1JRODEXZpMKNMem4+FQwvq+qRJc0AkBEC2P/axNVoSb+abqa2X+1m7mb5p+Q+JKc9P8NwiwjvaqKl95dt/XMrrKW0Ubu84RqVagmC+3tC+uZUZrmp7rP4ksp33Qo5cmmsNIiEAcv1xB9tiQMRMDzcjwrukoMhAywHkoewYy63/QmHeWmGk/F7MSOFZNcIcs062ZZ72YyH9I7RgaGWQp9Yeq3u7buV5E8EJk/twezQA0v2xLb9MQzKvKMCauVAeq1xXyLAEJj3F2lyK8jhbILuqa5tThcH9uWPantxSQsK2trZYnaeEvwSEdxtJMHWbtT/CizOledbfIgBA1fvjICJz87BmHuGdUVDs6yHhDdR/nzPp/c+NGjslPE91b9NXmJ6fOMYd2LrsvHgu4T1CC7G6RnPFeEECl+ZpIABAObcs7I8HpIQm1iogvAsKZjlTP2riyw4K/SU4eZw/Kgyw4gnkY+nJ/a5jXkwsvixrsTzCeYgWZSW/Q57ihRj5NAOaYwBkPLavP2akjC7WKoRBodqokOHSRtJpxVuaQWF6VBiqjgqn0t/STpwbcGDhl9Wf7N37bhJBFAZwEu+XxAsqRqN/nZ3ZLrisXIRKtajQCqJNq1ET3/89TMEmA8WWOWdnd9j9fi/QpMb02/lmzvGCD+3xwhU958MsoKleo4rJhAAcd73rj+vKSkTOTim/aLAdS5OQtTZ7hF5pbhSeEh+ehdzfc0d2o1B+q7BH4FN7vPC05snFwpk+BxvmALge+PZJHis7DUpTB7tMbO1Lb7v1tSG0STkleXq88Fn6P7WnTT3m4dQwyMKxMhV4PcmWtscXHBYmU8rUqK/Pq+KBCQDTPd8+yVvKUkwpwoxCe9+FdT57VkqrFDMKzxwqEzFE2jBlZu8gG01laBH84017fMFh4ZQyNIr0KtwmBEitP44od11l6S2lJ0R7LO2Pe6IrhQlZaJapPV7pj0NpfxwysjevPZb3xw2ChYE/7fHCC9ZzE8dPTJ5XACCd/rhJeYuVrQ6lJ1GGiYZNvJallVgbBmShUab2eGUDciKdB9nnZe+DIBuflGGPYKHuU3s8d7PKSIVOM2HtaQUACtMfJ8paz1F3/U7DJr7JHv602buySvT2+NRnaaM60oaEl71fBRlRJoI1EyMfVHxw/zZju4mzLSbYagcgdsOr/riurIWUmiauFDL8VoaWKBTG3FD4Z6fwDpWhKV4nyAsiQVaaGF99WXt8r+KHK3mNppnq8zCIBkDqllf9cUNZazn66fsaNtIV/Wv0ue9MwlK9M1kJhQ1i6LOeHyvDJMjKvjKEBOc+me9WfHGzykiFTjJhFdUxgNgjr/pjZe+to1CogfHSpClKKmQhLNc7k50dcSgMWYeyytAMshLZhcLRcNA/NZtSgXnYHs89qzFSoYNMWEN1DFC0/ljZayAU5uudMjQQCv/xLxS2CxsKjctlH8ZUVH62x8YyZFEqlGfCJxUAKFp/nG8o7CIUIhR6Sxk6pQqFA5uAkBQ2FXraHs89l6VCeSbEdUKAtDzyafpDvqGwg1CIUOitUp0UHlicFPYSbepTQXU9bY/nHlf5qVCeCbHEBCBFNzxaKYX6ePsgFK6FUJhVfTzUy3pUSLvetsdzT9mpUJ4J8cQEwFl/XCdLCIVl9w4PTdZBKMwqFA70spgK6a0y3Kh451mNmwrlmbCGxXYAxeyPlb0mQmG+JqKRNAPun/NdhEJLM23o+R0KE4tQGG1JKBzHcWrt8a2Kf+4bqdBllR/rZXh2DJCu68qf/rib65zCOoZXM3TTG159RBbKPKewRQy8Q9lu/sOrY7qQXuHlS5NRO9FaJ+1ROu3xo4qH7t9mbLwT77ZDJgRI20N/+uOGshaRmzV3dQ0bUaYB1tw5ciLdfUyJPsNec/c+yMibzdfcjfWyD+ShUaQXolFB2+O5J3rVjMhtJsRmO4DU3fGnP24pa7uUmgi7j+3tK1Mo6oL67A+Iw52i+yzd8dHj/abreew+PlaGLl3oSC/zcv9JpM/0i9oe/ycVTh2kawPGEwLMFbU/DpWtPVc/vathEz+USRZVEnbZf7JTdF+VoSe9nj/jfadFQTaGFreG23rZEfnHfCAdF7U9/l8qRCYE2DYPGWvjHNlTluqUImX6pmEDP4VDlRPN/IOZlOqlyaEydMXvTIa8L6WPQTZ+KUPL6vFxQh6KxIVqaxva4zWpMOVp4jO9BJkQwOCoP+5SnuoOrhQyG8kfGjbwRRjRB9zqb7dUlwpPxF9CiTaMmV9Kx0EW3iv+4+MZ+YfZ3Js6W9Eer0+FI0pLWy9BJgQwOOuPdylHIas9djIKbKLhcnVpRB+yj3n2ytQff5V+CR1pQ8KNIwdBFg5sriRsWXvMC4XxlrTHa1NhNHI1oPBlBQBcuOpPf9xQVloOI+m+hktNlCkma2P2BaRmiYbSHCpTTMIT2QG3uJwEWZhYXCkcb1l7zAuFiTJdr3jtXCqcOXl4jFk0AM5c86c/DpWVmFK1h/fHf9m7296mYSAO4JEQAsYzYzzDq8Ou3JKYtanbJkALCWx9oGIgYOL7fw86gYSTpl3jc0Ye7ifeomnWtF3v7ztjZo97YGDCNcJ0WPxXveePj7DHrIxr7yG76PnjMdPJXMPHAZSP4rouOj2+55Tb+hbrMVgQTbiOakJCinOrPPkxdBCNQrtXGmc0apJvzIRJMNAyTf8Ua8yoySf0Mc+5LoIc/It+1CRX97mbnnUtnzHXxej0+LpTcutVYQx4AddRTUhIkW6WJz8est2FCuwKGLUK8xhZ6NvGxquHPdaUVYUL7DErRDtthGgV4m8UevlKhQjKR3DNpPbp8cqdx/aHTbo8af+RQwj5p7b5cZ4F1gHY5tOtwjx8G89QC9N0LWANuVV4gj7mAaKd5rILvVX4pZ9rdklULD1u1T49PvNonycN7L54TDUhIRlqmh9Dj+1oBNYdMlpgvTvPSo0+NU6afNaMAWSW0EKOHnOJutEhXhbLY7k+oTYhPVbVSo/PXOUpXUCJJE86cAghOaDyYwn/lQrZTnoARX9tj5PNRjNmpcMsTRdYSNaIAHmBPWYlua6LG/768LJIguW6PxmXPz0O0OmxqFh6fOaAp7iAMeBJlxxCSJEuI6ot64Yh20FPgaag8Po1J5t8/mppj3jXdIGFCpsQIB+hj1kgK6cO0/XfviyOm/PW8JLrBJRPhE+Pvaqlx2ee86RJZK3bSkurCSncbfTAgP2qEF8T4luFsxEnGxyzBN/arolWjlZh/SeQT9DHPF87Xlyr8H1xVeGHPkuQ+T5QjKF8ppbT48tORexxa9uCYq6jwWNCLsCNEuXHAMMeoia02ir8SXtpNvjOklpgbGr8hr5f+6rwBH3Mc/wgaIcl/HipKbIm9HPuKVFQPrbT41tORayNIC8x89u6/ScOIaRgd8uUHwMoz/aMiWmd8ZV6hTvVhB1AEKZPIASs5lVhuib0DGpC/I1/lyX9KKZX+KGfuwIW1UqP5+j0+KZTGekRZKnATIsnXXUIIVnqmx+vyJBt5AdQnBZjlCCf53O6JgxdQIh5yjyC3Xj1rgpPsMcczXnSBNE/LzhBHvfzV8AVS4+XzUmPM4ZNBja20dCQCSEb1Tg/XlFtli08VFCkEUv5xsnWGRP8T0yXp4jYcFR9UacZ5AX2mJXgKa6dPVF9+zPI0mA3fcx1MZRPwDWyQelx1ivIYxtXjvccQsgGNc6Pz7jt0KAkRFM9lnJMFwsT2jOW4gGS4GndHAFyPfcVfvqFPeax5Ckta7NfwnJ0/J6ltXIuYJxA+TQ4Pc54704qfHi8T0MmhBjA5sclubGthBcyjd8OwAD6D+CMFhb+8+64gLEfJXnaZLprY7eWzcJPRyzNV5CHO+BpAkwJlnZs8cW7t8LsYfNusuAtnyV+1CKsanq88gg/gRxzHV0oJAQBkR+X6Mr2UBy2OyuHh4ELF0OwNT8pQ/7j85sZSwuHgObydZNplGM0VnNU+bJwVRIij9md8zVSgbE2W+O9slUS9hkz6ooGZU+P5+j0OKhuerzyFD2BLLiGLhQSgoDJjz1oNMnWzU5p4oS//s4ytKzeyNfJ+TLaOe7XLSodIp8csQwCdhZNBc/gAoLH1h1//IIPjt/1jXdOiZKnxyDR6XG7uunxmT3kCusxT3joEEIuyP0y5sf/S5tl+Xnafscba/Tt+4xlEfbfiNUNWmPXhS2Uz7Isqtkv/LSqCFHHHLndAc80xd61zfJevDIfRf7iymPMHtKmpcenL54+cirlzj5PaKGulexX7LsnpNKulDQ//i/abJOvvu+/edNp0r9T3/e/sk2E9agt26Qb5X8BZ7FyVBWLFcQxL7vzwWAg+SZTuxNYOs/zfoh83q3+D3Y3fZwsucpnznX49Hh0Vhi9OKjS8uZnPCnOO7yte+oQQi7MNcqPNW1GdhEKsGbMt5MxZHN7rO4EnCOe8O2mtubyi9dT+S+ilmGN1vb0OED/HvrJ/3r4vDotsxeIZYUu19A2GkLOR/lxYSQjaQbDD4h7hTkGJVTdq8Lza0KJqAlRu0Pt6yiDmmEO5bPkuik+PdaT1AfPnEpIB8hLwykTet6OkF1QflyYIGTkHD0XrHIl32oAG6had3bPL70jybeSrvWnwfHwb1jKKqXHkZX0OFEXVmI/ywFPmBh+SKTJY0J2QPlxgYZ1bz+htRVYpgZ8KwWbyPrW8B2FTd5FXJmPSmFgVHXJCMoHnx6PUulx2uNLFeie7ZmspU9/0qHJY0Iw8PlxCARGjBj8+Ubp8m3cBtbwh3C+Ad+mFYE1qsOK1HHzPYFW5nePY3x67Genx7q9A6fknvAEGZn9KqjONUpC6oLpAiD1LTQs8BQUIh7wzZawxWEdm4UdF5BF4cQFgGrcqwjzP+5c3poQWuj0eJhKj7Ptl71deIkntIzW0Tx3CPnN3t31qAlEYRy3MW0a+2ZrqrXd7NWJh4wGCWiGSi8kwRtK4l2//0fpa9JhF5RZQI74/D6C2Yuz58/MwIV9yKVBgl9UHweNBqwcak0aW2wKTW7vvizcKqKaQ2GQUMO0v2jHTpO1YxZGe5nH4uJm6/F3LjcVvUYbzzlHW3+RiTePAbrwCv34Me1vF/DARpGF+mOhWZ5uaCzcqtp3PGaaWuAuvy0at3SpV5quxz/4lJHkQyd3nJNRBZpzxEdygB56gX5cSCEi56wdal0acoGAznJ3fdntrhRV5nIRz9FkkPy/0tbv2Uj4sB7r2vV4yafNBM9NI/tVYYYrCgE6h35cOmlgXfjPxnPpIvRe8QOKKomW1z8XbnZu3edgVJpQm5zGfuZvyz7+BxqzQbVVj01zsWPhJ+tVoeYcyXtQgP5CPy7neuubHww3S6XpgnSaxfxflFBVjr9aXK3tUrk178TzLvOd3Vd/9a3uQLjyJb5a3HQ93teux2sn5N+uMyJPOUdb/j3fDwCgIvTjy9GO8v316gatfT9yqBNuGgRRGIbBgey4ju/vVldl7fvqqck3VfyHCoP0QJfjOp7vr55i5/tO76Jxa/U4IiI3UHzGSOaRk88TNmWWi0Lhx6sBeivXj3cEAABPoGrXY68o3CTHzOOTpiInqKHdqjDDdTQAEjzPVSwCAAB7un493pR94n1wYj5hIvE9uLHVqlDjOhoAEd4uTF8JAACs7WvXY/fUxzwHx+Nyc4GfFg7Z4i5vB48eA8jwBv0YAEBWPV7QI8eIy92LW66NJ9Vvl0o8LAoBZEA/BgBotB4Htevxmgok+5jLTL4MhBlWv4c+wKIQQAj0YwCARuvxoXY9VlTsGHKZkbADJ+NJ5SdeYiwKAaRAPwYAaLAex/XrsaYyOruWZeGQK/4oKRaFAGKgHwMANFiPnebrsSkJPC42ErVkG3OOS2VCLAoBxEA/BgDouB7rgnpsPxZO7gaCTNmUVZuopwMAsNReP/YIAACshLXrsSqoxxXHQrH3Pn+udoF1Jucxk/HH+znzfPQF60q4Xe8Xhg0BAICNpH49Xlepx6Yk40IzQedNRlXOZCeemEXhcPJ/uMZYCLfq3cLU36dJAQBakV6sHpt0KD0h37EprvLjvRx0Zjxjw0zmo9IA7XuNfgwA8GRRw/XYpWrcmP8Ren53zib3fHqfDToznnHOBFMh3Cj0YwCAhupxVrseb6iywBP9vsmX87+MZtPHQWfu+RchAyqAPfRjAAABUjYda9djj6rToeQPC8fnXzUJ2DAZdOZO8sYV4Cz0YwAACSI2eO3X47yjx7/JbJ/Ts6+axELOTs/4D1yZCJDvxysCAIArqMd/JFHRVPhxIMFLNkX0yEHIfTSf+C8pMRugQ88WJk0AAPCTvTtsUSKKAjB8aam2jWLJSh1bPw0exwUzLbRMckBhM0HYIIr+//+obFnOtOPoeHe7B3yfH7A7+Okw771nPOpxSR/9as2qZ3aiqYt2sx+3jZziO5K/WKQNOPcwuw0BALCjpXc9Hvue6x6OrO6xPtvSj1Mjc2xTctQdcJAeZfemAgB21POux+f+GyAGRl90RaKNi+vxqQumIleM5GwgpOf0YwDYx+qW63E/3ku3Z3MqrBb247aRx62JcKgQoB8DgJelaP71+H28n9nI5FTYKOzHqSivXDBHkqvpgINEPwYA73o89q7H39PxtBvvpW1xKoyK7mbPjSwp1O8zrTwSUBL9GAACW4m28K7HP+SP0WAel7foGZwKqwX3cKZGHjUSxcjLS6A8+jEAhLQUbeZdjz/Ild5yUfqvzQ1OhY2C7x+PjAxg63rMUhrg2rOWch4DAP5LPf6QqceijcvOhbOOubkmEq2deVorqbYuipUL0UBAj1vKxxgAsF3Xvx6/u1GPteWq5HUTc1NhXZROrKyMPOaxbNRwwCF60NLGMQBgq7Z3PX6fV4+1dDAs1bOtbbE+E22oH9VIPW6K1md/NUA/BoDS0jurx9qyW2YqNLZu73jjy9TURqiNRHsz4aoJQD8GgLLmt1yPv8kGoxIVeWBsKqxsWEozFOXEBfNStK8/xchzAaXRjwGgDNP1+Fw2SncfORfyj0rNBdQUJVWPaePwXiRa/zL5JNqxAw4R/RgAPOpxx7sef5Ei6Wr/qTBy4TREG+Z37poL5aVokyT5zKtCgH4MAD71eHon9VgbdfedCqunLpjahsaemrjQUZOMn0ly2TfU3oFAsv24HQMAStTj4R3VY2284z9ZWFpMU8ndVDiz8Xgnop0nv01Eq7OrEAfpSUv5EAMA7rge91rKwxdnJ7JFb7DnbZMjF0wz92damXgd90oyviS/XZj55YBw7reUdzEAoMjQvx6/bSmP1jmz0axIkbS782YaIzcmGqLljq2RC+O0ItqnZG0iYuO8IxDO05b2PgYAFJh61+NuS3vurtQaVSnQnu00FZq5bFLL/fzxyMKRwqZkfE3WLiSj6oADRD8GgN11bqEea06JXpz4viwciZXZRrRB/JeFI4UvJOM8uTIhIAP0YwAIVo+fuayoUZdN2vF2s46V792d5Hz3ZW5gS2GtcvNE4dpF30p6B0qhHwNAEFPR5t71+LG74filbNDZ4f8Ne0aOFZ6J0ovXpuFP7Z1WJeN1cu2blfQOlEM/BoAQOqKk/vX4gcsRHVUkV2+x2x5FrXLqgniVc/hyKYoLoilZF8m1y0929jwCgdyjH+MXe/eymzYQBWDYatX7zS2lhHBZWZyYIjD0Ai2NWiQitYAUiUrZ9P3fo9tjezA4Ax4L/98LxMrqaH7mDID71OOro9Zjza83xWiTf11h13Pi0rC+euH81ZCOxN2Fyroc/znAoTc9bRgAAE5Wj6dZ9VjbMRb2l4es1y7D8xzN1Py8dH6Roy5xP8OYUYm2fwNuvOwpUQAA2GFmXY/7mfVY880ReXGz/2+U4sdxH0Tpp1ZXt73i1SVhHcZsJ0yFqLq3PeVzAAAwW9rX45GxHpv5HTGIbvd+ZiQizkttS7Rl8gjT9wpXF1M81r6W6aVA4FD0YwAo3KqIeqxdPBeDVbDHsAwBObG+2v3q6rokjMOUAVMhqo5+DACHmB+5Hr/29mrVRDl0P+KnMtxAFu2T89XVDyVh8jtMGzMVouLoxwDgoB6/8g7gd+9zCblfgsnmuSizIBg6XV39QZK+hopeYc1mGlQZ/RgActfjW+t6/Mg7SKuWfyqcRu5XWD8UJXK7utpvSNIgNFpLUvPCAyrkCf0YAPLV4+i09Vi7bOSfCn9JTNMrXlu0m2DubnX105okjcId/kpSre4B1fGspwwCAMC+erw5dT3WOvmnwpmI45eGfdFWDldXdyRlvA13GUhKl4SM6njf06YBAMCuHpv9yFOPtXYt71Q4jZzfNWmKspm6Wl39tJExE5pcS0qt7QFVEevH/QAAkLKxrsfzfPVYu2jkvYP8y/ldk/j6ajerq83LHif/wizXkta99IBqiPXjUQAASIms6/HHWD22viqxyhWQix9qWqJtnKyubtVyz4R6KtQe0pBRDfRjANjj9sj1+IH9UpVhdkB2/a7JhShO7r3Um5IxE+adCmuMhagG+jEAFFuP39iv2otugiyfXK+lEcVBy1YjoTb+F+53LYyFqCz6MQDkqMdz63r88hgPtS2WQYblwvFR4XPR7O9C24+E+o5JtjthLERV0Y8BIEc9XlnX47dHeb53lv3Njo8KH4pS7Opq/7mYjbbhXnpfIbusUT2Pe/RjAMiwEW3poB4bp8KrIMvM7VFhW3bwTs1viNldeLB/EzGqMRXi3L3rKR8DAMCR6/F3Qz22nwpvgwxDt0eFvij206n9TDj5Guaw/ShGNbbT4My96Ck/AgCANrSvx18M9dh+KoymQYaN26PCpigFrq7uiNH4d5jP3a6hFjhr8X48DwAAypV1Pf5mrsfWd5D7QYap06NC/a1Frq6+tErH2vqnmPC+Cc4c/RgAdluUox6bJq2r8h4VtsTI906rk7GJJqftQAy6HnDW6McAsNPNkevxM89CI8cO66nTZ00u3KyubkrK5E94T+uxpLGXBueNfgwAhdXj954Fv5ljW+HG6QvI4uKczZeU6214f38mkvTUw3/27m4njSAMwPAkWyu11dJukR+Ro4njotFla4XWmmqCCSKJCSSecP/3UWttMuDsdswsLGHe5wbg8Mu8+81grb2hHwOATT1uO9fjTeGkFtoH5G6hR1wtZVARi1VScy4HkZPxQ8JQCL9s0I8BwKYeXxVSj3WVVwTkkftbIu7zmS4sC4MF/ujxIHI0vmXTBH7ZOdAdSgCAsR53C6zH5lWKtvVRYV0s11YBb9zVDPXY8aCQfAzfbB9ofkgAQG71OM6qx+7LJl9lulGRZ1yNsIDNXYs9E7dPChWPmmDdzfTjbxIAkFs9Psuqx+6fFcZ9merEcSbL9/vHalksXMvxRhrdtGPcnwbW3Gw//i4BAE+unOvxSXY9dr8CcCTT9Qq9TaVRVZp9sQQVZfLgdk2hLhDAuqMfA4BJO4d6rFvE13o3MtWwgFUTXaWunrVKYinqyqQzdTgm1IVcU4j1Rz8GAINuzvX48yK+1uvJdLHSVMXy1faCR82yWJKSMkom0avcKrM9Aay9j/RjAPhfPb5xrsfvRS72rK+lOfRuSSJQT5zWkMenymxXAB74QD8GgOx6fO1ej9+KfFSVrmd71LkvPBAos471VDjoMBPCa5/oxwCQPVIdrkg9flSyPirs+bc626wro2QaWZkmyijk3mp4YrYfn0gAQA71uGusx+52bY8Kh971Y22/ZU5yHlmYJMokDNgxgTdm+nEsAQA51OO2sR67a4SWR4X92Lt+nDEWTixmQkZCYKYfn0kAQN+9Hp+a67G7wPaocORfPzaMhdZT4YSREKAfA8C84crWYyHKoeWfu/exH/9RDsLMqdB+JtxlJIRv6McAMOsi53q8I3IU2D5rEnt7z15jK30qtJ8Jqx4N0gD9GACWUY+3hVjcUWHfrh9XhVeaoXrhLkp1x7t2wJMv9GMASK/H9871eEPkKlC6K8t+7FkJbWy94maaacIxIfDXJv0YANLqcbxi9ViIcmhZt5XOu7v2AjUvGUdG4198TQg8e3egOZYA4Le+0o1WrB4/2re8lebC70c5XibkTmR0xEvHgLkfdyUAeM29HsufGfXYXcNyah16einNP7VQzbmMDI55wQRI6cdtCQBec6/HF5n12F3L7h92la4hvFOuWqwgn6s5IZ8Twmcz/fhUAoDXYud6fJRZj901Lc8yr5WmIvzzYipMBtGcccJMCNCPAeA3e/fWk0YQhnF8oj1YD/VA1eDpapwXdnUVD1WLFnthUi0JaUnsRb//92hILczCLCy401Dn//sEhKsn77PvOy6tgtvjGVW8cr7cWgnypbuhqbBW7ROTCYEUQ38MAE+aBbfHy6p4u/l+YyvgS4VZqfCxmnJPJgTS1uiPAcBPe7yoPNgSWyvfHrUK0kpZ0r6my2MyIZC2QH8MAK72+OHZ7fGq8mEzX3L9IpY5FaT+HeS4arkRCfuaIzDgDf2xU6V+Eh8cXBsAmNiy8mE73/3qJu+2KbWTvYH8jfuEwPD+ONbQSRSfGQB4rkXlxZbY7nSGW7HsqUDNZj5sUhMJ+8A3MKo/vtahq8fnBgCKsKr8KOd6//iOTZOO+Yxdk7akbPK2HTDQH9d1yOoxfTEAY6a6Pe7bP67rLGyadKyU3KPChqSwZALQH1uSE2aEADqmuz1Wai7fUZpLNk06dpyjwrYI31wCg16broD740psAKBI75Qv+T4qbIb+psmTPdeosCG064DDe9MTan9cOTAAUKwPypf5XJdzbhmFuQrkx6dBIXNUwGXJdIXZH18RCQEUT3kzK5aKzpCwfvzH7OCosMbmMUB/7HBBcQzAgyXlzZxYLnWGC7HMq4CVxdbuv1FY2lIAnP1xRYclYuEYgA8Lyh+xsX48yrrYatXqDVsmQK7++JMOSUJzDKDP1LfHfS/d3eVaPw76Dl9ZbL9+iK0U9F8DDO2Pz3VA6owJAfT5H0Lhhlha3KQZb1R402ZQCOTsj690KPiaEIDDlF8pHFidONUZTgmFzlHhSU1sfFEI0B/r5MwMc38URYcd+wCQR8NY1pRHc2JpZoZC5mHOFM2jx8Awq6YrnP746tpkOoqIggDGdW8sM8qjrVzrxwmh8K8VsXCjEBhm2fSE0h9HJsPHRrIPAOO79nu62iaW41yhcFcFbU8ylBWAtMXg+uPIuP0kEQKYkLEprzbFwqHC0XYkw7YCEHh/HLuHhMff9wFgMofG8lZ5NS+WC52BUNhTki7WTIAx+uNEv3SxMxJGn/cBYFIP/zAU7oolIRSOtiFOmwrA0P74WL9wJ8ahQSQEUNjy8Svl1WyuUHgsPSUVtnXp4lNLYIz++Ey/bJEZ9Ju9u91NIojCOH7s2koxGMJb2li/7Z4hSArBFBSIfTFpIt+4/5vR+MEcBim7uBO6w/93FU/OM+fM048MAP7HUI1LCSpxxird4Sv/3P3VZPcYyOvNCfXHA90yfc4AoMSLNOcSVM0ZXwiFRXZz+BIa2OfdyfTH35aMCQEEoNaFbCIUHpV9hslLS2Cfy1Ppj2dLXhMCCGCtlvgIhUdkHxXy7zGwV+dU+uOh+h4yAKjURRpCYXHNNgdpAPrjlxePp3xoB6AMj2o0xEMoPLoe/x4DB/XHwzRSffVMeU4IoBRzNVriIxQWF3pU2GZQCOTpj2dplGZ3ZEIAYfxU40zCqjljkSsUNuXU3ThPVwDk6I8HaZTmZEIAgSzV6IiPSeHxdcmEQE4tNUZpjPpkQgChqCVbCIWvwE3bdMfcrQZ2ex9/f+yXx2RCAJVcPiYUHqiZXLs/rhPqdOAFFxp7fzzmFg2AUFaEwmq46iZJ90oAnHR/7J+tvs8AoCz3aryVLYRCABUSe3880Q1PGQCUZqjGpfgIhQCqJPL+2BsUTtcZAIS5SHMugSXOeCAUAihbS43PaWQmuuE5A4DyqHUhgSXOuE13GBMKAZTRHy/TuHiDwlEGAOVZqyWhfcoVCp1RFwA4tD9epFGZcI0GgKeyF2mk7ozV7Q6EQgAHa0TcH9+pNc4AoESPajQktLrLg1AI4GDn8fbHC7Wm3zMAKNFcjZaE5grrCQAU8CHe/nik1iADgGDLx2cSWNMVlggA0B//NmNQCCCkpRodCaxGKATwL/THOQwYFAIISS0J7aMrrCYAcHh/3E+jMVKLu9UAsiovH/cIhfjF3t3upBFEYRxfiZUSaq3Wph+a9NPsWbLAsooor0VjIdEapamm7WLv/zbapA1OIjQ7yobZ4f+DW9jkyTwz5wCZ2xZNV7nihKXHALJ0uYKJNGbeeABgpCCalnJFKLrIB4ClGopm08takA4LTQA8w47oOsoRVdFc+ACwXDXR7HoZexkYe+8BgKFXTvbHLQZXA8jShWheeBn7EDC7GkD2dl3sjyM23AHIlOi2vIx9ZCINgPnoj43WmRz7ALBcX0XnZe1tYOydBwD0x0odiua7v6aSP0YL3PTCYfff7zAEYGgoD6bFQtYG5koF+5U3XnsAbLIrmiPlhJpoxv46mSTno1Fz3AsWOxi0vgiApZlKtqbTqUzF7C95+co3C/seAFvsiC5SLujLzNpcKZwk9ZGWBRe4vr0QALDKXnnLA2CFomhi5QLR+c5L1M34LEihSiIEYKXShgfAAiWZcaQ/roim4bvsrt7pBelc3/4QALDUJrEQsMC+PHCjP9ZCocM77ibJaBykN8jLDSMAa4pYCFjAuf74UDSh76LkpheYqHJKCMB6Je4WAsboj1OHQhcXH9/Vx4GZYUsAwH5FniIDpuiPDUJh3XfKeScMTDVojgHkBIeFgDH64/9pyIxToXCimoG5a54cA8iP7R0PwAqVRNNQuVcTzSffDVoiNNLlNiGAPCmSCoFV2hfdicq7mntjCrVEaOaA6hhAzpQ9ACuzJbpQ5Z1rofCucxY80a0AQN6QCoEV2pMZF/pjp0LhfT0MnuCs3b5qNoeyQP+o2o3jOKwAwAr8iuN4WP3ZJxUC1inLAwf6Y4dCYWJYG8ftXvM0itRfoczV6hIGAVgh7LZkHuZYAwboj9cgFE7qocnRYPMy+qx0oczRr7YrAGCNcMBrE8AqbvXHLSdC4X3qm4Th1WmkHuvIY9+GFQCwS3sgj2wzrxBIj/54MdEc+/mUjIM04l4zUvNF/TmnhBXgN3t3t9o2EIRhWJSmIdCkpOQSViOxTm3hWPWf0tjYCtQE4hJ6kBDf/230dGIs20kF2hHvcwl7NOw3P0B4RgPZ9j0C0Iwvok2dbaL0YovcNDkse1iVrtpAtj1vUgAI0oRhEyAYn0XpONNS60Wh88lB01np9prIloLkGEC4/JO8dUqADDTkRJTCmeZFyWJrDpeE8/TxuMpYy5k4BhCyTU6ADIThokX5cV8UH9tysCT0s9IdNszlrZzoGEDYNjl7aYAwnLcnP74WpRtb4vyhinB4fGGsDagJAYRuuyo8jwAcify4QiHKIrZj4fenxrOhO1KXf0IA9myemDUBQtCe/HgsNtcU7l9Ck6WlO941NSEAg3zBVyEQgtbkx5nJ4ePXcbLHdPXe+WutoCYEYMOErkIgBK3Jj3sGh4/XZVItuxm+v6tSy1IAsGHAADIQgAvRxs6qoWiz2IJ9zYSj1X8G6MIZEwBmjArR2FUINOOrKBNnlRftTxy+1/uk0kPp3q8jWp4CgBkd0U4iAE24FCV3VvVE+R0Hb13WkRtrQ8JjAGZtCkZNgOZ9a0V+3BVbLYUvvrokXNbxV3qbAoAhHfJjIACtyI/7Yml19XqcVJivlu6DBqKNUgAwZMSqQiAArciPc1F+xmFbzCtLQvdhXT4KAVj2LMpZBOA45Mf7o9O7OGTrm6rgeFbfE/gUAEy5o6kQCEAL8uNctB9xwBbz+noJtR6jxwAsG4kWAWjEpSgDZ5AXK7PH68dkt3RZ5+nnuxQAjMk5agI070q0rrMnF83Hwfrrk52mw3pPP3PgDoA5t6JcRQAacSpK5szpyxu/4lCVyU6+hkLckx4DsK0jyqcIQCPObOfH3cLGmMn6vub5Eq3PhTsAtmUUhUAAjOfH12LixN3LPNnlYVnPI3DNBIBtGTtpgBCYzo+9mPgoLOtPjrUBLYUAjBPlcwTgSOTH/9i7m92mgSgMwyvY8FOVazg+sZzQWCSp49hIbWmRqFDTBdANvf/bgA1i4rHbLlz7nPp9ruLVfJ5xMB57OCjsmI5X0hcN1CkA+EMUAhZ43o/XHg4K228dbwvpjQbWKQD4QxQCJqjb/XiuDg4K5bzfCyaxE6IQgHdEIWDCBw0sxY9M1f4bhfu+jwljKZePAXhHFAImvNFQIV6keuibwTcK2/91fCZCFAIAUQhY81pDmThR1nroJDHndzWLZVdCFAIAUQgY5HI/jprwLjHn5/kslooQhQBAFAIWedyPoyY8tTceS0sT5nsRIQoBgCgELHK4H6e1NnxMrJHOGyZEIQAQhYBJ7vbjTJvyxJqyezo2EYX3uzkAPK+cKAS88bYf77TpIrGmfGA6thCFu1oB4Lmtt0Qh4Mt7DVViW7FQtf5B4e3qoVvHBqLwswLAAOqMKAR8eaeBuZhW1XETfklsua1mkepS/hk/Cm8UAAaxIQoBX15poBbDiqX+ZfyFwrYmXMl/40fhRgFgGDdEIeCKm/04rzV2ltjS0oT5tQRGj8J7BYCB/CAKAV987MfpRp024ZWERo/CXAFgIGuiEPDFw36cLtRpE2aXcoAoBDAdRCHgjPn9uMg26rUJt80mJAoBTAdRCHhjez+u5rW6bcLv0kQUApgOohDw5tjsflx0F6GeWvu5XUsTphIhCgFMB1EIeHOkoVJsSLPdWrtdOHif8FpiRCGA6SAKAXfeauDXp9EtFwt9xJ25/5g8qQmJQgBTQhQC7hyrN18Ta8onNaG1KMwSAOgXUQi4dqS+mJuOW5ow30sLohDAS0cU/mHvblfUBqIADCcSDWJ0CXgJM5MS8AOEtCDUdfsBC4W4P0Qovf/rqLWwmGXjZvSHZ2be5ypeMjnnAG7LjEsElkzdcWU1UQjAd0Qh4DaX3o8X8j4TatW1CYlCAL4jCgG3jYwrnqUtJzyyaEKiEIDviELAbX3jhqqUNnT8z37buQmJQgC+IwoBt7kRhTKTUP/ZFm/Uqg1RCMB3RCHgNheiUOTD8dFubbGLhigE4DuiEHCb+CisNtKO2r1a2TQhUQjAd0Qh4DbZUVgdHkW+G5/UVk1IFALwHVF4FMej3n/9OI4Ap8RGrKflXAumijd+qUuIQgC+CzwKB9NekpqmNMmnkwhwhZHo6VDO5H4iPNlv7ZqQKATgu5Cj8CEfmzZZPo0AJ5hzpQDz2YuWb1cWTV/UZUQhAN8FG4WTPDOXpcOHCJDPnNPoaFU0ld/VZUQhAN8FGoXTxHQxHkWAdEThNX4UTcvP6gNEIQDfBRmFo8x0lZGFkI4ovMJv+0MmRCEA3wUYhfEpCclC+IIotLfb2i+jIQoB+C64KJwkxtaYNTWQLCUKb/6hcKU+RhQC8F1oUdhLzRXyQQRIlZozLsz93t+saFqrDohCAL4LKwoniblOxiAyxGpEodiLcpLs7z54TBQCkCioKJym5mr9CJCJKLS0W99/yIQoBCBQSFGYm1sMeUKGTEShpVrAkAlRCECgcKJwMDS3GVOFEKkRhSsNy200n1Q3RCEA3wUThYOxaVMtluV8dlKWi+f2KuTHQkiUmDM/NezO25WqI6IQgO9CicK2JqwOjy+66et80xKGKVUIgRpRuNW4rL77JROiEIBQgURhSxMe5vp93zYVVQhHNKJwo2H1eFyrrohC/GXvblfaCKI4jK+iBEmsKF7CzNmyoBEK6YvtNjE1EBDa0A8B8f6vo19n1sTZzRbyd/L8ruJhz5yzQO4OIwo3NuGkWvnt6sVyUxXyrhByiMIew+Mn1xpRCCB3hxGFV5uSsPYJ0wnbJngHiMLdh8ezX641ohBA7g4iCi/tlfXKp9WVvXJVAFqiKPzm0WF4/OjaIwoB5O4QonBoTZNb3878wZqOC0DKsQXGHm+4F/jlMVEIQNUBROHFwBrGtW+r/mlNRwWg5NQCPzy2e1S5RkMUAlB0AFF4bg2V72LKsgm0RVG49NjqZSY0PCYKAcjJPwqPrWHqu5lPeFYIZURhW5+UhsdEIQA52UfhRbIJu1fhdQHoIApbepYaHhOFAORkH4UnySbsXoUjBsgQQhS2VEkNj4lCAHJyj8JhognbViEbyJB1ZIG/Hls8ag2PiUIAcnKPwlFix2S3bZPBhwKQYYHvHpv9memcrSYKAUjKPAqHFln7XVUWOSsAGRby2OxrGbl1e0cUAhCTeRSOLLSs/c7GFuFTIXQQhS28lJF7t39EIQAxeUfh0CI3fneriYUuC0AFUdjCogzdfXb7RxQCEJN3FI4sdOf7WHDBGqKIwrRntS0TohCAnqyj8MhCk9r38mChYQGIIAq7fiicOQVEIQAxWUfhmYUWvp8bC50XgIgBUZgyLyO/nQKiEICYrKNw8H+P+o5ZNYGkQfxyFqm71V+cBKIQgJico/A6cba636fC0wLQQBSmOLlzNEQhAEE5R+FZ4kVhZ0vmx1BEFKZUZejJaSAKAYjJOQoH8epxf1Pmx1BEFCa4MqJwjoYoBCAo4yi8sNDc91ezfwxFI6LwbVUZ+uhEEIUAxGQchaepNZPu1vzqDoJO4i17NLgydLf/nx4ThQA0ZRyFV6npcXdTHhVC0D/27i61bSAKoLAS6vihaUOyg8L8gMBNwDR0MDRRhQShD7Yf3IDw/tdRmhTn2pZNak3I9eh8C7gwehCHETNai8I7iw21vnuriUIAGiUchW/wTW3upAxQgSjcq1G6UUgUAtAm4Sh0ko3jwQknGaABUXiUG4VEIQBt0o3CEydc2zjuOGkCfYjCfRZaNwqJQgDa9CQKb2wctRNOM0ADonCfoHWjkCgEoE26UXj6Fq/PkRMuM0CDwVpcWEhLtRuFRCEAbXoShSMbx/xYVo8+GTjht4VU6byjkCgEoFC6UXgZLQqlY1k9+mTjSk5IhcqfmRCFADRKNwo/OGFOFCJdROFuRuVfj4lCACr1JAptHEQhNCIKd5t4qTKaEIUAlCEK/8/tkawefUIU7rTw0nejClEIQBmikJ1CHLsvTvhm8SJ4aWpUIQoBKEMUEoU4ek74ZbEyK7xQGF2IQgDKpBuFV5w+Rl84yWLFeOne6EIUAlAm1Sg8GwyJQvQFUbhD7SVNF1cThQAUSjMKz06Hbs29jWPkhKsMUIEobLdUfB8NUQhAnxSjUCRh7NfnV/59DIWIwnZTxffREIUA9EkwCj+euy2PNo6cKIRCRGG73Au50Sa5KFw2o6oaNUsbR/PExrA00/pJVUacNq4ajQ9u1vy1sABRmGUXH1yLBxvHtRNOMkCFoRPmFs8Wqo+ZpBaFZSj8P0UoOwfhdFX0k2nXvjG1f1GEpuO0ydq0ziXXhNVS89C5MsuXaZNqaYF9ehCFp67d3EZx64TPGaDCxqkqPAuqj5mkFYUm92tyE3Na3aWVytxvqDvEktma9qosPMYHh15KKwovPjkh/kmT0gnDDNCBKGxVeGFi1EknChcTv2WysAdqxLTOHTcb+xaVPcyy9tuKUacHFy9Zm9xvGbNbiP5G4cDt9GhjqBUvHj1GFLYpNf/NJKkoNL6VsQepfJvisGmL3Lcazw6aVvhWwR5mFHOpdto+rbTAayUVhWdXbo8fNoKfnDOBRkRhm+CFG6NPKlEY/A4h6jTTueKkySzmtGDffan7pgE9jELx6fitvh/PHedMoNE5UdiiUH1JYTpRGPxOIeo0E6HiZBXGnBbsOy1VTqMKQRT+Ye/+VpsIojiOR9EEiW2p+ALCzBkJrA0Eq2Mg7TbuQkVIvAhCiO//GpoidXdzssmenMrM7u9z6cZDZi70S/bfo2cDqnVnTzfGJYUQpBdU8MvC1twVfTDhaUcUelfDq04z4orjq1Bzmre6SxVMQxUCovDRkA5J7Klm11TwqgcQiFIU3ljYucIqNQFqRRR6V8urTjPiiuOrUHOat7pLbTwNVQiIwvon0QxI97/KWyp62wMIBKKQMXIF702A2hCF3h3gVacZccXxVag5zVvdpTachioEROGjV8S47J/pPqrwHmePIUyIwl2rsF9x15Io9O6gRHWaEVYczytP011qo2moQkAU1jbhi/PqI2qu7GlGhLPHECZE4a4s9HuP2xCF3h3B6E4TVhzP605rw8ZBx7UhCpkmHDyc3O1TSaJ4RSFd9ABCgSjcNQ393uMWRKF3RzG604QVx/O60+LfOOi6FkQh04Rv+tyh+5k9wU8KbuUAzGPbv1iwdhn6k6tbEIXeVY0W83U2clVGNi31WbZIJdOKFVd8fdwmc1VeNG06l07jlzrN1oobN/JZ5lNUIXQzCp9T1WDY++ucSsZW7gOVDHsAwShF4b0Fa034Z49jj0K/7+VxiasyomlL+8fSC6YxFbfcd8SfMM0wVShZarLvgJFPW3pUITTWgigcUtXZxd5fET9YmZ2Tx697AOFAFO7wgb/3OP4orGkOwxwSTuMPSSuOr0LxNL4KlZcqn4YqhA5G4TOqetUvHD6nkuu5FbrCD4UQLkThjpEr+GaCFHUU1hQHW4XSafxBacXxVSiexleh7lIF01CF0NkovBhQxfPaCw7vZlbkhnBFIYQLUVi1ckWfTJBijsLa3mCrUDqNPyytOL4KxdP4KtRdauNpqELobBT2z4jqf8I7H2hUYU6E1x5DuBCFVYkrGJkwRRyFB2qDrULpNP4D0orjq1A4jV/pwuouteE0VCF0Nwrf8E1Y9JxOr8JbIjyjEAL2jgo+WrCT4F9nEnUUHtEaC+Yjwmn8R8QVx/66pzrNWNWlrhpNQxVCd6PwJdOEO85OrsKcygb9HkBQqMiCTcN/IE3EUciUhuBDCtNkFcdWoeo0o7px6arBNFQhdDcKL/gm5D8lr8IbIsJbjyFoiMK6Swq/mjDFGoVMZ4TyseMqjq1C1WlGdePS1dHTUIVgbVejsP+abUL2BLL8HuTZFeHkMYQOUVhmXMFnE6hIo1DpJ0D9acdXHFuFqtOM6salK/E0VCE0EXUUXjJNyHpBVSN7rOSaKs5w8hiCgygs865gYgIVZxT6Uy4WXKtOM+KK4zouUZ1mVDcuXR01DVUIf3UxCp9R2WXdT4pVV3N7jNmYqgZ46TGEB1FYNorhksI4o5AtDGHcqN1rW19xPPPU0+LZOIAWRGG19N7UP81wx3hmD7q9JsIFhRCBAaKwaBnFJYVRRiHbF8K40X0qH19xNcxTT4tl4+xyvd5YgLij8LLJSd23tOt6NDuQhPe0hVeZQPgGVJDYrlvH8JTCGKJw5fM8T5bSGOHjRnOaMw0rrsg88bRvcWzcZvKwvLUFiDgKL5qd1B0S43r8w+4zyx+SEDeZQBQQhSWZK/huQhV8FC7KOaLwbl71aS4RV1xdFa4F0xL3TwQbt7NU/LsBMUfhi4YndYfEusu5Lpzd/iRCE0I8EIUlkwhefBxBFPpKeW0mXFk0j5u13Vp6lWlustp+Ne+aVxz7NpLl9qtlzDTJdxvP7dYmlyx1um/jpkobt9m2dOHP5xYg1igcNo61Ie1xf5MnM/souR3fEaEJISqIwv33mWQmVIFH4dz9M8qybOK4GJHkSJ6s54tUa5pL89SJKo6rQpfnuXSaZ/6icOP4+Js86calFiDSKKzcZfK6f0xHDqjG3dUDeoTrCSEiiMKipSsywQo8CnN3iJHenKI/ja+4w4zqNO80l7qc/peNw0+Fv9m7n1WngSgA421pG6St0uIjzJlIoW66kJCFaElABJtNXYS+/3P4D3Si4y13Oug5N9/vAQ7OuPluw8zAfhTO/MB0EhE/g5yuoAmh1pooDPQmrq5WH4WpMRLPkfzT0isu5LJOqxIqLrUK829cI4DJKFwWkRsKb3u+8enW3E8Iveb//aoSTZoy8MqpZTwKnST86JhjWpVYcXHnrNOqnBUnXZ1344hCPM0onMU/Ht+29al2vGMCxQZR+ElGrrJxzsR4FDqRjHHjUv+D4xWnd5rmjeNKa9iMwmWRfJ30tPApisUEUGwQhW9l5Noy8NqppTwK64wB0dVZc6S6UXF6p6neuE4Ai1E48+n/huXWP978+QTQjCgMGTlnoj0KXcYYka7OOU2qBytO7zTVG8fXY4jJKFwWPvRi8jjTuX+cNS/bQTuiMHC18Z6J+iiUKmOMSFfnnCbnhIpLWWmbNE3xxlXl3xwFMBmFi3vvDlytH5OEHDqGfjui8Jd+kAhOL+1RKFVCjCTEjZMErow7dhKT2JiVpHhd/pONe3eRBM1flwrYjMJh0j2fJFhtSEI8JQsfeC/jdhg0gtNLfRTKOeuBhCoxbeL6dzk/gZ6i0w6SpmvjS3Vp045lzP6iYal4auxF4SrLIyPTZ/62HR+OYcMgCj/LuDVGDh8biEI57SMx0kvG8jp2kqj7M1nbi6Tqqui0nEutk+cdItPOXc6lXgUwGoXzyA+FKZarnX/IZsHxElgxiMIPMm5WDh9biELpmt965F3TZZzW9nKH63kw7tjLPa5VGZmWban7Q85p1fW+pQ7GVb0AVqPwecbXiJcvt5t4ED5bcS8hDCEKA7WRw8cmolCkc8dfRXh0Gaftzxe5V98c26+j6vZ86jIstWrLb+rKdYo3rj5cM2xc+2PjmhM30cByFG7jPxSmmy5m8/na/1DM57PFlCCEMUThT3ZupDEShd9c+qZpDv0l4zTXj6FFLqfvG3eVLPpv0xw/6+F3o47CtQ/sJgCIwgEjLx9bikIAI2EtCl/60HQC4Csf+Cij1hOFADCOKHzmA+sJgG98SEatt3IjDVEIQBtrUVj4AC8SA0Sh1WsKiUIA2hiLwpc+xIEQgCj8TWPlRhqiEIA2xqLw2fA+GgBE4dCZKASAUURh4QO8NwIQhQ/eXf3GKUYUAlDGVhROfaCYAIj8uXSSMWutXFNIFALQxlYUbvl6DNyMwnG/bb8nCgFgDFG44esxQBQ+qAzsnWZEIQBlTEXhkq/HAFH4RB40IQoBaGMqCl/yxB1AFBKFX9i7gxa1gTAAwxlxVyRGUPwJmRkQ2ovtIQht02WE9mIOzUX8/7+jrdvCrCa7CWbFb+Z9zrnnJfnmG6IQwLOYo3BhPGkCgCg8UxOFABBDFGbGM08A/DMznm86YnJuuSMKAdwbUVFoPFkC4L8xtUAUAkBEUaiMZ5EAaIzCUkeMKATwbg65K3Z/FS4/6ABJisIHFtIAHaLwq44YUQjgXdRuZ1/auVoHRlIUThkpBIhCopAoBG7t6Na2yfpDpUMiKQr9994sAUAUXnDW8zO/Z0QhIMSxsK1KF1IWSopCthQCLZbG80tHzFnPx/yeEYWACNXevqp0OhiConBuPKMEQPPA7XcdMaIQwKCeSvuWbTCzhYKiUHHOBCAKiUKiELidqrBdhHJngKAoHHHOBOgShZ90xIhCAMM5bm03RRiThVKjMAHQEoU/dMSIQgCDqUvb1TaIKhQUhWPuMwGIQqKQKARaDd+EcVWh0CgcJwBaovCzjhhRCGDAJoysCgVF4YTDx0Ab49MRIwoB3LAJfYUWT1AUspEGIAqJQqIQuIm8tH3JX1goNArTBABReI4oBDCM3DYpN+7p8Icr1rbBQQsnJwrnxqOSLpRSo2crpR4TIFxE4QlRCGAALU1Y+NFX78vLZpQ+VignClWPKHxUo+XYnMuWoxX7DREmovCEKAQwhLwpCY/6pcpdZOFeyyY0CuevBOFqkZl2s2lKGCI8xvdFx4soBHClxiZcH/SlahPYD2ShUdhahOnSvC17oAsRmInxhHLhUn9EIYBrNTbhpur26E6LFlQUqqnpKkuZMURIiMITohDA1fI+22bqMqRPhQFFYTozfUwWfC5EOIjCE6IQwHV6NuFFFW60ZMFEYTozvU3Jwt/s3ctq20AUgOGRkSyMb9j4ETRnIGCyCLQY90LrRhACtbPIoqHv/xwlWjQTNUo8HtXOkf8Pb70VP9KcOegKorBCFAKIVDgXNj6ycc/8top1JAoXVRKShThbRGGFKAQQZ+v+UQT9RfUDuBNROEnlUDm7UdAJRCFRCCDeKrwJ7e7CedZWsS5EYZZLhFFiAPXG5AJRCCDWlav7Vtg3FZ35fqw/CvupRJoZQLuUXCAKAdTFN+G93cOF8xRWL/VROM0l2piThdCOKCQKAUT6GNKEvqXzrKxeSqPwb8UNc2lBvjCAaql4ftrzRRQCONB9UBP6dl05VKgnCqcv7T4eSrNROutlSaXXm6W5vGZoAM1S8Xy154soBHCYwtWtd3ZPa+exeumJQiOe5PUmzOdZYur6SS+VRgMDKEYUVohCAAeJa0K77cikidIoXLzShPlgYRolsxFViA4aiOe7PV9EIYBDFC4mCpcd2XSnKApzedJrbMJ0aN4wHeRUIbomIwofEYUADlI4F1OFD0ThsaMwlSezhrnjNDH7GI64mgbdQhRWiEIA4aomjKhCovDEUZga0x9J3Tgx+1qMmTZBl2Ti+WXPF1EIIFjhXEwVEoUniMKen3/GzKUmz0xN8NtClptAq0w8N/Z8EYUAQhXORVUhUXiCKMzEYxZSM56aMP2Z1OXcYg2liMIKUQggWOFcbBUWROGxozART5LLc4O+CZaMpGZsAJUW4rm154soBBBm61x0FV4ThceOwol45q2MDvfnUtMzgEris+eLKAQQZOVcfBWWzrOzaimKQpP/h6unZ1IzNYBGRCFRCCCiCWOqcOfYaHL0KExbbcKGRXmpATQiColCAC004boIr8LCeUqrl6YonEmDsTHtVeHCAAoRhUQhgBaacGc3wVVYOs/W6qUpChs3HU9ixzZ9IwMoRBQShQDaaMLwNcgPzrexemmKwom8LDNxBlxhDf3Edyu3p/l9+nBql0Qh2vOlLMtll12X5dXyqO7se7JydStbuQ6rwtJ1ZM5EVRQ2TJqMTKwxpwqhXi549JkoRFvubgStu1zad6OhCYOrcON8V1YxVVE4l5cMTaypeBhAhkpEIVGIdv0Q/GHv/lbUBqI4jo9pVcraFZc+QC+cY0mJsRSEUppoAoL0xkBlofT9n6OlpdtJzFhk/uXM/j7XEhQEv+TMiU7s5DCcPmqa8NYqPO1XqqVkjFUU3lGPmTCXkGohANhBFCIKg2kyhwoZSPOVwI1h3Cs8fdY04c1V2L7QnvP0mFcU3lOPRJibzOgJVk2AJUQhojCAZp3mR3KsekxDpOE3AosG90ec+ibUV+FH3RA6lt1jZlEoZnRpbvuPYzE/Bo4QhYhC39blkbyp0lr6ReDMANZzdU14vQo/aZpQ9UNyxisKF3RhKmyYTEkxFgDcIAoRhV6tyy15dtw00p+MQI/9/FjfhKq19kVqE8Z0o5BZFM5JYfUtvCLFgwDgZkaAKPSlSI8URL6TeohCNoJHoa4Ju7SrKOqFIjpRyC0Ke374EmHFG3qCQ4XA0UsCRKEfRbqlYI76LEQUsmEehe6bUF+F3QvFs3rMLwoX1JUIO0glALgZEyAK+0WUhFezEFHIhnkUum9CfRV2LhTPMwoZRuGcuhL791mwaQIMjQgQhR7sthRcXss+iEI2wkbhj8smXEp5QxUqTRjZ8JhdFIrX1JEIB4cKRwKAGUQhotCDJqdBSGUPRCEbQaPwvNc04Q1VqGvCs+SOWxSOqeOtsCOhJ4hCYAhRiCjsFd1twj+qWl5AFLJhEIV+m1Bfhb+bMLYDhQyjcDKltimiEKAbhSvPPpAiESG9QBQ6U5Q0HNuddCsj1fv4fCFFnjo3kCjUN6Heoa8Kz+mqLYomZBeF4hV1IAoBEIWIQveaigallE5lpHoXH9/fpmFEoa4Jr0svq/DiQnE0Ib8ovKeOkfW9ZkQhMIQoRBS6VQ9mdPxXXsgWRCGi0E0TylO6+p9ImpBfFIoHaltY3z5GFAJDiEJEYUfsTUhUFVKFKEQUGjShWRXG0oQMo3BEbVMHUTgRAMwgChGFLu1oiNpViChEFBo0oVkV7r/LOPCLQvGS2u7w8GoARCGi0KWahqlVhYhCRKHdJtRXYYTPouEbhXNqmwkLRsE/FgCiEFE4rJ/xQc+OL6sQUYgovGa56rht5HtKn0MTcozCiwXkse09k4UA4AZRiCh0prnahNs8PWRZVkvrsl/SsqJrHqUTiELLwkfh0jTlTukzaEKWUXhPbdOJMDYlxZ0A4AZRiCh0pahIq0pr6VqxLrektZEuIAotCx6FS/OUO23ib0KWUShm1PYgTN3RP9gzAY4QhYhCV0rS2Ja19GSdk85aOoAotCxsFBo0oeq8ib4JeUbhS+pIhJnJjBSvBQA7iEJEoSMHXRKmhfQoy3Xvo5H2IQotCxqFRk2oOm9ib8JIopDeCCMJqcYCgB1EIaLQBf2BwrKQnmUV9cqlfYhCy/xEYbHe5Me/R103u0b+ZtiEqjr2JowlCmlkts+M6TFwhyhEFLqRU59jJgNIqddBPkEUPt8oLHaP1FEdGiktNuF5H3sTRhOFNDcYHk9J9UoA8IMo/Mne/bYsDYVxHD+K3SOcitFL6PyCge5+0qCCc9ZGggSRRBjV+38d3RaFzqk784jbdX6fxyIIgl+v82eMwptYoc7W6Lso12cXkBmF4UahSTLUsZubNuEvLYyYKIxmrZtwggNTRdQ/jEJG4S2YDDUSfS+mQA2r/2IUBhuFSYZTUuuvCatKLY2YKPyJcesm5KCQ+o9RyCi8hUfUyPX9GIs9lchgFAYahWWBMz6lt2rCXIsjJgrb3jk9m4CDQhKAUcgovIFN15rwiT151oRRGGgU5hnOe/OZTRhgFGIyU65eRgC684NGxChkFHbmZ1xr270m1Do9NSpkFIYZhRYXfX/3+p/3X3QbP46b8K0WSFQUAsMH5eJhjoqYR4+pnxiFjEL/Njhm9b2Z4sSokFEYYhSaFA18enddE756HUYTSotCxGOXMWGMqpki6iVGIaPQvwRHCn1/ZYYjpXbGKJQQhaYAmlUhm/CvsKLQIQsHI+zw3moSgVHIKPQvq7v9pQNyLwNMRqGEKLRA0ypkE/4RWhQC8bOHxknIk8ckBKOQUehdjiMr3QkpqjKjXTEKBURhgsa+fmYT7oQXhU+ev1TnTJ/FqDHhhkLqLUYho9C7LapS3Q0bD+dfGIUConABB2s24U6QUQhEL8ZTVWswnABsQhKGUcgo9M3UHfLtiARVW+2IUSggCtc4km2TnRTH3mt3gTWhgCic46RoNHw52Cu9wWD4fAKATUjyMAoZhb7lnR0U1j5pxWhHjMLeR2GCKvv/rU1eeDiOVNuEH7Vc/Y9CNY5wQTwajWL8xSYkmRiFjELftt0dFNblwFI7YRT2PwpNhkPFYfUt19fuPK1twldaMAFRqGYTXO85m5B6jVHIKPQtQwevozm9q9BqB4xCCVGYXPoKGIurZt3hNaGIKFQPczjjg0xIFkYho9CzEujas0z2ba9JVkahiCjMLv8tsACu+KAfX1dIb0IZUajUIMY1ooEi6jdGIaPQsxWqjO6QHFWGURhWFC6bjIotrthl8PZ1hfgmlBKFSg0jtPaCS8fUe4xCRqFnFi2W3srF1Ta6EYOqBaMwrCi02Lc2je60zDZswiCiUE2fo52YY0ISgFHIKPQshevF1RubwYPMbnQDBSoSRmFYUZihyXuaNQ4UbMIworBlFsZjRSQAo5BR6JnzJC6BN7m+7BEVllEYVBSWDefYJQ49sgkDiUKlpvMITuIxV45JBkYho9Avgyp9noVHifOOMiBlFAYVhSvsWzZ9IZC3bMIPATShsChU6mE8QWMjTglJDEYho9CvhePp3iW8Wrqfji4YhUFF4SP2ZA4n1bOyXRN+0wGQFoVPps8maCCeTxWRGIxCRqFfC7dBnMng1brF+jajMKgoTBs/5dAUOFAYNmFAUfhkOn4R4ZzRs5kikoRRyCj0awmnrVg5PFsyCh0FHYWJPqfMcMCyCcOKwp3ZeD6KcCx+MeRxY5KHUcgo9Ctx2+Zn4VniFgVgFIYWhZnDf4gch1ZswuCi8Dd7d7TaNgyGYZiU7WCHK7uAnfxfirvEDgNB1mJ5NhhMoNS0qyns/q9jpN1cW27SKHNSRfqe84RAcvBa+SU9m0zOzs4/PPl0dvZxwgVC8hSjkFH4rlEYY2Qxo9BSaFEIm3fU6Ctks9vv4Tah91FIFAhGIaOQUcgoZBRukqOnSjc34VXATcgoJPIDo5BR6FcUakahpdCisLI7WV2hJ2YTMgqJ/DVBx+LIYvzFKAw2CiOMrLSLAjAKQ4vCGB2J9c6piE3IKCTy1gSuYBT6EYUlDFq2KTCymruPLQUdhbn9Y85sxya8+i0BQYtRSHTCGIWMQsNxzymUBqPSdleuMAovLkKLwgRdtfVt3qrerQlvJSRoMQqJThijkFF44ChUcsTTq/N0jw/IKAwqCjN0JbJm9RPN2YSMQiJPfYErGIV+RGENUy1bFQqjyQvr/7d593FoUVigS9W2rwASNiGjkMhPn+EKRqEfUSgwzWW7VGMkOpW3NTA0jMKgolCU9ddfom/OJmQUEnnpK1zBKPQkCnMYEnlLXTbxf9NlbZUErYhRGFYUavRk9k8SqmATMgqJfHQOVzAKPYnCBoZKXFLANGcUhhWFc/QV8qa0QkdvdvXXsAmTKMpmMwkKWoxCohPGv48ZhSOLYCrEIQlMNaMwrCiUCj1VKmtWk6+6bcKfU9OPFZ6oWEezVMKAFqOQ6IRxowmjcGQzmLQ4RMGghFEYWBSW6Gus9ywD2cYmvFyhq9JZLf5Di1FIdMJ4JA2jcGwwKYdWSzKYGkZhaFGYXqMvsp9ERLGhCe8xVCVz8RxajEKiE8YoZBSOLYapFGe89uEYhYFF4fIea3ZvnOboqdKtTWhS2u8uRItRSHTCGIWMwrGVMFXOLBXOMFAzCgOLwuV0eoeu3Raza4WexqYJ11Ti1HStCKOQUUi0LQoXRxYzCn2MwhoDkTgihykXYRQGFYXLdi9IR77HruXErgnX8kw8xSgk8sIEHdMjWzAKfYxCyWFSjozalxgoRRiFIUXh8vV6S/bYub6wbMK1KnJm2ZxRyCgkYhQyCg+uxEAjLqgVBmoRRmE4UXi7nD57gGFuP5G6urFowpbyMgsZhUReYBQyCkeXwuTIXpMYA7GIMAqDicKX20du7vZYzU4Veu4GTRhsFjIKibzAKGQUjk9jQDkwYx9hKBNhFAYThd0b6fRgrDC136j0OH0RY3fKu9lCRiGRFybGiMxWjEIXnEAUzmBy4bDCDEOViDAKQ4nC/i3FlzDoPUYjLqf/PMBK7tk1eIxCIi8wChmFBxBjKE/lXRXYtFDIKAwjCtdN2PUIQ2Z/tfdKd5rw+tuza+wieffHJEYho5CIUcgoPLwZnKvCQm1aKGQU/mHvbneUBqIwjpcGNWZfjJu9hDmnm7JQRCjBxZaUSIImRrJG4v3fiGjUtLNt6Yy2zAzP75vx41Ly53ReziMKD00oedRY45BsueDxc/DT+G4h8hZ348n9jGvFLh1njSgEcAKiEFHYhohLZDs6mVVcPShEFJ5DFB6aUBbGGqesr7noW3DwUZSaP0zuuUbqzrAQUQjgBEQhorANa2Y2abfJhrl6UIgoPIMoLGnChy9Dluw11qZ+lZtQDsPBjKtsDdh/hShEFAKYEYWpAV8LiMJ2jJnZmJNpkj3nyY2BKHQ/CkubkCjU+YCmXPDp3UdxxGKwZDbpifgJUYgoBDArCgMDvhYQhe1IYi4V7ahzo5gL5LEQotD5KCy5pfjQhAd7jR8KScYFj3NxXHjv9itkRCGAGxCFiMJWjEzZdLmOWCIfkoModD0KK5uQkq3Gp0LetBSJJkaDJZu21BZRiCgEQBQiCruQcoU43FFnhilXGdFviELHo7CkCd9+qVr9Gmn84hmLRuaTpVlLbRGFiEIARCGisBNJxpX2I+rCbpNxpTH9gSh0OwpLmnBRc6b5WGPJ7J1omoWu3m+CKARwgzFR+MJTgyg0PAppHXONfTikNu1G44xrZPQXotDpKCxtwpxUZ4ScccFyLhoaDbiE/VWIKARwg3RlU7dmxjyTiMIWrPiIOIqiNPzvogOW1CwoRBQ6HYVlTVg/0o536hup7hUe4KmLVYgoBHAD57wPjkAUGsCeKKQNmyq/jAtR6HIUljdh/Ug707i0ZyKamzhYhYhCADeYE4XPPSWIQvOjkFI2U6EJEYUOR2FVE9bvlE/puJCLHkRzi6lzVYgoBHDD1Smj8Bvn9DwliEILotDUKlxRDqLQ3SgU5U0oG+t8QPZcsBwJBe9cq0JEIYAb+qeMwvf8F6LQySg0sgrjIelCFFoVhSKoaEJZpjFKlo84nAoVD0u3qhBRCOCG/GPxPeiSHIXPPCWIQiuikEI2jf67Y0ShXVHYuAlpF3NRlpDyBd8DoWI0deq8QkQhgBvyj8Us6NiAc3xPCaLQjiikFZslW5MmRKFdUVjXhLKhzh2IGy4KhYp5xJLY4rtNEIUAbrg5ZRS+4ZzXnhJEoSVRSOuYDbJPSJNOFE7dM+OcKGydZhSWNuEHhYn2Rn1xxHIhlAxYktl7DzKiEMAN/imjMDXgewFR2Lpkz8YIqWVDhhaoRmFpEwqqEbFkTcq39kznQknIkj3ZClEI4IZ8FD4GXeOcK08FotCeKCTaGDIszNakC1FoAIUoVG1CSrZcFCfqU/BIqCmZT1oKUQjgBp9zgq59MuWhRBS2axexAULShig0QdMobNSEsjVLIo0Vs+N/rUJbN5vYE4W9gwv/l0vOOfz79vBfrzyAs3Zx0iiccc61pwJRaFMUEo22fGL7HWlDFBqhcRR+CJ4QdMxG50fEmIsW/1iFW0uXFZodha96t75/0++/4EYu+/2Xvt/rXXsAZ6fHOZ+DjhVCoecpQBRaFoVEq5NmYVQZFIhCawypmUXwhNA5VHNEx2VcsJwLNXJVpmQlM6Pwuvfs0IIvWNvloQ4ves89gLNRiMI3QacMOqgQUdiFVcYnktbkBKLQGsNWm5CSTOOMGPmIw3uhaPCkRG1kWhT2Lvz+Ff83/Rv/Fi+W4Sy84pzOo/Ar5/ieCkShfVFINExj7tw23FENRKE1htpNqHl6UqbxF58IRREXxFa+QGY2JQqvb/2bS27F1UsfU0NwHucMfrB3tzttw2AYhtMKVlUNICoOIX49BdKEjbZrKbRrtErZJLSKbRXSzv84FjYmHK9a7Hy4cfRc/4FfQbf88Zobdl34HwOiMGVfFKZGZrswiWJmFEFt4pJNqD9pPSrwaM9bT8/0Rv6bFiKBySiUe/CoRzVzh92OA9BeJLjjhj2QwHU0IApTVkZhKt7sEjJgvVxtmWkNGsrYNkn1TSiLSLJi+ULKWIw8PbMFZQTMPiQ4SBSeHQ9dMuakP8AtFGgpl15pR2FrZtIgCo0LRr6/DGvi+34Qs4PYfiGox6hQE36MmYY1ZU1UZlhPKOPG03RLGWtmHxIYj8JO94jMc4fHOGYILSR+TQk3bUyCjqMOUZiyOgpbK0YV1mNVrAm/M4HuvRG1p+diypqXvGyyYtYhgdEoPBOC0LzeECuG0DbiFzXmpj2R4NhRhyhMIQobaXtHULkwMNCEqRFJlizfhrJ8T890TK+svGtCAmNReDoY9ujg3PMLB6A9DvvOXUiCvqMMUfgMUdhUnzet9ykwSiWTvt4WaUJZoafndpSxmOl/1XZ/pSQwE4Vn5yfUGMNjLBhCWxz2nbtrEpw4yhCFzxCFAKWbUBaSJNYfcXgz9fTM6ZWNS4UkMBCFF/0GLBFmnZzjhCG0woAED9w0EjnqEIUpRCGAZhPq3xuh5F5/xOGl/gay1Z8pCWqOwjeN2DTex0UXQgtIT5qY9kiCjqMKUfgMUQhQdROy70uShAVGHEYlHkG2cKmQBBVHoVyEVFoSPtv5gvC3hDShC6F9TjONwU37QYJjRxmiEFEIUEcTfuQhSfwCLyfPPD1XJNowuxiIwnK7xmEY+f5I4XDqNniZlkX/hS6E1iLBHTctJMHQUYYoRBQC/PX1Q4VNyHlCkkB/xOF4WuauScLsYiAKz857pG0S7vxV0ZmlcbDxdyHpO8G9E7CY+KE9cdOuSdBzlCEKEYUAf72ttAn5w6PcFvf6Iw6vSr2BPGJWqTsK3xy7pCcJ0xpkVbhP21B7Z3mIOTVgK2lQoWkkOnVUIQoRhQAvvnPZ7c/iTZiaf6GsdYERh+88LdkfD5lV6o3CiyHpCCMpBytKw2VIGnrnWC4EK/Xp1SM3bkyCgaMKUYgoBHjxnktuv7IiPP7XN5JELJ9PWW/LLBVumU1qjMLTrkuC3B6MWY3i1XJNyo4GDoB1uiTgxt01Ynw1ohDAXlHVTShcgdPZzw0pYzHV/LTt/VJri8JOnxRNdpuAGRH44YTU9LpYLgTbDEiw5KZdksB1VCEKEYUAf3hc8rPsr9l3rDBmueQRhzeelit7r5rUFIUDl5Qky9WWGRVvdoph2O84ADY58KDCBxKdOWoQhYhCgBd+FbvHclou/zlWeM9yBZQ1LzGrMGYWqSMKT7s9xRXCmB1EvAlJxQl2kcEmb6SZNKY9NmFSIaIQwFYe5xVUoccllyRZsnwbyrr1dCxIEDGLVB+Fp31SsI4CdlCjKKF8bveNA2ALEjxx456aMKkQUQhgK59XUIUel0XXJFmxfDvKWMw8DXNr94+rjsLOEeXbrRpxG2e7CXG4ENrkwDNpLpvw/DGiEMBSHudlq3BvE37yrkiicqwwoYybqaduZu3+ccko1E/CyXLUoKcA71c7ytVHFoId+vTqCzePRBeOGkQhohDgmc/30KvC/U3oTReUlSh0SDyhjEtPw9jWp+6qjMLBUX4RNm+2d9qFyEJohy4JHrhx4wYMpUEUAtjJ47xsFe5vwtRbkuxYvhVl+Z66ua3zq6uLwoFrYRH+kXYhshBa4EK6fmxa2IChNIhCADv5vHQV7m/CZxFJfJZvSVmzovvHzB5VRWHHzT1H2KBd431duEYWgu3OSBBy4+YNGEqDKASwksd52SqccZk/9V6EJAlYrnupC8bTgvvHAbPGL/budrdpGArjeEFAhdhAQ1xCfIxS2nTAUrqVZHRjUjQJrdrYC7D7vw1AgOa4To7dAo7r53cDiA9Ff4594jWj0PIuYXXSic2SdotxhSyEsHleP5bXpNjpWUEUIgoBDINCvgr5JjxO/pjsUV1eCNYip5ossTYI9Me6dhTySZiXwWzejEpqhQ/UQLdt+10/ljf+z48RhQAhSqRcrwrNTXhnOqO6TPBGVPc6sZUGeqlwzSjkv0s47/axsa44qahFH1kIXfaYFPL/G/g/P0YUAoQolarjA6l5s1ITqlLSjAVvvOq1whEpchGMdaPw0Q61CWdIeGd4RS228MoJdNd9H68fq069nx8jCgEClEhVKs6WqnAq2pibsG5AmpHgZVSzt9qlwgBu0P2ybhQ+7FOzKg1qSHhnMc6p2TbeRIauukeKgfz/Lr2fHyMKAcJz9kGqEsFWoXsTJpO3VJcvBKvIVzxAzsLcNFkvCvtfqVF2KMJVHFbU7Dk2TqCbPL9+rJ8fW/3/CVGIKITofdQGhT98+8BUoVMTmq8VzgvBGlLNbJLYeR3mr3W9KGxuwqtwurjBKMPGCQSn73nTRJ46f78aUYgohNgtDQp/+txchXwTlseJwQFpSsFL+VEh+2eNRShWiUJeGc75eaP2y4VbL3oA3fPA60N3+vlx/1GPhyhEFELsDINCpgqZJtx93/TQiOZQ8OopMEvsTMNcP/4HUZinG5GEPy1KavQAZ8jQPd43TQaketJjIQoRhRA7w6CQqUKmCS8a53lL1wqPBKuoVnrtjhSVCMVfj8I81O0S9yy83wPomBe+N03ktfbRKhaiEFEIkTMMCu2r8OzA0IQ0TswmM6qrCsE6WukL1rMgH7pzj8KYkpDJwi3sIUPHPPX9pom8IZXFPB1RiCiEuBkGhUwVsk1IL5t/dpor52uFiZ1XiMINTEImC3ewcALd4n3TZJ8cP1WIKEQUQtwMg0KmCtkmpJfMVrDiRPAqUry0jMIgv0njHIW31KjcyCT8lYVYOIEwPCCF9OGcFP0eC1GIKISoGQaFii9SN7VoQhoxHxB0DLaTFfaPX0cRhePzzd44bjLMqMFzDAuhQ+6TYld6kLmtmiAKEYUQN31QqEmkbso3ISXNJntUlxeCsyDFAFH4x+0FNcgCfM/OzXBOZn0MC6E77pEikx58ItV2j4EoRBRC1NoHhcJYhWwTEvuxGFUmWGoAvEIU/pbukVkVzN93HYcVhoXQdY9IUUkfLt1eNUEUIgohZsygUBirkGtCStqkpEkFZ6y20gpRGMwTby5ROCCz/ETEoUhzrCFDx237/ny13CWnV00QhYhCiBg7KBTGKjQ34aXlhvCANCOn/ePEShrkz9U+Ct/tkdl4Y/dLli2uyGynB9AJj0lRSh+unb5KgyhEFELE+EGhMFZhSxPy3TZZ+ob1wmXTxPIHHuTP1ToKy1mslwnrhhUZbT/rAXTAE1JcSB8unEaFiEJEIcTLZlAojFXY0oR8t031opmLdimisOb2hozyYM7J/56GM+T+wx6Af09JcSl9+HRKKubKLaIQUQjx0geFTYaOF1f4s11NaR+Fs8RKmD9XuyhMz3FyrJ4hY98EuqtPd66lFzcu70EiChGFEC1mUKiYSkaSOQ3z9knBr4KUa24fj0QgrKJwn4zmkZ0c3xlVZLKFI2Tw77n/S4Ulqfrt/1tCFCIKIVrMoNChChOhRSFn6Vpha9FU+CQNd3Scx/xPUjEmIxwhg3cP/V8qlJcOo0JEIaIQYsUMCh2qMBEic3uKbrR0rbAQjY7wogl3dJxt9AMmvOEcR8jQSc/8f6lQ7jqMChGFiMLv7N37btMwFMfxgoAJcZMQj2Afo7RNAjQtabteUq1SQIJWYxSq7f1fg3ETruPE9qA4WX6f/0GABHx1HB9DWxkGhfZVyDjnO7coZC9JsbNbU0gTZmV8O6Nw3O7VhBUCHCFDLZ1431QoRGI/KkQUIgqhpZRB4YrfsAqX+8L/yROrUZ6iNGxmQ5KEzEqPJI0Zoxmi8OoUY8JSq4w0Th51AHx6TpKx+AtNHBUiCgGa4kzI1txooW/Ci+Kg5rVdtilWNoPChN0gCnlTVEfh2wRjwioBFllD/Tzy/vzxtXPrUSGiEFEI7aQMCvfc4DJdVjQhX5BkzCyMErVuZlynT8pPbYVuXxTGU9LIMCY0rLK+hw8LwaOnJEmEH5/I9lkTRCGiENrpo9OgkK1FxZxQTbces5GSzWWT1ZBkKbMyIknEm6IqCuf0G/4lKjOb48NCqJvHJPkg/Phi+6wJohBRCK3kMii8PFsKQxPy7Q3OeGNzFapN2LP9+33rovCUNPLW7iYsEw7xYSHUy0OSdIUX6qjwWacMohBRCK3ErAeF+zdCmJrwGslGzEqXFHmfH1oM6UDAbvODJuVReDUgjV0rnzCpto1I424HwJMX/l+6K4wK73XKIAoRhdBKqd2gcNMPRKn4gv+RKTtpbIwGpJpv+R/9iA4lTGKdm815EbgsCoMELx1bC0jjYQfAjwfk/6U7Ibp04E6nBKIQUQitNLEZFF6kosqKS3bK9WMr6ZQKdoufXbhaZ6SaMEuDRq4pLIvCYIpn7Rz0h1T0BNdNwJN7NVhKo+4qfNwpgShEFEIrmXcUbthEVHpXPp+JmKWAtKIoI40eszRq5uXjkiick8YcR8elZpGuCnHdBPy4T5JT4ckruy8qEIWIQmglIeNFlx+XwqUJeUiSKbPVJXvTkFmakCTjjaGNwjH90swjcS8CKjpBFYIXz0hyLnxJSHbytKOFKEQUQitVnx6ztTBY7/mhLclSZmtA1ibM1pgkc94Yuig8xa1jZ/pbyCcvOgAePCbJXHgypwPPO1qIQkQhtJKQKUPCs0BUW3685AU5SWJma5SQpTG7WWk26MUPkgzKmzDC0bGJ/tU7rKYBHx7W4VETIT7b3DVBFCIKoZWEbGXcQCObMK4zJ0nErKVTstJl1kKSNWiqVojCq4SKYg5msx0V3e8A/HcvSJILXz68J9lj7d0rRCGiEFppIiQTwwYayTK94HoLko0cqjBxaEL3LYVD3hxqFF4l2ERzcwFW00A9UB0eNRHi1OJZcEQhohBaKRWydKNuoNEL+hteZkuygNkbDZya0GzQ0E8KlSjUN2GDBp++hUNUIdTBc5J8Et58Mb9rgihEFEIrMaX2zvb9iTB4s+dVcpJEzMWYDGLmIGzsPd3DKAzOqSDD54QOVjmqEGrgUT3Oj9W1NE86RYhCRCG00kY4Cs4uebVYOT928TKhCr2UuYhJ1qSKIskgmGI74d+aZZoqxBpr+M8e1OT8WOTGZYWIQkQhtFMqXKwZNwqV2Z6T0esplUgC5iZp6JbCwyjMp424YrLq9/s1LtXZHI+bgH91OT+evzcdICMKEYXQTpdCYdpAYzY0P1PsnoVJ4P53u6ELaTinagtuq//Dih/VbLHL6acsDnlNxahC8K4u58filAw3kBGFiEJoqVTYmbANtzMn2UvmbNJVujAZp8xZRLItbxCqMrTsrlWc0W/ResuPpL9TfnnxEf+ot+tdRt9lO+ff0QJVCM5u6/mxODfcQEYUIgqhpTZLYSG94NZC431hszTu9gZ0bdAbByG7gZBkEW8SUrlfO17kdCjq8yNYRVQUzPhRLDKSZQvHHz5EFYJnz+uxv1qIMR1Sn/lBFCIKoa32wm0DjVlOspB50W3s3ePKKMysmjDMqSja8n8tIK3cMUBtM1eVh24FiyoEzx7V4/3ja1+p8g1kRCGiEFqLGTfQOIqVUaEPIcmGNb4DoUES51U00q2Ko+67Vh8LOW6EbyPS2c24NVQhfGPvfnTShqI4jnfLlCwuIzM+Qnu6FErRCB1aaYWMhJiwETb/JHv/5xi4uVxuC8mZt/cP/X0eQA1i+HrhnGvcMVlx//Ha4pG2vPO2IAoRhdBc09u9G2jYlmT+qLBDrm6uXntlE05Ixn8cGN9HRxXGw90npwzLCaoQjDolwU1o0Dnt20uDKEQUQoP9mu3bQMOXGD8q7JGr9x5LUcg/F5vua7VcbRPqqsJi32cseT80tliDSSckeAxNeqJtbzwBohBRCI3m31Zcb/wr+E9Sko187ToOj5kEwWuKbjokqr8KhbzSUIUFEaoQDsIxic5Dk1Z7PlaIKEQUQrN996OdG2j45iTq+rp9pi3WLs/bQWUTyvLamlBWKGxCVCEciFMS3IcmXdHu6+4QhYhCaLyfX2e34Vo0+xb/VPoyfu1rdkmieeAYpU0oy2trQlmhrAlRhXAozkhwtwhNSnb/ISAKEYUACs1JNEh9rfrk8D6aNbVNKMtra0JZoagJa6/CEw9Ak5YlV91tDGjbkfcCUYgoBFCooC1Xvk69zO2DwkBxE8pyFU2oqwoLIlQhHJD3JBiERi3udg2bIAoRhQD1HRXSZ1+jruMHhYHqJpTlNTRhNqilCgsiLVX4xgPQom3NqsKKvTSttvcHohBRCKBSQcbeQL4gp0ePg2CmsAkH3e6AW4X8pBpEm9/vdZdfhfwm7Ha7NVRhq+0BaPGBBE+hWTc79nYiChGFAEpNpDTzdRnRtjhwTKGuCTs9f22UsL4ivwk7L8nfV1yFBUmyKPXXooH6KvzoAehwRIK70LBB9QgyohBRCKBUTNv6vh7pgLY8BI6ZqmvCyP8r4nxNfhP6/0ScKuQ34eVLfabdV1chrjYBM47JolGTcHFXOYKMKGxAFC7jeBZFD0lCNE9mywCgVg9kZIV1V0oF157p06GqJsxG+2Itr6EJ+VXIb8IXHeVV+M4D0OHUolETcVuhWIWIwkONwjjuRVE/Sea04dSPDo4bS5mSpb4GV44/z8utMhn/fxMyqlBBE/KrkN+EKqsQ6wrBiDMSXYWG/aiaxUcUHlIUCkeCEvm1BqBGs/Jreu3kJJkEjknqaUJ+FfKbkF+F/CZUWYXLIUmOPAANPthzq8nGfUUVIgqdj8I4jstHgqhCMCkh3cMmEUmmgVvyepqQX4X8JuRXIb8JeVXIf9jOPID6vbXoVpONVakKEYVuRuEyjovnI8EhCVCFYInlsFQQ9Rpljr95XJBkuFTRhPwq5Dchvwr5Tai+CrGYBgz4SKIkNG3xSJIzRKFTUdjbHAlOSIQqBAsVpLUKR5njbx5PGY3DaEJ+FfKbkF+F/CZUX4UFYQQZDDglwWNo3NVd6d8jRKE7UTgb0h+oQrBdrrMKRxm5PXm8HJJESRPyq5DfhPwq5DdhHVV4Q88wggxavSFRJzTunCStNqLQkSgcP9ALVCHYbjzRV4WfM5L0AqeUH6xCRRPyq5DfhPwq5DdhHVWYU8knD6B2H6zaSlM1gtxq2xyF6ZeH7rMfX9KmR6HUhKhCsFo5WZLUr0VEsn7glpwkkYom5Fchvwn5VchvwjqqMCcJhk1AjyO7ttKs3ZCk1bY1CkedFQmy5LrJUVhQGaoQ7NUj0rKZpk9Ebt95XJAkV9SE/CrkNyG/CvlNyK9CfhNi2AS0OG7ZtZWmajFN68TGKEyjFZWsLtLGRuGcqqAKwVpRVbWolnacf15PSfKkrgn5VchvQn4V8puQX4X8JsSwCejwnkR5aIF7kp3YF4X9jCplF2kzozCmHVCFYKucZFnkq9W7JNnQsQ2F43kpCsfqmpBfhfwm5Fchvwn5VchvQtxsAhp8JOuOChcrkp1YFoWjS9ppcN3IKIxoJ1QhWCqhkk7qK3SdOd+Ev9m749a0gTCO47asSql1dOwlmCdymlwWTESbqSgUpFCQlbr9sff/NsbabkRzXv3pRe/M8/23lULb6Me784m3Ul2XuAmTgglRFeImxFWIm9C8Cie0vZsax5XcF8sGWKtVeGUVCmPS1h1UEIUT0sYq5CxsPCMIL/jWsQofbvUAXJc5EwKCQlWImxBXIW5CXIX4UykfK+SAzEyl+e7bkEKF1/agcCDpg/ph9VAoSR+rkLMwlQopbpupk5yBCefgdYmbEFchbkJchbgJcRXiJuRjhdwRurVvqVCpwrolKBz06cOyIaNQEauQsy2lCpOOmWXCMzDheIFel7gJcRXiJsRViJsQVyFuQj5WyJXfjYVLhSoV3tatQGHOhFoVMgpVsQo5y1KqkLph+8Ci7BxM6E2A6xIyIa5C3IS4CkETmlfhhDbzM8rHxwq58mtadq+7bSpsfrYAhXkT6lVYMRTSQS2kjIRIWYXc0RvPShgjIBI6CxNOgXdrgAlRFWImNK/CKfD8DqtQb0LR7tB6jVaN40rtivI9+3akUGHj68lRmDehvixkFH7Q7FWCQTD33puzCrkTNCENCw2SMA08x1qmBKkQNyGuQtyEuApxE+Iq3NGEig823tY4rtTqDRuXClUqpKtTo7BHO9cfMArVEhTiIQiWXi5WIXfKItrCwvAAEro/i8bzJHqyAzchrkLchLgKcRPiKtzNhH+TtN5ljeNK7dLKpUKlCq/rJ0XhiIBklVA4Jl1SroSYbkiQVcjZ0pS21O20scJRdj5nYwV03hc3Ia5C3IS4CgETmlKh3oTtQULr8VwabqNqLBUqVXjbOiEK7wkqqhAKA9oslXLyKsGxl4tVyNnYPKUtJcBy4UD0aFsT9/6D55sY+p1prkvMhLgKAROaUiFuQlyFehO+N6T1mjyXhiu3OzuXClV3vKPG15OhcJAR1rDCKJS5L7IKOdsbS9paP97lSg4jSdt78NxrU1737aFGhaAJcRUCJjSlQtyEuAr1JnwvovXuahxXZi2yc6lQqUK6OxUKJYH1GYWsQs6RBGnKZKSzQCi6CWlauHecsPgLGbXbGhXCJsRVCJjQhApxE+Iq1JpQd5r9osZxZXZt46zC174TsIVcLgrvCS6uDAqnRRSyCjmnChakrzeKO5skCDsi7r1L6Zy2jj1vXnyLq1MhbkJchYAJTagQNyGuQp0J8w0y3kDmjlmLLLytyVvPVKxxcwIUDjLCC6uCQkEbrTxWIedW44h2qd/7X0Y7lIaei80KGtKoUH3ZyoFZrE0AE5pQIW5CXIU6E+br8AYyp68yS4X+t0cq9qV+dBTGtEe9yqJQeKxCzrWCBeGd4zJh8YqO2m2tCucpbjVchYAJDahQaULzKlSbUD/6gjeQuY0qtFToj35QsebFkVEY0l51GIWsQs6ZxoLMNnNuYPVb8+KALa0K1SY0r0LchGEke/EQV6HGhGZVqDGh7sYJzRrHldk15fvl29RTQoru6kdFYZf2ql8RFK6KKGQVcg62XJG5Uhc/dKwaW50N2loVBilstbjX641CFGvwz4lzO9mYCnETdqK4g6sw+MCE6rk0PMKaK7kWrTXxreqFFDUvjojCkPZMVAOFsvhGm1XIOVkgyUypcPa/9aEwjaatVSGhVhPZTs+PAvg5eoT1YRWiJrxPXr8rAlSIvWjElI9HWHMld0f5Xny7eiZV1/WjobBLe5ZUFIWBxyrkHO2dhZUlobdMC5vHWhXiJgS+0YAJcRXiJuzuOHOiu/9CQp/W+lTjuBKrNyjfN9+uRj9JUePrkVAY0t4JRiGrkHOsYFVhEnreqrB5DKgQoB6sQtyEgArNmJBIICpEXjGGtN5VjeNK7JLyJb5lPSWk6lPrKCjs0t71K4FC2gWFYST/FoWsQs72lpOU9m429VwuKG4eAypEoYerEDchrkLchIZUKHYfgdHgYYWcJtNLhV3ftr6Tsst6+SgM6YA6lUTh0ttsuqB/LaZnoUI/Jc7KFibW6cZTSfuUTly8f0m+RWHzGFAhyjxchbgJcRXiJkRUCJhQu4F8XeO4Eru09mZ3uomFRI2b0lEY0wHJSqKwILzZOuzmzqtw/IM4a0uNwGz5gP6RH1/cHFWdTxQ2jwEVAsgDHmDAhLgKcRPiKgQfOKR8PKyQK7mmvROs33pakLLbi5JRmNEhheePwjFt9pHvUtdVOE6Is7h06ZnIn8gF7drPX13f91xvmRY2jwEV4sTDH4KbEFchbkJchcjD1L/z2xrHldiNxROs35OPpOxTq0wUCjqo+PxR+Ie9e91JHAjDOI4bDzG6JG68g01faDkUiF0iBzGaqMSsiUJcyN7/fWzY7KGVofLQtzhTnv+3/bA2TST8fNuZacjblnVXMBW2hFldqIPCRe1h9CjvNHmdLjbyKgAKf0iiME0oWwJeoGBCQIW4CXEVqpiQa01Yzn22elua2PEmho7L+aGwLpmKdhCFN8mp2liWG185rcJHYXb3rIbCRb3aMJqIqVk0D9uVP7mPwsYbETUBo+C8w/8bbkJchbgJcRVqmJBrTVjO7YnV29KkrjeJsVAbhU3JWH/3UBh68QIxFbi82uRWmOU1VFCY7KndDof/qrXb7VElkfsovJFELUwpHdyEuApxE+IqxE2IqxA34XJnJcZybN/ubWnSh4UxFuqisCMZCwuPwutUFF6ZYfftymEVNoRZng4KwZxH4bUk+oY5JcBNiKsQNyGuQtyEuApBEwYDMVUuMZZfZUk0rdjZUMzFWKiJwkiy1i06CoNUFN6JuTuH9yskCq2PKMQy/wFXA1SImBBXoYIJARXiJsRViJlQTPFcE5ZzZ/avNVnUW+204z1tFF5K5oKdQ2Hi8qGYCx0+24QotD6iUOGTDKgQNCGuQsCECirETYirUMGE3JaG5dvhkf1rTWLLkI3tn+iisCeZC3cbhbIqh0+8IwqtjyjEexbBVQiYMJsKB8DhwplUCJhQR4WD/qYm5LY0LOcOXFhrsujpVVZ2+ulQEYWRZK9bcBT+2AyFDp+DTBRaH1GIN5INVHgRcw3AGvxKzV69Xu81Uai9PAAqjPMzAk2IqzCIZFH9Mst77SclxnLss8SbVOytPZHVHe9pofBSFAoKjsIw9XVBWdWzuyokCq2PKIR7BqwWq9+r14IuasIH/zt8pUWwCX0fVmG3Vav3+vClvj/gS4pbneAy29n7pyXGcmxPbD/XZOkZsrnTg7IKCnuiULhrKGysOSl0VoVJFF7kmsSKQpYSUaj0OcathpvQN6tQ34SACuPhJvR9SIX4lcx9KjGWY18k3uOoYnGdoaT15eQwOwovRCOi0JTnrgqTKKzmmsR68lhKQhTmMv6u5WFCswr1TQioMKsJjSrUN+HDz9g/uIM1y7nykQubFf5t9CppHR2fZ0RhU1TqFxuFkorCsZi78dxVIVFoZURhlkIBVKhgQkCFGU1oVqG+Cc0qVDeh/yIcFTIg3bUmYcXu2pEsl3ThYQYUtkSl3o6h8Db59rq5keeuColCKyMK83pPtpaHCXEV4iYEVKhgQkCFwJVMD945KmTb67MbmxUaWWjuy0F5UxSGolK0Yyhc68um4bmrQqLQyojCDIWSjwqrKSb07yEV4iYEVKhiQrMKtU3o34twVMiAVNeajCvW9z4L5fTs/HATFA5Ep2aRUXglb1vn2yb0PHdVSBRaGVGo8CutrMLLgZE1wKxQwYSwCnETAirUeEmSo0K2xc4kUa1if0ssNLX/6esTiMKqKBUUGYUNeds6XzcNz2EVEoVWRhSqDQpfMKvhJsRnhTifABUqmRBXIX5THBWybXd45NgD5EXtsazTZD7tASjsiFLhTqFw7CVryXItz3NYhUShlRGFWh/iFx9SIW5CfFaI8wlQoZIJcRXiN8VRIdt+5849QF5aiZzWYzSfttdDYV2UGuwUCsP3T0oYeZ7LKiQKrYwoVBoU/vR9RIW4CfFZIc4nQIVKJsRViN8UR4XsI9qXRNOKGz0NZ7J2s3mnVX0PhqLWZYFReGdCYboKW57ntAqJQisjCtUGhYAKYRMCs0IFPsEqxFd+ACrMelMcFbIPqXzk0BbWiaaRYEX1sNPpV6tds8zUCgqMwuB9FHrNcXz23PQ8t1VIFFoZUag2KMRViJsQnxXifMJViJsQUKHiTcnvOCpk2+lAXNrCOtFo/igbNohms+i1/r9I1KrtEgpbnqHrm79+u/Y8z3EVEoVWRhRu2O0yP3AV4ibEZ4U4n3AV4ibUV2E3NN4UR4Xsw9p3awvrZNOxWFe0SygMVlFq0QJvzquQKLQyonDDRkuDQkCFsAnxWSFuQoCfF10FE+qqsHuxxk1JopMSY0BZHyBLr+JUo3AiltUtLgrDZRSmVgAVEoVWRhRu1rPRH7gKcRPis0LchLgKcRPiKsRNmP7zT0uM5dqBJJo4sS9NvN58JjZVJQoLpEKi0MqIQq1BIa5C3IT4rBA3Ia5C3IS4CnET3vu+z1HhL/butqdpKAzjeDWiIfEhGj+CvefwYYJuPs5NTZiEQIKQqeH7fw/hxUi7bLX/9bQ7vXv9Xys4w4tfrnJOFa3WB8h/e+0rKhcedAiFr9LlvKlQKIwyoXCjvo4KVMVUyE3It0JuwnwzoEJgQqpCbsLiL/8gUQrFHyC378Umq54jDy2OXvpF4fcSKHSmQqEwyoTCjdpbHgqpCrkJ+VbITci3Qm5CrsJwJly+q/BWolSt7Vhb76XJd3oxj2Ew/OIXhVYGhb5UKBRGmVC4UUcFrIIq5CbkWyE3IVchNyFXITdh8Vd/kihVb3faey/Ncp8GR8e25V4LhX5UKBRGmVC4SVPL1c/EVchNyLdCbkL+BJmbkKuQm7B4KnyYKAWq/A5kG/da3afBdhfD591BYboyTyoUCqNMKNykQQF2sAq5CflWyE3It0JuQq5CbsLiD/E4Uarenlq+/V7bO90fD7clwwOvKDyz5dLVOVKhUBhlQmH1i6v7i7gKuQn5VshNyLdCbkKuwvAm1AXWqoF2Lddx6+6lWSfD+dAab+AVha9suXRNflQoFEaZULhBkwLtEBVyE/KtkJuQb4XchFyFQUx4afl0K42qv7v3Ldd5z0+n+xfjeZOz4bvOoHCUrsuNCoXCKBMKeV9HBQhhKuQm5FshNyHfCrkJuQrD74SmW2lUAz2y9t9W+F8cXulw/Pfcaq8zKByka/OiQqEwyuwmobBsh5btpJ+JqpCbkG+F3IR8K+Qm5CosZcITshNe9yhRquZ2LN9Fz2n7lmmf/t1SfXSKwkOGQhcqFAqjTCiseh/NrM9VyE3It0JgwmBbITchV2GxCRFor9tNlAKFuJfmuGUvQV5EUciyUn12isI9hEIfKhQKo0worPiTfNnvIxUCEwbcCrkJ+VbITchVyE1YvBPqqIkCBbqXpo0vQV5UIwrPrUwHXUHhJC3KhQqFwigTCnGTAltBFXIT8q2Qm5BvhcCE4VT4cVh9JzQdNVFNdMvyHfVcVgmFcyvToCsofJMW5kGFQmGUCYUVj5n0F0EVchPyrRCYEGSFKuQmRCrM/9/xnVBHTdRWum3ZWn+HdR0oHFuZXjpF4cCWm6aFOVChUBhlQiFtWgARoMIKJoRbYbEJebMCFUITchViE+bFrKMmakvd6cJhE45CftKkMyj0r0KhMMqEQtr3ZfNwFVYyId0KuQlnsw1VyE3IVRh4JzS91UQ10t37HThsUgmFEyvV+86g0L0KhcIoqxWF3z6s6Vvvprah8MwsiAq5CWdX4a0QmDD7RU5mXIXchLOrsAoD74Rm9xKlQIFuK/zj8LAJRWE+K9Xz7qDQuwqFwiirFYVvn63pbe+mtqHwjYVQITfhT1tgjW2FwIS5fytXITBh7hNRFVbfCUcTy/Y0Uar+diybrzebBEHh0Mq05xOFE+ueCoXCKBMKYUcWRIXAhHnuzeBWOKQm3FyFwITZT4RVWHUnHP34YdmeJEo10K7lm/e8xVHIjx8f+ETh1CJWYebPCIXuEwor/BhXOG0yACbMj11wK6Qm3FyFX4AJM5+Iq/DgC/5GeRMu/2KoripUTXT3gfcjyByF/PjxC58oTEcRq3AvXSQU+k8oZE0skAr5Tgi2whAm5CrkOyFXIf9Gq0yYTnVVoWq+h/ecH0GuhsIXVqaXTlF4aBGr8CxdJBS6TyhkjSyQCvlOyLdCbsLKKuTzHVdh1Z3wqq96fqy20C1bytkRZI5CfifN0CkK00nEKjxMFwmF7hMKUa9tTZczpkK+E/KtkJsQqrDKfIdUGHYnvO63nh+rLbRjri+mwSjMZ6XyisKYVfg7XSQUuk8oRE1sbUiFfCfkWyE3YUgV/gr5iX6G2wlX6n4nUaqRdl1fTNMICt97RWHEKhyki4RC9/1j725XnAbCMAxH8QPxYxE8hUkVdXcVNr80lQTcFqlgVxTx/M9DFMqa7KadOxMmM2+f+7cwCFYunjYToRBVlROrkO+EfCvkJgxX4Rb8jYAKw3fCXZVedafm6GnZ7cqSCgNReFH69NIsCpNQoVB47AmF8NvjqVXId0K+FXITchXynZCrMHwnHPrv91mhVJQePDF8XWEgCtfHjsIEVKivj48+oZC0LPe2pSrkOyHfCrkJuQr5TshVONFOuOutnj9Ws3Ty0O51hQCF4++keW8YhbOrsK0OHC8Umk8oHP3t8ZswFfKdkG+F3IRchXwnDFFh+E64a63nj9UsvSjNqlAozFyFAyasardLKDSfUDj63/CntxVXYfhOyLdCbkKuQr4TchUG74SdzvX8sZqnx2WvXwsjARSOv5PmtWkURlAhMmH/Rhqh0HxCIajriPq2j9AKqJDuhHwr5CbkB23hTjidCrdwJ+zW6vtjNVOPSqOXWEdB4RvbKEQqjGPCpbtOKDSfUAha9356G65CvhPyrZCbkKuQ74ThKtzynVDfH6sksqrCQBR+FQqhCrM2oVCYZkKhf+3NT2i7DlAh3AkrvBWOM2H1toEqpPNduAr5Tnhg931YKBWtB09tqrCHQlzp0wfrKPRWYeYmFArTTCj07/Mtb4OsmwAVop2wqZd4KxxlwtbVVIVjd8JlQ1UYsBPuv1/oRaHUUFKhT+Eo/FL6ZB6FvirM3IRCYZoJhf6ddYzm3JAKNx4qxDthUztHVfhquynL36tLaELHVThuJ1zCg3Yn8Z3w8LPkzwul4vXsoUUVhqLwQij0V2H2JhQK00wo9K7uPY+FVNjH2u/N6pLthM4BFXaiJgQq7PCzXF2ynXDMQZerzWbDDqpaj/94nxRKRezkhgoNvAY5Dgpf2kehhwrjmLBxvYRC8wmFI19n0l5jcclUuIvuhECFQSYEKuzHdsIIB+0zoTvVS03UfJ2Uvb7kr8JQFP4QCudRYd0MmLB2vYRC8wmF4z6l6/2f340HbOBOCFQYZMIAFbKdMNJBVes3/d4vlIrZY3sqDEXhR6HQW4X5m1AoTDOhcNyFNOfuOkw1vhOio8JNyLHGd0J8UPhO2O9Ml9Io/6TCRFB4fhQoPKBCAyYUCtNMKPTtW/l/p46qMHwn5EdxExIVhu+E0x9ETOg+61IaBYqgwteLrAtF4ffSp/fHgcK9KrRgQqEwzYTCcRfSuF6fKNX4TshVyE0IVBi2E0Y6qGr9L548KZSK293S1jPIoSh8JxR6qdCGCYXCNBMKffvZfZ2Jhwq30++EXIXchBxrfCeMdFDVgl8E3C2UitwjWyoUCp3LTYXMhEKh/YRC36rehTRcheE7IVchNyHHGt8JIx1UteT/3HuFUgeSChNA4ZujQeGwCi2YUChMM6Fw1Dvubn1DRsVUyHdCrkJuQo41vhNGOMjHhH3IF0odSioEKOQJhb4qNGBCoTDNhMIxPymsbncjUiHfCbkKuQk51vhOGOmgqoX3kd8plMJNr8KzRa4JhX/LSIXYhEKh/YRCz352XeOrwtXUOyFXITchxxrfCflBfCc8XKMfFSpYBBX+WGSaUPivbFTITSgU2k8o9Kzy+TxyFfKdkKuQm5Bjje+E0x/ETejO9aNCNXt2VBgHhRdHhcJhFeZuQqEwzYTCMbcUfhv8Yw1UId8JuQq5CTnW+E44/UHchO5UNxWq+bupwvXXRY4Fo/Cq9Om4UDiswsxNKBSmmVC4CzySsEafs80UOyFXITchxxrfCSMcBEzoat1UqBLopgqvslThH/bub7WJII7i+CqihKhF32EnUkmjF90LxUxwIX+QXhjBKL7/e+iF0NhMZE7OsDnTnu+9DIHs+ukvuzM0Cq+NQlKFvAk38/Z4RuH9zyg84bLctZgK+TkhrkLchDjW8DnhQAt1fZvZZx9/7ARKqLDGI++MwtvUVXh7s0Vunkbh/c8oPAEPy/9eazNAhfCcEFchbkIca/icEF8InxPCDxWOGufO0yjch4OQjcLbxFUoYEKjUDOjMK+wX49ewDfcnBBXIW5CHGv4nHCghbr+xMcCnjfOERVWYX0bFhqFe0mrUMGERqFmRuEJ317SavicEF8JNyGONXROONBCXX/yC0RPG+fO1ONQ/zbWNAo3Iaerh4fC0iqcCZjQKNTMKMzqMuw1o62GzwnxlXAT4ljj54T8QuRtrfP21U6jcah+axoahZ9CTm8eIArLqjAqmNAo1MwozGoH3iqWkArxOSGuQtyEONbwOSG/EHtb23n7aidSQoXXdb2EbBT+m6oKNUxoFGpmFGa1CXtdIc+q3baC5oS8CnET4lgD5oTDLNT1zAz4dePc+Ro/q/wlZKPwTpoqFDGhUaiZUYhvZzdvT1PhFpoT8irETYhjjZoT8gvxt7Wp3zRxMl0cqvDL+0k9GYV3klShigmNQs2MQvjLu2lbToX4nBBXIW5CHmv4nJBfiP9MftPE6ZRQYZhNqskovJugCmVMaBRqZhTmtMzYujrnIOQtNCfkVYibEMcaMyfkF+I/08ZvmjidXr6o+XUTozCRmAp1TGgUamYU5hTTdwpchWtoTsirEDchjjViTsgvxH+mnc80cUI9TajwW5zUkVGYSkqFQiY0CjUzCuFNnaYtr0J8ToirEDQhjzV8TsgvxH+mS59p4qQahWofLDQKE0mpUMmERqFmRiF8nsnXNrv+UDZrbE7IqxA3IY41fk7IL9T1BW5MTxrnzt2rUOuDhUZhOhkVSpnQKNTMKESPvehI2ayBOSFQPP5eyxq4BVBYw03IL8TPPsN+jXNnbxwO29SwY6FReCQRFcaQ7qql41H4AQjvn2/C1P0noxD97s5Y2dz8pc0KnBPi1/uv7Wq1Wif/LCRVmObnCjAhtxBgQuxMk5eNc2fv0bNw0I8Kdiw0Co+koULgHw7SNDjxjMKcx87e0bIJN3+wtl0HwoTAFQ+YkPhI6+12fRMOigMt1PVFHhj168dOo4sXVf6EbBQeS0GFaiY0CvUzCnMupmVxrKVNiBcBE7JYyyvSCw3g3L3/BnzQnRPp6ZMaf0I2Co92fhXKmdAo1M8oBF4+BoqACaki4KchsBYHWqjri21C+apxTqJRqO8n5IFQ+PGho/A48GoyoVGon1GY89QZsbk0aEK8SPipPNZikYUAE/r1Y3ePGodEnybKeVJIxquwIhMahfoZhTk70hC/UKImxIuEn0pjLQ60UNcXO9japx87oVJn3oVr5Y2sjUI2XoX1mNAo1M8oBF4+xloAJqSKhJ/KYi0OtFDXFzS/96RxQqVONwlf3k5kMwqBhlThUtGERqF+RmG6qwLWWQAmpIqEn0piLQ60UNeXfWT0onFOplFI9F32fROjEGhAFS4kTdjOgxPPKEx3WeI+sQBMSBUJP5XDWiy6EGBC7vRj70njtBo/C4f9UD31zigkKqfCSkzYtj+Dk27TGoXJ3hXZ+33aARhnWhxZaDZvyzbfkSbkVdj1ZdHvPWl+s3e3O0oDUQCGWbJLY0TJEi6BOTXVUtSI3y1bIgmuiWnUoN7/hZj9g10ddgudMqfN+9wAIU3Jy2lnBsqMhmLxS+ewkCiswd3v4rIlTcjzY+1mRKFd4qbgVvmJbs0iseXT2rgXidXC+Veai1VeOKlo2SEKoc1gLK0ZFhKFNbiswnY0oTFPBIplhii0y6UkrXELz091a8aJ3LaIUtOEla0/t4VxLt5Y2jNq4O/quAfociFtGRYShTU4rcJ2NKExnz8IlFqsDVG4h5Q5bqhkZRqxmud/r+12aUnCpvozi00jlpumOreQHTYqhEKjYUuGhURhTe6rcCl2a6PE5+fJCb27ilBNbFwJS750LwrzugEyL7fNNjYNimdRFK3jwjSrWCeLU+SnmWWbXRFmy4YucNADtBmM2zEsJArrcV+FS7HLDHAiYcmbSlH42+hm2aawlmIZZUmSzKPYdEYa37AEofvPiaLYdecuZIeNCqHSRSAt2LOQKKzBdRXShNCh41HIzdRBiZQMeoA+o0dis1F1wAlRWIPzKqQJoUL3onDZup8JHB2FbFQIrS7F5joJ9agdhb+IQodVSBNCg+5FYaTy9Vy4ExGFaIGzQGy+6VlwUjsKX0kVU6KwUhXShNCg41HYofcAYb3CFz1Ap8FYRPW5d0ShF2lOE0Kv7kXhlijsOHavRktMAtXPkIlCP9KcJoRa3YvCREoKg86JiUK0xGAsonfTQqLQkzSnCaFVx6PQoHs40gTtcRGI1SsF65CJQl/SnCaEUmFJNN3ja1jyyei2IQo7jiNN0CKPxyJK97KuHYXXUsEHotBWhTQhdLoKS6Z7zFRG4Sq+sY7+ISWLCF5dZVk2j1yTkmH/tsnZjVEP0GISiNX1x/BIWqJQqnhGFFqrkCaESutwpy1RWMTRPNkIcJdH55f9s8c9wLvBWOx+fg8bRRTqdV8V0oSoyHsUvjX+pLMoWQhQVXDen3DoCXw7G4pN0ytOiELF7q5CmhD11Y/C19M9wpK18WQ2zwU43KPLSQ/wadCXPV75ysL6UfhO7kcUHlmFuQF8eBmWzNRGYbrcMiHE8YLxQwaG8Gl0LlaHZKGyKHwuVbwjCo+owjw1gA+fKkXhPPzrypzcLBOgrgfMC+HTw0CsKmdhO6PwBVF4aBXShPDAFoWfp3u8CUvMaRURi0rgxrDPyhP4M7gUu0OzUEkUPpX7EYWHVyFNCI/isORlpSj8YU4oZkgIlx6c9YCa3D9DrpaFyqLwo9yPKDy4CmlC+PT7VhRqO9IkTgRw65wshD8Ph2JXJQtbGYVPiMKDqpAmhA/2KHxfKQpjsxdJiBYgC+HPoB/IPt++h3chCrsXhf9VIU0Iv/6wdz+qTUNRHMerVEtpN1F8ASE5R1q3LNPM2do/W11hBlpHY5bI3v85dCJ42ZLmDJLec8vv8w6Fb2/uOfeODeeatlffIAmhKQe4WwjWHHapVJasuJyyKIyoGqLwaVWIJgTb2HAiisKlvwPTEwJoThcbasCaZ20qFU9mXMbJKPyMKJRXIZoQrBM9fuyxYew3b46thNCwXgvAlmd9KpeGXEFHFGYk4SEKK0xv6R80Idi3ZMOVV+KCDb5A81+Ooyid3BuGoNKGDOHOTO7lURRTlT6+IYMF1RMnlZcLlUQhIQprMqB/AjQh2FD+pImKnTTLM9pqkwbhikG5iAxsQZjkEW31ugVgzZaJk1q+IuuIwk+IQoGbZXB5GcyOfADbrtgwL/21smHhN2kabA3CScjgBOtR+NcouKZynXctAAuMQeRS10OuQXNRGJLEB0QhgEtk26vnOxs/PjqjUtcJDgjdoSMK7w3TmMo8bwFYIMrC7MFxIaIQUQjQsF9sOLc+fjygMhGK0C16ovBvF+JmIWhUkYUUJfyfrigMSOIUUQjgkjs2XIjGjy/8pkxvqViczxjcoioKmVdBRsVetAAsEGZhbAwjq4rCCaIQYA+xyRONH9/5zVhcUqEMh4QOUhaFfwwjrLIGhaqykLJHf4o1RGFKEmNEIYBTxqLx4/EOJk0WZyVJyOAgfVHIHEZUpIPDQrDqZa9P222CGTOrikLhgyaIQgCnfGTDd9Hrx2u/CceFTRgjCR2lMQqZww0VaeOBE7Crd0DVXagqCjOS+IIoBHDKFRveiyZNxn4D5lRkgg/HrtIZhcxJTAU6b1sAVj1rk6AL9UQhiXiIQgCnLETjxx6bfviGBpswwniJu7RGIa9yvIYMKh12qdImH7FI01E4IomviEIAt9yx4cQrMxBcKqy5CeOAwV1qo5A5zKjAwasWgF0vn/epUpYOV/ajULimEFEI4Bg2fRa9abKuvQlxTLh3FEdhyWFhp9cCsK3XJoEoGFmOwglJBIhCAMcsRZMm6yYvFR7TYzgmdJzmKGQOY3xCBqUOux0SyNJkZjEKc5I4RRQCOGYtmjT5JrhUWOMumnjE4DbdUcirDT4hg1YvewckssmHK0tRGJHECaIQwDGebNJkwAbPr9HN4ybcYOjYecqjkDnFFDLo9arbIWkYJjMLUZiRxHtEIYBjfrLJE10q/OLXZ3pJD6UMzlMfhZxQkectABV6bZLKroNwx1FIIseIQgDXsOhNk3VTzx/f0kM5g/v0R2HJysI3uFgIShy+6JPcJk9GbGg0CkMS8RCFAK5ZsuGj7FLhT78uA3oIb5jsBQeikEcx3kIG3V697tBTbNIgXO0gChOS+IQoBHDOFRvGXpnzRpbSHKEJ95QLUVhShR2Mm4Aib7sdepo4mhhp2EgU5iTxAVEI4JyFbH31nA0Dvx7TMzThnnIiCnkUY2Mh6Gd0oVwcpZNhuGomCiOSOEUU/mbv/paTBqI4jtP6b5yKnTree7OewwQkhRIjgUgZrTOYDtQBY3B4/+ewjjeLJrqYBfYkv88TtHffOYecBRDnjnU3qkC4j/2xjyasKhlRWFCF9KgB4BStC3e0DNbxqtezG4UJmfAQhQDyjFhzrYpM7e+PP6EJK0tIFBZV4dMGgGNOLp5RGUkQpHEc9+6VjcIJGWkhCgHkWZhdKmxZ3x9/eYtbNJUlJQp5RahCkOL8UZP2YhnsZElGQkQhgDwfWKeK3FjfH/u0bcZQGWKikH3K1cRpGnDR47OnT0iGQCEKAeS5Y91CFZlavl99jXdMKkxOFHJKOVCF4K7z04ckQAdRCCDRiDUts/3x1PqXx8mEoToERSEvKQeqEJx2ctEkx/URhQASLVgzNdwfq9clXdK2Njtr3iutdlNQSVE4SShXEwcLwWWPX144PTH0EIUAEn1g3Y3Z/viq7FcmIh63i1ZxkJEVyyBeRVwbkqKQ25QHZ6xBgJPTF67+xnCIKAQQic2O0lyxbvO6FN/5HxRGfpCQZcnMr0kYiopCTikPqhBkeH7m5MhQIQoBRLpijafM7lffWH3fzrVUitYZ7Um2du2f/aXOUTjPKA+qEOQ4d60MO4hCAJnesC40e/94anNQGLNLJnFGe5X57g1Guc5RyD3KhSoEWZ6/PH3hygcoEaIQQKaN4f74M+uUvUFh5lIj9VI6gLTiH1sLi0KeUYEnzxsAspzfp+Hxp4YeohBAqJHZ/vjjJWtG9gaFPXZGL6ADCRz6r3+qdxTOE8qFyzQg1eOTs9NXQUbH0kUUAgi1MNwf37Luu61BYcCuiAI6oFmFp4XSopBjyocqBMEe/DqpFcdpECR0UGOFKAQQ6qvh/jhkO1dpJrTFlTaap3Rga5f25vWOQs4oH6oQ5HrAmq4atlqj/r3OTwPaKx9RCCCWZ7Y/Vu9Yt7FzozBlN6wSOrjM4ZvdNYvCFRVqNgBE+i0K/2lE1vQRhQBime6PP7ONB5A9FweF84COYlbNYaG8KOSMCj1tAEi0axSGZE0LUQgg1lfWtVShqY1R4czBQWE7oSPJKvnBicAoXFERVCEIZRSFugHZohCFAHJ5Zu8fq2sLo8IuEbk2KFzToTl7pbG2UcgZFTtrAMizcxRGZEkHUQgg2IJ1C8OrNLz5z89MHBsU/n11POhE/ZL8zpj+Iq3eClliFK7oD6hCEG3nKByRJX1EIYBgG9bdqkJXpUeF74nIrQfuoiUVCNreUNkRtvodyufk0881jEJOqAieNgGRdo7CkCwZIgoBJBux7qMqEnLZUeE16ZZ8dFFCuQaXXWVXOGqPKVfmQBsjCtekWdO2JzhMA+IYRqH9HxWOFaIQQLI3hqcK1W3ZUeE30q3YBvtNOI66ai+8DuVJKlaFIqNwQhq/TTqcKwSBdo/CPlnhIwoBRLtjw09NQi75rMlb0iRH35vmNmHgqf0ZtmtQhSKjcOuvHocD0uET5B/s3e2O0kAUxnE0Gr8YE42XcHqGtFAqUGuhLgF2SRDDunHdt3D/16GbNTqFLU5najvTfX6XoB/47zmdGXBP+ShMuRI+ohDAbSMhC1VHhSuvpNCuYyaTjUYSmgoHra9CN6PwkiXTgyp82QFwSvkopIyrECIKAdy2FLKp8qhw6ZUTsSwQpqpvwmFC/113zAduGp+aPvko3LJkQknMec86AC7RiMKAKzAmRCGA43whS1RHhb5XzoIlG9Gs7Xfe1wupFlHW6jPIbkahWOd/19KMc1696QA4RCMKp1yBCFEI4LozIesqjwrPvDJOrNoeHzZhRHVJx7xvLVrD0Si8ZElClLIMryCDYzSikLgCKaIQwHU7IYtOVe8qnO+8EkKbzh7f8p44pRpNWvy2iaNROGPJlIh8/gWHTcBROlE4YGMxIQoBnJdvvRGpPmsy8krwWbYVTQp4zzihWvm8rzXvIDsahbnZ8VC6oQMvm4CLdKLQZ2NDRCGA++5Ub6Whkf5Zk4E9N1fPNpwXUN3SjJntuqLniUfh7cHrrQHjs0JwlU4UUsamQkQhQAv4QvaFis2FzP+meUvhrWhS3HgT3ldhSz8rdDUKg4NHGZIx47NCcJRWFAZsaEyIQoAWIOVR4bnIOfdUXdhzIc3AgiZ8qEJ7/k0QhdvDeUeYcc7bDoAjtKKwy4YiRCFAG3ybK48KP2m+a9Jn2Uw0Z7axoQnvq7CVC2RXo1Dc8F/dP79WuK0QnKQVhRSzmQRRCNAKZ8qjwkToLZB9a24pXNvRhA9VaM9O/clH4fqRz+WHnPMKjyCDI/SicMhGAkIUArTCTiiPCkd6C+SIJbFozocazh1rnkFuxXN3zkbhZ/l/ouCSjncdACfoRWHIRrqIwoqc9P3Z4N7MDy88gPqlyqPC07nWAnlgy0wsZlkWUoMmzLa0MqIwyB8/fpDEnPO+A+ACvSikgA3EhCiswsVqwbJ1hC4EBY2NCs9Fzlxtgbyw5KrmS86ZUqPG7bus0Nko/PDoIcoUC2RwkWYUdtmAjyisQP+aDw36HkC9RsqjQpoKjSusbYmfG5ZNqFlh1rpRobNRKFhCf0RYIIODNKOQeqwtI0ShsYtr/gVZCM27EzlfSPldE9F3KAoDlsUJNSxq3aiwbVFIPSyQwT26UeiztiGi0NjqIxeKPIA6rYRsfqq+QBY/vH9aWvLIXcyyLjWux7Ir4Tx3o/D748/6JxkWyOAc3SikmDVlCaLQ0Mk1H7PAp4WgzXxUOFJeICvdS9NnK1phwrIBNS9lay5wfOpRGBf8uTDFAhmcox2Fvv6gEFFo5mTBx31cegD1WQlZdFpigTxyJQqvWBaSBQK25AgOorBohjzBFdbgGu0opFh3UIgoNLP8yIwqBIvciZyvVGKBfFYqCm+Eqg+3caVY9r1ng3ynbuL/YT3YikKIwt+uiqIwiVn2GgtksJ5+FHZ1B4WIQuM5IaoQrDLaCz064qvIW5aJwlio2cYM1dgMRBFE4W+f5Sg89jP5vANgOf0opB5riAlRaGbBKtYnHkBddiLnE5W4wnr+o/oo3N4wmFBcTCMKC6KwcIH8pgNgN4MoDFnDFFFoJmI11x5AbVKRc05HnIm86TfvmJVGFGJOaEjtuhtEYUEUFi+QX3QA7GYQhTTk0nqEKDTSZ1UrD6AuO6F+LQ39ZO9ud5MIojCO80WNiYkx8RLOnrNZEBbsgstLgQJNEGM1vrbp/V+HfjHMYLvM7KzDjDy/G0CbNP1nDnNmIbpJUiWzj8I+gyOjdTeIwuNRqP/dwrJCCJ5LFI4KtjTtIgrdXLGpIQbI4M/GYi0NTURXNhyFM4Ym7eRhiEKDKKQ2q160AILmEoWUsqWcEIVOFlztv/sPQyQ+LUWzsflaodwYRyGmx6cgXmxZMZaIVEWhvsIad00gdBZR6D5A7hGi0M2WGUeFEKI3FndNaJOLjhqNwluGPyL6UuEs2mf7KqOQMt7DuyYQOrcopAu2UIwQhW66/Bu+VQghykSzoCrv5QBhfBwwRKFLFFKHVa9aAAFzjMLRlI1NS0IUuvnBNrYJgDd3oslHVCWVA4SLJuHqiQ8z/SMjciQKS1ZgLQ2EzTEKqTSvwowQhW4u2Q42WINHb0UzoUrvRLf8higM1kx86Ef7at+RKKQxq563AMLlGoU0MW9CRGET02NcNYEw3S8tlhXSOquoQsco/MjQqK340Nc/MiJaFB6bqOEJZAiacxRSZtqEiEJXOdvpJQD+bESTr6nKKK+oQrcoFIZGFeLDR/0jI3IsCinnPWywhqC5RyFlZk2IKHTWYzvDBMCjzOYGMm0qqtAxCr/wXjGAGtqs+ClecKyLCo9GIRW8h6NCCJlRFLp/rzAjRKG7IVtKADy6E92CbK4gP1KFmeMzdx2CGtITFNoXVswlHsejMMVRIUSiiSik7gVXKkpCFDaAbb1JADy6EU2+saxCoWai8Jb3pgQ1dNl/oW1Z0ZZ4HI9C6uCoEOJgEIXOW6x7I0IUIgrh/3f4rklG1d7KIWokCmesIKjjFIsKY71+rEchjgohZg1FIZUdfkSREiEKEYVwDlaiS6naBzlETUThV1Z0CWqY+j+2a8d608QgCqmNo0KIgksU6tIHs7DIiBCFiEI4E29F17WuwrKBKOyzIiWooeP/2G7Oip3EQ43CCT2si6NCiIJbFOrK/pA1u68pEaLwfKJwfbFjOA9X2aXJADlf21fhp0S1YEVRoy4yghp6rLgVL3asGEs01CgckNFR4csWQJCco1BXSufLlH+bDi/mJREhCs8oCgcMZ2S4MhkgZ2RdhROtCt/UmSmyYkBQw+AEs9wi0ofu1ChcmlzdwbMmECwtCsP+8g2icMuWkmpoQnAxXJkMkFP7Ksy+uUbhjvfaBDXkJ4jCWaRvmqj/7gsyOSrEC8gQKkRhRK7Yzjbxac1wZnoPDpAz0d3YV+GSHo1CLCqsFPeiwn6k66u1mJ3gqBBihiiMxuc5W/qR+NRnODcrkxXW+ca+CuXGLQq32tENRBKFwnFuKtSisDA7Knz2tAUQIERhJC6zIdu6TnwaMpyba5M3kCVb16jC60/1oxCLCiNdVCgFK75LLGasGpgdFT5pAQQIURiHxZbtfU4qIQrBQcUv1UR076hGFS7vmorCEUEkUdiLcymNHoXTkdGanxctgAAhCmOw6nENV0k1RCH8myi8X4oupWPey982f0chiwksKox0UaGM45wfF6wZm43kX7cAwoMoDN/lnGtZJNUQheAoM3zYRN7XqsLr+0aicEIQSRTKzyjnxwXrugY/UyywhjAhCn+xdy+7TQNRGMezAYQAIRCPMD4HOUpsaO2ShNq5NZJpVRq1kIT3fxCuouNLnck4Ts7A91tn0U2av+ZyRjw/Jitx4tVCFEJbUeh95oK+2uYi5JLJzC4KMahwD94fYz7MhnTX7IaI8rrqAT7dw1QaEAlRKFw/s//BrocohLaisHysMLzYXoUTLju5QRTuwPXp1Twk3R27ISLTpcLcJ191AMRBFIq2DOgv0UMKEYX/Jd/T1B8rnMzVNnOfyyZjiyjEoMI9GB3l0seaNGt2Q0QFXaPSftIBEAdRKFgS0gPkPXFXiMJT+CEizTT4J0wNv1Tf2GgwTd4Vlw0RheacH1TIm8KlZydEZLpUeEa6Zx0AaRCFci1ishd6hxaT5i38EOYr/Z/QM/1S9bjAV8rqugnpLNoCgwrt5Psl5cNIycGn7iIq6hoNsH7dAZAGUShVL6M/HBhHgyhEFJYMuOBKKZvrJqQbYnp1PccHFTLfFlrUBUTGS4UDuoerJiAQolCm5YqamCaeAURhHqJwr1F4M+Icsyqcf+ACqzbpkmagwEJ0lDsfd+TeVBoi86XCU/oLr5qAQIhCiRKfGolnnglEYR6isGkU5t1MuOBKGThhnVUUYnq1s4MKmS/dWyqkCv3tU2nwqgkIhCgUaByTc+uEiEJEYckXuyrsh6yxi8KUNKECC13SbPhQNu4tFVKF90ZHNV92AGRBFIrTm1K92GeqszJsQkRhAaKweRTmKS76pHbeQo4sXj7DoEJXBxUyp5QzZPGuqcLHs+2tjVGFIA+iUJhlSluky9pbKPHCawxRiCjcRxRaV6Eah1oUWu1iruleoMCCT5pbPpivpItYvHdUxVfVRtg/BskQhaIkfkz1gl79B9PE2wNEIaLQNgrzBpZVeOE3ikIMKnR2UGFpqbDL0lVHYaQeEGH/GARDFB5Y7xev2jijetm4th/jdOntAFGYhyhsEIXmVfhWGTlpFoVZ7ucZLAyO9Q5xRLq1+BeQtSg0ud80xP4xCIYoPJyZH8T0R7ZalPqtF9AWfuLp+mmmF+FqnHi7QRTmIApbiEJvxEVXysjFB/7l3OLeAQYVujuosBRZ5yzcHVUKVLUB9o9BMEThgSSLjAqmuYhLUtpitfRKlj3/t/7M2x2iMAdR2EYU3lhUYe5k4bnVCbOANLL/s4n18UhRyF/dumtyTtX62D8G9yAK7TU/Kxjf/1F+TPWm0qMCUYgo3HcVno0soxCDCh0eVFg6VXjLsp1TtffYPwb3IAqbaP6KcfY7FfoZ1YvHnnSIQkSh6RBrHs2Vmf6E76z6YEiakQKXopC/OrWBvKFqkcn+8YsOgCSIwvYlK6oRet7M5DCheIhCRKHxEGv258rQyZB0bAaDCt0dVPjD9aVLG8gR0W5XTSK8fwxiIQpbN8uo1oYNDhM6AFGIKNylCi+UoUXzKBwqcCoKOSCHbiBH9ICuqjbE+8cgFqKwbbOYmskcqQlEIaJwlyoMTauwT7oUgwoP5i1pLvmgbiknY8HWdO85aT6a7B+/7gAIgigskdWE8cJzBKIQUbhbFX6ymoxiE4WnChyaXv3TO3LnWCFpHpHON9k/7gAIgihs1zKmRkIHDhMiChGFVlXIJ+1FIQYV7sMxz/VtyJmHTUjz+InJqMIuad50AORAFLZrSk0EThwmRBQiCi2r8GquDJySJmAjiEKXp1f/dL2mnEuxl02GpOk8Jd2ZqjTCUBqQClHYqvB/OEyIKEQUmvjic4l/1tpklC4GFTaVz/E7Pqx3lHcp9bLJd/budjeJIArj+NT4EmNjg/ESlnMMKktVBBYRUDBBGtqGLYL3fyHGatvZ7qydHRj3THl+302MH/TvduYZ/Tf6UB3Y/Py4g1EakApR6NPbvThMiChEFNYdV6y51YzuFDu8c4f16rCHCn/bUNZSaBWmmShUh6SJbf5kHysAMRCFPsV7cZgQUYgodK9CHnlaRllgqHBriUWOe7QMowoHdOOpUjWbnx+3SPNMAYiBKMwS8qEwrvwlY0QhotA2Cu2dfeO8/qRMFC7ZDtarwx4q/C2ZB1GFG7rxQKkj0vUtRmmeKgAxEIUZMj4Uzpr1ACEKEYV363HeeOplGWWNocJt9Umz5v8upRCqsH1rifrQZr/6Ew4VgkyIQn/OycnHRj1IiEJEoYVTNhiViELLLMB6deBDhZc2IVThkm4cKKVqNvvVMQ4VgkyIwgwBV4+HwR0mRBQiCkuI2KA7iYp13JZRVpl/msFB0yLH/WoHUIV0KwqPSNeLjFpYKgSZEIX+zPbkMCGiEFFYxtcx57VOo2IuI8YYKgx9qPDSYpmrQml7hYvc6ySHFsdZe6R5oACkQBR6c74vhwkRhYjCUi4abPBqYjeXN2BLcfZ7DThoV/6mSDInkr1ifZyLwhpp3lgcKnyoAKRAFHrTpJLWjVB/cowoRBRq3KZpeNy0msvbsBUMFYY/VFhQhZSyJK9zdffSZpTmDZ4/BpEQhd40qKT39aAhChGF1npc5mNh4rSMkvlVjQgcxNVHIb+mnJWkg4WD/Cc/0vUt5n6OFIAQiEJvhlRSoLeOEYWIwvIiLvGx8J3LMgqGCsMfKvwjJZJ8sHCVPxz4gjRJZPQK89UgEqLQmxhRuO8QhcUuxmzSn+xuGWWemYsDBy0JUWiqwnnMUmRnCi89Is0Hizv1NQUgBKJQgyhEFCIKPUeh/rqJSWtkuqmpS9gKhgrvw1BhYRVSe8gyzG8t0uRGaSKzD7hpAhIhCjUVR+GwHjREIaKwnCkbdafWyyj2UdiOwEFPRhRySnI/FpLmufrjicUlp9e4aQISIQp1+FKIKEQU+o1C3c8xG51Moqy2w30HDBXuAukSrkxKBm0JJwuPTW33wuI867tsTQLIgCjUIAoRhYhCb1Fo/yNkbo3+Md+xcorCTgQhrldfSeZEIq8hp6ZHjB+RJo6MXuFNE5AIUbgd3D5GFCIKtzBls/Hptps0GCrc+VBhzBVK1mQwH1SdhQPT0cADi+ePO3jTBCRCFHrToJK+14OGKEQUOrjos1m3WXAJlpyisB9BmOvVVxZLkpiFbWPaka5595smLxSADIhCb95SWXjR5J5BFFo4O+UC3Y75EuzQtiIwVLjbocIZV2qxooIsHHJ11sa5wYcWX6nf4PoxCIQo9OYz3j7ed4hCKz8bXODkbxY23Y62ZSeEIdT16msxFVgdc1VIc6Cu1Cz+Q5Lg+jEIhCj05wuVF3+thwpRiCjc9cfC6ywkp59iLjFUuNO/dddctWRNBZbxgqtwbC67Z6SJLZbBHysAERCF/nwjF61Qf4aMKEQUevhYyCdNx+vHWK++P+vV1xYzKjRLK+jClG4cqmtHpPlg8Wd7oABEQBT6c05OPo7qQUIUIgrdnU25ULcZJaRZsqUVhgq31SGdhEdE0jkVW8YJ/1+bgoOBpIuMOnj9GARCFHr0g9zEQfYDovAXe/e64jQURmE4igcGTyheQrL2kNqmFROxYxvH4kAIqMXYA3j/1+EBbb+MSZPuNO2Xsp7fA8PMj+Gd7HRtRmET329MqesYkqmF69VnNVS4EYfYJU0mI3M8YcmuzD0I79xC3KQhhRiFLerDVtzBM2RGIaOwGffalBlZ3ayRcaiwsTcQekaFXooKq2SSjWJzBGnJ074LCFfVv9sLh0gFRmGblrAV3XhdwyhkFNqq/MDJZ0iZqYPr1Wc2VLj1eY16wtZBeOZs3YXwmps01BmMwjbNI1hLuhYRjEJGob2qM+QVhLWpJ4YwdMlCD8LaaDEOoY8j3IHQq977eewQqcAobNUNGljOvS5hFDIKD2DmmyIJhNDUhA2uV5/FUKHQW0GZJ47wDMKrkt8thwpJH0bhf5QcIAOIOnUbMqOQUXgQn66rPjMCmxe+Apcs+NjQFYXGZMqy8MKRIIRuoStGIenDKGzX9CPsdeuKE0Yho/AwvhZkYQ/SmEOFO53xUKHiLLzvSI8hcKiQOoNR2LJphEaCzpwhMwoZhYfy4525JYaUmXoSbL13ycIAW+qi0JieoncL81l3D8Jbt8iAUUj6MArbNvuIZvyOzNMwChmFLWZhCmHNocLdznqoMC9epNDByXkB4dItxPVq0odRWKH9E+TlBLt05ooTRiGjsMUsTCB8s4lC3X/e1HqPDZVRaMznTMXjwidOzl0Il1yvpq5gFB7BEKX+DBJ+iLBbMPP0YxQyCg+dhdey7yQOFR7NKwiB0SkOvuHULhyh3lBhyCgkdRiFx9D/iEL/XhmcDlFhqP8MmVHIKBQO/ZGTEaSRRRT6LlkIsKFnvbqwCxOc1H0n5w6EsvVqRiGpwyg8jg8J/iMvOZ4F2K38ipN5v9/X8CSRUcgoPLyvrl9wp0nNOOFQ4aGHChOj2mgS4mTulEYhrzShDmEUHstgibwolplQfYb8sV8w9Lv57zgK/L2rg1GYxyjUF4W/zG7Mb98g1I0TCD2XLAyxoW2osNA4WIc4BUeouV4dMApJHUbh8UwHwyDCH0lBwk19VIinnjAfJsiL4pm3H0ahxChUGYWe9+PLtTELCKmpQ5YkhwotXUJITTfEo2yyCMMUrSuPOghlV5owCkkdRqEi88ozZH/7tTGKBPulB6NQYhQqjcLfp8hXGaTx/uvVb1zSsl49Hv0zNh0mo/M5o5DOAqNQlUGC3ZK/aeGjTDz16mIU5jEK1Ubh7W+MzNSy5lBhY5Bi08gomyThCnlpmEwylWM3FWIILxtG4WOHSANGoS7VZ8jLecUgdlS/PhiFOYxCzVHoRRAWFkOFb1063Xr1OEhW2GWVBB0rwwzCA+eWh9h6XxKFvPyY1GEUajMPUMG/jLDTjVcTozCHUag6CpcQVqaWHjY4VHiIocLMMghD1BMGHTpPXux80HcPAqOQuoJRqM8gQUOxVwujMI9RqDoKfUgx16vt2UfhxOytt1hhH6t1V7pQ/lwXNlF4xSgkdRiFCk39qINVyChkFFpo96XCGBscKrQ0hrA2+xlZ3Uy8WsdGvxjCI5sovGQUkjqMQpXmS1RRd4LMKGQUtgt7v1TI9epDr1eHe1XTZAVbYWa0yyA8ZRTSeWAUKtVP0MjAq8QovIVRqDsKAwjpvid8HCq0dAXh2z4PCdFIOvlsVEtyrxQyCuk8MArVanaGHE29KozCWxiFuqPQt1gqDBmFpxkqHIVobqH6FDnF1gWjkM7ET/budkVtIIziuC20pfSNll7CzElIrFExitFq3xBsQCgW197/jbTffLRm48QkzozndwkLu/snkzlhFNrrujPkB12OUXiEUWh3FH6ClASXWHOo8FoTSCZJ6HcWZhBeMQrJE4xCmxmfIRtFCKPwBKPQ7ijUYwjry4YKGYU1DxUaJ6Gvh8gJhLeMQvIEo9BuqzGqSnQpRuERRqHlUfgAyfw/91RRBalZFC53qFVu6ZWTFAevO4xC8gSj0HKLpSuPChmFjMKGrSANOFRYrv2hwiRH3VIrhwshvGQUki8Yhdb79M2NsUJGIaOwYd9hPJk3gNBXVEFsEIXZFk34HFgnhvCRUUi+YBQ6YDV24QIyo5BR2LS16ToKhwrbHSr8jDKjZNgPQ3GNJQyHWXeOElvrHhb+gfCcUUi+YBS6YLF0YKuQUcgobNrS/Et3EBJFFUSXRuFyi8eM4n6oCvRmWRePSgK77HHwpsMoJF8wCt3wKYG5vn4co/AYo9D2KOyZfumOQ4U1CC8cDY9zFErj2USVmMziFMXWVl1DziA8ZRSSNxiFrvgyhqlvuk1jCBn9k0BYffLC6pa/VAtIa9MoTBVVMIVUcp56TppN1YWm2RxF9jYdIScQnjAKyRuMQmcs+jCl2zQG3ZtIt+yb4SgNhwrrcMmXZDYpCsShMjJLXBinSXHwosMoJG8wCh0CU7/0YxiF5FoUriDFplFo9184a80hDIxuHafDiTLWK3xc+CewxAbCB0Yh+YNR6BCcsGupkFF4fyLdsu+QdkG5mEOFV+uWvsmZ5TgnjVQ1k2FBFu4CO/yG8IpRSP5gFDqEUUh2iXTb1hBy06HCmaIm1qvj3DAJq2dhasd1kzWE54xC8gej0CGMQrJLpNu2NP2oyYZDhVcbljyr+40z5tf+sCcZztlaUYUQ3nQYheQPRqFDGIVkl0i3rWf8ihmETFHd69UFTRhP1NWmXVurMIbwjFFIHmEUOoRRSHaJdOvGEPZBuT2HCq8VQthe0oRpqGrRn9tZhTsI7xiF5BFGoUPsvn2cgu5NT7duCSkLSqU4GCmqIIR0QRNmE1WTXtfKKsxx8LrDKCSPMAod8g2GdJuGoDszXujWfYH0x+ihDocKK4Iki+zsveP5TAlNPCxcB7cVQ3jPKCSfMAodsoRk2xdN9Bx0XyLdvgWMzo+5Xl0HSIOSJhz1VK2mI+uWaY5PjxmF5BNGoUNWOGLZt4/1T9BdWepbeDA8P044VHi1UdFk+GaPU7Gq2yTBfz4Hhho8PWYUkk8YhQ75Bcm+N75+8K7JPYm0gdudHw8Yhc0NFW5xqq8aMMR/4sBIg6fHjELyCqPQJWvb3/j6mdAZg6+Rd74stIEbnh9nHCq8WlYQhTucilQjIpzKs+BmdhA+MgrJK4xCl6wcON0jataD4X41o7CpocLfODGfqoaEc3uuIG9yHLzoMArJK4xClywg2LVSSNSSL4ZXDiAkiiqIzkZhljfchNL0L3v3tto2EARg2O1FofRESx9hPTKWI9mmkqljRyGGgBAYjEMO7/8ivejNKHFA8uKVdvV/j+Ab/4yY2U1vlk0eRPlMFCIsRKFXCmkuHQMBupF27x9nXK++yKHC/dGqCe2r8CHqRinKB6IQYSEKvXLIGRRi6J5Ei9tE4cbgDMmpKHyRV9o1oX0VVkXUhb0oX0dEIcJCFPplKk09jYEg3YpWcqjw8k6cAVrY7pjYV2EWdSEV5SdRiMAQhZ656+/qMeDETS7avk0U/jU4QybK4uSFwrm5uIm8kkYdOIrygyhEYIhCz+zyft4oBJwpREs5VHhxszc/+Iv9zWr7yzTVPnJuXf96TBQiMEShbxJp4n4MhCoR7dgmCqcGZ0hF2Z74ePzHOLHufgP5RZSPRCFCQxR655YThRi4vM1Td3sOFVpbvi6xo9RsEuPGTOoWkWuVKN+JQoSGKPTPLU2IYZu3eupOlNjgDHNRsrdnq6+NI6us412TWJRvI6IQoSEKPXSb8+0YQ7ZrdarwyKFCWxNRnqN9JTVr48zfjo8VlqJ8IQoRHKLQR7s7eV/OgUKE7q5NGGR6smRgnWLRVmqylXFnKTXPkVOFaJ+IQgSHKPTTVN5TcIsGwbtv8w3xkUOF1kQrKpHuVrpnXY4Kt/Un7ohCBIco9NShkFNSxoQYgBupKZr/ka8MbKPwUWpS41Sy6XBU+CzKb6IQ4SEKvXWYllKXF4cxMARFi1WTBw4VWpuJUom2cd3Zy+5GhXH9SCFRiPAQhT7bTdNS/svTKUNCDEbSYtVkUd+ThW0U1i2Na386GxWWonwkChEgotB7h6urq90YGJSy+bRozaFCa0t5T2acm3R1q7AQ7TtRiAARhQD8M23xqglReMEonBj3UtHKyJUXUX6NiEIEiCgE4J+DNH/VpOJQoa1r0br+PZPXe0aOVKL8JgoRIqIQgIeemj+CmwlRaGnSp0GhMbFo28iNh/qaCVGIEBGFADx0JTX76H0lhwptrfo0KDQm6WTV5CjKR6IQQSIKAfiobDwt2hKFb6wm82Ubclq8tDNJzFniDlZNFqJ9JwoRJKIQgI/uG1+l2Xb/vbNfruNM+iKLpyvbUeFj5EIpyq8RUYggEYUAfHSTN71KsyAKlWS9kX7ZxIndqLCKHChE+0AUIkxEIQAvFaI9N4zCuRm0JJY+miVWmy/r6PIeRfk6IgoRJqIQ+Mfe3bY2DYVxGI8P+IAPKPhS8E1yp7SmWXVpXV2bWUEoA6GsaP3+X0RUmHe6zp0cyLxPzvX7BjKQa/8sdxCkjeMNYw4V/vXO2kp4aT5LW6lE+ZF37uu5KE+IQvQUUQggTKVoVX4tUco0XuNjsas6Sds4ah4v79xClIcPiEL0FFEIIExj1wPWF///iIoFH83OhH8M/Y/k1HnXzkV5mRCF6CmiEECg1qJ9c7pefZrGaijWjby/dbfNO7YV7XnbKHx/0Ce5RBTCCKIQQKDOpKF2+GZtvIcK7Tdhuyoc3upRmp0oj5O2UXjjG1BEIYwgCgEEajl1mwoXotj+b+5SjE3Y6jWg2W1+1GQr2h2iEL1FFAII1dDtW3dbDhWeSBiGqbO3zR99py5EuZ8QhegtohBAqJbi9K27STM7IjSz8wmTfzs98Xv/eJR3aSLaq8TFs5ZR+CIBDCAKAQSrFu38mr2ojv5QYSmhOPYbPxd5lypRniZO3rSMwtcJYABRCCBYG7epUJR5Gp+BXDGtz4pimf1HRXF2tJYrjlJXoqzzDk1Ee9JNFN5LAAOIQgDhcpsKd5EfKqxkz+oss6EoZc/pzOePCne5B8+hkChEjxGFAML12WkqrBrPJ6MzlKbpl8yOYur7BvJclLw7E9HudhSFjxLAAKIQQMBKl6lwLZdiPFRYScPqc2bJcuU5FR6JMs87U4ny6wt3vH2M/iIKAQSscJkKF6LM0sgMpGG1zIyppWHo8++a5H9ZGAqJQoSJKAQQMpepsIz6UOFItKm5JlRbYasH/OPDvw3YGAqJQoSJKAQQMpepcBJ1FJ6KVmT2bKbi89GZa37uJoZCohBhIgoBBG1vKqzzqyYxHyociFZnFn3xen5c3cZNmovmUOgXheODPhCFMIcoBBC0Qm7+AnLMUfhONHsPj39bizLyuElT5d3Yeg6FzShMDxoQhTCHKAQQtlIa6vwqifhQYWl/KNybCo8NReGuORQSheg5ohBA2BymwiriKDwWZZzZtBEtdTP3jUL/oZAoRM8RhQACV0rD5EAURnyoULTMqpUoY48H43kXvp43h0KiEH1HFAIIXCHKwdHoB1H4W5lZVYsysBKFi72hkChE3xGFAEJ341S4EOUkjUoYUTi0GIX7QyFRiN4jCgGEbiMNu3zfKOJDhaJ8z6wyGYXf9oZCohA/2bsblcaBKAzDEVxFXL2K8as02tRiWvxrpIJQBKEotnv/N7IswnbS2mwNDTuZ8z53UArty0zOSfSIQgCtV6jkvXJRYd+ZwklhXYV8PxOiEPEjCgG03kzVL7t7NbyosB1RGOIzhbl8x0QhDCAKAbRf/x8vu5Mndaa0cPr4JogovFo5KCQKYQBRCKD9xsPqDdYLu4sKc3mezsI0rrOnMNXSW2fnFvLtEYWwgCgEEIGuSqYVN4G5M+VCnv5ZmB7lyYN4o0km335CFMICohBABMbTyrU0H3YXFQ7kGQb67uOJPFkIUfj6It8eUQgTiEIAMXhUyaJiUWHYv3S7dq7wfwh7qjMenjcZhR/yHSVEIUwgCgFEYVI1a5KxqPDTMMSnCsdT1Yn2la+7wSkTnRKFsIEoBBCFy6q1NFfy3DlTMvkmAV4gz1XnkcJek1H4trK3miiEDUQhgDjMK2ZNbg0vKryTwn6rSaGSfq2/hM5OZfIdHhCFMIIoBBCH2bBi1kSeW2dLrpIssLPCQmUjt53B+pfd0JTJcUIUwgiiEEAkuhWzJrK7qND1VTa9PAvHbKKy1G0pbW539Yd8JwlRCCuIQgCRGE83z5rkWrp2toxyrShmZ2GY9bWq57Z0raWXzi5dqWSPKIQZRCGAWPRUVnhRaHdRoXNdrZk8///jwsvnudYM3LbU2EaahXxHCVEIM4hCANHIpA2p8GA5Ct2F2iIfuS2dNzZ8/CDf4QFRCDuIQgDRmKnsfflHb3hRoXO9e7XE9l/NoKnh40IlPxKiEHYQhQDi0d20rDA1HYXuTu0wqHn6WXR2J5fvJCEKYQhRCCAe4+mGZYVXhhcV/jFQG6RuayM1NGeSqWSPKIQlRCGAiPTk8e4VX41HoUsVvrTu8My0szPFi3xHCVEIS4hCADGZb7hAlidzBoVfhWntj5M1dXl8eEAUwhSiEEBMZsOvL5DfDG+v/tRV2FL3HffyFE1dHh8nRCFMIQoBROVZZen6CdC9M+k85Bnk+279yZlFU5fH+wlRCFuIQgBxmXx5gfyhvwwuKvw0CvcK+aLnviWT51dTl8enRCGMIQoBxOVJZdP1RYU3zqjf7N3ditNAHIbxcRU90CKKguiBJ+nb0MZ+2Vht62dBWAqCrLju/d+IZyX/bgqaZtJh5vldwbInfUhm3uRhzliX6//NW1XNPL08vnBEIRJDFPq3/T4MyvhTH4jZsO4F8q+0hwr38olCUwxPW9jZeXp53HNEIVJDFPr25lLB+UwWImp1L5BnqhhmCRtPQ3pcuJg3+eEpVfHbz8tjPSYKkRyi0LOpQvRu2wfitdXtbyCvUh8qNPLpvPh/pQ4Up1nN82ULF6lXXr55rAtHFCI5ROGBJJqQKkTkprImB0OFowwNTCUphCeuhY+7xysZPUcUIj1EoVdvFKpvfSBeny5l7FaDwS75ocKT5TpQZmeRy8Ny9Y8rGY+JQiSIKPQqvCPde1/6QLy2sq7sgbFFhgZyhfGosFDVj0ErbmRcuBajcFzrvfaIQgSCKPTpp8J13QciNpR1U43CZIcKT6UgHhXm8nDNZCSj59qMwkGtmfaIQgSCKPTpi8L1rg/E7Jus0UdVLDM0oCAeFZaqWvlYo9FjohBJIgp9Cvpbo30gZltZu0J7SQ8VnqLQoTLr3NT+AV7WaC4cUYgkEYUGUQjEYijrShXrDK1EYffrPsuNqmY+1mjuOaIQaSIKDaIQiMZExzBU2NBct2zGWbdGqioHbZjJMN88bui19v4pCl84IABEoUEUAtH4+U5HEIWtRWHn8z65jFkrazQ7GQ9d91H4ygEBIAoNohCIx1hHMFTY0Fo11lmHlqWqSh8HCp+6M0ThXQcEgCg0iEIgIp9VjyhsKFeNzTLrzkrGzMOBwkf3zxGFzx0QAKLQIAqBiHy6VD2GCptZqkaXhb2WcelhoVB3XBt62vunKHzpgAAQhQZRCMRkSxS2S7XmWUfGG1XtPre3UGjXaLh9jEQRhQZRCETlu2oxVNjQ4qz/zeVCxkcPnzy+54hCJIwoNHxH4eRsvhGFSNI1UdimQjU626UZyfgzaMHvwzUaohApIwp9GoYTYm+IQiTp2LHCaYaTssxaLDP/prJmg9NNZD1zPqLwba2vRCGCQxRaRCEQl61qMFTY0FxHFJl3Q1k37a9W64nzEoVZrZwoRHCIQosoBCLzXXUmGU4MM2uUebaWdfWj/UsmPUcUIm1EoUUUArG51i0MFTaU61xV+GEja9X+JZMH94lCJI4otIhCIDa1xwrLDA18UIMq9NKEk/YvmeiOIwqROKLQIgr/snevK04DYRzGgx8UERTFK5D0ndK09kCmpbEHrSDESmGxbOv934iHD5pJpl1NZmKTPL9LWLbDQ9L5F2idj3OGCl2R2qvQ3oSpqm4tpkcBUYiuIwpNRCHQPu+l6LaPu5u1kiuiRejHQDx8ofAoplcBUYjOIwpNRCHQQhOGCh0ZSsbK/zKNvQn3iaosyV8yeUwUAkShiSgE2mgneYMQJYwl434vOXoZuhdJ3tT9xeMnLwKiECAKTUQh0EabOUOF7ocK15HkrZzH9iKWvKP7i8fyOiAKAaIwhygEWqlw2SQJUTUKU3WUgmTh9uBfSd5aVacLl0yIQoAozCMKgXZ6z1Ch83NYK1sVxkvXEWq69zBG8yogCgGisIAoBFpqIoY4RNVzeG/sunh4Nb+M/TThWvKXTIhCgCgsIgqBtjoxVOiAZGUeuhl039FjQj9NeBTTk+dBQBQCRGEBUVjF53g+n8djXJDO53O9G9+U06jXGZudZC1CVI3CbSaxTOO31Y98XVMTys+Lx0QhQBQWEYWlbYaCBjptel1xt2eo0O1Q4dSILMNqVq26l0Ox+KbcDxTKs+AHohAgCouIwtJSQSPtep3xhSh0G4VH89GbSQ/C0t5GYnP00YQvg5+IQoAoLCIKy/ogaKhBrytGDBVWltjGYZK90yzsR2Kzj5T70Wp5GvxCFAJEYRFRWNYbQUOlva64Iworm1nf5m6/ipUu8RJ5MBSrc6Kcj1b/uXhMFAJEoU8di8I7QWPd9bqCocLK3kmG/hNb93JB1A//wTJZiV16aFITEoVoJqLQVH8Ujtz6b1E4EjRWd24gp0Sh04P4q/pjLJfoZPmXRTjTcslauW/C7C8eE4UAUVhQcxS+P4lrpxFRCKLwgmy4rEKU8FayVEZylitd+G4RXrV4F2m56Jw0rAmJQjQTUWiqNQo3Y/HhtCEKQRRabeU31qtLkqyD0Vzf5Jo4GSxDq/4kiuWabwflQioGY4yGKASIwoI6o3CzEz92G6IQROGDH8lliBK0OVRomJ7lAfFwNhtkDulZMtTygPNUOXEvBrMJiUKAKMyrNQrH4suEKARRaPOJoUIP69Xmw0Ln1gdPTfgoyCAKAaLQxn8U+q+oEVEIovChf9NJiBKi69c/Ei1O6a3y1ITmQCFRCBCFBTVG4Un82RKFIAotPjJUWNnMjMKi41mc0VPVzCYkCtFMRKGpxigUj9L/HYV95MTG3/7/62gU9iQjClHCxBwqtBnvxYlzpLw14avARBQCRGFBS6JQiMJbQxTeBvmNoUIXJ7FWVoe1gyzUU+WrCS2j1UQhvrN3B6ttA1EYhUW7CKUthUKhtItulCsj4wgHnDZq4hgMBWHQJsbY7/8iVbxwR9I0jqUZ5Xo43wN4YYQ4IOYfEIUtRCFRuEcUBiqTf2YxOrgVwyoxOP2IvJkm59yERCHOE1HYQBQShU+IwkAZUchQYUdiSv5vXEhX26xM3Clf0oREIUAUtg0XhYX4kxGF2hCFOqRi0P3GU+tODHnyjIf7rXQwM37Uwz0m9iYkCgGisGXAKEzFnz9EoTZEoQ6pHDBU6Hao0C7fnd6F9wE0IVGI80QU1g0YhfMb8aWYE4XaEIU6XInhd4y+UbhOjsp3HaLQYxN+sDYhUQgQhXYD3WiyEF8mr36jyQhEoUoTOWCo0P1Qod20QxT6a8KLT5ENUQgQhW3+o9B/FS4uiUJ1iEId5mLIY/SNwo3uKMxXUuO9Ce1RePR/IQqhBFHY4D0KTZNC3MuWl0ShPkShEnLAUKGToULVUXhCExKFAFFo4T8KTcs0cyutkpAoVIgoVKIgCp2+ireao3B6QhMShQBR6FkqFR0xQBSehigMFUOFvf0Uk+IoXEvds+eOiUKAKLQgConCClEYqgeisDcxlWqjMBu8CU0/TozCrxGgAFHYRBQShRWiMFQMFfZXe5inWqNw47IJ/Ufh9whQgCisIwqJwj2iMFQLotDtUOFYZxSWhdMm9B+FbyNAAaKwiSgkCitEYagYKuwvrxWcyigsH902of8o/BIBChCFTUQhUVghCkO1JAp7u1YfhflWmj73akL/UfgtAhQgCpuIQqKwQhQGSwxZjA5SMcwURuF4JU3vouM4fQwQhQ1EIVH4hCgM1g1DhX2NlEdhJq/fhEQhzhNR2EQUEoUVojBYZjHcxejgSkzqonAjLW+io4hCgCi0IAqJwgpRGCzWq/vTHIXlo7S8jwZjj8JfVtdEIdQhCpuIQqKwQhQGKxXDbYwOZmLIVUWh5YjJxZBNaI/C2GpEFEIdorCOKCQK94jCYLFe7XiocKopCtcr6XjdMVEIEIUtRCFRuEcUBmsihjRGB5kYMkVRuJOWjy9sQqIQIAotiEKisEIUBov1atdDhWqisJxJ98lqohAgCi2IQqKwQhQGay6GcYy/7N3RSuNAGIbhuOwie+CKi5cQ/pZWTSuNYl1pcWGhBArFRev938jG9cBhEk0mKdN/xve5hlJeksw3HUzEsNIShfNCKr63bkKiECAKaxCFRGGJKIyXMFS426FCJVGYSdVJ0hpRCBCFVUQhUfiCKIzXvbyZpej7Z7xVEYXrleiYoiEKETSi0EYUEoUlojBeDBX2JyYNUTh/EC3HjolChIwotBGFRGGJKIzXRAzXKfpG4WL/UZgVUnH0I3FBFAJEYQ2ikCgsEYXxYqjQw1ChhyhseHX80/GICVEIEIUVRCFR+B9RGK+lGG5T9I3C8Z6jcL4VFbcdE4WIAFFoIwqJwhJRGC+GCj0MFXqMwjsRJTfbEYUIH1FoIwqJwhJRGK8NUbjbKHzeZxQuctFziwlRiOARhTaikCgsEYURY6iwt1sx5HuMwnGh8HNCohDhIgotfqNw8yeTNq6elkRh2IhCPa6Iwr6GOqJwvRKNnxMShQgXUWjxGoUjaW91ThSGjCjUg6HC3q7FtK8onBZSdXiQqEAUIkhEocVnFC7EyZIoDBhRqMcTUdibgihcP4uoWyckChE4otDiMQon4ug3URguolCPkRhuUnSQi2G6jyicbkXXZcdEIWJAFFr8ReFGXN0TheEiCvVgvbq/Mw9R6P6Y8PA0UaNFFF4ShVCHKLT4i8KFOLsgCoNFFOpxLoZJig7GYsh2HIV5i8eEql8dvxBDThQiFEShxV8UXomzCVEYLKJQD9arPa9XL3YchetH0XvquC4Kz4hChIIotPiLQnGXEYXBIgoVEUOWooORGFaDBruNwnEhik8dd4zCowTQgCi0eIvCDVH4qRCFirBe7XmoUAz5ZS0xFE1XmGgdrDYct/iRzeXN1wTQgCi08aSQKCwRhTHLzEZJ0cGNGAqXKJyltWYtN27u6h8TfkuUOWjxjcIZUQh1iMIKvikkCodDojBmrFd7HirciqE5kGQ9eMf0QdSfMHl1ShQiSERhBaePicLhkCiM2UQMuv/21PolhsXgY3lzFGYtNm7WjxLACZNXX8QwSmvNVA4s4nMjCqsC2SlcPmUO7olCJ0RhzBgq9DxUmDdX+KUYxoM6WSF1jo4ThU5a/Ma0hy0+I6KwTgA3mlysxA1R6IQojNmFGEYpOsjE8HfwscfmQpo0bdxMt+E8JrS3q2+IQoSCKKyj/+7jpXyEKPzH3h23tA2EcRzPxE3KdGNjr2Akj6N1bQVTaau1TBCKIAyH4vt/I2OdlSdH7nJtIdxdvp9/BwNlrF+au1/CQxQGhKHClocKr5uj8Id74+ZmJbWOAxuieXMkisdlnYDexYJOIwoNLUSh/nN/K/3BPRQ7ojBIRGFAfosyy7FvFL74RKG7woeujZuHa6l3ENgQzZsPopQeH2mhxi26hig0tBCFyu+7kfiYPC8LZTGROkRhwIjCkDBU2O5Q4bkjCj2uM/+5l4hOE6698/gnNhYlvPvT6Cai0NBCFO5vKURhbIjCkKwqu3nY9//jx22i8MxjqHBWPUwY1WnCtfeizHjLHaJBFBqiiMJnojA6RGFIGCpseahQlIutbq6cl1LvMOjv1nqi9JsvcB9lQBCIQkMUUTghCqNDFIbkmShsOQo1n0OK+n5JHK8wqTrxWKS5YLsa4SEKDVFEoRCF0SEKQ8JQ4f4udh4qnPoeUrx5EoteqBdMNkTzyOpeBgSBKKwiConCNaIwaXdEYbvr1StR5s3Xj+U1CSPboXnzzuN5+TSW85HoFKLQ0Jko/F4QhQ5EYdIYKtzfbPuhQvcvvBTl/OH6XuodRRBQB6IM8lpzZgoRIKLQ0JkonBVEoQNRmDSisOX16oEoI4+bJuW9WHwN+oJJ3ftM+h6/wHDHddAxRKGhM1H4syAKHYjCtDFUuLf5NkOFM48t57F4OAn+yfGaaFNLBLNIgwARhVWdicLroiAKHYjCtBGFLaxXa6Jduv5CU0x3jje+iXKV1yt162ZAGIjCqq5E4WpRFEShA1GYtlHlQxs7GIpyf9qg9LjaI02+hH7neOOLx9PyS1G+ZkAYiEJDN6Lw4l8TEoUORGHaWK9ueajwyeMU50hM8R0m/O9YlHFea87lY4SIKDR0Igp/rZuQKHQgCtPWF2WaYwelKLNTt5Eoox0OFR7GcZhw7bNoU497JhH9cEgcUVgVaRQWNRbPTU1IFNoRhWljvbrlocJzj1N2U7E6/phF5L0opc+vL5bn4kgfUViVThQufonFzaYJiUI7ojBtQ1HGOXYwMF5W7Cba0P3dY6z3SzZObCuFmijHGRAIotCQShQ6mrB4RRQ6EIVpY6iwjaFCrRSl35yZeqw6su/RPok2t3ye8ZI7BIkoNCQShbceTUgUOhCFaVuIMsixg7EoT6cNXnze8ZFCEhp3j698kjqyb0KRMqLQkEYU3k7E4q54QxQ6EIWJY6iw5aHCgU8pXYkpviQ07h6P8npnvM8EQSIKq9KIQnsTLguFKLQjChO30kGTYwdTUR5PGzyINvV7ftyLZ4VGL1drfY8jhUcZEAqi0JBCFC79mpAodCAKE8dQYRtDhdqj13afdhhjEmZZT5SrS8tPynQ1wkQUGhKIwqVYTIaFRhQ6EIWJuxHlMscORHvY6lDhmfX5cfTvfvsgPudVZxwpRJiIQkP8UWhvwtuigih0IAoTx1BhG0OF2kA8Onwg0U86H1jvHmslRwrxl737W3EaCuI4ntbWqo2urnqhiFcn05JqUtdNq1VbbUGoF4Io/nn/FxEFs3Nkk51sbJxJfp8HWBBk98ucnDk6IQp99qNwI29CRGExRGHLvff/ckPdKJxV+6gwLvpO0fymllCyufolPikEpRCFf7EehYVNuN9Ff0EUlkAUthwWFTayqJDLJMeqGXEGPyocE7dy55ubb19oKy8KPzjNEIWCKNxUeNoOUVgCUdhyO2JWDg4fhalkKc3c+qgwlDzd4k6JMfWEH7Td/Qnz3GmGKLwwCtfbppuQRyGY1cEoxKLCphcVfnwj+dhuSdzI3JbCHkn+YyV0Bg8fgyrXEIWc7Sis2ISIQuhwFC4QhQ1G4Sr9TL6Zk1w16QfGDCTly+ehVi9ZQ1shCn2Wo/BTxaftEIXQ4SjEosLalsJFhbMf34nhC/zKr2DYGxX2iMvcxafHWEgDuiAKfYajcLeo2ISIQkAU/oIoPNz26k26p/PFgjvN5kaFA+LmgrvHJm/TQIshCn12o7B6EyIKocNRiEWF9Z0Ss5r87eOXr9+pUOrOFxNjLJnGomEo31yN02NQxotC3du6EIVlUfi08tN2iEJAFCIKD7S9+uPsx2cqlwi20hi7gBySaNPRa8rh9BiUuT1hXjjNEIUlUfiWKjchohC6HIVYVFjfiph08sfmCwvCYnPJqNDUcx9D2aDwFZ0xNgqFDkAUeoxG4f9vwmhNYNUi6iBE4UEWFT5L999JJnOiUeEgsOLqSDYoTCmH02NQZ8LETjNEYY6kFg2OgPYERm2iDloTkzq4hJiYrys2IBSZykaF9wIj7sgGhQmdwekxqHN3wjjNEIU5cRPuouYkBDYt1lEXYXt1bVOqJZWNCkMja2mOyHMima9iczWocwNRyLQrClkTNuEbgUWLXdRJW+/RNbiEhOpJZKPCO4EJN2WDQv+ayXEAoIsXhUunGKIwRyLbXdSsdwT2bDvahFhU+A9QPSclu264XmBAX/Rv84vX0Nk4dMbjCZM4xRCFOZLYrqOmrU/SbAFl9qepJps4ibpqQ4zqX316vaZqRtdHomnalBgblzFujYjLZMsdwwBAmSuIQq49Ubjt5odiAFhU2JgnVEF4514QXCcuFv1gEwfIN8nzSvJ3zNyDLdAFV8w8aYIorBKFKZoQoMxbYnRvXlArJanB8Ci/jSGYpyVk7AC5T54noo7GkkJQ6BGikGlNFHZyyQgAFhU26oQkwuvjqwWvA8ein6z/BvIR+V46wbPHuGYCGtl55w5RmEMTAtT1iZiZg0uY04WOh0cBN5aNCpcZGcqnqyF5Vq7IzNYAFDrooZknTRCFOTQhABYV/n9TKjXo9y56HziW/WjlS56PyZMti4/Fcc0EtJswc6cYojBHv/3/p+0ADFvQmVMHlzAVBiHXJy4Tfq+o+g3kIfmmwkHhOADQ54GV7dVtiMJ/A00IgEWFGtB5wuNhT/xCcOwKLF+TZ6T2s8Ie+VKHQSEYdsPKThpEIZoQ4EBP8Khe3P+TvbtbcSIIwjDcxpgY80f8FxQ86KkJEROVaEgMCosK6oGIB97/neiBSHVc1+phM6nG97kCFWS/rZ76yi851J3dngSt+ajwtWh+2wonfUnsN6bVY/po4NTdWvkS/SIUCjfLAIoKHUlSzuPh1BSiJLEwPyAPgke9saTmpp9hnkef+L8VU1RIKCQTAkf67+m6ecEvFQrtu7SDg8GacQPZ6bJJV1K7yKAQRXtYSicNoZBMCFBU6MkLUayZbSKJF9Y9FpebGQNJrWO0XD1mUAi3rteK515/QuE/nX2tABAKW5KGwk5oNipc2suxbwdnZpLab+Nf6cEng0L4VReyfkwo5NwxQFGhJ69FuRmajQqf2I8r950V0wzlwMIWoBkUwrEHtfI+ukUoJBMChEJP5qJ0m87X5tHYS+MtFQ5FzPl2qf8qDArh2I1a+RTdIhRe7DuZEMhxJr9RVNjMRpRRsOr1rd/hbSXhKxUOxfxBYbpLzaAQnpWyflxgKPwgl4Zzx8BPtFf7Ilow61h3TeJCEp5S4VAO7DfGn18uV2aAXx4Wcv24wFD4VEzIhMAJPBNlG9HAS1Emwao3su6axJ0k/KTCodiXTNJ6HY6ZwLX7hVw/LjAUVq+kJc8qALRX/5uDokKVqAyfdK7kQN/FDnJHDi2iMdo63KIGlFrze+2pxFC4EAtO2wEnsBTF8e/Dnj0RZRjsxuZAtVlLysXj6yArE24l0Q2AY4VsmpQYCt+ciQGZELCiqNCVrKJC7Yok9puMVHj62ya9gRx6Ei+wloSTB3DgfI9qxe8jSomhsPr6UY7uM5kQaOCrKKuIBhaizEKGgf0BebuXQ4NwSr1xXibcSWIWAM/ulHHTpMhQWL1ZyZE9p4oGoKgww+mLCv+spZFnealw3AsnM+3nZcK5KNTRwL37Zdw0KTMUVtXTt2dyNN92XLYDGtJz/JcRDWxFGYcc1w53d3NS4SmXkIeiqIJC2+YxWybw71atLKNTpYZCAD5RVNh6UaHWNQYrnQq1a6Ft+nNCbb2J1vVptkxQgBtF1FcTCgFcpu+iuP112Ld981A4ldQuNxXe7IXWTce5mXAhif4kAM5dLaK+mlAIoKooKvTEUFRorvp7nZsKR1dCy6715Q9PNhf/uT3MN4Ec14v4qJBQCOAyfUgTCVoOhWEsif0yMxW2vcjb64oYdky0zZrHY5SnLuGjQkIhAIoKfckuKtSmWe+w27X8adzisHDYt2VCbcXjMQp0r4SmQkIhgKOFwl1E26EwdBpO3bRZL7Ri0hXFeAnnmYvlGCDToxKaCgmFAKqKokJP5qLcDLm6WRlrs5JzjG6HFnT6co7Fv/51eDxGiR7W2rvoEqEQwKVKG1HQTnu1NulLah4vtJPzdKfhyG6PRNHdivbPIKmtRjnqAs4fEwp/sHcvvUoDYRzGB6yQioDgNd5Wr28JxdIYalMhGuMl0Zj4/b+Nx92gXGbKkEz1+W1OzuacHTxhOn8AMFQYGbUMjbeRZ2ct9aB0Yq6ol+ghm0LOHXczW41uupNZIr2FRxQCIAojozbjL9V9Ve3+6ZutPzBXMpnrQXktp23Uxnceo0NuZZZSokQUAgiqZKjwYhu1TI23wdjhCrKtXulBw+tk4STVw0o5I9d9YwN0xZPM9lNiRBQCePWK9eqotBoqtE2Hui/3ufFsG4Y/RO7N9bCqOd+ErNGgu+7HP0pDFAIIqmCo8GLv1DIyLYzUtwoXlR6R9kxAo0SPWNdyxlJ5oBAd9iizfJQYEYUAXrFeHZeWQ4W2mXcV1ms9ZjwamCAm/bt6xG4r3k3YN0CHPM9sXyRCRCGAoN4zVHixrVpS00ri/byebHd6VPrAXGowSvSoVeHfhHMDdMm9LPrzY6IQwA3Wq2PiMFTof9lEl+L9YaHt7mxqLvAgHepRu1L8m3DMQiE65mX058dEIYCwvtlv9oIWihAXbKdD/yqURaUnDNMHrUJsMprrKevapQm5ZIKuexj9+TFRCOA3hgpjojbTUk9bVGH9Rk9L+j3jY/BgNtaTqoW0aEKdGqBjnkZ/fkwUAgjrg1oaQQuVWgampVGbKpRipecks9HUKUtvp2M9Y/dGWjXhyACd8zj282OiEMANhgqj4jBU6KKvf3onDhYbdTCe9x/0jgTrpDfqJ3fVQV7ThPh/PIt9v5ooBBDWV7UsBS2sw0ShSfVPubhYVupqmCRJ/0aazGc3P2Y3v6qzvJB2TZgaoIOeZrYfEh2iEEBYr/dfVdBC7rnG51+F/lkY3mrhvuVtownRWXcy22eJDVEIIKxPiqD65gJj/dOmjiML80bc5LqPJkR3Pcxs3yU2RCGAwBRBJeYCgwNVWIib5UqvZZcX4qZe6T4GCtFh9zJbfI/XEIUAiMKoJSZwFe4acdTkeg3Vm1ocFRvdRxOi017GPVVIFAIIbK0IygSvwqW4qstKA1tvxVmz0z00ITruedxXTYhCAERh3EzwKtR34q7JdxrMpizE4nztmCbEP+J+Zilju2pCFAIIbKkIanqFKlzV4mEbpgurd414qHNVmhD/mBdRXzUhCgEQhXHrmStUYdWIl21e6UU2ped/LDb6l4QmRMc9zWL+VhOiEEBgrxVBXR5Cg7n+rRRPTbnWdqp8WYun7U7/wBYN/gWPM1shUSEKAQT2/q0ioMQEkOrf1rV4W5TrSr1s8mUh3up3ShPin/Qws20lKkQhgFevOD+OWM9cqwp3C2mjWLxZb9TBKi8X0kpz6O/PDH6xd3c5bQNRGIZDCTElEQnhRwKpd6PPlm05kZvIkPiCdgddQPe/jVIkqgTsIBLbnNrvswRfvTrjOYP/3+TS35Q5S4hCAJX7KVRm2KvGUAVWmdtXEszTWVwUb3kcR2kYZG5vafGHANrgm+GtNEQhgOrNhWp41aXQ0NNby8AdLAme3f8OnmTuYEmst7yrHtAKd77dB5CJQgA1+PUY7k0HGX1pk+GgV52xpwIrW8dXzqW53hqNe0BLnPmbvjtDiEIAxugg/R4+sppGWpr61f1hIbGeEK126ptdYE0UAjCGKKzN4KuKzMysxchWEteO0Xa3ZkeFRCEAY4jCGp2oSJ46E8JcXDFB+12bHRUShQCMIQrrNPZk9Qw5iCV+J0QXXFodFRKFAIwhCms16KtQHLhPlcxUaMrvhGidY6ujQqIQgDFEYc1OVCxK3KdJIhU76QGtM7E6KiQKARgjorBm45FsZWGW5uLoGB1idVRIFAIwRkRh3QYXkp0sLE1CXXB0jHaa+DZHhUQhAGMkorB2V55KRIFrVBKphHfUA1rqxuaokCgEYIxEFNZvMFWZeO0aE0SSuGGCzrnzTb6ATBQCMEYSUdiAo5HKLOeZa0K4UJkRY0K02o2/xchrk0QhAGMkEYVNGFyoVB49uJolq1wSfxOim+78LffOBKIQgDF6QhQ2YtxXueU8cbXJwoXK9bl0jNY79rfYeGuSKARgjP4iCpsx9LTDLMxcHdaRdvB41g4d8GpX4Q9nAVEIwBg9IwpL1XSG3FQXrqNcu3zh5BidcOxveXQGEIUAjNELorAR51PtFs8fXEWScKbdpuc9oBMml/bW0hCFAIzRC6KwIUd9vWMZHT4wzNarhd7R584xuuPa3loaohCAMfqHKCzVeBZKiyhM3J6S5yAkCYFNt+bumhCFAIzRBqKwXPNZKOVxuk4+2INBOltKJCHw2qlv7a4JUQjAGG0hCkvVnIXl4ihdB5l7T7BOo1hPSEKg0Jm1J5CJQgB/2Luj1bZhKADDtaLE9SI7deLRLjR3QgpZ2UJW6PUgvRvsYu//LvNgg5iORi6pcyL931P86Eg6wrgXiMJhZHPXx+PD191uu259sX89rVubXRuDD66POUmIFC29sL0mRCEAYdz/EYUDqIrcDS4veHGMRK2E7TUhCgEIQxSe02Rs3KDMmH8JkaybhazPColCAMIQhWeWFW4wBXNjJO2j79g+2T6IQgCxIwrPbjIt3QBKDgmRvA+iBshEIQBhiEIJKmXcuzI1NwmBqzsvaYBMFAIQhigUYlYb905MPbsC0Br5rmcbjigEEDuiUI5qrN3JlWOKEPjn5pPv2NhwRCGA2BGFokyawriTMcWUe4TAoWvftbbBiEIAsSMKxammhTlJEHKNEHhh5cXsQCYKAQhDFIpUNUrn7q103RCEQNAAebu3gYhCALEjCuWqGjUvXS9Gq4Y7hMArrr2Uf2mIQgDCEIXSzTKl9NFjQ62VyshBoP8A+ZsNQxQCiB1ReCkmWZapP7QuTZ6bUutatZos4zUJ8PYBsv9pgxCFAGLnDvz6HIIoBHDJ7ryMdXdEIQBh3IHHdQiiEMBFG/muzd4GIAoBxI4oBJCaW9/1wwYgCgHEjigEkJrlQsISZKIQgDBEIYDk3HsBj02IQgDCEIUA0rPyXdtnewxRCCB2RCGABN36ru97ewRRCCB2RCGABC0XZ3+CTBQCEIYoBJCie9/zCTJRCCB2RCGAJI16ViFR+Ju9e8dtGwgCMExgmsFWBIjlQ3xUgtZQkeQADtLEjZHOVQrf/xpRIiAyJVEPg6JWw/87Acsfs7scANYRhQDmyYWrfkxDFAKw7mGjUHcaOabRnQQA9qRF2PO6PIEoBGDdA0RhqapeNjr3V/i8wm10slGrapkAmLMyu6YKiUIA1sUZhdvpn3OuCreVOee2U8U0ATAzTdj3shxEFAKwLqIoTFVFcueycCfO5SLkITAfdeg5+RNrohCAdRFE4UK95K4K8ahcLl4XCQDj8tBzqgqJQgDW3TMKU63FFSFehZOawSFgmQs9J6qQKARg3X2iMNW6dVl4EC4nDQGj9p8gD1chUQjAusmjMFXpYjoqvlTlhDIE7Emr0DNYhUQhAOsmjcKFz2M+LT6vyj03DQFbyiz0DFUhUQjAusmiMG3yRxwQHg1DJoaAIRdWIVEIwLppojD1XbDE1QwMATM07Pv2ujwQWxR+XQPAuKaIwsZWEW51PgFggw8HDqswtigEgLHdPArT2sap8aFKOEYGbLikColCAHNyiyj0WRhX5rZkp9ZjvOy4rdG/RRIAFvhw4NeyjygEMCfjR2FZjJCArYh43UiTUehGIyLtCLuVK00AGHC+ColCAHMyehT6z4XWvw5splpCnKqqSPvZQKwTAAb4cGD9c/kBUQhgTsaOQn/lTrlcatXknlS9tFdu3ssTAAYcq8KX5Q5RCGBORo5Cf+kJcS5NZMtCUm0kv/QKIhcLARN8OPDty/K/CKJwvQKAM+KMwsXZpio68XHfydNGuiKcUyYADPChr/8IOYIofHpeAcA0fo8ahXk4wbWR5+BHpZeTU0OXALDAhxPPTWKIwu8rAJjGj1GjMAwoWv+Io7WFb4swgPUmgA0+DD83iSEK3xkVApjG2/uYUajHg7CJ6/LgdVI9HoYsNwGMKLPBi4UxROHT+m0FALf3vH4aMwrrsK/zFiZqqe94avKHvbtbcRoIwzgenZNx/CAQMpM0TY8kb7AiRVd20ZW1oCcieKCne/+3YYuisyRDt2mjmfb/u4jh4f2YFzhZRSZdH59vTCIUtrdLioUAxnb947Y9aihUcldWxVwjvCMvCYXAqSqcdL3ftJCnEQoBYEruGQpz6VhU8ZcK09xmVAqBE5Y66Vp/JhQCwNBQWEif0kbcQ07ngV2TeBapAeyUWunxhlAIAEO3jzMJKBdVfCmqyK2TgOxkGuMAtmrpcXVJKASAYaFQ7fq4WsdRM0x1ZR2H7oBzkkuP1RdCIQAMCoVpKbuU0x7GK7SqvV+rKRQCZ0Nn0rtvQigEgCG3j4tMdnJTDFSpnqvalNLFRCFwJmZOeqy+jRUKP7QAEJ9AKByYChfJZMy0VsoaJ2H8XA2ci9TK2MXCu6fnASA+nVAYVpSD62xFpVSltU7GNdN6rpQyxskwZYwn+wDcQyV9Vh9HCYVvWwCITzcUhqW17GJ7s5qRvzKzoTYqvZUeMiS4pTZqY4yTw9kptr8BjDhYKFfH+rPwuvG0ABCfHaEwEO+CzMC+c2n+WKg+tfkrk1EYxgmBU5Ya6fXmOD3kl43nRQsAsbkKhMKgmd07FDqJgSUSAqdOSa/1URZOlo3npgWA2KxCoTAsrdxemya5TJ87gZN9AAa2kI/TQ37N+jGAuN00nofJPc0qc//lXSsT5yrWS4AzkS6k39dPR/2T5roFgNgsA6Fwp3RuS+ko06TDyIRFfb0ZwP6qTHqtDh0tvGwYKgQQtYvG8zjZz2xeG/FlRRJRKHQEQuAMFU76rQ88fHdB/xhA1Brfg2QAXVkjv7ii/xj99DhbsVcCnCslAYfFwneN5/q2BYCorBpfMlgxV0oVgdQoU+KMyhkhBM5bqFh4WCxsG/aPAUTsR+N5koxjIVNQmlpp4iCALSUh6y/H+b76ewsAUbnzhj1KxpE6+Y+csSrXDA8C8BVGAobHwiWlQgDxuml8j5OxqEz+MWeMUrlmcBBAeA05ZP3m0+H94+9MFQKIyUXje5aMp9BaKWXDN+oO9/tCntaaC8YAdksXErRqL5/v723jW7YAEI1V43ua/DMzvVH5J41lH+aXWm1prRkVBDCELiXs/avn+3rR8Fch8JO9u9lNG4gCKDxR1UIISWmo+WvJKroTgYSobMuua5SySKVGiCxAVVn0/V+jVMoCG2p7LFXx1Od7iqM7M3dgKV8OvVbVMGqm0X0ASit/t2X51fAUOYjlkM8BMgBbRJJwpQCgZjo9nWU1M/3/mA3WACwUxnLoWgFA/QxaOsvSDYxGhbxABmAhTxLOFADUUbOvM4WPhY+R50IVArDPVhLaCgBqyhnqbF+KdqEvSes7AKi6e0m6UABQW85Q53ZhUGhXIbNCAJZJN+GlAoA6y89CPXEfbvNEVCEAu9yLcKMQAAyzUC9XOQfJgS8pCzbTAKiwSFLOFQDUnjPUBUzunjLC8LOk+WyxBlBVvxaS0nijAADKaelCJqvHh4wXyClThoUAKmm+kbT3CgDwR7OnC5qH7tOpMpzKkZibhQCqJ1zIkXcKAPBsNO7q4sKVOwtuEzw5tomYFgKolHAaiwgvjwEgi9PXZiah685mz1cNA09OiBcsLQRQGeuF7HGhEADyDHpdXcI8DFeu++27nBTvojkDQwAvbRLtYjml8VYBANI6TkuXtd7IX8Xe3hQAXsDW87yN7NGEAGBi9GFYtgp9AQC70IQAkGEwLtmFPwQAbEITAsC/6cKtAIA9LnljAgD5Bq/62li0EQCwxDlNCADFjJybrjaz3gkA2KDBPyYAYKJpOjD8xLAQgAWurxQAwEzn49goDLc/BQAqrX2mAAAlJ4Y3XbIQwH+hfaEAAL/Zu7ectoEwiuMDH5DJcAs1di6+PFljBBFFUREigLqJvnT/GymhonHaBJyS4PH4/1uBH49mxud8wCgRE1SMhVwiA3DUsTuRsKdn5EVqSoJiLjAlqbzQMz0FAHXq6TitEg2//+S4EIBzOt1TVaeB1vHvADgsNmFojIlEYq0HCgBqoRNJTb940/SJkRMADjk+O1e1GOhQ0lkO3K7AmHSWDxUA1EDrRETMs2Kp6Y+nW66SAdSss9fd3TlQn22gRYwpPp8xIpwdAmiFI1s2yVvn7uJy8nVs0QAUn7STDsUMi7oNjcQ8PQTgtR274C5vK7Kh+/YUWqanJas/Dv4VDZORAgAv7dmyq7ztyIYOYzWjVQZx5FYenBtmMdfJAPxzYhfc5/iTDa/GjxYOOVJoi17ibCB8FUQhd8kA/NK1ZeMciy4eyIbO2FdohzArmiEjFwLwyEHHlj3kIBu6qnOg0AKjNCiaI4h4YAjAF/u27DbH+9mQxsiadBX814uKpiEWAvDEkS27yVHF/cVkSjZcA300qChu0inhq0AUADTfuS17bG8fDdnQfV8UvBcV2zA0c/1iGwxPCwE0H300ZMPG2FHwXfaBTbpnMpPoFxU3UmYSmTHPguJ/9UmFAJru1C64zvGRbHgzGX+z+Bd9NKgkXXd9LhOJtd7syojWOhbJ1t3TixQANBt9NJt3TTbcjkMFz42qLxEneqS2b6QTkarnh1oBQJMd2AUXOciGrqKPxn/RezfEkSRa1UFrSd/LhpkCgCbbtXP00cxsIxsymrcRZwq+GxarmDTW9T/a6+k4NcVKCgCa7MiWXeYoY1DZKfTR+K9Ypp+Gbq0Mj8IVydCtzwSA9RzaOfpoliAbuoPi6hZYkghdXZFL+jwqBOCXPVs2zbEc2dAB9NG0wPKDwsS1vZBRkvb50wSAZ3ZsCX00lTGoXINjBf8FK/8wkcSNu9lBIibgTSEAD3XtHMXV1ZEN10MfDTZSXd3PJKzvbxMdStZ/+/sUADTWiS2hj6Z+ZMPVOgotoKu2FOrPC4c9LVKtxzpU+MXeveU2DYRhGJ7GbTqdhmBwbcc5+MqaqSrUioozbABxz/6XQoMUeQJEJE7szuF9VvHJh/cH4K2Rtr1r4IZbjub9bSQQA3XYPePf50xmokdpYSw8KAQQrEvdokfjHA4q06OJT1qaTpRSdfJEronTmWVmX5kbHz0CwCl6NA2cxDakRxOTtDQnkqlWnWxbqY3MZHUudirZhADi8ELbHhu47Gkbxnw076VAJNLCDE6l4t9ys6/a0ZwiAHTp0RCu9kKkB5XPBeIhKzO0ssPf0LZqKQDAZ/RoPBbbNqRHE5e8NAPLj/nvpeS3YwCem+otnxv4J5ZtOBGIzKzIzJDKzqMwK/iYEID3Xmnbmwb+Cv5oHj2aGC1XlRlOt9fHVcF7YwABGNOjCU6423AsEKV5XlRmGIf/aJLVC54RAgjDtba9bxCM8LYhPZqYzdtjw306LEmjVvlcAEAoJrpFjyZEH8M5mkePJnpzmRTK9KjcN15d1smSPQggLGfa9o0eTbj834b0aLCZhotEKdOH/L/ZxFIlC8kcBBCi17pFjyYGHm/DGwHYpEySWpXmdGqxWypzKUlTAwjXVG+5bxCJ9Tb07GgePRrsMpNysd6HqjJHKdh8ACJ2pVv0aCLk00HlCwHstxDl0jpsXO17IbmQAgDi9UeP5muDOPmwDS/p0eBoc7mNGQgAGxe6RY8GTm9DejQAAPRnoluEq+H00bypAAAAPbnRLXo0cHob0qMBAKA/59r2pQGc3YZnAgAAWOjR4Hncdz6aR48GAADHXWnbQwM4e1D5WgAAgJ6M9ZbbBnB1G9KjAQCgPyNt+/AJONDd3ePbh5/ff+je/WLnDnaaiKIADF8apCEtEHiGyRliTWuNoxFpWBuTbiQE3/9FVDaeWWgC4Q434fue4l/95wUAqGUZ2W0PT7Vd7e6Gf7ShHw0AtG0R2fcemm3DiwIA1HIY2a6HZtvQjwYAqjmLkZsentfVdvdzuI9ncFIAgFqOI7vr4UGLbehHAwBZzR/NtoespTacFwCglllkQw815TbcDT/iUWYFAKhlHn/50TC1m+3mdxv60QDAS1tEdt/DE9Vvw+MCANRyEn/40dCEhzYc/GgAYHIHMbLv4eXtt7e7b4MfDQD8lx8Nr8T+kx8NAEzjNEa+dNCOy8iWBQCoZRbZuw4asvKjAYBpHM0j+9pBO9YxclQAgEoWkQ0dNOSDHw0ATGQZ2fsOGnId2VkBACo5iOz6cwfteBvZYQEAarmIbNVBQz760QDANE5jZN1BO/xoAGAq55FtOmjIJrI3BQAYqfajueygHevI5n40ADDmR8PrcOVHAwC/2LmD1ASCIACAo5iIGJUEnzD0QUWCRMTo/9+VY3oPyW2Hga16SDXyFtmhQj9uz8i2BQAYyd5HQ798NADQyiKy7woduUa2LwDALx8NU+GjAYBWVuJq+nXy0QDA33w0TISPBgBaeYnsq0JHjpG9FwAg8dEwET4aAGhlHdmzQkc+I/soAMBYFpFdKnTkGtmsAAAj2cWAuJqePHw0APAfHw3TcIpsXQCAkbzGwL1CP+4+GgBoZB7ZqUJHjpHNCwCQ+WiYhlv4aACgjXVk1woduUS2KgDAWDY+GvrlowGARmaRPX009OQQ2aYAAJmPhonw0QBAI9sYOFfoxz2yZQEAEh8NU+GjAYBWlpE9KvTjHAPiagAY8NEwET4aAGhlI66mX8/IdgXgh507SkkoiAIAOoUVkSWKSxguopIiiaTuf119dv3QvzcMvHMWcoDMR8M4rCObFABgKIvIzhU68uOjAYC7fDSMxSqyaQEAhjKPbFehIz4aAGjk9S2yVYV++GgA4CEfDeNw9tEAQCNTHw3dOl0j+yoAQDbcR1OhIz4aAGhlEtmhQkeOkS0LAPDPR8NY+GgAoJX3yDYVOrKL7KUAAImPhpH4juzNRwMAg3mJbFuhIxsfDQDc56NhJHw0ANDKUlxNv/aRLQoAkPhoGItjZE8FABjILG6cKvTj4qMBgEd8NIzDNrKPAgAM5DVu/Fboh48GAFp59tHQr01k8wIADGUa2aVCP3w0ANDKh4+Gfh3E1QDQyCSyfYWO+GgAoJFZZFcfDT1ZR/ZZ+GPnjlYhiqIAgJ4RJmFEPuG2r0yRkIg8a8qTNP7/R7zuUePt3HbNWh+yACDz0bAjfDQAMJFFbLgZoI7nyOYNAOhlL7LbAQpZRrbXAIBe5pFdDVDHU/hoAGArHw27wkcDAFM5jex6gEJefTQAMI2Zj4a6riPbbwBAL0eRvQxQyIOPBgC28tGwK64iO2kAQC/n4mrq8tEAwEQOfTTUdRMbDhsA0MlxZB/3UMjSRwMAEzmJ7GuEOj5XkZ01AKCTWWSrEQr58tEAwEQuInsboZB1ZJcNAEg6fjSfI9Rx56MBgIkcRfY9QiEfkR00ACDr99G8jFDHe2RzHw0AdHMQ2eMIhfz4aABgOx8NO+LPR7NoAEAnl5GtRyjERwMAU9n30VDXOrJZAwA6WUS28tFQydJHAwD/8dH8snNvKQkAUQBAJylD7EGtYbiEikUmUrn/dfV7/ehzhgues5DDdThGtm4AQDLwoznsoY6DjwYAJllEtutQyDaylwYAjPIQ2W+HOk5nHw0AzLGO7NihkI/IXhsAMMptZJsOhRx9NAAwx3Nk51OHOjY+GgCYZBXZT4dCdj4aAJhjGRf2Her4juy+AQCjLCJ771DINrJFAwBGuY/srUMdp/DRAMC/fDRci8/IVg0AGOXRR0NdPhoAmOQmsnOHQjaRPTYAYJRVZJ8dCvHRAMAkTz4a6noTVwPAJIvIth0K8dEAwCRLHw117ePCsgEAg6wj23UoxEcDALM8+Gio6xzZcwMABrkRV1PXJrLbBgCM8uqjoa4vHw0AzPEUF04d6vDRAMAsLz4a6nqP7K4B8MfOHaW0FUUBFL0+nkqIJrQ4hMuhaLAiDaJm/uPq7wm0P8V7OTRrjWCPYMOZYT+a9w51PEd260cDAOf8aLgMH340ADDJXWSfHep4O0W2awDAIA9+NNTlRwMAs6yRvXQo5BjZQwMABtlFdvKjoRI/GgCYZeNHQ10HPxoA+LuBP5rnDnX40QDALNeR/exQyFNk3xoAMMpdZD861OFHAwCzbP1oqOslsu8NABhljeyxQyHHyK4aADDI3o+Guj79aABgkk1kHx0KOUS2bQDAIDfhR0NZfjQAMMtiXE1dT5EtDQDI/Gi4DG/hRwMAc2wj+9WhkNfINg0AyPxouBB+NAAwyVVkpw6FPEZ23wCAUTaRvXYoxI8GACbZxRnjaip5j+y2AVyS/fKVtjdVSqhqjex0gEKOka0LwJ9c/5dngv0aX2z515L7AIDf7N1BbsJADAVQJyJBEQEE4gy+/xGronZbCZooGfPeCWb5ZXtsaMGt3mb76zEXN+3mJQAAqzhXS4XjnE/b1wpHmRAAaMctahlyWe/fCu0TAKAdxeYKD7mKR7zMQCEA0JIhSjnkj837xwkA0JA+ShEKAQCEwrjnKrrdxFMAgKVUvnnU5RrmeN0pAQCacay2k+ae37YvFPppAgC0pFj3OGI859P21dRRKgQAWjFFPf2ci5ou8Z6xt78aAGjBXGyg8NelW1D8x7XjMzwG2LFTB/CnYnurAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPhiDw4EAAAAAID8XxtBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVXagwMSAAAAAEH/X7cjUAEAeArE6Ugg3sIAGQAAAABJRU5ErkJggg==";

// src/ui/modals/enriched-modal.ts
var EnrichedModal = class extends import_obsidian20.Modal {
  constructor(app2, enrichButton, code) {
    super(app2);
    this.code = code;
    this.enrichButton = enrichButton;
  }
  onOpen() {
    const enrichedTitle = this.titleEl.createEl("p");
    enrichedTitle.innerText = "This code has already been enriched! \n Are you sure you want to again?";
    const imgRow = this.contentEl.createDiv();
    imgRow.addClass("enrich-img");
    const enrichConfirmImg = imgRow.createEl("img");
    enrichConfirmImg.setAttr(
      "src",
      theme === "dark" ? Robot_Enrich_DM_default : Robot_Enrich_default
    );
    enrichConfirmImg.setAttr("height", "200rem");
    enrichConfirmImg.setAttr("width", "auto");
    const btnRow = this.contentEl.createDiv();
    btnRow.addClass("enrich-btn-row");
    new import_obsidian20.ButtonComponent(btnRow).setButtonText("Yes").setIcon("check").onClick(() => {
      const clickEvent = new Event("click");
      const cache2 = PiecesCacheSingleton.getInstance();
      cache2.setIsEnriched(this.code, false);
      this.enrichButton.buttonEl.dispatchEvent(clickEvent);
      this.close();
    }).setClass("enrich-confirm-btn").setTooltip("Continue enrichment");
    new import_obsidian20.ButtonComponent(btnRow).setButtonText("No").onClick(() => {
      this.close();
    }).setIcon("x").setClass("enrich-deny-btn").setTooltip("Cancel enrichment");
  }
  onClose() {
  }
};

// src/ui/plugins/SaveToPiecesWidget.ts
var SaveToPiecesWidget = class extends import_view.WidgetType {
  // id to the closest match snippet
  constructor({
    codeBlock,
    piecesPreview,
    lang,
    id,
    codeBlockNum,
    disableEnrichment = false,
    relevant
  }) {
    super();
    this.notifications = Notifications.getInstance();
    this.cache = PiecesCacheSingleton.getInstance();
    this.debounceNCS = DebounceNCS.getInstance();
    // if we want to show the enrich button or not
    this.shareableLinks = ShareableLinksService.getInstance();
    this.tempCollapseTimer = void 0;
    this.handleNCS = async (codeBlock) => {
      if (!this.score && !this.identifier) {
        this.debounceNCS.ncsSearch(codeBlock).then((res) => {
          this.score = res?.score ?? 0;
          this.identifier = res?.identifier ?? "";
        });
      }
    };
    this.enrichButton = (container, holderDiv, id) => {
      const enrichBtn = new import_obsidian21.ButtonComponent(container).onClick(async () => {
        const cache2 = PiecesCacheSingleton.getInstance();
        if (cache2.getIsEnriched(this.codeBlock) && pluginSettings.enrich_confirmation) {
          const enrichedModal = new EnrichedModal(
            app,
            enrichBtn,
            this.codeBlock
          );
          enrichedModal.open();
          return;
        }
        const loading = holderDiv.createEl("div");
        loading.addClass("share-code-bouncing-loader");
        loading.createEl("div");
        loading.createEl("div");
        loading.createEl("div");
        container.replaceChild(loading, enrichBtn.buttonEl);
        const draft_seed = await draft_asset({
          text: this.codeBlock
        });
        const links = await AutoLinker.linkCode(this.codeBlock);
        const linksArray = Array.from(links).reverse();
        const titleParent = document.getElementById(
          "placeholder_Div:" + this.codeBlockNum
        )?.parentElement;
        const descParent = holderDiv.parentElement;
        const name314 = draft_seed.asset?.metadata?.name;
        const desc = draft_seed.asset?.metadata?.annotations?.map((el) => el.text).join("\n");
        titleParent?.insertAdjacentHTML(
          "beforebegin",
          `<div><h1>**${name314}**</h1></div>`
        );
        let fileLinks = 0;
        for (let i2 = 0; i2 < linksArray.length; i2++) {
          if (app.workspace.activeEditor?.file?.path === linksArray[i2].path) {
            continue;
          }
          descParent?.insertAdjacentHTML(
            "afterend",
            `<div><p>- [${linksArray[i2].name.slice(0, -3)}](&lt;${linksArray[i2].path}&gt;)</p></div>`
          );
          fileLinks++;
        }
        if (fileLinks != 0) {
          descParent?.insertAdjacentHTML(
            "afterend",
            `<div><p>**Links:**</p></div>`
          );
        }
        descParent?.insertAdjacentHTML(
          "afterend",
          `<div><p>${desc}</p></div><br>`
        );
        descParent?.insertAdjacentHTML(
          "afterend",
          `<div>${draft_seed.asset?.metadata?.tags?.slice(0, 5).map((tag2) => {
            return `<span>#${tag2.text.trim().replace(/ /g, "-")}</span>`;
          }).join(" ")}</div><br>`
        );
        cache2.setIsEnriched(this.codeBlock);
        container.replaceChild(enrichBtn.buttonEl, loading);
        if (id)
          ActivitySingleton.getInstance().referenced(id);
      }).setTooltip("Enrich code snippet").setClass("save-to-pieces-btn").setIcon("sparkles");
    };
    this.expandButton = (container, ID) => {
      const expandButton = new import_obsidian21.ButtonComponent(container).onClick(async () => {
        if (!ID) {
          this.notifications.error({
            message: Constants.EXPAND_ERROR
          });
          return;
        }
        DisplayController.createExpandedView({
          snippetId: ID,
          snippetTitle: this.cache.mappedAssets[ID ?? ""].title || ""
        });
        ActivitySingleton.getInstance().referenced(ID);
      }).setTooltip("Expand via Pieces").setClass("save-to-pieces-btn").setIcon("expand");
      return expandButton;
    };
    this.shareButton = (container, holderDiv) => {
      const shareButton = new import_obsidian21.ButtonComponent(container).onClick(async () => {
        const loading = holderDiv.createEl("div");
        loading.addClass("share-code-bouncing-loader");
        loading.createEl("div");
        loading.createEl("div");
        loading.createEl("div");
        container.replaceChild(loading, shareButton.buttonEl);
        if (this.id) {
          const existingLink = this.cache.mappedAssets[this.id].share;
          const link = existingLink ?? await this.shareableLinks.generate({
            id: this.id
          });
          copyToClipboard(link ?? "");
          if (existingLink) {
            this.notifications.information({
              message: Constants.LINK_GEN_COPY
            });
          }
        } else {
          if (this.score > 0.97) {
            const existingLink = this.cache.mappedAssets[this.identifier].share;
            const link = existingLink ?? await this.shareableLinks.generate({
              id: this.identifier
            });
            copyToClipboard(link ?? "");
            if (existingLink) {
              this.notifications.information({
                message: Constants.LINK_GEN_COPY
              });
            }
          } else {
            const id = await createAsset({ selection: this.codeBlock });
            if (typeof id === "string") {
              const link = await this.shareableLinks.generate({
                id
              });
              copyToClipboard(link ?? "");
            }
          }
        }
        container.replaceChild(shareButton.buttonEl, loading);
      }).setTooltip("Share via Pieces").setClass("save-to-pieces-btn").setIcon("share-2");
      return shareButton;
    };
    this.copyButton = (container, id) => {
      const copyButton = new import_obsidian21.ButtonComponent(container).onClick(async () => {
        let codeBlock;
        if (this.lang && this.codeBlock && this.codeBlock.substring(0, 3) !== "```\n") {
          codeBlock = "```" + this.lang + "\n" + this.codeBlock + "```";
        }
        copyToClipboard(codeBlock ?? this.codeRaw);
        new import_obsidian21.Notice("Snippet copied to clipboard!");
        if (id)
          ActivitySingleton.getInstance().referenced(id, void 0, true);
      }).setTooltip("Copy code to clipboard").setClass("save-to-pieces-btn").setIcon("copy");
      return copyButton;
    };
    this.editButton = (container, id) => {
      new import_obsidian21.ButtonComponent(container).setIcon("pencil").setTooltip("Edit snippet").onClick(async () => {
        new EditModal(
          app,
          PiecesCacheSingleton.getInstance().mappedAssets[id]
        ).open();
      }).setClass("button");
    };
    this.annotationsButton = (container, id) => {
      new import_obsidian21.ButtonComponent(container).setIcon("sticky-note").setTooltip("Edit annotations").onClick(async () => {
        new AnnotationsModal(
          app,
          PiecesCacheSingleton.getInstance().mappedAssets[id]
        ).open();
      }).setClass("button");
    };
    this.saveButton = (container, holderDiv, relevant) => {
      const saveButton = new import_obsidian21.ButtonComponent(container).onClick(async () => {
        const loading = holderDiv.createEl("div");
        loading.addClass("share-code-bouncing-loader");
        loading.createEl("div");
        loading.createEl("div");
        loading.createEl("div");
        container.replaceChild(loading, saveButton.buttonEl);
        const anchors = relevant?.reduce((ret, el) => {
          if (el.path) {
            ret.push(el.path);
          }
          return ret;
        }, []).slice(0, 3);
        const id = await createAsset({
          selection: this.codeBlock,
          lang: this.lang,
          anchors
        });
        if (pluginSettings.autoOpen && !app.workspace.getLeavesOfType(
          Constants.PIECES_SNIPPET_LIST_VIEW_TYPE
        ).length) {
          await app.workspace.getRightLeaf(false)?.setViewState({
            type: Constants.PIECES_SNIPPET_LIST_VIEW_TYPE,
            active: true
          });
          app.workspace.revealLeaf(
            app.workspace.getLeavesOfType(
              Constants.PIECES_SNIPPET_LIST_VIEW_TYPE
            )[0]
          );
        }
        if (id !== void 0) {
          const expand = this.expandButton(container, id);
          container.replaceChild(expand.buttonEl, loading);
          this.debounceNCS.saveCodeToExpand(this.codeBlock, id);
          this.score = 1;
          this.identifier = id;
        } else {
          loading.remove();
          const computedWidth = 46 * container.childElementCount;
          container.style.width = computedWidth + "px";
        }
      }).setTooltip("Save code to Pieces").setClass("save-to-pieces-btn").setIcon("save");
    };
    this.codeBlock = codeBlock;
    this.piecesPreview = piecesPreview;
    this.lang = lang;
    this.id = id;
    this.codeBlockNum = codeBlockNum;
    this.disableEnrichment = disableEnrichment;
    this.relevant = relevant;
  }
  toDOM() {
    const holderDiv = document.createElement("div");
    holderDiv.addClass("save-to-pieces-holder");
    if (this.codeBlock.length < 5) {
      return holderDiv;
    }
    this.handleNCS(this.codeBlock);
    const { id } = this;
    const collapsedHolder = holderDiv.createDiv();
    collapsedHolder.addClasses(["p-collapsed-pieces-holder", "collapsed"]);
    const collapseControlButton = new import_obsidian21.ButtonComponent(holderDiv).onClick(async () => {
      clearTimeout(this.tempCollapseTimer);
      if (collapsedHolder.classList.contains("collapsed")) {
        if (!this.piecesPreview) {
          this.copyButton(collapsedHolder, id ?? this.identifier);
          if (!this.disableEnrichment) {
            this.enrichButton(
              collapsedHolder,
              holderDiv,
              id ?? this.identifier
            );
          }
          if (id && this.cache.mappedAssets[id]) {
            this.expandButton(collapsedHolder, id);
          } else if (this.score > 0.97 && this.identifier && this.cache.mappedAssets[this.identifier]) {
            this.expandButton(collapsedHolder, id ?? this.identifier);
            this.editButton(collapsedHolder, id ?? this.identifier);
            this.annotationsButton(collapsedHolder, id ?? this.identifier);
          } else {
            this.saveButton(collapsedHolder, holderDiv, this.relevant);
          }
        } else {
          this.copyButton(collapsedHolder, id ?? this.identifier);
          this.editButton(collapsedHolder, id ?? this.identifier);
          this.annotationsButton(collapsedHolder, id ?? this.identifier);
        }
        this.shareButton(collapsedHolder, holderDiv);
        collapsedHolder.classList.remove("collapsed");
        const computedWidth = 46 * collapsedHolder.childElementCount;
        collapsedHolder.style.width = computedWidth + "px";
        this.tempCollapseTimer = setTimeout(() => {
          this.tempCollapseTimer = void 0;
          collapsedHolder.classList.add("expanded");
        }, 500);
        collapseControlButton.setTooltip("Hide Pieces actions");
      } else {
        collapsedHolder.classList.remove("expanded");
        collapsedHolder.classList.add("collapsed");
        collapsedHolder.style.width = "";
        collapseControlButton.setDisabled(true);
        this.tempCollapseTimer = setTimeout(() => {
          this.tempCollapseTimer = void 0;
          collapsedHolder.innerHTML = "";
          collapseControlButton.setDisabled(false);
        }, 500);
        collapseControlButton.setTooltip("See Pieces actions");
      }
    }).setTooltip("See Pieces actions").setClass("save-to-pieces-btn");
    const svgElement = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "svg"
    );
    svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg");
    svgElement.setAttribute("width", "20");
    svgElement.setAttribute("height", "20");
    const pathElement = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "path"
    );
    pathElement.setAttribute("d", Constants.PIECES_LOGO_ALT);
    pathElement.setAttribute("fill", "currentColor");
    pathElement.setAttribute("stroke", "none");
    pathElement.setAttribute("fill-rule", "nonzero");
    pathElement.setAttribute("fill-opacity", "1");
    svgElement.appendChild(pathElement);
    collapseControlButton.buttonEl.innerHTML = svgElement.outerHTML;
    holderDiv.appendChild(collapsedHolder);
    const children = Array.from(holderDiv.children);
    children.reverse();
    holderDiv.innerHTML = "";
    children.forEach((child) => holderDiv.appendChild(child));
    return holderDiv;
  }
};
var PlaceHolderWidget = class extends import_view.WidgetType {
  constructor(idNum) {
    super();
    this.idNum = idNum;
  }
  toDOM(view) {
    const holderDiv = document.createElement("div");
    holderDiv.id = "placeholder_Div:" + this.idNum;
    holderDiv.style.cssText = "height: 0px; margin-top: -9px;";
    return holderDiv;
  }
};

// src/ui/plugins/CodeDetectionPlugin.ts
var CodeDetectionPlugin = class {
  constructor(view) {
    this.connection = ConnectorSingleton.getInstance();
    this.codeViewProps = {
      inCode: false,
      isPiecesExpand: false,
      premoExit: true,
      lang: void 0,
      id: void 0
    };
    this.decorations = this.buildDecorations(view);
  }
  update(update2) {
    if (update2.docChanged || update2.viewportChanged) {
      this.decorations = this.buildDecorations(update2.view);
    }
  }
  destroy() {
  }
  /*
         This iterates over the current editor view
           - finds the code blocks
           - keeps track of the code written within the blocks
           - appends an 'add to pieces' widget at the end of each code block
     */
  buildDecorations(view) {
    const builder = new import_state.RangeSetBuilder();
    let codeText = "";
    let codeBlockNum = v4_default();
    for (const { from, to: to2 } of view.visibleRanges) {
      (0, import_language.syntaxTree)(view.state).iterate({
        from,
        to: to2,
        enter: function(node) {
          if (!node.type.name.includes("codeblock")) {
            this.codeViewProps.inCode = false;
          }
          if (this.codeViewProps.inCode && node.type.name.endsWith("codeblock-bg")) {
            codeText += view.state.sliceDoc(node.from, node.to) + "\n";
          }
          if (node.type.name.includes("codeblock-begin")) {
            const langText = view.state.sliceDoc(node.from, node.to);
            let lang = langText.slice(3);
            lang = lang.split(":");
            this.codeViewProps.id = void 0;
            if (lang[1]) {
              this.codeViewProps.id = lang[1];
            }
            this.codeViewProps.lang = lang[0];
            this.codeViewProps.inCode = true;
            this.codeViewProps.premoExit = false;
            const listCharFrom = node.from;
            builder.add(
              listCharFrom,
              listCharFrom,
              import_view2.Decoration.widget({
                widget: new PlaceHolderWidget(codeBlockNum),
                side: 1
              })
            );
            const spanButtons = Array.from(
              document.getElementsByClassName("code-block-flair")
            );
            spanButtons.forEach((spanButton) => {
              if (spanButton.classList.length === 1 && spanButton.classList[0] === "code-block-flair") {
                spanButton.onclick = () => {
                  const intention = {
                    application: this.connection.context.application.id,
                    seededConnectorAsset: {
                      format: {
                        fragment: {
                          string: {
                            raw: codeText
                          },
                          metadata: {
                            ext: SearchLangToClassificationEnum[spanButton.innerText]
                          }
                        }
                      }
                    }
                  };
                  try {
                    this.connection.api.intention(intention);
                  } catch (e3) {
                    console.log("Pieces: Intent error", e3);
                  }
                };
              }
              if (spanButton.classList.length === 1) {
                spanButton.addClass("listening");
              }
            });
          }
          if (node.type.name.includes("header-5") && view.state.sliceDoc(node.from, node.to).includes("Pieces Preview:")) {
            this.codeViewProps.isPiecesExpand = true;
          }
          if (node.type.name.includes("codeblock-end") && this.codeViewProps.inCode) {
            const listCharFrom = node.from;
            this.codeViewProps.inCode = false;
            builder.add(
              listCharFrom + 3,
              listCharFrom + 3,
              import_view2.Decoration.widget({
                widget: new SaveToPiecesWidget({
                  codeBlock: codeText,
                  piecesPreview: this.codeViewProps.isPiecesExpand,
                  lang: this.codeViewProps.lang,
                  id: this.codeViewProps.id,
                  codeBlockNum
                }),
                side: 1
              })
            );
            codeBlockNum = v4_default();
            codeText = "";
            this.codeViewProps.isPiecesExpand = false;
          }
        }.bind(this)
      });
    }
    return builder.finish();
  }
};
var pluginSpec = {
  decorations: (value) => value.decorations
};
var codeDetectionPlugin = import_view2.ViewPlugin.fromClass(
  CodeDetectionPlugin,
  pluginSpec
);

// assets/onboarding/saveWithShortcut.png
var saveWithShortcut_default = "data:image/png;base64,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";

// assets/onboarding/keyboardShortcuts.png
var keyboardShortcuts_default = "data:image/png;base64,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";

// src/ui/views/pieces-onboarding.ts
var heroLink = "https://youtu.be/rWm_VMOhaNk";
var supercutLink = "https://youtu.be/5atxB5RRUvI";
var RIGHT_CLICK_SAVE = "https://storage.googleapis.com/pieces_multimedia/PROMOTIONAL/PIECES_FOR_DEVELOPERS/OBSIDIAN/MACOS/RIGHT_CLICK_SAVE/16X9/PIECES_FOR_DEVELOPERS-OBSIDIAN-RIGHT_CLICK_SAVE-MACOS-16X9-6_22_2023.gif";
var EMBEDDED_BUTTON_SAVE = "https://storage.googleapis.com/pieces_multimedia/PROMOTIONAL/PIECES_FOR_DEVELOPERS/OBSIDIAN/MACOS/EMBEDDED_BUTTON_SAVE/16X9/PIECES_FOR_DEVELOPERS-OBSIDIAN-EMBEDDED_BUTTON_SAVE-MACOS-16X9-6_22_2023.gif";
var SEARCH = "https://storage.googleapis.com/pieces_multimedia/PROMOTIONAL/PIECES_FOR_DEVELOPERS/OBSIDIAN/MACOS/SEARCH/16X9/PIECES_FOR_DEVELOPERS-OBSIDIAN-SEARCH-MACOS-16X9-6_22_2023.gif";
var SHARE = "https://storage.googleapis.com/pieces_multimedia/PROMOTIONAL/PIECES_FOR_DEVELOPERS/OBSIDIAN/MACOS/SHARE/16X9/PIECES_FOR_DEVELOPERS-OBSIDIAN-SHARE-MACOS-16X9-6_22_2023.gif";
var DISCOVERY = "https://storage.googleapis.com/pieces_multimedia/PROMOTIONAL/PIECES_FOR_DEVELOPERS/OBSIDIAN/MACOS/DISCOVERY/16X9/PIECES_FOR_DEVELOPERS-OBSIDIAN-DISCOVERY-MACOS-16X9-7_17_2023.png";
var COPILOT = "https://storage.googleapis.com/pieces_multimedia/PROMOTIONAL/PIECES_FOR_DEVELOPERS/OBSIDIAN/MACOS/COPILOT/16X9/PIECES_FOR_DEVELOPERS-OBSIDIAN-COPILOT-MACOS-16X9-7_17_2023.gif";
var onboardingMD = `<a href="https://docs.pieces.app/extensions-plugins/obsidian" style="display: inline-block; text-decoration: none; border-radius: 4px;">Docs</a>		<a href="https://pieces.app" style="display: inline-block; text-decoration: none; border-radius: 4px;">Learn More</a>

### Elevate your Obsidian experience with Pieces

![Pieces for Developers Obsidian Plugin Video](${heroLink})

## Your Guide to Getting Started with Pieces for Developers Obsidian Plugin

**Pre Requisites**
- Make sure to install Pieces OS. Pieces OS is the core dependency for all of Pieces' applications, including the Pieces for Developers Obsidian plugin. This is what allows all of our ML processing to run on your own device, and serves as your own centralized knowledge database.
- (optional) Install the Pieces for Developers Desktop App for the full experience utilizing all of Pieces for Developers' AI features, further boosting your productivity.

#### 1. Save your first snippet
- To save a snippet, highlight the text, right-click, and select "Save to Pieces."
![Save with Right Click](${RIGHT_CLICK_SAVE})

**Additional ways to save**
- Click the Pieces Save button within any code block.
![Save to Pieces via Button](${EMBEDDED_BUTTON_SAVE})


- Highlight the desired code and use our dedicated keyboard shortcuts
![Keyboard Shortcuts](` + keyboardShortcuts_default + `)
![Save to Pieces via Shortcut](` + saveWithShortcut_default + `)


#### 2. Find & use your snippets
- To access your saved snippets, click on the Pieces icon in your left sidebar
![Search Your Pieces](${SEARCH})


#### 3. Share your Snippets
- Collaborate with others with ease using shareable links for your snippets
![Share you Snippets](${SHARE})


#### 4. Discover new Snippets
- Automatically find highly relevant and reuable snippets
![Share you Snippets](${DISCOVERY})


#### 5. Enrich your code blocks
- Automatically generate tags, titles, descriptions, and links to other similar code snippets with the simple press of a button!
- Just click on the 'P' button embedded in your code blocks, and click on the enrich icon!


#### 6. Hack your brain with the Copilot
- Interact with a Copilot grounded on the contents of your vault
- Select which files you would like to use as context
- Available in both Cloud and Local LLM runtimes (i.e GPT and Llama2)
- Suggested queries automatically generated
- Quickly reach relevant notes
![Pieces Copilot](${COPILOT})


### Maximize productivity with our Flagship Desktop App
Utilize the Pieces [Flagship Desktop App](https://pieces.app) in combination with our Obsidian Plugin to streamline your workflow and enhance your development productivity.

- Get back in flow with our Workflow Activity View
- Save time with In-Project Snippet Discovery
- Enjoy real-time and scope-relevant suggestions
- Extract and use code and text from screenshots

![Watch on YouTube](${supercutLink})


### Socials

<a href="https://discord.gg/GkmyfqWf3W" style="display: inline-block; text-decoration: none; border-radius: 4px;">Discord</a>		<a href="https://www.youtube.com/@getpieces" style="display: inline-block; text-decoration: none; border-radius: 4px;">YouTube</a>		<a href="https://twitter.com/@getpieces" style="display: inline-block; text-decoration: none; border-radius: 4px;">Twitter</a>		<a href="https://www.linkedin.com/company/getpieces" style="display: inline-block; text-decoration: none; border-radius: 4px;">LinkedIn</a>		<a href="https://www.facebook.com/getpieces" style="display: inline-block; text-decoration: none; border-radius: 4px;">Facebook</a>
`;

// src/connection/DedupeAssetQueue.ts
var DedupeAssetQueue = class {
  constructor() {
    this.idMap = {};
    this.inFetch = false;
    this.batchSize = 15;
  }
  push(id) {
    this.idMap[id] = true;
    if (!this.inFetch)
      this.doFetch();
  }
  async doFetch() {
    const cache2 = PiecesCacheSingleton.getInstance();
    const config5 = ConnectorSingleton.getInstance();
    this.inFetch = true;
    let IDs = Object.keys(this.idMap);
    while (IDs.length) {
      for (let i2 = 0; i2 < IDs.length; i2 += this.batchSize) {
        const batch = IDs.slice(i2, i2 + this.batchSize).map((id) => {
          delete this.idMap[id];
          return config5.assetApi.assetSnapshot({
            asset: id,
            transferables: false
          });
        });
        const assets = await Promise.all(batch).catch((e3) => {
          console.error(
            `Error fetching asset: ${JSON.stringify(e3, void 0, 2)}`
          );
          return null;
        });
        if (!assets)
          continue;
        const formatRequests = assets.map((asset) => asset.formats.iterable ?? []).flat().map(
          (format5) => config5.formatApi.formatSnapshot({
            format: format5.id,
            transferable: true
          })
        );
        const formats = await Promise.all(formatRequests).catch((e3) => {
          console.error(
            `Error fetching format: ${JSON.stringify(e3, void 0, 2)}`
          );
          return null;
        });
        if (!formats)
          continue;
        formats.forEach((format5) => {
          cache2.fetchedFormats[format5.id] = new Date();
          cache2.formatTransferables[format5.id] = {
            file: format5.file,
            fragment: format5.fragment
          };
        });
        const mergedAssets = mergeAssetsWithTransferables({
          assets: { iterable: assets },
          references: cache2.formatTransferables
        });
        renderFetched({ assets: mergedAssets });
      }
      IDs = Object.keys(this.idMap);
    }
    this.inFetch = false;
  }
};

// src/connection/CheckVersionAndConnection.ts
var CheckVersionAndConnection = class {
  constructor() {
  }
  static run() {
    if (this.promise === void 0) {
      this.promise = this._run();
    }
    return this.promise;
  }
  /*
         This will recursively call itself until BOTH POS is open AND POS has a proper version
          - also makes sure to update ui when fetchFailed changes
     */
  static async _run() {
    const posOpen = await loadConnect();
    await versionCheck({});
    if (posOpen && versionValid) {
      this.promise = void 0;
      return;
    }
    if (posOpen === DisplayController.fetchFailed) {
      DisplayController.fetchFailed = !posOpen;
      DisplayController.triggerUIRedraw({ searching: false, fetch: false });
    }
    await sleep(waitTimer);
    setStreamOpen(false);
    return this._run();
  }
};
CheckVersionAndConnection.promise = void 0;

// src/connection/stream_assets.ts
var identifierWs;
var cache = PiecesCacheSingleton.getInstance();
var fetchQueue = new DedupeAssetQueue();
var streamOpen = false;
var setStreamOpen = (val) => {
  streamOpen = val;
};
var waitTimer = 1e4;
var stream = async () => {
  streamIdentifiers();
};
var streamEnd = false;
var streamIdentifiers = async () => {
  if (streamOpen) {
    return;
  }
  streamOpen = true;
  streamEnd = false;
  if (identifierWs?.readyState === identifierWs?.OPEN) {
    identifierWs?.close();
  }
  identifierWs = new WebSocket(
    `ws://localhost:${portNumber}/assets/stream/identifiers`
  );
  identifierWs.onclose = async () => {
    if (streamEnd) {
      return;
    }
    DisplayController.fetchFailed = true;
    DisplayController.triggerUIRedraw({ searching: false, fetch: false });
    streamOpen = false;
    await sleep(15e3);
    CheckVersionAndConnection.run().then(() => {
      streamIdentifiers();
    });
  };
  identifierWs.onopen = () => {
    if (DisplayController.fetchFailed) {
      DisplayController.fetchFailed = false;
      DisplayController.triggerUIRedraw({ searching: false, fetch: false });
    }
    PiecesDatabase.clearStaleIds();
  };
  identifierWs.onmessage = async (event) => {
    const assets = JSON.parse(event.data);
    let asset;
    for (let i2 = 0; i2 < assets.iterable.length; i2++) {
      asset = assets.iterable[i2];
      const snippetEl = document.getElementById(`list-view-${asset.asset.id}`);
      if (asset.deleted) {
        snippetEl?.remove();
        const removedAsset = cache.mappedAssets[asset.asset.id];
        const removalMap = cache.snippetMap.get(removedAsset.language);
        if (removalMap !== void 0) {
          if (removalMap.length !== 0) {
            removalMap.forEach((snippetId) => {
              if (snippetId === removedAsset.id) {
                removalMap.splice(removalMap.indexOf(snippetId), 1);
              }
            });
          }
          if (removalMap.length === 0) {
            cache.snippetMap.delete(removedAsset.language);
          } else {
            cache.snippetMap.set(removedAsset.language, removalMap);
          }
        }
        delete cache.mappedAssets[asset.asset.id];
        cache.assets = Object.values(cache.mappedAssets);
        PiecesDatabase.writeData();
        if (!cache.assets.length) {
          if (DisplayController.defaultView !== "discovery" /* DISCOVERY */) {
            DisplayController.defaultView = "newest" /* RECENT */;
          }
          DisplayController.triggerUIRedraw({ searching: false, fetch: false });
        } else if (DisplayController.defaultView === "language") {
          langReset();
        }
        return;
      }
      fetchQueue.push(assets.iterable[i2].asset.id);
    }
  };
};
var renderFetched = async ({ assets }) => {
  const config5 = ConnectorSingleton.getInstance();
  const loadingDivs = document.querySelectorAll(".loading-div");
  if (DisplayController.defaultView !== "discovery" /* DISCOVERY */) {
    loadingDivs.forEach((loadingDiv) => {
      loadingDiv.remove();
    });
  }
  const newDivs = document.querySelectorAll(".new-div");
  newDivs.forEach((newDiv) => {
    newDiv.remove();
  });
  if (newDivs.length || loadingDivs.length) {
    const onlyDiv = document.querySelectorAll(".only-snippet");
    onlyDiv.forEach((el) => {
      el.remove();
    });
  }
  for (const element of assets.iterable) {
    const cachedAsset = cache.mappedAssets[element.id];
    let processed = processAsset({ asset: element });
    const annotationsReqs = Object.keys(element.annotations?.indices ?? {}).filter((key) => (element.annotations?.indices ?? {})[key] !== -1).map(
      (annotation) => config5.annotationApi.annotationSpecificAnnotationSnapshot({
        annotation
      })
    );
    const annotations = Promise.all(annotationsReqs).catch((e3) => {
      console.error(e3);
      return [];
    });
    if (!cachedAsset) {
      cache.prependAsset({ asset: element });
      cache.storeAnnotations(await annotations, element.id);
      processed = processAsset({ asset: element });
      const languageSnippets = cache.snippetMap.get(processed.language);
      if (!languageSnippets) {
        cache.snippetMap.set(processed.language, [processed.id]);
      } else {
        languageSnippets.unshift(processed.id);
        cache.snippetMap.set(processed.language, languageSnippets);
      }
      if (DisplayController.defaultView === "newest" /* RECENT */) {
        const parentEl = document.getElementById(
          "pieces-snippet-container"
        );
        const sortedAssets = cache.assets.sort(
          (a, b) => b.created.getTime() - a.created.getTime()
        );
        const newIndex = sortedAssets.findIndex(
          (asset) => asset.created.getTime() < processed.created.getTime()
        );
        const newElement = renderListView({
          contentEl: parentEl,
          snippetObject: processed
        });
        if (newIndex === -1) {
          parentEl.appendChild(newElement);
        } else {
          parentEl.insertBefore(newElement, parentEl.children[newIndex - 1]);
        }
      } else if (DisplayController.defaultView === "language" /* LANGUAGE */) {
        langReset();
      }
    } else if (!AnnotationHandler.getInstance().annotationsAreEqual(
      cachedAsset.annotations ?? [],
      await annotations
    ) || processed.raw !== cachedAsset.raw || processed.title !== cachedAsset.title || processed.language !== cachedAsset.language || processed.share !== cachedAsset.share) {
      cache.storeAnnotations(await annotations, element.id);
      processed = processAsset({ asset: element });
      if (processed.language !== cachedAsset.language) {
        const oldMapKeyValues = cache.snippetMap.get(cachedAsset.language);
        oldMapKeyValues?.forEach((value, i2) => {
          if (value === processed.id) {
            oldMapKeyValues.splice(i2, 1);
            if (oldMapKeyValues.length === 0) {
              cache.snippetMap.delete(cachedAsset.language);
            } else {
              cache.snippetMap.set(cachedAsset.language, oldMapKeyValues);
            }
          }
        });
        const newMapkeyValues = cache.snippetMap.get(processed.language) || [];
        newMapkeyValues.unshift(processed.id);
        cache.snippetMap.set(processed.language, newMapkeyValues);
      }
      cache.updateAsset({ asset: element });
      let parentEl;
      if (DisplayController.defaultView === "newest" /* RECENT */) {
        parentEl = document.getElementById(
          "pieces-snippet-container"
        );
      } else if (DisplayController.defaultView === "language" /* LANGUAGE */) {
        if (processed.language === cachedAsset.language) {
          parentEl = document.getElementById(
            "code-view-" + searchLangSpecificEnum[processed.language]
          ).lastChild;
        } else {
          langReset();
          return;
        }
      }
      if (!parentEl)
        return;
      const snippetEl = document.getElementById(`list-view-${element.id}`);
      const opened = snippetEl?.children[0].lastChild?.checked;
      snippetEl?.replaceWith(
        renderListView({
          contentEl: parentEl,
          snippetObject: processed,
          opened
        })
      );
    }
  }
  PiecesDatabase.writeData();
};
var closeStreams = async () => {
  streamEnd = true;
  identifierWs?.close();
};
var langReset = async () => {
  const openLangs = [];
  const langContainers = Array.from(
    document.getElementById("language-snippet-container").children
  );
  langContainers.forEach((langContainer) => {
    if (langContainer.firstChild?.childNodes[2]?.checked) {
      const desiredLang = langContainer.id.split("-")[2];
      openLangs.push(desiredLang);
    }
  });
  const snippets = cache.assets;
  DisplayController.createSnippetListView({
    containerVar: document.getElementById("snippets-tab"),
    snippets,
    viewType: "language" /* LANGUAGE */
  });
  openLangs.forEach((lang) => {
    try {
      const snippetContentParent = document.getElementById("input-" + lang);
      snippetContentParent.checked = true;
      const clickEvent = new Event("click");
      snippetContentParent?.dispatchEvent(clickEvent);
    } catch (e3) {
    }
  });
};

// src/actions/suggestion.ts
async function suggestion(e3) {
  try {
    const config5 = ConnectorSingleton.getInstance();
    const clipboard = e3.clipboardData;
    if (clipboard) {
      const clipboardData = clipboard.getData("text/plain").trim();
      if (!clipboardData.length) {
        return;
      }
      const activeFile = app.workspace.getActiveFile();
      const basePath = app.vault.adapter.basePath;
      const filePath = basePath + "/" + activeFile?.path;
      const suggestion2 = {
        application: config5.context.application.id,
        seededConnectorCreation: {
          asset: {
            format: {
              fragment: {
                string: {
                  raw: clipboardData
                }
              }
            }
          }
        }
      };
      if (activeFile) {
        suggestion2.seededConnectorCreation.asset.metadata = {
          anchors: [
            {
              fullpath: filePath,
              type: AnchorTypeEnum.File
            }
          ]
        };
      }
      await config5.api.suggest(suggestion2).then((res) => {
      }).catch((e4) => {
      });
    }
  } catch {
  }
}

// src/actions/qgpt.ts
var QGPT = class {
  constructor() {
  }
  static getLoadedAllFiles() {
    return this.loadedAllFiles;
  }
  static getLoadCount() {
    return this.loadCount;
  }
  static getQGPTFilesLength() {
    return this.qgptFilesLength;
  }
  /*
  This function will call /relevance in order to preload the embeddings for files in user's vault
   - If this is called again before the first execution finishes, it will 
  */
  static async loadContext() {
    this.loadedAllFiles = false;
    if (this.cancelLoading) {
      return;
    }
    if (this.loadingPromise !== void 0) {
      this.cancelLoading = true;
      await this.loadingPromise;
      this.cancelLoading = false;
    }
    const cache2 = PiecesCacheSingleton.getInstance();
    const config5 = ConnectorSingleton.getInstance();
    const { vault } = app;
    const MAX_PATHS_PER_REQUEST = 8;
    const files = cache2.gptContextPaths;
    this.loadCount = 0;
    this.qgptFilesLength = files.length;
    const basePath = vault.adapter.basePath;
    const contextLoader = async () => {
      while (this.loadCount < this.qgptFilesLength && !this.cancelLoading) {
        const startTime = performance.now();
        this.loadCount = Math.min(
          this.loadCount + MAX_PATHS_PER_REQUEST,
          files.length
        );
        const cur_paths = files.slice(this.loadCount - MAX_PATHS_PER_REQUEST, this.loadCount).filter((file) => {
          return this.loadedFiles[file] === void 0;
        }).map((file) => {
          return basePath + "/" + file;
        });
        const relevanceInput = {
          qGPTRelevanceInput: {
            query: "nothing",
            paths: cur_paths
          }
        };
        await config5.QGPTApi.relevance(relevanceInput);
        cur_paths.forEach((path) => {
          this.loadedFiles[path] = true;
        });
        const endTime = performance.now();
        await sleep(endTime - startTime);
      }
    };
    this.loadingPromise = contextLoader();
    this.loadedAllFiles = true;
  }
  static async askQuestion({
    query,
    relevant
  }) {
    const config5 = ConnectorSingleton.getInstance();
    const params = {
      query,
      relevant: {
        iterable: [
          {
            seed: {
              type: SeedTypeEnum.Asset,
              asset: {
                application: config5.context.application,
                format: {
                  fragment: {
                    string: {
                      raw: relevant
                    }
                  }
                }
              }
            }
          }
        ]
      }
    };
    const result = await config5.QGPTApi.question({ qGPTQuestionInput: params });
    return { result, query };
  }
  /*
  	This will go to relevance with question: true in order to query GPT
  	- returns the query as well as the result from /relevance
  	- it's necessary to return the query as this is called by the reprompt function
  	- so in that case we need to send the query back to the view
  */
  static async askQGPT({ query }) {
    const config5 = ConnectorSingleton.getInstance();
    const cache2 = PiecesCacheSingleton.getInstance();
    const { vault } = app;
    const files = cache2.gptContextPaths;
    const basePath = vault.adapter.basePath;
    const filePaths = files.map((file) => {
      return basePath + "/" + file;
    }).filter((file) => {
      return this.loadedFiles[file];
    });
    const relevanceInput = {
      query,
      paths: filePaths,
      options: {
        question: true
      }
    };
    const params = {
      qGPTRelevanceInput: relevanceInput
    };
    return {
      result: await config5.QGPTApi.relevance(params),
      query
    };
  }
  /*
  	Calls reprompt in order to generate a prompt
  	- uses the generated prompt to return the response from /relevance
  */
  static async reprompt({
    conversation,
    query
  }) {
    const reversedConv = conversation.reverse();
    const config5 = ConnectorSingleton.getInstance();
    const repromptRes = await config5.QGPTApi.reprompt({
      qGPTRepromptInput: {
        query,
        conversation: {
          iterable: reversedConv
        }
      }
    });
    return repromptRes;
  }
  /*
  	Calls the /hint api
  */
  static async hints({
    relevant,
    answer,
    query
  }) {
    const config5 = ConnectorSingleton.getInstance();
    return config5.QGPTApi.hints({
      qGPTHintsInput: {
        relevant,
        answer,
        query
      }
    });
  }
};
QGPT.loadedFiles = {};
QGPT.loadingPromise = void 0;
QGPT.cancelLoading = false;
QGPT.loadCount = 0;
QGPT.qgptFilesLength = 0;
QGPT.loadedAllFiles = true;
QGPT.allFilesAsContext = () => {
  const cache2 = PiecesCacheSingleton.getInstance();
  const files = app.vault.getMarkdownFiles();
  const paths = [];
  const folders = [];
  files.forEach((file) => {
    if (file.stat.size > 1e5) {
      return;
    }
    paths.push(file.path);
    if (file.parent !== null && !folders.includes(file.parent.path))
      folders.push(file.parent.name);
  });
  cache2.gptFolderNames = folders;
  cache2.gptContextPaths = paths;
};

// src/utils/levenshteinMethods.ts
var truncateAfterNewline = (str) => {
  const newlineIndex = str.indexOf("\n");
  if (newlineIndex !== -1) {
    return str.substring(0, newlineIndex);
  } else {
    return str;
  }
};
var calculateLevenshteinDistance = (str1, str2) => {
  const m = str1.length;
  const n = str2.length;
  if (Math.abs(m - n) > 2) {
    return Infinity;
  }
  const dp = [];
  for (let i2 = 0; i2 <= m; i2++) {
    dp[i2] = [i2];
  }
  for (let j = 1; j <= n; j++) {
    dp[0][j] = j;
  }
  for (let i2 = 1; i2 <= m; i2++) {
    for (let j = 1; j <= n; j++) {
      if (str1[i2 - 1] === str2[j - 1]) {
        dp[i2][j] = dp[i2 - 1][j - 1];
      } else {
        dp[i2][j] = Math.min(
          dp[i2 - 1][j] + 1,
          // deletion
          dp[i2][j - 1] + 1,
          // insertion
          dp[i2 - 1][j - 1] + 1
          // substitution
        );
      }
    }
  }
  return dp[m][n];
};
var findSimilarity = async (codeBlock) => {
  const config5 = ConnectorSingleton.getInstance();
  const cache2 = PiecesCacheSingleton.getInstance();
  let comparisonScore = Infinity;
  let comparisonID = "";
  const rawCode = {
    query: truncateAfterNewline(codeBlock)
  };
  const result = config5.searchApi.fullTextSearch(rawCode);
  const assetArray = [];
  await result.then(async (res) => {
    res.iterable.forEach((element) => {
      assetArray.push(cache2.mappedAssets[element.identifier]);
    });
    const returnedSnippets = assetArray;
    returnedSnippets.forEach((element) => {
      try {
        const currentCompScore = calculateLevenshteinDistance(
          codeBlock,
          element.raw
        );
        if (currentCompScore < comparisonScore) {
          comparisonScore = currentCompScore;
          comparisonID = element.id;
        }
      } catch {
        console.log("Error in calculating similarity score");
      }
    });
  });
  return { similarity: comparisonScore, comparisonID };
};

// node_modules/marked/lib/marked.esm.js
function getDefaults() {
  return {
    async: false,
    baseUrl: null,
    breaks: false,
    extensions: null,
    gfm: true,
    headerIds: true,
    headerPrefix: "",
    highlight: null,
    hooks: null,
    langPrefix: "language-",
    mangle: true,
    pedantic: false,
    renderer: null,
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartypants: false,
    tokenizer: null,
    walkTokens: null,
    xhtml: false
  };
}
var defaults = getDefaults();
function changeDefaults(newDefaults) {
  defaults = newDefaults;
}
var escapeTest = /[&<>"']/;
var escapeReplace = new RegExp(escapeTest.source, "g");
var escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
var escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
var escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape2(html, encode) {
  if (encode) {
    if (escapeTest.test(html)) {
      return html.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html)) {
      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html;
}
var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
function unescape(html) {
  return html.replace(unescapeTest, (_, n) => {
    n = n.toLowerCase();
    if (n === "colon")
      return ":";
    if (n.charAt(0) === "#") {
      return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
    }
    return "";
  });
}
var caret = /(^|[^\[])\^/g;
function edit(regex, opt) {
  regex = typeof regex === "string" ? regex : regex.source;
  opt = opt || "";
  const obj = {
    replace: (name314, val) => {
      val = val.source || val;
      val = val.replace(caret, "$1");
      regex = regex.replace(name314, val);
      return obj;
    },
    getRegex: () => {
      return new RegExp(regex, opt);
    }
  };
  return obj;
}
var nonWordAndColonTest = /[^\w:]/g;
var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
function cleanUrl(sanitize, base, href) {
  if (sanitize) {
    let prot;
    try {
      prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, "").toLowerCase();
    } catch (e3) {
      return null;
    }
    if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
      return null;
    }
  }
  if (base && !originIndependentUrl.test(href)) {
    href = resolveUrl(base, href);
  }
  try {
    href = encodeURI(href).replace(/%25/g, "%");
  } catch (e3) {
    return null;
  }
  return href;
}
var baseUrls = {};
var justDomain = /^[^:]+:\/*[^/]*$/;
var protocol = /^([^:]+:)[\s\S]*$/;
var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
function resolveUrl(base, href) {
  if (!baseUrls[" " + base]) {
    if (justDomain.test(base)) {
      baseUrls[" " + base] = base + "/";
    } else {
      baseUrls[" " + base] = rtrim(base, "/", true);
    }
  }
  base = baseUrls[" " + base];
  const relativeBase = base.indexOf(":") === -1;
  if (href.substring(0, 2) === "//") {
    if (relativeBase) {
      return href;
    }
    return base.replace(protocol, "$1") + href;
  } else if (href.charAt(0) === "/") {
    if (relativeBase) {
      return href;
    }
    return base.replace(domain, "$1") + href;
  } else {
    return base + href;
  }
}
var noopTest = { exec: function noopTest2() {
} };
function splitCells(tableRow, count2) {
  const row2 = tableRow.replace(/\|/g, (match, offset, str) => {
    let escaped = false, curr = offset;
    while (--curr >= 0 && str[curr] === "\\")
      escaped = !escaped;
    if (escaped) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row2.split(/ \|/);
  let i2 = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) {
    cells.pop();
  }
  if (cells.length > count2) {
    cells.splice(count2);
  } else {
    while (cells.length < count2)
      cells.push("");
  }
  for (; i2 < cells.length; i2++) {
    cells[i2] = cells[i2].trim().replace(/\\\|/g, "|");
  }
  return cells;
}
function rtrim(str, c, invert) {
  const l = str.length;
  if (l === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l) {
    const currChar = str.charAt(l - suffLen - 1);
    if (currChar === c && !invert) {
      suffLen++;
    } else if (currChar !== c && invert) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.slice(0, l - suffLen);
}
function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  const l = str.length;
  let level = 0, i2 = 0;
  for (; i2 < l; i2++) {
    if (str[i2] === "\\") {
      i2++;
    } else if (str[i2] === b[0]) {
      level++;
    } else if (str[i2] === b[1]) {
      level--;
      if (level < 0) {
        return i2;
      }
    }
  }
  return -1;
}
function checkDeprecations(opt, callback) {
  if (!opt || opt.silent) {
    return;
  }
  if (callback) {
    console.warn("marked(): callback is deprecated since version 5.0.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/using_pro#async");
  }
  if (opt.sanitize || opt.sanitizer) {
    console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
  }
  if (opt.highlight || opt.langPrefix !== "language-") {
    console.warn("marked(): highlight and langPrefix parameters are deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-highlight.");
  }
  if (opt.mangle) {
    console.warn("marked(): mangle parameter is enabled by default, but is deprecated since version 5.0.0, and will be removed in the future. To clear this warning, install https://www.npmjs.com/package/marked-mangle, or disable by setting `{mangle: false}`.");
  }
  if (opt.baseUrl) {
    console.warn("marked(): baseUrl parameter is deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-base-url.");
  }
  if (opt.smartypants) {
    console.warn("marked(): smartypants parameter is deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-smartypants.");
  }
  if (opt.xhtml) {
    console.warn("marked(): xhtml parameter is deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-xhtml.");
  }
  if (opt.headerIds || opt.headerPrefix) {
    console.warn("marked(): headerIds and headerPrefix parameters enabled by default, but are deprecated since version 5.0.0, and will be removed in the future. To clear this warning, install  https://www.npmjs.com/package/marked-gfm-heading-id, or disable by setting `{headerIds: false}`.");
  }
}
function outputLink(cap, link, raw, lexer2) {
  const href = link.href;
  const title = link.title ? escape2(link.title) : null;
  const text = cap[1].replace(/\\([\[\]])/g, "$1");
  if (cap[0].charAt(0) !== "!") {
    lexer2.state.inLink = true;
    const token = {
      type: "link",
      raw,
      href,
      title,
      text,
      tokens: lexer2.inlineTokens(text)
    };
    lexer2.state.inLink = false;
    return token;
  }
  return {
    type: "image",
    raw,
    href,
    title,
    text: escape2(text)
  };
}
function indentCodeCompensation(raw, text) {
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
  if (matchIndentToCode === null) {
    return text;
  }
  const indentToCode = matchIndentToCode[1];
  return text.split("\n").map((node) => {
    const matchIndentInNode = node.match(/^\s+/);
    if (matchIndentInNode === null) {
      return node;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node.slice(indentToCode.length);
    }
    return node;
  }).join("\n");
}
var Tokenizer = class {
  constructor(options2) {
    this.options = options2 || defaults;
  }
  space(src) {
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: "space",
        raw: cap[0]
      };
    }
  }
  code(src) {
    const cap = this.rules.block.code.exec(src);
    if (cap) {
      const text = cap[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: cap[0],
        codeBlockStyle: "indented",
        text: !this.options.pedantic ? rtrim(text, "\n") : text
      };
    }
  }
  fences(src) {
    const cap = this.rules.block.fences.exec(src);
    if (cap) {
      const raw = cap[0];
      const text = indentCodeCompensation(raw, cap[3] || "");
      return {
        type: "code",
        raw,
        lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, "$1") : cap[2],
        text
      };
    }
  }
  heading(src) {
    const cap = this.rules.block.heading.exec(src);
    if (cap) {
      let text = cap[2].trim();
      if (/#$/.test(text)) {
        const trimmed = rtrim(text, "#");
        if (this.options.pedantic) {
          text = trimmed.trim();
        } else if (!trimmed || / $/.test(trimmed)) {
          text = trimmed.trim();
        }
      }
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[1].length,
        text,
        tokens: this.lexer.inline(text)
      };
    }
  }
  hr(src) {
    const cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: "hr",
        raw: cap[0]
      };
    }
  }
  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      const text = cap[0].replace(/^ *>[ \t]?/gm, "");
      const top = this.lexer.state.top;
      this.lexer.state.top = true;
      const tokens = this.lexer.blockTokens(text);
      this.lexer.state.top = top;
      return {
        type: "blockquote",
        raw: cap[0],
        tokens,
        text
      };
    }
  }
  list(src) {
    let cap = this.rules.block.list.exec(src);
    if (cap) {
      let raw, istask, ischecked, indent, i2, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
      let bull = cap[1].trim();
      const isordered = bull.length > 1;
      const list = {
        type: "list",
        raw: "",
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : "",
        loose: false,
        items: []
      };
      bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
      if (this.options.pedantic) {
        bull = isordered ? bull : "[*+-]";
      }
      const itemRegex = new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`);
      while (src) {
        endEarly = false;
        if (!(cap = itemRegex.exec(src))) {
          break;
        }
        if (this.rules.block.hr.test(src)) {
          break;
        }
        raw = cap[0];
        src = src.substring(raw.length);
        line = cap[2].split("\n", 1)[0].replace(/^\t+/, (t) => " ".repeat(3 * t.length));
        nextLine = src.split("\n", 1)[0];
        if (this.options.pedantic) {
          indent = 2;
          itemContents = line.trimLeft();
        } else {
          indent = cap[2].search(/[^ ]/);
          indent = indent > 4 ? 1 : indent;
          itemContents = line.slice(indent);
          indent += cap[1].length;
        }
        blankLine = false;
        if (!line && /^ *$/.test(nextLine)) {
          raw += nextLine + "\n";
          src = src.substring(nextLine.length + 1);
          endEarly = true;
        }
        if (!endEarly) {
          const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`);
          const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
          const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
          const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
          while (src) {
            rawLine = src.split("\n", 1)[0];
            nextLine = rawLine;
            if (this.options.pedantic) {
              nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
            }
            if (fencesBeginRegex.test(nextLine)) {
              break;
            }
            if (headingBeginRegex.test(nextLine)) {
              break;
            }
            if (nextBulletRegex.test(nextLine)) {
              break;
            }
            if (hrRegex.test(src)) {
              break;
            }
            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
              itemContents += "\n" + nextLine.slice(indent);
            } else {
              if (blankLine) {
                break;
              }
              if (line.search(/[^ ]/) >= 4) {
                break;
              }
              if (fencesBeginRegex.test(line)) {
                break;
              }
              if (headingBeginRegex.test(line)) {
                break;
              }
              if (hrRegex.test(line)) {
                break;
              }
              itemContents += "\n" + nextLine;
            }
            if (!blankLine && !nextLine.trim()) {
              blankLine = true;
            }
            raw += rawLine + "\n";
            src = src.substring(rawLine.length + 1);
            line = nextLine.slice(indent);
          }
        }
        if (!list.loose) {
          if (endsWithBlankLine) {
            list.loose = true;
          } else if (/\n *\n *$/.test(raw)) {
            endsWithBlankLine = true;
          }
        }
        if (this.options.gfm) {
          istask = /^\[[ xX]\] /.exec(itemContents);
          if (istask) {
            ischecked = istask[0] !== "[ ] ";
            itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
          }
        }
        list.items.push({
          type: "list_item",
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents
        });
        list.raw += raw;
      }
      list.items[list.items.length - 1].raw = raw.trimRight();
      list.items[list.items.length - 1].text = itemContents.trimRight();
      list.raw = list.raw.trimRight();
      const l = list.items.length;
      for (i2 = 0; i2 < l; i2++) {
        this.lexer.state.top = false;
        list.items[i2].tokens = this.lexer.blockTokens(list.items[i2].text, []);
        if (!list.loose) {
          const spacers = list.items[i2].tokens.filter((t) => t.type === "space");
          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t) => /\n.*\n/.test(t.raw));
          list.loose = hasMultipleLineBreaks;
        }
      }
      if (list.loose) {
        for (i2 = 0; i2 < l; i2++) {
          list.items[i2].loose = true;
        }
      }
      return list;
    }
  }
  html(src) {
    const cap = this.rules.block.html.exec(src);
    if (cap) {
      const token = {
        type: "html",
        block: true,
        raw: cap[0],
        pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
        text: cap[0]
      };
      if (this.options.sanitize) {
        const text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape2(cap[0]);
        token.type = "paragraph";
        token.text = text;
        token.tokens = this.lexer.inline(text);
      }
      return token;
    }
  }
  def(src) {
    const cap = this.rules.block.def.exec(src);
    if (cap) {
      const tag2 = cap[1].toLowerCase().replace(/\s+/g, " ");
      const href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : "";
      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, "$1") : cap[3];
      return {
        type: "def",
        tag: tag2,
        raw: cap[0],
        href,
        title
      };
    }
  }
  table(src) {
    const cap = this.rules.block.table.exec(src);
    if (cap) {
      const item = {
        type: "table",
        header: splitCells(cap[1]).map((c) => {
          return { text: c };
        }),
        align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
        rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
      };
      if (item.header.length === item.align.length) {
        item.raw = cap[0];
        let l = item.align.length;
        let i2, j, k, row2;
        for (i2 = 0; i2 < l; i2++) {
          if (/^ *-+: *$/.test(item.align[i2])) {
            item.align[i2] = "right";
          } else if (/^ *:-+: *$/.test(item.align[i2])) {
            item.align[i2] = "center";
          } else if (/^ *:-+ *$/.test(item.align[i2])) {
            item.align[i2] = "left";
          } else {
            item.align[i2] = null;
          }
        }
        l = item.rows.length;
        for (i2 = 0; i2 < l; i2++) {
          item.rows[i2] = splitCells(item.rows[i2], item.header.length).map((c) => {
            return { text: c };
          });
        }
        l = item.header.length;
        for (j = 0; j < l; j++) {
          item.header[j].tokens = this.lexer.inline(item.header[j].text);
        }
        l = item.rows.length;
        for (j = 0; j < l; j++) {
          row2 = item.rows[j];
          for (k = 0; k < row2.length; k++) {
            row2[k].tokens = this.lexer.inline(row2[k].text);
          }
        }
        return item;
      }
    }
  }
  lheading(src) {
    const cap = this.rules.block.lheading.exec(src);
    if (cap) {
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[2].charAt(0) === "=" ? 1 : 2,
        text: cap[1],
        tokens: this.lexer.inline(cap[1])
      };
    }
  }
  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      const text = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
      return {
        type: "paragraph",
        raw: cap[0],
        text,
        tokens: this.lexer.inline(text)
      };
    }
  }
  text(src) {
    const cap = this.rules.block.text.exec(src);
    if (cap) {
      return {
        type: "text",
        raw: cap[0],
        text: cap[0],
        tokens: this.lexer.inline(cap[0])
      };
    }
  }
  escape(src) {
    const cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: "escape",
        raw: cap[0],
        text: escape2(cap[1])
      };
    }
  }
  tag(src) {
    const cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
        this.lexer.state.inLink = true;
      } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
        this.lexer.state.inLink = false;
      }
      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = true;
      } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = false;
      }
      return {
        type: this.options.sanitize ? "text" : "html",
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        block: false,
        text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape2(cap[0]) : cap[0]
      };
    }
  }
  link(src) {
    const cap = this.rules.inline.link.exec(src);
    if (cap) {
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && /^</.test(trimmedUrl)) {
        if (!/>$/.test(trimmedUrl)) {
          return;
        }
        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        const lastParenIndex = findClosingBracket(cap[2], "()");
        if (lastParenIndex > -1) {
          const start = cap[0].indexOf("!") === 0 ? 5 : 4;
          const linkLen = start + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = "";
        }
      }
      let href = cap[2];
      let title = "";
      if (this.options.pedantic) {
        const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
        if (link) {
          href = link[1];
          title = link[3];
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : "";
      }
      href = href.trim();
      if (/^</.test(href)) {
        if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
        title: title ? title.replace(this.rules.inline._escapes, "$1") : title
      }, cap[0], this.lexer);
    }
  }
  reflink(src, links) {
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      let link = (cap[2] || cap[1]).replace(/\s+/g, " ");
      link = links[link.toLowerCase()];
      if (!link) {
        const text = cap[0].charAt(0);
        return {
          type: "text",
          raw: text,
          text
        };
      }
      return outputLink(cap, link, cap[0], this.lexer);
    }
  }
  emStrong(src, maskedSrc, prevChar = "") {
    let match = this.rules.inline.emStrong.lDelim.exec(src);
    if (!match)
      return;
    if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
      return;
    const nextChar = match[1] || match[2] || "";
    if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
      const lLength = match[0].length - 1;
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
      const endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
      endReg.lastIndex = 0;
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
      while ((match = endReg.exec(maskedSrc)) != null) {
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
        if (!rDelim)
          continue;
        rLength = rDelim.length;
        if (match[3] || match[4]) {
          delimTotal += rLength;
          continue;
        } else if (match[5] || match[6]) {
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue;
          }
        }
        delimTotal -= rLength;
        if (delimTotal > 0)
          continue;
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        const raw = src.slice(0, lLength + match.index + rLength + 1);
        if (Math.min(lLength, rLength) % 2) {
          const text2 = raw.slice(1, -1);
          return {
            type: "em",
            raw,
            text: text2,
            tokens: this.lexer.inlineTokens(text2)
          };
        }
        const text = raw.slice(2, -2);
        return {
          type: "strong",
          raw,
          text,
          tokens: this.lexer.inlineTokens(text)
        };
      }
    }
  }
  codespan(src) {
    const cap = this.rules.inline.code.exec(src);
    if (cap) {
      let text = cap[2].replace(/\n/g, " ");
      const hasNonSpaceChars = /[^ ]/.test(text);
      const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text = text.substring(1, text.length - 1);
      }
      text = escape2(text, true);
      return {
        type: "codespan",
        raw: cap[0],
        text
      };
    }
  }
  br(src) {
    const cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: "br",
        raw: cap[0]
      };
    }
  }
  del(src) {
    const cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: "del",
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2])
      };
    }
  }
  autolink(src, mangle2) {
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      let text, href;
      if (cap[2] === "@") {
        text = escape2(this.options.mangle ? mangle2(cap[1]) : cap[1]);
        href = "mailto:" + text;
      } else {
        text = escape2(cap[1]);
        href = text;
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  url(src, mangle2) {
    let cap;
    if (cap = this.rules.inline.url.exec(src)) {
      let text, href;
      if (cap[2] === "@") {
        text = escape2(this.options.mangle ? mangle2(cap[0]) : cap[0]);
        href = "mailto:" + text;
      } else {
        let prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
        } while (prevCapZero !== cap[0]);
        text = escape2(cap[0]);
        if (cap[1] === "www.") {
          href = "http://" + cap[0];
        } else {
          href = cap[0];
        }
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  inlineText(src, smartypants2) {
    const cap = this.rules.inline.text.exec(src);
    if (cap) {
      let text;
      if (this.lexer.state.inRawBlock) {
        text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape2(cap[0]) : cap[0];
      } else {
        text = escape2(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
      }
      return {
        type: "text",
        raw: cap[0],
        text
      };
    }
  }
};
var block = {
  newline: /^(?: *(?:\n|$))+/,
  code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
  hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
  html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
  def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
  table: noopTest,
  lheading: /^((?:(?!^bull ).|\n(?!\n|bull ))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  // regex template, placeholders will be replaced according to different paragraph
  // interruption rules of commonmark and the original markdown spec:
  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  text: /^[^\n]+/
};
block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
block.lheading = edit(block.lheading).replace(/bull/g, block.bullet).getRegex();
block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
block.normal = { ...block };
block.gfm = {
  ...block.normal,
  table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
  // Cells
};
block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.pedantic = {
  ...block.normal,
  html: edit(
    `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`
  ).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
};
var inline = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noopTest,
  tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
  // CDATA section
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(ref)\]/,
  nolink: /^!?\[(ref)\](?:\[\])?/,
  reflinkSearch: "reflink|nolink(?!\\()",
  emStrong: {
    lDelim: /^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/,
    //         (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
    //         | Skip orphan inside strong      | Consume to delim | (1) #***              | (2) a***#, a***                    | (3) #***a, ***a                  | (4) ***#                 | (5) #***#                         | (6) a***a
    rDelimAst: /^[^_*]*?__[^_*]*?\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\*)[punct](\*+)(?=[\s]|$)|[^punct\s](\*+)(?!\*)(?=[punct\s]|$)|(?!\*)[punct\s](\*+)(?=[^punct\s])|[\s](\*+)(?!\*)(?=[punct])|(?!\*)[punct](\*+)(?!\*)(?=[punct])|[^punct\s](\*+)(?=[^punct\s])/,
    rDelimUnd: /^[^_*]*?\*\*[^_*]*?_[^_*]*?(?=\*\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\s]|$)|[^punct\s](_+)(?!_)(?=[punct\s]|$)|(?!_)[punct\s](_+)(?=[^punct\s])|[\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])/
    // ^- Not allowed for _
  },
  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: noopTest,
  text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
  punctuation: /^((?![*_])[\spunctuation])/
};
inline._punctuation = "\\p{P}$+<=>`^|~";
inline.punctuation = edit(inline.punctuation, "u").replace(/punctuation/g, inline._punctuation).getRegex();
inline.blockSkip = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g;
inline.anyPunctuation = /\\[punct]/g;
inline._escapes = /\\([punct])/g;
inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
inline.emStrong.lDelim = edit(inline.emStrong.lDelim, "u").replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "gu").replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "gu").replace(/punct/g, inline._punctuation).getRegex();
inline.anyPunctuation = edit(inline.anyPunctuation, "gu").replace(/punct/g, inline._punctuation).getRegex();
inline._escapes = edit(inline._escapes, "gu").replace(/punct/g, inline._punctuation).getRegex();
inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
inline.normal = { ...inline };
inline.pedantic = {
  ...inline.normal,
  strong: {
    start: /^__|\*\*/,
    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    endAst: /\*\*(?!\*)/g,
    endUnd: /__(?!_)/g
  },
  em: {
    start: /^_|\*/,
    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
    endAst: /\*(?!\*)/g,
    endUnd: /_(?!_)/g
  },
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
};
inline.gfm = {
  ...inline.normal,
  escape: edit(inline.escape).replace("])", "~|])").getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
};
inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
inline.breaks = {
  ...inline.gfm,
  br: edit(inline.br).replace("{2,}", "*").getRegex(),
  text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
};
function smartypants(text) {
  return text.replace(/---/g, "\u2014").replace(/--/g, "\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018").replace(/'/g, "\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C").replace(/"/g, "\u201D").replace(/\.{3}/g, "\u2026");
}
function mangle(text) {
  let out = "", i2, ch;
  const l = text.length;
  for (i2 = 0; i2 < l; i2++) {
    ch = text.charCodeAt(i2);
    if (Math.random() > 0.5) {
      ch = "x" + ch.toString(16);
    }
    out += "&#" + ch + ";";
  }
  return out;
}
var Lexer = class {
  constructor(options2) {
    this.tokens = [];
    this.tokens.links = /* @__PURE__ */ Object.create(null);
    this.options = options2 || defaults;
    this.options.tokenizer = this.options.tokenizer || new Tokenizer();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    const rules = {
      block: block.normal,
      inline: inline.normal
    };
    if (this.options.pedantic) {
      rules.block = block.pedantic;
      rules.inline = inline.pedantic;
    } else if (this.options.gfm) {
      rules.block = block.gfm;
      if (this.options.breaks) {
        rules.inline = inline.breaks;
      } else {
        rules.inline = inline.gfm;
      }
    }
    this.tokenizer.rules = rules;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block,
      inline
    };
  }
  /**
   * Static Lex Method
   */
  static lex(src, options2) {
    const lexer2 = new Lexer(options2);
    return lexer2.lex(src);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(src, options2) {
    const lexer2 = new Lexer(options2);
    return lexer2.inlineTokens(src);
  }
  /**
   * Preprocessing
   */
  lex(src) {
    src = src.replace(/\r\n|\r/g, "\n");
    this.blockTokens(src, this.tokens);
    let next;
    while (next = this.inlineQueue.shift()) {
      this.inlineTokens(next.src, next.tokens);
    }
    return this.tokens;
  }
  /**
   * Lexing
   */
  blockTokens(src, tokens = []) {
    if (this.options.pedantic) {
      src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
    } else {
      src = src.replace(/^( *)(\t+)/gm, (_, leading, tabs) => {
        return leading + "    ".repeat(tabs.length);
      });
    }
    let token, lastToken, cutSrc, lastParagraphClipped;
    while (src) {
      if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.space(src)) {
        src = src.substring(token.raw.length);
        if (token.raw.length === 1 && tokens.length > 0) {
          tokens[tokens.length - 1].raw += "\n";
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.code(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.fences(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.hr(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.blockquote(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.list(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.html(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.def(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.raw;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else if (!this.tokens.links[token.tag]) {
          this.tokens.links[token.tag] = {
            href: token.href,
            title: token.title
          };
        }
        continue;
      }
      if (token = this.tokenizer.table(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.lheading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startBlock) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startBlock.forEach(function(getStartIndex) {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
        lastToken = tokens[tokens.length - 1];
        if (lastParagraphClipped && lastToken.type === "paragraph") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        lastParagraphClipped = cutSrc.length !== src.length;
        src = src.substring(token.raw.length);
        continue;
      }
      if (token = this.tokenizer.text(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    this.state.top = true;
    return tokens;
  }
  inline(src, tokens = []) {
    this.inlineQueue.push({ src, tokens });
    return tokens;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(src, tokens = []) {
    let token, lastToken, cutSrc;
    let maskedSrc = src;
    let match;
    let keepPrevChar, prevChar;
    if (this.tokens.links) {
      const links = Object.keys(this.tokens.links);
      if (links.length > 0) {
        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }
    while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    }
    while (src) {
      if (!keepPrevChar) {
        prevChar = "";
      }
      keepPrevChar = false;
      if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.escape(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.tag(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.link(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.codespan(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.br(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.del(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.autolink(src, mangle)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startInline) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startInline.forEach(function(getStartIndex) {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
        src = src.substring(token.raw.length);
        if (token.raw.slice(-1) !== "_") {
          prevChar = token.raw.slice(-1);
        }
        keepPrevChar = true;
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    return tokens;
  }
};
var Renderer = class {
  constructor(options2) {
    this.options = options2 || defaults;
  }
  code(code, infostring, escaped) {
    const lang = (infostring || "").match(/\S*/)[0];
    if (this.options.highlight) {
      const out = this.options.highlight(code, lang);
      if (out != null && out !== code) {
        escaped = true;
        code = out;
      }
    }
    code = code.replace(/\n$/, "") + "\n";
    if (!lang) {
      return "<pre><code>" + (escaped ? code : escape2(code, true)) + "</code></pre>\n";
    }
    return '<pre><code class="' + this.options.langPrefix + escape2(lang) + '">' + (escaped ? code : escape2(code, true)) + "</code></pre>\n";
  }
  /**
   * @param {string} quote
   */
  blockquote(quote) {
    return `<blockquote>
${quote}</blockquote>
`;
  }
  html(html, block2) {
    return html;
  }
  /**
   * @param {string} text
   * @param {string} level
   * @param {string} raw
   * @param {any} slugger
   */
  heading(text, level, raw, slugger) {
    if (this.options.headerIds) {
      const id = this.options.headerPrefix + slugger.slug(raw);
      return `<h${level} id="${id}">${text}</h${level}>
`;
    }
    return `<h${level}>${text}</h${level}>
`;
  }
  hr() {
    return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
  }
  list(body, ordered, start) {
    const type = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
    return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
  }
  /**
   * @param {string} text
   */
  listitem(text) {
    return `<li>${text}</li>
`;
  }
  checkbox(checked) {
    return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
  }
  /**
   * @param {string} text
   */
  paragraph(text) {
    return `<p>${text}</p>
`;
  }
  /**
   * @param {string} header
   * @param {string} body
   */
  table(header, body) {
    if (body)
      body = `<tbody>${body}</tbody>`;
    return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
  }
  /**
   * @param {string} content
   */
  tablerow(content) {
    return `<tr>
${content}</tr>
`;
  }
  tablecell(content, flags) {
    const type = flags.header ? "th" : "td";
    const tag2 = flags.align ? `<${type} align="${flags.align}">` : `<${type}>`;
    return tag2 + content + `</${type}>
`;
  }
  /**
   * span level renderer
   * @param {string} text
   */
  strong(text) {
    return `<strong>${text}</strong>`;
  }
  /**
   * @param {string} text
   */
  em(text) {
    return `<em>${text}</em>`;
  }
  /**
   * @param {string} text
   */
  codespan(text) {
    return `<code>${text}</code>`;
  }
  br() {
    return this.options.xhtml ? "<br/>" : "<br>";
  }
  /**
   * @param {string} text
   */
  del(text) {
    return `<del>${text}</del>`;
  }
  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */
  link(href, title, text) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text;
    }
    let out = '<a href="' + href + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += ">" + text + "</a>";
    return out;
  }
  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */
  image(href, title, text) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text;
    }
    let out = `<img src="${href}" alt="${text}"`;
    if (title) {
      out += ` title="${title}"`;
    }
    out += this.options.xhtml ? "/>" : ">";
    return out;
  }
  text(text) {
    return text;
  }
};
var TextRenderer = class {
  // no need for block level renderers
  strong(text) {
    return text;
  }
  em(text) {
    return text;
  }
  codespan(text) {
    return text;
  }
  del(text) {
    return text;
  }
  html(text) {
    return text;
  }
  text(text) {
    return text;
  }
  link(href, title, text) {
    return "" + text;
  }
  image(href, title, text) {
    return "" + text;
  }
  br() {
    return "";
  }
};
var Slugger = class {
  constructor() {
    this.seen = {};
  }
  /**
   * @param {string} value
   */
  serialize(value) {
    return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
  }
  /**
   * Finds the next safe (unique) slug to use
   * @param {string} originalSlug
   * @param {boolean} isDryRun
   */
  getNextSafeSlug(originalSlug, isDryRun) {
    let slug = originalSlug;
    let occurenceAccumulator = 0;
    if (this.seen.hasOwnProperty(slug)) {
      occurenceAccumulator = this.seen[originalSlug];
      do {
        occurenceAccumulator++;
        slug = originalSlug + "-" + occurenceAccumulator;
      } while (this.seen.hasOwnProperty(slug));
    }
    if (!isDryRun) {
      this.seen[originalSlug] = occurenceAccumulator;
      this.seen[slug] = 0;
    }
    return slug;
  }
  /**
   * Convert string to unique id
   * @param {object} [options]
   * @param {boolean} [options.dryrun] Generates the next unique slug without
   * updating the internal accumulator.
   */
  slug(value, options2 = {}) {
    const slug = this.serialize(value);
    return this.getNextSafeSlug(slug, options2.dryrun);
  }
};
var Parser2 = class {
  constructor(options2) {
    this.options = options2 || defaults;
    this.options.renderer = this.options.renderer || new Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.textRenderer = new TextRenderer();
    this.slugger = new Slugger();
  }
  /**
   * Static Parse Method
   */
  static parse(tokens, options2) {
    const parser3 = new Parser2(options2);
    return parser3.parse(tokens);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(tokens, options2) {
    const parser3 = new Parser2(options2);
    return parser3.parseInline(tokens);
  }
  /**
   * Parse Loop
   */
  parse(tokens, top = true) {
    let out = "", i2, j, k, l2, l3, row2, cell, header, body, token, ordered, start, loose, itemBody, item, checked, task, checkbox, ret;
    const l = tokens.length;
    for (i2 = 0; i2 < l; i2++) {
      token = tokens[i2];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "space": {
          continue;
        }
        case "hr": {
          out += this.renderer.hr();
          continue;
        }
        case "heading": {
          out += this.renderer.heading(
            this.parseInline(token.tokens),
            token.depth,
            unescape(this.parseInline(token.tokens, this.textRenderer)),
            this.slugger
          );
          continue;
        }
        case "code": {
          out += this.renderer.code(
            token.text,
            token.lang,
            token.escaped
          );
          continue;
        }
        case "table": {
          header = "";
          cell = "";
          l2 = token.header.length;
          for (j = 0; j < l2; j++) {
            cell += this.renderer.tablecell(
              this.parseInline(token.header[j].tokens),
              { header: true, align: token.align[j] }
            );
          }
          header += this.renderer.tablerow(cell);
          body = "";
          l2 = token.rows.length;
          for (j = 0; j < l2; j++) {
            row2 = token.rows[j];
            cell = "";
            l3 = row2.length;
            for (k = 0; k < l3; k++) {
              cell += this.renderer.tablecell(
                this.parseInline(row2[k].tokens),
                { header: false, align: token.align[k] }
              );
            }
            body += this.renderer.tablerow(cell);
          }
          out += this.renderer.table(header, body);
          continue;
        }
        case "blockquote": {
          body = this.parse(token.tokens);
          out += this.renderer.blockquote(body);
          continue;
        }
        case "list": {
          ordered = token.ordered;
          start = token.start;
          loose = token.loose;
          l2 = token.items.length;
          body = "";
          for (j = 0; j < l2; j++) {
            item = token.items[j];
            checked = item.checked;
            task = item.task;
            itemBody = "";
            if (item.task) {
              checkbox = this.renderer.checkbox(checked);
              if (loose) {
                if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                  item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                    item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                  }
                } else {
                  item.tokens.unshift({
                    type: "text",
                    text: checkbox
                  });
                }
              } else {
                itemBody += checkbox;
              }
            }
            itemBody += this.parse(item.tokens, loose);
            body += this.renderer.listitem(itemBody, task, checked);
          }
          out += this.renderer.list(body, ordered, start);
          continue;
        }
        case "html": {
          out += this.renderer.html(token.text, token.block);
          continue;
        }
        case "paragraph": {
          out += this.renderer.paragraph(this.parseInline(token.tokens));
          continue;
        }
        case "text": {
          body = token.tokens ? this.parseInline(token.tokens) : token.text;
          while (i2 + 1 < l && tokens[i2 + 1].type === "text") {
            token = tokens[++i2];
            body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
          }
          out += top ? this.renderer.paragraph(body) : body;
          continue;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return;
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(tokens, renderer) {
    renderer = renderer || this.renderer;
    let out = "", i2, token, ret;
    const l = tokens.length;
    for (i2 = 0; i2 < l; i2++) {
      token = tokens[i2];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "escape": {
          out += renderer.text(token.text);
          break;
        }
        case "html": {
          out += renderer.html(token.text);
          break;
        }
        case "link": {
          out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
          break;
        }
        case "image": {
          out += renderer.image(token.href, token.title, token.text);
          break;
        }
        case "strong": {
          out += renderer.strong(this.parseInline(token.tokens, renderer));
          break;
        }
        case "em": {
          out += renderer.em(this.parseInline(token.tokens, renderer));
          break;
        }
        case "codespan": {
          out += renderer.codespan(token.text);
          break;
        }
        case "br": {
          out += renderer.br();
          break;
        }
        case "del": {
          out += renderer.del(this.parseInline(token.tokens, renderer));
          break;
        }
        case "text": {
          out += renderer.text(token.text);
          break;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return;
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
};
var Hooks = class {
  constructor(options2) {
    this.options = options2 || defaults;
  }
  /**
   * Process markdown before marked
   */
  preprocess(markdown) {
    return markdown;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(html) {
    return html;
  }
};
__publicField(Hooks, "passThroughHooks", /* @__PURE__ */ new Set([
  "preprocess",
  "postprocess"
]));
var _parseMarkdown, parseMarkdown_fn, _onError, onError_fn;
var Marked = class {
  constructor(...args) {
    __privateAdd(this, _parseMarkdown);
    __privateAdd(this, _onError);
    __publicField(this, "defaults", getDefaults());
    __publicField(this, "options", this.setOptions);
    __publicField(this, "parse", __privateMethod(this, _parseMarkdown, parseMarkdown_fn).call(this, Lexer.lex, Parser2.parse));
    __publicField(this, "parseInline", __privateMethod(this, _parseMarkdown, parseMarkdown_fn).call(this, Lexer.lexInline, Parser2.parseInline));
    __publicField(this, "Parser", Parser2);
    __publicField(this, "parser", Parser2.parse);
    __publicField(this, "Renderer", Renderer);
    __publicField(this, "TextRenderer", TextRenderer);
    __publicField(this, "Lexer", Lexer);
    __publicField(this, "lexer", Lexer.lex);
    __publicField(this, "Tokenizer", Tokenizer);
    __publicField(this, "Slugger", Slugger);
    __publicField(this, "Hooks", Hooks);
    this.use(...args);
  }
  walkTokens(tokens, callback) {
    let values = [];
    for (const token of tokens) {
      values = values.concat(callback.call(this, token));
      switch (token.type) {
        case "table": {
          for (const cell of token.header) {
            values = values.concat(this.walkTokens(cell.tokens, callback));
          }
          for (const row2 of token.rows) {
            for (const cell of row2) {
              values = values.concat(this.walkTokens(cell.tokens, callback));
            }
          }
          break;
        }
        case "list": {
          values = values.concat(this.walkTokens(token.items, callback));
          break;
        }
        default: {
          if (this.defaults.extensions && this.defaults.extensions.childTokens && this.defaults.extensions.childTokens[token.type]) {
            this.defaults.extensions.childTokens[token.type].forEach((childTokens) => {
              values = values.concat(this.walkTokens(token[childTokens], callback));
            });
          } else if (token.tokens) {
            values = values.concat(this.walkTokens(token.tokens, callback));
          }
        }
      }
    }
    return values;
  }
  use(...args) {
    const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
    args.forEach((pack) => {
      const opts = { ...pack };
      opts.async = this.defaults.async || opts.async || false;
      if (pack.extensions) {
        pack.extensions.forEach((ext) => {
          if (!ext.name) {
            throw new Error("extension name required");
          }
          if (ext.renderer) {
            const prevRenderer = extensions.renderers[ext.name];
            if (prevRenderer) {
              extensions.renderers[ext.name] = function(...args2) {
                let ret = ext.renderer.apply(this, args2);
                if (ret === false) {
                  ret = prevRenderer.apply(this, args2);
                }
                return ret;
              };
            } else {
              extensions.renderers[ext.name] = ext.renderer;
            }
          }
          if (ext.tokenizer) {
            if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
              throw new Error("extension level must be 'block' or 'inline'");
            }
            if (extensions[ext.level]) {
              extensions[ext.level].unshift(ext.tokenizer);
            } else {
              extensions[ext.level] = [ext.tokenizer];
            }
            if (ext.start) {
              if (ext.level === "block") {
                if (extensions.startBlock) {
                  extensions.startBlock.push(ext.start);
                } else {
                  extensions.startBlock = [ext.start];
                }
              } else if (ext.level === "inline") {
                if (extensions.startInline) {
                  extensions.startInline.push(ext.start);
                } else {
                  extensions.startInline = [ext.start];
                }
              }
            }
          }
          if (ext.childTokens) {
            extensions.childTokens[ext.name] = ext.childTokens;
          }
        });
        opts.extensions = extensions;
      }
      if (pack.renderer) {
        const renderer = this.defaults.renderer || new Renderer(this.defaults);
        for (const prop in pack.renderer) {
          const prevRenderer = renderer[prop];
          renderer[prop] = (...args2) => {
            let ret = pack.renderer[prop].apply(renderer, args2);
            if (ret === false) {
              ret = prevRenderer.apply(renderer, args2);
            }
            return ret;
          };
        }
        opts.renderer = renderer;
      }
      if (pack.tokenizer) {
        const tokenizer = this.defaults.tokenizer || new Tokenizer(this.defaults);
        for (const prop in pack.tokenizer) {
          const prevTokenizer = tokenizer[prop];
          tokenizer[prop] = (...args2) => {
            let ret = pack.tokenizer[prop].apply(tokenizer, args2);
            if (ret === false) {
              ret = prevTokenizer.apply(tokenizer, args2);
            }
            return ret;
          };
        }
        opts.tokenizer = tokenizer;
      }
      if (pack.hooks) {
        const hooks = this.defaults.hooks || new Hooks();
        for (const prop in pack.hooks) {
          const prevHook = hooks[prop];
          if (Hooks.passThroughHooks.has(prop)) {
            hooks[prop] = (arg2) => {
              if (this.defaults.async) {
                return Promise.resolve(pack.hooks[prop].call(hooks, arg2)).then((ret2) => {
                  return prevHook.call(hooks, ret2);
                });
              }
              const ret = pack.hooks[prop].call(hooks, arg2);
              return prevHook.call(hooks, ret);
            };
          } else {
            hooks[prop] = (...args2) => {
              let ret = pack.hooks[prop].apply(hooks, args2);
              if (ret === false) {
                ret = prevHook.apply(hooks, args2);
              }
              return ret;
            };
          }
        }
        opts.hooks = hooks;
      }
      if (pack.walkTokens) {
        const walkTokens2 = this.defaults.walkTokens;
        opts.walkTokens = function(token) {
          let values = [];
          values.push(pack.walkTokens.call(this, token));
          if (walkTokens2) {
            values = values.concat(walkTokens2.call(this, token));
          }
          return values;
        };
      }
      this.defaults = { ...this.defaults, ...opts };
    });
    return this;
  }
  setOptions(opt) {
    this.defaults = { ...this.defaults, ...opt };
    return this;
  }
};
_parseMarkdown = new WeakSet();
parseMarkdown_fn = function(lexer2, parser3) {
  return (src, opt, callback) => {
    if (typeof opt === "function") {
      callback = opt;
      opt = null;
    }
    const origOpt = { ...opt };
    opt = { ...this.defaults, ...origOpt };
    const throwError = __privateMethod(this, _onError, onError_fn).call(this, opt.silent, opt.async, callback);
    if (typeof src === "undefined" || src === null) {
      return throwError(new Error("marked(): input parameter is undefined or null"));
    }
    if (typeof src !== "string") {
      return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
    }
    checkDeprecations(opt, callback);
    if (opt.hooks) {
      opt.hooks.options = opt;
    }
    if (callback) {
      const highlight = opt.highlight;
      let tokens;
      try {
        if (opt.hooks) {
          src = opt.hooks.preprocess(src);
        }
        tokens = lexer2(src, opt);
      } catch (e3) {
        return throwError(e3);
      }
      const done = (err) => {
        let out;
        if (!err) {
          try {
            if (opt.walkTokens) {
              this.walkTokens(tokens, opt.walkTokens);
            }
            out = parser3(tokens, opt);
            if (opt.hooks) {
              out = opt.hooks.postprocess(out);
            }
          } catch (e3) {
            err = e3;
          }
        }
        opt.highlight = highlight;
        return err ? throwError(err) : callback(null, out);
      };
      if (!highlight || highlight.length < 3) {
        return done();
      }
      delete opt.highlight;
      if (!tokens.length)
        return done();
      let pending = 0;
      this.walkTokens(tokens, (token) => {
        if (token.type === "code") {
          pending++;
          setTimeout(() => {
            highlight(token.text, token.lang, (err, code) => {
              if (err) {
                return done(err);
              }
              if (code != null && code !== token.text) {
                token.text = code;
                token.escaped = true;
              }
              pending--;
              if (pending === 0) {
                done();
              }
            });
          }, 0);
        }
      });
      if (pending === 0) {
        done();
      }
      return;
    }
    if (opt.async) {
      return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer2(src2, opt)).then((tokens) => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser3(tokens, opt)).then((html) => opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError);
    }
    try {
      if (opt.hooks) {
        src = opt.hooks.preprocess(src);
      }
      const tokens = lexer2(src, opt);
      if (opt.walkTokens) {
        this.walkTokens(tokens, opt.walkTokens);
      }
      let html = parser3(tokens, opt);
      if (opt.hooks) {
        html = opt.hooks.postprocess(html);
      }
      return html;
    } catch (e3) {
      return throwError(e3);
    }
  };
};
_onError = new WeakSet();
onError_fn = function(silent, async, callback) {
  return (e3) => {
    e3.message += "\nPlease report this to https://github.com/markedjs/marked.";
    if (silent) {
      const msg = "<p>An error occurred:</p><pre>" + escape2(e3.message + "", true) + "</pre>";
      if (async) {
        return Promise.resolve(msg);
      }
      if (callback) {
        callback(null, msg);
        return;
      }
      return msg;
    }
    if (async) {
      return Promise.reject(e3);
    }
    if (callback) {
      callback(e3);
      return;
    }
    throw e3;
  };
};
var markedInstance = new Marked(defaults);
function marked(src, opt, callback) {
  return markedInstance.parse(src, opt, callback);
}
marked.options = marked.setOptions = function(opt) {
  markedInstance.setOptions(opt);
  marked.defaults = markedInstance.defaults;
  changeDefaults(marked.defaults);
  return marked;
};
marked.getDefaults = getDefaults;
marked.defaults = defaults;
marked.use = function(...args) {
  markedInstance.use(...args);
  marked.defaults = markedInstance.defaults;
  changeDefaults(marked.defaults);
  return marked;
};
marked.walkTokens = function(tokens, callback) {
  return markedInstance.walkTokens(tokens, callback);
};
marked.parseInline = markedInstance.parseInline;
marked.Parser = Parser2;
marked.parser = Parser2.parse;
marked.Renderer = Renderer;
marked.TextRenderer = TextRenderer;
marked.Lexer = Lexer;
marked.lexer = Lexer.lex;
marked.Tokenizer = Tokenizer;
marked.Slugger = Slugger;
marked.Hooks = Hooks;
marked.parse = marked;
var options = marked.options;
var setOptions = marked.setOptions;
var use = marked.use;
var walkTokens = marked.walkTokens;
var parseInline = marked.parseInline;
var parser2 = Parser2.parse;
var lexer = Lexer.lex;

// src/ui/modals/ask-qgpt-modal.ts
var import_obsidian22 = require("obsidian");
var AskQGPTModal = class extends import_obsidian22.Modal {
  constructor(app2, selection) {
    super(app2);
    this.text = selection;
  }
  onOpen() {
    const askTitle = this.titleEl.createEl("p", {
      text: Constants.askQGPTTitle
    });
    askTitle.addClass("ask-modal-title");
    const selectionRow = this.contentEl.createEl("div");
    selectionRow.classList.add("ask-row");
    const selectionCol = selectionRow.createDiv();
    selectionCol.classList.add("ask-col");
    selectionCol.innerHTML = marked.parse("```\n" + this.text.trim() + "\n```");
    selectionCol.classList.add("ask-selection");
    const inputRow = this.contentEl.createEl("div");
    inputRow.classList.add("ask-row", "ask-input-row");
    const inputCol = inputRow.createDiv();
    inputCol.classList.add("ask-col", "scrollbar-hide");
    const inputText = inputCol.createEl("span");
    inputText.classList.add("ask-input");
    this.inputText = inputText;
    inputText.addClasses(["gpt-input-textarea", "scrollbar-hide"]);
    inputText.title = DisplayController.fetchFailed ? "Pieces OS not detected, please launch Pieces OS to use Copilot." : !versionValid ? "Pieces OS is not up-to-date, please update to use Copilot." : "Ask a question about your selection";
    inputText.contentEditable = !versionValid || DisplayController.fetchFailed ? "false" : "true";
    inputText.spellcheck = true;
    inputText.focus();
    const sendCol = inputRow.createDiv();
    sendCol.classList.add("ask-col");
    inputCol.classList.add("ask-col", "ask-col-input");
    const sendDiv = sendCol.createEl("div");
    sendDiv.innerHTML = Constants.SEND_ICON;
    sendDiv.addClasses([
      "ask-send-svg",
      "min-w-[30px]",
      "min-h-[30px]",
      "justify-center",
      "flex"
    ]);
    const sendSVG = sendDiv.firstChild;
    sendSVG.addClass("text-[gray]");
    sendSVG.addClass(
      "ask-send-svg",
      "cursor-pointer",
      "hover:text-[var(--text-accent)]"
    );
    sendDiv.onmouseup = async () => {
      if (inputText.innerText.trim() === "") {
        return;
      }
      this.handleQuery();
    };
    inputText.onkeyup = async (evt) => {
      if (inputText.innerText !== "") {
        sendSVG.removeClass("text-[gray]");
        sendSVG.addClass("text-[color:var(--interactive-accent)]");
      } else {
        sendSVG.removeClass("text-[color:var(--interactive-accent)]");
        sendSVG.addClass("text-[gray]");
      }
      if (evt.key !== "Enter" || evt.shiftKey) {
        return;
      }
      if (inputText.innerText.trim() === "") {
        return;
      }
      sendSVG.removeClass("text-[color:var(--interactive-accent)]");
      sendSVG.addClass("text-[gray]");
      this.handleQuery();
    };
    selectionCol.scrollTop = 0;
    selectionCol.children[0].scrollTop = 0;
    if (selectionCol.children[0].children[0])
      selectionCol.children[0].children[0].scrollTop = 0;
  }
  async handleQuery() {
    await PiecesPlugin.activateView();
    const query = this.inputText.innerText;
    if (!query) {
      new import_obsidian22.Notice("Please enter a question for the Copilot!");
      return;
    }
    const gptTab = document.getElementById("gpt-tab");
    if (gptTab.style.display === "none") {
      const navTab = document.getElementById("piecesTabs");
      const clickEvt = new Event("click", { bubbles: true });
      navTab?.children[3].dispatchEvent(clickEvt);
    }
    setTimeout(
      () => postToFrame({
        destination: "webview",
        type: "askCopilot",
        data: {
          query: query.trim(),
          relevant: { text: this.text.trim() }
        }
      }),
      300
    );
    this.close();
  }
  onClose() {
  }
};

// src/connection/ApplicationStream.ts
var ApplicationStream = class {
  /**
   * Private constructor to initialize the object and establish a connection.
   * This constructor is typically used in singleton patterns to prevent
   * external instantiation.
   */
  constructor() {
    this.ws = null;
    this.connect();
  }
  /**
   * Closes the WebSocket connection if it is open and sets the WebSocket instance to null.
   */
  closeSocket() {
    this.ws?.close();
    this.ws = null;
  }
  /**
   * Establishes a WebSocket connection if one does not already exist.
   * Constructs the WebSocket URL based on the basePath parameter, replacing
   * the protocol with 'wss://' or 'ws://', and appending the specific path for the stream.
   * Sets up event handlers for message reception, error, and close events.
   */
  connect() {
    if (this.ws !== null)
      return;
    const url = (ConnectorSingleton.getInstance().parameters.basePath ?? "http://localhost:1000").replace("https://", "wss://").replace("http://", "ws://") + "/applications/stream/identifiers";
    this.ws = new WebSocket(url);
    this.ws.onmessage = (event) => this.updateSettings(event);
    const refreshSockets = (error) => {
      if (error)
        console.error(error);
      this.ws = null;
    };
    this.ws.onerror = refreshSockets;
    this.ws.onclose = refreshSockets;
  }
  /**
   * Updates the settings based on the received message event.
   *
   * @param {MessageEvent} event - The message event containing the data to update settings.
   * @returns {Promise<void>} - A promise that resolves when the settings update is complete.
   */
  async updateSettings(event) {
    const identifiers = StreamedIdentifiersFromJSON(JSON.parse(event.data));
    const storedApplication = await copilotParams.getApplication();
    if (!storedApplication)
      return;
    if (!identifiers.iterable.some(
      (el) => el.application?.id === storedApplication.id
    ))
      return;
    const application = await ConnectorSingleton.getInstance().applicationsApi.applicationsSpecificApplicationSnapshot(
      { application: storedApplication.id }
    );
    this.updateCapabilties(application);
  }
  /**
   * Updates the cloud capabilities setting
   *
   * @param {Application} application - The application object containing the capabilities to be updated.
   * @returns {Promise<void>} - A promise that resolves when the update is complete.
   */
  async updateCapabilties(application) {
    const capabilities = application.capabilities === CapabilitiesEnum.Blended ? "blended" : "local";
    PiecesPlugin.getInstance().settings.cloudCapabilities = capabilities;
    PiecesPlugin.getInstance().saveSettings();
  }
  static getInstance() {
    return this.instance ?? (this.instance = new ApplicationStream());
  }
};

// main.ts
var pluginSettings;
var theme = "dark";
var Prism;
var migration;
var schemaNumber = 1;
var _PiecesPlugin = class extends import_obsidian23.Plugin {
  constructor() {
    super(...arguments);
    this.notifications = Notifications.getInstance();
    this.cache = PiecesCacheSingleton.getInstance();
    this.connection = ConnectorSingleton.getInstance();
    this.linkService = ShareableLinksService.getInstance();
    /*
           Saves the current editor selection to pieces
       */
    this.saveSelectionToPieces = async ({
      getSimilarity
    }) => {
      const markdownView = this.app.workspace.activeEditor;
      if (markdownView instanceof import_obsidian23.MarkdownView) {
        const editor = markdownView.editor;
        const selection = editor.getSelection();
        if (selection.length < 5) {
          this.notifications.error({
            message: Constants.NO_SAVE_SELECTION
          });
        }
        if (getSimilarity) {
          return await findSimilarity(selection);
        }
        try {
          const file = this.app.workspace.activeEditor?.file?.name;
          const line = editor.getCursor().line;
          const description = `This snippet came from ${file} on line ${line}`;
          return await createAsset({
            selection,
            annotations: [
              {
                type: AnnotationTypeEnum.Description,
                text: description,
                id: v4_default(),
                created: {
                  value: new Date()
                },
                updated: {
                  value: new Date()
                }
              }
            ]
          });
        } catch {
          this.notifications.error({ message: Constants.SAVE_FAIL });
        }
      }
    };
    /*
           Handler for editor menu -> share snippet
            - creates a snippet
            - generates a link
            - copies to clipboard
       */
    this.saveAndShare = async () => {
      const id = await this.saveSelectionToPieces({});
      if (typeof id === "string") {
        const link = await this.linkService.generate({ id });
        copyToClipboard(link || "");
      }
    };
    this.onload = async () => {
      _PiecesPlugin.instance = this;
      versionCheck({}).then((val) => {
        if (val === false) {
          this.notifications.error({ message: Constants.UPDATE_OS });
        }
      });
      Prism = await (0, import_obsidian23.loadPrism)();
      theme = document.body.classList.contains("theme-dark") ? "dark" : "light";
      document.body.addEventListener("change", () => {
        this.themeChange();
      });
      pluginSettings = this.settings = await this.loadSettings();
      this.addIcons();
      updateConnectionType(this.settings);
      this.registerViews();
      document.body.addEventListener("paste", (e3) => {
        suggestion(e3).catch(() => {
        });
      });
      loadConnect().then((val) => {
        DisplayController.fetchFailed = !val;
        sleep(100).then(() => {
          DisplayController.triggerUIRedraw({ searching: false, fetch: false });
        });
      });
      if (!pluginSettings.hasLoaded) {
        pluginSettings.hasLoaded = true;
        await this.saveSettings();
        this.showOnboarding();
        ActivitySingleton.getInstance().installed();
      }
      PiecesDatabase.getData().then((data) => {
        this.handleLoadData(data);
      }).catch((e3) => {
        console.log(
          "Pieces: Something went wrong fetching assets from piecesdb.json ",
          e3
        );
        QGPT.allFilesAsContext();
      }).finally(async () => {
        this.startApplication();
      });
      this.addRibbonIcon("pieces_logo", "Pieces For Developers", async () => {
        await this.toggleView();
      });
      this.loadCommands();
      this.addContextMenuItems();
      this.addSettingTab(new PiecesSettingTab(this.app, this));
      this.registerEditorExtension([codeDetectionPlugin]);
    };
    this.startApplication = () => {
      FileTracking.getInstance(this);
      DisplayController.snippetsFetched = true;
      sleep(100).then(() => {
        DisplayController.triggerUIRedraw({ searching: false, fetch: false });
      });
      CheckVersionAndConnection.run().then(() => {
        AutoLinker.findCode();
        ApplicationStream.getInstance();
        this.loadAnnotations().then(() => stream());
        QGPT.loadContext();
        if (pluginSettings.autoDiscover) {
          Discovery.discoverSnippets();
        } else {
          Discovery.discovery_loaded = true;
        }
      });
    };
    this.loadAnnotations = async () => {
      const annotations = await this.connection.annotationsApi.annotationsSnapshot({});
      this.cache.storeAnnotations(annotations.iterable);
    };
    this.handleLoadData = (data) => {
      if (data && data.assets.length && !DisplayController.snippetsFetched) {
        if (!data.assets[0]?.schema && data.assets[0]?.annotations) {
          for (const snippet of data.assets) {
            for (const annotation of snippet.annotations ?? []) {
              annotation.created.value = new Date(annotation.created.value);
              annotation.updated.value = new Date(annotation.updated.value);
              if (annotation.deleted)
                annotation.deleted.value = new Date(annotation.deleted.value);
            }
          }
          this.cache.store({ assets: data.assets });
        }
      }
      if (data && data.gptContexts?.length) {
        this.cache.gptContextPaths = data.gptContexts;
      }
      if (data && data.gptFolderNames?.length) {
        this.cache.gptFolderNames = data.gptFolderNames;
      }
      if (data && data.enrichedCode) {
        this.cache.setAllIsEnriched(data.enrichedCode);
      }
      if (data && !data.gptContexts) {
        this.cache.gptContextPaths = [];
        this.cache.gptFolderNames = [];
      }
      if (data && data.remoteCopilotState) {
        copilotParams.saveState(data.remoteCopilotState);
      }
      let dataMigration = data?.migration;
      if (dataMigration === schemaNumber) {
        migration = dataMigration;
        return;
      }
      switch (dataMigration) {
        case void 0:
          dataMigration = 1;
          this.cache.gptContextPaths = [];
          this.cache.gptFolderNames = [];
      }
      migration = dataMigration;
    };
    this.onunload = async () => {
      closeStreams();
      await this.saveSettings();
      document.body.removeEventListener("paste", (e3) => {
        suggestion(e3);
      });
      document.body.removeEventListener("change", () => {
        this.themeChange();
      });
    };
    this.addContextMenuItems = () => {
      this.registerEvent(
        this.app.workspace.on("editor-menu", (menu, file) => {
          menu.addItem((menuItem) => {
            menuItem.setTitle("Save to Pieces").onClick(async () => {
              await this.saveSelectionToPieces({});
              if (this.settings.autoOpen) {
                const leaf = this.app.workspace.getLeavesOfType(
                  Constants.PIECES_SNIPPET_LIST_VIEW_TYPE
                );
                if (!leaf.length) {
                  _PiecesPlugin.activateView();
                }
              }
            });
          });
          menu.addItem((menuItem) => {
            menuItem.setTitle("Share Via Pieces Link").onClick(async () => {
              const { similarity, comparisonID } = await this.saveSelectionToPieces({ getSimilarity: true });
              if (similarity < 2) {
                if (typeof comparisonID === "string") {
                  const link = await this.linkService.generate({
                    id: comparisonID
                  });
                  copyToClipboard(link || "");
                }
              } else {
                await this.saveAndShare();
              }
            });
          });
          menu.addItem((menuItem) => {
            menuItem.setTitle(Constants.askQGPTTitle).onClick(async () => {
              this.askQGPT();
            });
          });
        })
      );
    };
    this.askQGPT = () => {
      const markdownView = this.app.workspace.activeEditor;
      if (markdownView instanceof import_obsidian23.MarkdownView) {
        const editor = markdownView.editor;
        const selection = editor.getSelection();
        if (selection.length < 5) {
          this.notifications.error({
            message: "Please select some text to ask qGPT about!"
          });
          return;
        }
        new AskQGPTModal(app, selection).open();
      }
    };
    this.registerViews = () => {
      this.registerView(
        Constants.PIECES_SNIPPET_LIST_VIEW_TYPE,
        (leaf) => new PiecesSnippetListView(leaf)
      );
      this.registerView(
        Constants.PIECES_ONBOARDING_VIEW_TYPE,
        (leaf) => new PiecesView({
          leaf,
          workspace: this.app.workspace,
          title: "Welcome to Pieces for Developers!",
          type: Constants.PIECES_ONBOARDING_VIEW_TYPE
        })
      );
      this.registerView(
        Constants.PIECES_EXPANDED_SNIPPET_VIEW_TYPE,
        (leaf) => new PiecesView({
          leaf,
          workspace: this.app.workspace,
          title: "Pieces Expanded Snippet",
          type: Constants.PIECES_EXPANDED_SNIPPET_VIEW_TYPE
        })
      );
    };
    this.loadCommands = () => {
      this.addCommand({
        id: "save",
        name: "Save to Pieces",
        hotkeys: [],
        editorCallback: () => {
          this.saveSelectionToPieces({});
        }
      });
      this.addCommand({
        id: "share",
        name: "Share via Pieces",
        hotkeys: [],
        editorCallback: async () => {
          const { similarity, comparisonID } = await this.saveSelectionToPieces({
            getSimilarity: true
          });
          if (similarity < 2) {
            if (typeof comparisonID === "string") {
              const link = await this.linkService.generate({
                id: comparisonID
              });
              copyToClipboard(link || "");
            }
          } else {
            await this.saveAndShare();
          }
        }
      });
      this.addCommand({
        id: "switch_context",
        name: "Switch Pieces Context",
        hotkeys: [],
        callback: async () => {
          const leaf = app.workspace.getLeavesOfType(
            Constants.PIECES_SNIPPET_LIST_VIEW_TYPE
          );
          if (!leaf.length) {
            await _PiecesPlugin.activateView();
          }
          const navTab = document.getElementById("piecesTabs");
          if (navTab.children[0].checked) {
            navTab.children[3].click();
          } else if (navTab.children[2].checked) {
            navTab.children[1].click();
          }
        }
      });
      this.addCommand({
        id: "askQGPT",
        name: Constants.askQGPTTitle,
        hotkeys: [],
        callback: this.askQGPT
      });
    };
    // This function loads and merges default settings with user-defined settings.
    this.loadSettings = async () => {
      return Object.assign(
        {},
        DEFAULT_SETTINGS,
        await this.loadData()
      );
    };
    // This function saves the settings data using the saveData function.
    this.saveSettings = async () => {
      await this.saveData(this.settings);
    };
    this.toggleView = async () => {
      const leaf = this.app.workspace.getLeavesOfType(
        Constants.PIECES_SNIPPET_LIST_VIEW_TYPE
      );
      if (leaf.length) {
        this.app.workspace.detachLeavesOfType(
          Constants.PIECES_SNIPPET_LIST_VIEW_TYPE
        );
      } else {
        _PiecesPlugin.activateView();
      }
    };
    this.showOnboarding = async () => {
      const leaf = await this.app.workspace.getLeaf(true);
      await displayPiecesView({
        leaf,
        type: Constants.PIECES_ONBOARDING_VIEW_TYPE,
        markdown: onboardingMD,
        inlineTitle: "Welcome to Pieces for Developers!",
        active: true
      });
    };
    this.themeChange = () => {
      const temptheme = document.body.classList.contains("theme-dark") ? "dark" : "light";
      if (temptheme !== theme) {
        const leaf = this.app.workspace.getLeavesOfType(
          Constants.PIECES_SNIPPET_LIST_VIEW_TYPE
        );
        if (leaf.length) {
          this.app.workspace.detachLeavesOfType(
            Constants.PIECES_SNIPPET_LIST_VIEW_TYPE
          );
        }
      }
      theme = temptheme;
    };
    this.addIcons = () => {
      (0, import_obsidian23.addIcon)("pieces_logo", Constants.PIECES_LOGO);
      (0, import_obsidian23.addIcon)("codeSVG", Constants.CODE_ICON);
      (0, import_obsidian23.addIcon)("aiSVG", Constants.AI_ICON);
      (0, import_obsidian23.addIcon)("save-all", Constants.SAVE_ALL_ICON);
      (0, import_obsidian23.addIcon)("sparkles", Constants.ENRICH_ICON);
      (0, import_obsidian23.addIcon)("openNote", Constants.OPEN_ICON);
      (0, import_obsidian23.addIcon)("aiSVG", Constants.AI_ICON);
      (0, import_obsidian23.addIcon)("userSVG", Constants.USER_ICON);
      (0, import_obsidian23.addIcon)("sendSVG", Constants.SEND_ICON);
      (0, import_obsidian23.addIcon)("sendSVG2", Constants.SEND_ICON);
    };
  }
  static getInstance() {
    return this.instance;
  }
};
var PiecesPlugin = _PiecesPlugin;
PiecesPlugin.activateView = async () => {
  const piecesLeaves = app.workspace.getLeavesOfType(
    Constants.PIECES_SNIPPET_LIST_VIEW_TYPE
  );
  if (piecesLeaves[0]) {
    app.workspace.revealLeaf(piecesLeaves[0]);
    return;
  }
  const rightLeaf = app.workspace.getRightLeaf(false);
  await rightLeaf?.setViewState({
    type: Constants.PIECES_SNIPPET_LIST_VIEW_TYPE,
    active: true
  });
  if (rightLeaf)
    app.workspace.revealLeaf(rightLeaf);
};
/*! Bundled license information:

complex.js/complex.js:
  (**
   * @license Complex.js v2.1.1 12/05/2020
   *
   * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
   * Dual licensed under the MIT or GPL Version 2 licenses.
   **)

decimal.js/decimal.mjs:
  (*!
   *  decimal.js v10.4.3
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   *)

fraction.js/fraction.js:
  (**
   * @license Fraction.js v4.3.7 31/08/2023
   * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
   *
   * Copyright (c) 2023, Robert Eisele (robert@raw.org)
   * Dual licensed under the MIT or GPL Version 2 licenses.
   **)
*/
